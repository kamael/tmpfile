<!doctype html>
<html>
<head>
<title>../src/frames.cc</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000;   border-radius:5px;  box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndex { border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Called C++ object pointer is null -->

<!-- BUGTYPE Called C++ object pointer is null -->

<!-- BUGCATEGORY Logic error -->

<!-- BUGFILE /home/haha/code/v8_5_0/v8/out/../src/frames.cc -->

<!-- FILENAME frames.cc -->

<!-- FUNCTIONNAME Print -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT e4d7d8d6cfd189502a078cd64fbc776c -->

<!-- BUGLINE 1340 -->

<!-- BUGCOLUMN 10 -->

<!-- BUGPATHLENGTH 10 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>out/../src/frames.cc</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 1340, column 10</a></td></tr>
<tr><td class="rowname">Description:</td><td>Called C++ object pointer is null</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>// Copyright 2012 the V8 project authors. All rights reserved.</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"><span class='comment'>// Use of this source code is governed by a BSD-style license that can be</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"><span class='comment'>// found in the LICENSE file.</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"><span class='directive'>#include "src/frames.h"</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"><span class='directive'>#include &lt;sstream&gt;</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"> </td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"><span class='directive'>#include "src/ast/ast.h"</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"><span class='directive'>#include "src/ast/scopeinfo.h"</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"><span class='directive'>#include "src/base/bits.h"</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"><span class='directive'>#include "src/deoptimizer.h"</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"><span class='directive'>#include "src/frames-inl.h"</span></td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#include "src/full-codegen/full-codegen.h"</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#include "src/register-configuration.h"</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#include "src/safepoint-table.h"</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#include "src/string-stream.h"</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"><span class='directive'>#include "src/vm-state-inl.h"</span></td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"> </td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='keyword'>namespace</span> v8 {</td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"><span class='keyword'>namespace</span> internal {</td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"> </td></tr>
<tr><td class="num" id="LN23">23</td><td class="line">ReturnAddressLocationResolver</td></tr>
<tr><td class="num" id="LN24">24</td><td class="line">    StackFrame::return_address_location_resolver_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"> </td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"> </td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"><span class='comment'>// Iterator that supports traversing the stack handlers of a</span></td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"><span class='comment'>// particular frame. Needs to know the top of the handler chain.</span></td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='keyword'>class</span> StackHandlerIterator <span class='macro'>BASE_EMBEDDED<span class='expansion'>: public Embedded</span></span> {</td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN31">31</td><td class="line">  StackHandlerIterator(<span class='keyword'>const</span> StackFrame* frame, StackHandler* handler)</td></tr>
<tr><td class="num" id="LN32">32</td><td class="line">      : limit_(frame-&gt;fp()), handler_(handler) {</td></tr>
<tr><td class="num" id="LN33">33</td><td class="line">    <span class='comment'>// Make sure the handler has already been unwound to this frame.</span></td></tr>
<tr><td class="num" id="LN34">34</td><td class="line">    <span class='macro'>DCHECK(frame-&gt;sp() &lt;= handler-&gt;address())<span class='expansion'>do { if ((__builtin_expect(!!(!(frame-&gt;sp() &lt;= handler-&gt;<br>address())), 0))) { V8_Fatal("../src/frames.cc", 34, "Check failed: %s."<br>, "frame-&gt;sp() &lt;= handler-&gt;address()"); } } while (0<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN35">35</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"> </td></tr>
<tr><td class="num" id="LN37">37</td><td class="line">  StackHandler* handler() <span class='keyword'>const</span> { <span class='keyword'>return</span> handler_; }</td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"> </td></tr>
<tr><td class="num" id="LN39">39</td><td class="line">  <span class='keyword'>bool</span> done() {</td></tr>
<tr><td class="num" id="LN40">40</td><td class="line">    <span class='keyword'>return</span> handler_ == <span class='macro'>NULL<span class='expansion'>__null</span></span> || handler_-&gt;address() &gt; limit_;</td></tr>
<tr><td class="num" id="LN41">41</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN42">42</td><td class="line">  <span class='keyword'>void</span> Advance() {</td></tr>
<tr><td class="num" id="LN43">43</td><td class="line">    <span class='macro'>DCHECK(!done())<span class='expansion'>do { if ((__builtin_expect(!!(!(!done())), 0))) { V8_Fatal("../src/frames.cc"<br>, 43, "Check failed: %s.", "!done()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN44">44</td><td class="line">    handler_ = handler_-&gt;next();</td></tr>
<tr><td class="num" id="LN45">45</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"> </td></tr>
<tr><td class="num" id="LN47">47</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN48">48</td><td class="line">  <span class='keyword'>const</span> Address limit_;</td></tr>
<tr><td class="num" id="LN49">49</td><td class="line">  StackHandler* handler_;</td></tr>
<tr><td class="num" id="LN50">50</td><td class="line">};</td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"> </td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"> </td></tr>
<tr><td class="num" id="LN53">53</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line"> </td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"> </td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"><span class='directive'>#define INITIALIZE_SINGLETON(type, field) field##_(this),</span></td></tr>
<tr><td class="num" id="LN57">57</td><td class="line">StackFrameIteratorBase::StackFrameIteratorBase(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN58">58</td><td class="line">                                               <span class='keyword'>bool</span> can_access_heap_objects)</td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">    : isolate_(isolate),</td></tr>
<tr><td class="num" id="LN60">60</td><td class="line">      <span class='macro'>STACK_FRAME_TYPE_LIST(INITIALIZE_SINGLETON)<span class='expansion'>INITIALIZE_SINGLETON(ENTRY, EntryFrame) INITIALIZE_SINGLETON(<br>ENTRY_CONSTRUCT, EntryConstructFrame) INITIALIZE_SINGLETON(EXIT<br>, ExitFrame) INITIALIZE_SINGLETON(JAVA_SCRIPT, JavaScriptFrame<br>) INITIALIZE_SINGLETON(OPTIMIZED, OptimizedFrame) INITIALIZE_SINGLETON<br>(INTERPRETED, InterpretedFrame) INITIALIZE_SINGLETON(STUB, StubFrame<br>) INITIALIZE_SINGLETON(STUB_FAILURE_TRAMPOLINE, StubFailureTrampolineFrame<br>) INITIALIZE_SINGLETON(INTERNAL, InternalFrame) INITIALIZE_SINGLETON<br>(CONSTRUCT, ConstructFrame) INITIALIZE_SINGLETON(ARGUMENTS_ADAPTOR<br>, ArgumentsAdaptorFrame)</span></span></td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">      frame_(<span class='macro'>NULL<span class='expansion'>__null</span></span>), handler_(<span class='macro'>NULL<span class='expansion'>__null</span></span>),</td></tr>
<tr><td class="num" id="LN62">62</td><td class="line">      can_access_heap_objects_(can_access_heap_objects) {</td></tr>
<tr><td class="num" id="LN63">63</td><td class="line">}</td></tr>
<tr><td class="num" id="LN64">64</td><td class="line"><span class='directive'>#undef INITIALIZE_SINGLETON</span></td></tr>
<tr><td class="num" id="LN65">65</td><td class="line"> </td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"> </td></tr>
<tr><td class="num" id="LN67">67</td><td class="line">StackFrameIterator::StackFrameIterator(Isolate* isolate)</td></tr>
<tr><td class="num" id="LN68">68</td><td class="line">    : StackFrameIteratorBase(isolate, <span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN69">69</td><td class="line">  Reset(isolate-&gt;thread_local_top());</td></tr>
<tr><td class="num" id="LN70">70</td><td class="line">}</td></tr>
<tr><td class="num" id="LN71">71</td><td class="line"> </td></tr>
<tr><td class="num" id="LN72">72</td><td class="line"> </td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">StackFrameIterator::StackFrameIterator(Isolate* isolate, ThreadLocalTop* t)</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">    : StackFrameIteratorBase(isolate, <span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line">  Reset(t);</td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">}</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line"> </td></tr>
<tr><td class="num" id="LN78">78</td><td class="line"> </td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"><span class='keyword'>void</span> StackFrameIterator::Advance() {</td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">  <span class='macro'>DCHECK(!done())<span class='expansion'>do { if ((__builtin_expect(!!(!(!done())), 0))) { V8_Fatal("../src/frames.cc"<br>, 80, "Check failed: %s.", "!done()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">  <span class='comment'>// Compute the state of the calling frame before restoring</span></td></tr>
<tr><td class="num" id="LN82">82</td><td class="line">  <span class='comment'>// callee-saved registers and unwinding handlers. This allows the</span></td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">  <span class='comment'>// frame code that computes the caller state to access the top</span></td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">  <span class='comment'>// handler and the value of any callee-saved register if needed.</span></td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">  StackFrame::Type type = frame_-&gt;GetCallerState(&amp;state);</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line"> </td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">  <span class='comment'>// Unwind handlers corresponding to the current frame.</span></td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">  StackHandlerIterator it(frame_, handler_);</td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">  <span class='keyword'>while</span> (!it.done()) it.Advance();</td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">  handler_ = it.handler();</td></tr>
<tr><td class="num" id="LN92">92</td><td class="line"> </td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">  <span class='comment'>// Advance to the calling frame.</span></td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">  frame_ = SingletonFor(type, &amp;state);</td></tr>
<tr><td class="num" id="LN95">95</td><td class="line"> </td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">  <span class='comment'>// When we're done iterating over the stack frames, the handler</span></td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">  <span class='comment'>// chain must have been completely unwound.</span></td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">  <span class='macro'>DCHECK(!done() || handler_ == NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(!done() || handler_ == __null<br>)), 0))) { V8_Fatal("../src/frames.cc", 98, "Check failed: %s."<br>, "!done() || handler_ == __null"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">}</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line"> </td></tr>
<tr><td class="num" id="LN101">101</td><td class="line"> </td></tr>
<tr><td class="num" id="LN102">102</td><td class="line"><span class='keyword'>void</span> StackFrameIterator::Reset(ThreadLocalTop* top) {</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line">  StackFrame::Type type = ExitFrame::GetStateForFramePointer(</td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">      Isolate::c_entry_fp(top), &amp;state);</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">  handler_ = StackHandler::FromAddress(Isolate::handler(top));</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">  <span class='keyword'>if</span> (SingletonFor(type) == <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">  frame_ = SingletonFor(type, &amp;state);</td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">}</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line"> </td></tr>
<tr><td class="num" id="LN111">111</td><td class="line"> </td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">StackFrame* StackFrameIteratorBase::SingletonFor(StackFrame::Type type,</td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">                                             StackFrame::State* state) {</td></tr>
<tr><td class="num" id="LN114">114</td><td class="line">  <span class='keyword'>if</span> (type == StackFrame::NONE) <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN115">115</td><td class="line">  StackFrame* result = SingletonFor(type);</td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">  <span class='macro'>DCHECK(result != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(result != __null)), 0))) { V8_Fatal<br>("../src/frames.cc", 116, "Check failed: %s.", "result != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN117">117</td><td class="line">  result-&gt;state_ = *state;</td></tr>
<tr><td class="num" id="LN118">118</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line">}</td></tr>
<tr><td class="num" id="LN120">120</td><td class="line"> </td></tr>
<tr><td class="num" id="LN121">121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">StackFrame* StackFrameIteratorBase::SingletonFor(StackFrame::Type type) {</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line"><span class='directive'>#define FRAME_TYPE_CASE(type, field) \</span></td></tr>
<tr><td class="num" id="LN124">124</td><td class="line">  <span class='directive'>case StackFrame::type:             \</span></td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">    <span class='directive'>return &amp;field##_;</span></td></tr>
<tr><td class="num" id="LN126">126</td><td class="line"> </td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">  <span class='keyword'>switch</span> (type) {</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line">    <span class='keyword'>case</span> StackFrame::NONE: <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">    <span class='macro'>STACK_FRAME_TYPE_LIST(FRAME_TYPE_CASE)<span class='expansion'>FRAME_TYPE_CASE(ENTRY, EntryFrame) FRAME_TYPE_CASE(ENTRY_CONSTRUCT<br>, EntryConstructFrame) FRAME_TYPE_CASE(EXIT, ExitFrame) FRAME_TYPE_CASE<br>(JAVA_SCRIPT, JavaScriptFrame) FRAME_TYPE_CASE(OPTIMIZED, OptimizedFrame<br>) FRAME_TYPE_CASE(INTERPRETED, InterpretedFrame) FRAME_TYPE_CASE<br>(STUB, StubFrame) FRAME_TYPE_CASE(STUB_FAILURE_TRAMPOLINE, StubFailureTrampolineFrame<br>) FRAME_TYPE_CASE(INTERNAL, InternalFrame) FRAME_TYPE_CASE(CONSTRUCT<br>, ConstructFrame) FRAME_TYPE_CASE(ARGUMENTS_ADAPTOR, ArgumentsAdaptorFrame<br>)</span></span></td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">    <span class='keyword'>default</span>: <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line"> </td></tr>
<tr><td class="num" id="LN134">134</td><td class="line"><span class='directive'>#undef FRAME_TYPE_CASE</span></td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">}</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line"> </td></tr>
<tr><td class="num" id="LN137">137</td><td class="line"> </td></tr>
<tr><td class="num" id="LN138">138</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN139">139</td><td class="line"> </td></tr>
<tr><td class="num" id="LN140">140</td><td class="line"> </td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">JavaScriptFrameIterator::JavaScriptFrameIterator(</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">    Isolate* isolate, StackFrame::Id id)</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line">    : iterator_(isolate) {</td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">  <span class='keyword'>while</span> (!done()) {</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">    Advance();</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line">    <span class='keyword'>if</span> (frame()-&gt;id() == id) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line">}</td></tr>
<tr><td class="num" id="LN149">149</td><td class="line"> </td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"> </td></tr>
<tr><td class="num" id="LN151">151</td><td class="line"><span class='keyword'>void</span> JavaScriptFrameIterator::Advance() {</td></tr>
<tr><td class="num" id="LN152">152</td><td class="line">  <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN153">153</td><td class="line">    iterator_.Advance();</td></tr>
<tr><td class="num" id="LN154">154</td><td class="line">  } <span class='keyword'>while</span> (!iterator_.done() &amp;&amp; !iterator_.frame()-&gt;is_java_script());</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line">}</td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN157">157</td><td class="line"> </td></tr>
<tr><td class="num" id="LN158">158</td><td class="line"><span class='keyword'>void</span> JavaScriptFrameIterator::AdvanceToArgumentsFrame() {</td></tr>
<tr><td class="num" id="LN159">159</td><td class="line">  <span class='keyword'>if</span> (!frame()-&gt;has_adapted_arguments()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN160">160</td><td class="line">  iterator_.Advance();</td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">  <span class='macro'>DCHECK(iterator_.frame()-&gt;is_arguments_adaptor())<span class='expansion'>do { if ((__builtin_expect(!!(!(iterator_.frame()-&gt;is_arguments_adaptor<br>())), 0))) { V8_Fatal("../src/frames.cc", 161, "Check failed: %s."<br>, "iterator_.frame()-&gt;is_arguments_adaptor()"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">}</td></tr>
<tr><td class="num" id="LN163">163</td><td class="line"> </td></tr>
<tr><td class="num" id="LN164">164</td><td class="line"> </td></tr>
<tr><td class="num" id="LN165">165</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line"> </td></tr>
<tr><td class="num" id="LN167">167</td><td class="line"> </td></tr>
<tr><td class="num" id="LN168">168</td><td class="line">StackTraceFrameIterator::StackTraceFrameIterator(Isolate* isolate)</td></tr>
<tr><td class="num" id="LN169">169</td><td class="line">    : JavaScriptFrameIterator(isolate) {</td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">  <span class='keyword'>if</span> (!done() &amp;&amp; !IsValidFrame()) Advance();</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line">}</td></tr>
<tr><td class="num" id="LN172">172</td><td class="line"> </td></tr>
<tr><td class="num" id="LN173">173</td><td class="line"> </td></tr>
<tr><td class="num" id="LN174">174</td><td class="line"><span class='keyword'>void</span> StackTraceFrameIterator::Advance() {</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line">  <span class='keyword'>while</span> (<span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN176">176</td><td class="line">    JavaScriptFrameIterator::Advance();</td></tr>
<tr><td class="num" id="LN177">177</td><td class="line">    <span class='keyword'>if</span> (done()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">    <span class='keyword'>if</span> (IsValidFrame()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN179">179</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line">}</td></tr>
<tr><td class="num" id="LN181">181</td><td class="line"> </td></tr>
<tr><td class="num" id="LN182">182</td><td class="line"> </td></tr>
<tr><td class="num" id="LN183">183</td><td class="line"><span class='keyword'>bool</span> StackTraceFrameIterator::IsValidFrame() {</td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">    <span class='keyword'>if</span> (!frame()-&gt;function()-&gt;IsJSFunction()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">    Object* script = frame()-&gt;function()-&gt;shared()-&gt;script();</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">    <span class='comment'>// Don't show functions from native scripts to user.</span></td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">    <span class='keyword'>return</span> (script-&gt;IsScript() &amp;&amp;</td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">            Script::TYPE_NATIVE != Script::cast(script)-&gt;type());</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">}</td></tr>
<tr><td class="num" id="LN190">190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN191">191</td><td class="line"> </td></tr>
<tr><td class="num" id="LN192">192</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN195">195</td><td class="line">SafeStackFrameIterator::SafeStackFrameIterator(</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">    Isolate* isolate,</td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">    Address fp, Address sp, Address js_entry_sp)</td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">    : StackFrameIteratorBase(isolate, <span class='keyword'>false</span>),</td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">      low_bound_(sp),</td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">      high_bound_(js_entry_sp),</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">      top_frame_type_(StackFrame::NONE),</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">      external_callback_scope_(isolate-&gt;external_callback_scope()) {</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">  StackFrame::Type type;</td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">  ThreadLocalTop* top = isolate-&gt;thread_local_top();</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">  <span class='keyword'>if</span> (IsValidTop(top)) {</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">    type = ExitFrame::GetStateForFramePointer(Isolate::c_entry_fp(top), &amp;state);</td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">    top_frame_type_ = type;</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (IsValidStackAddress(fp)) {</td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">    <span class='macro'>DCHECK(fp != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(fp != __null)), 0))) { V8_Fatal<br>("../src/frames.cc", 210, "Check failed: %s.", "fp != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">    state.fp = fp;</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">    state.sp = sp;</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">    state.pc_address = StackFrame::ResolveReturnAddressLocation(</td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">        <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(StandardFrame::ComputePCAddress(fp)));</td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">    <span class='comment'>// StackFrame::ComputeType will read both kContextOffset and kMarkerOffset,</span></td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">    <span class='comment'>// we check only that kMarkerOffset is within the stack bounds and do</span></td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">    <span class='comment'>// compile time check that kContextOffset slot is pushed on the stack before</span></td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">    <span class='comment'>// kMarkerOffset.</span></td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">    <span class='macro'>STATIC_ASSERT(StandardFrameConstants::kMarkerOffset &lt;<span class='expansion'>static_assert(StandardFrameConstants::kMarkerOffset &lt; StandardFrameConstants<br>::kContextOffset, "StandardFrameConstants::kMarkerOffset &lt; StandardFrameConstants::kContextOffset"<br>)</span></span></td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">                  <span class='macro'>StandardFrameConstants::kContextOffset)<span class='expansion'>static_assert(StandardFrameConstants::kMarkerOffset &lt; StandardFrameConstants<br>::kContextOffset, "StandardFrameConstants::kMarkerOffset &lt; StandardFrameConstants::kContextOffset"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">    Address frame_marker = fp + StandardFrameConstants::kMarkerOffset;</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">    <span class='keyword'>if</span> (IsValidStackAddress(frame_marker)) {</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">      type = StackFrame::ComputeType(<span class='keyword'>this</span>, &amp;state);</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">      top_frame_type_ = type;</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">      <span class='comment'>// Mark the frame as JAVA_SCRIPT if we cannot determine its type.</span></td></tr>
<tr><td class="num" id="LN227">227</td><td class="line">      <span class='comment'>// The frame anyways will be skipped.</span></td></tr>
<tr><td class="num" id="LN228">228</td><td class="line">      type = StackFrame::JAVA_SCRIPT;</td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">      <span class='comment'>// Top frame is incomplete so we cannot reliably determine its type.</span></td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">      top_frame_type_ = StackFrame::NONE;</td></tr>
<tr><td class="num" id="LN231">231</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">  <span class='keyword'>if</span> (SingletonFor(type) == <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">  frame_ = SingletonFor(type, &amp;state);</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">  <span class='macro'>DCHECK(frame_)<span class='expansion'>do { if ((__builtin_expect(!!(!(frame_)), 0))) { V8_Fatal("../src/frames.cc"<br>, 237, "Check failed: %s.", "frame_"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">  Advance();</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">}</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line"> </td></tr>
<tr><td class="num" id="LN241">241</td><td class="line"> </td></tr>
<tr><td class="num" id="LN242">242</td><td class="line"><span class='keyword'>bool</span> SafeStackFrameIterator::IsValidTop(ThreadLocalTop* top) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">  Address c_entry_fp = Isolate::c_entry_fp(top);</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">  <span class='keyword'>if</span> (!IsValidExitFrame(c_entry_fp)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">  <span class='comment'>// There should be at least one JS_ENTRY stack handler.</span></td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">  Address handler = Isolate::handler(top);</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line">  <span class='keyword'>if</span> (handler == <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">  <span class='comment'>// Check that there are no js frames on top of the native frames.</span></td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">  <span class='keyword'>return</span> c_entry_fp &lt; handler;</td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">}</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line"> </td></tr>
<tr><td class="num" id="LN252">252</td><td class="line"> </td></tr>
<tr><td class="num" id="LN253">253</td><td class="line"><span class='keyword'>void</span> SafeStackFrameIterator::AdvanceOneFrame() {</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">  <span class='macro'>DCHECK(!done())<span class='expansion'>do { if ((__builtin_expect(!!(!(!done())), 0))) { V8_Fatal("../src/frames.cc"<br>, 254, "Check failed: %s.", "!done()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line">  StackFrame* last_frame = frame_;</td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">  Address last_sp = last_frame-&gt;sp(), last_fp = last_frame-&gt;fp();</td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">  <span class='comment'>// Before advancing to the next stack frame, perform pointer validity tests.</span></td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">  <span class='keyword'>if</span> (!IsValidFrame(last_frame) || !IsValidCaller(last_frame)) {</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">    frame_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line"> </td></tr>
<tr><td class="num" id="LN263">263</td><td class="line">  <span class='comment'>// Advance to the previous frame.</span></td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line">  StackFrame::Type type = frame_-&gt;GetCallerState(&amp;state);</td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">  <span class='keyword'>if</span> (SingletonFor(type) == <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">    frame_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN268">268</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">  frame_ = SingletonFor(type, &amp;state);</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">  <span class='macro'>DCHECK(frame_)<span class='expansion'>do { if ((__builtin_expect(!!(!(frame_)), 0))) { V8_Fatal("../src/frames.cc"<br>, 271, "Check failed: %s.", "frame_"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN273">273</td><td class="line">  <span class='comment'>// Check that we have actually moved to the previous frame in the stack.</span></td></tr>
<tr><td class="num" id="LN274">274</td><td class="line">  <span class='keyword'>if</span> (frame_-&gt;sp() &lt; last_sp || frame_-&gt;fp() &lt; last_fp) {</td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">    frame_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">}</td></tr>
<tr><td class="num" id="LN278">278</td><td class="line"> </td></tr>
<tr><td class="num" id="LN279">279</td><td class="line"> </td></tr>
<tr><td class="num" id="LN280">280</td><td class="line"><span class='keyword'>bool</span> SafeStackFrameIterator::IsValidFrame(StackFrame* frame) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">  <span class='keyword'>return</span> IsValidStackAddress(frame-&gt;sp()) &amp;&amp; IsValidStackAddress(frame-&gt;fp());</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">}</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN284">284</td><td class="line"> </td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"><span class='keyword'>bool</span> SafeStackFrameIterator::IsValidCaller(StackFrame* frame) {</td></tr>
<tr><td class="num" id="LN286">286</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN287">287</td><td class="line">  <span class='keyword'>if</span> (frame-&gt;is_entry() || frame-&gt;is_entry_construct()) {</td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">    <span class='comment'>// See EntryFrame::GetCallerState. It computes the caller FP address</span></td></tr>
<tr><td class="num" id="LN289">289</td><td class="line">    <span class='comment'>// and calls ExitFrame::GetStateForFramePointer on it. We need to be</span></td></tr>
<tr><td class="num" id="LN290">290</td><td class="line">    <span class='comment'>// sure that caller FP address is valid.</span></td></tr>
<tr><td class="num" id="LN291">291</td><td class="line">    Address caller_fp = Memory::Address_at(</td></tr>
<tr><td class="num" id="LN292">292</td><td class="line">        frame-&gt;fp() + EntryFrameConstants::kCallerFPOffset);</td></tr>
<tr><td class="num" id="LN293">293</td><td class="line">    <span class='keyword'>if</span> (!IsValidExitFrame(caller_fp)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN294">294</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (frame-&gt;is_arguments_adaptor()) {</td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">    <span class='comment'>// See ArgumentsAdaptorFrame::GetCallerStackPointer. It assumes that</span></td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">    <span class='comment'>// the number of arguments is stored on stack as Smi. We need to check</span></td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">    <span class='comment'>// that it really an Smi.</span></td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">    Object* number_of_args = <span class='keyword'>reinterpret_cast</span>&lt;ArgumentsAdaptorFrame*&gt;(frame)-&gt;</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">        GetExpression(0);</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line">    <span class='keyword'>if</span> (!number_of_args-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN302">302</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">  frame-&gt;ComputeCallerState(&amp;state);</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">  <span class='keyword'>return</span> IsValidStackAddress(state.sp) &amp;&amp; IsValidStackAddress(state.fp) &amp;&amp;</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">      SingletonFor(frame-&gt;GetCallerState(&amp;state)) != <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">}</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line"> </td></tr>
<tr><td class="num" id="LN309">309</td><td class="line"> </td></tr>
<tr><td class="num" id="LN310">310</td><td class="line"><span class='keyword'>bool</span> SafeStackFrameIterator::IsValidExitFrame(Address fp) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">  <span class='keyword'>if</span> (!IsValidStackAddress(fp)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">  Address sp = ExitFrame::ComputeStackPointer(fp);</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">  <span class='keyword'>if</span> (!IsValidStackAddress(sp)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">  StackFrame::State state;</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">  ExitFrame::FillState(fp, sp, &amp;state);</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">  <span class='keyword'>return</span> *state.pc_address != <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">}</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN319">319</td><td class="line"> </td></tr>
<tr><td class="num" id="LN320">320</td><td class="line"><span class='keyword'>void</span> SafeStackFrameIterator::Advance() {</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">  <span class='keyword'>while</span> (<span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">    AdvanceOneFrame();</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">    <span class='keyword'>if</span> (done()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">    ExternalCallbackScope* last_callback_scope = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">    <span class='keyword'>while</span> (external_callback_scope_ != <span class='macro'>NULL<span class='expansion'>__null</span></span> &amp;&amp;</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">           external_callback_scope_-&gt;scope_address() &lt; frame_-&gt;fp()) {</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">      <span class='comment'>// As long as the setup of a frame is not atomic, we may happen to be</span></td></tr>
<tr><td class="num" id="LN328">328</td><td class="line">      <span class='comment'>// in an interval where an ExternalCallbackScope is already created,</span></td></tr>
<tr><td class="num" id="LN329">329</td><td class="line">      <span class='comment'>// but the frame is not yet entered. So we are actually observing</span></td></tr>
<tr><td class="num" id="LN330">330</td><td class="line">      <span class='comment'>// the previous frame.</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line">      <span class='comment'>// Skip all the ExternalCallbackScope's that are below the current fp.</span></td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">      last_callback_scope = external_callback_scope_;</td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">      external_callback_scope_ = external_callback_scope_-&gt;previous();</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">    <span class='keyword'>if</span> (frame_-&gt;is_java_script()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">    <span class='keyword'>if</span> (frame_-&gt;is_exit()) {</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">      <span class='comment'>// Some of the EXIT frames may have ExternalCallbackScope allocated on</span></td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">      <span class='comment'>// top of them. In that case the scope corresponds to the first EXIT</span></td></tr>
<tr><td class="num" id="LN339">339</td><td class="line">      <span class='comment'>// frame beneath it. There may be other EXIT frames on top of the</span></td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">      <span class='comment'>// ExternalCallbackScope, just skip them as we cannot collect any useful</span></td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">      <span class='comment'>// information about them.</span></td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">      <span class='keyword'>if</span> (last_callback_scope) {</td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">        frame_-&gt;state_.pc_address =</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">            last_callback_scope-&gt;callback_entrypoint_address();</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN349">349</td><td class="line">}</td></tr>
<tr><td class="num" id="LN350">350</td><td class="line"> </td></tr>
<tr><td class="num" id="LN351">351</td><td class="line"> </td></tr>
<tr><td class="num" id="LN352">352</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN353">353</td><td class="line"> </td></tr>
<tr><td class="num" id="LN354">354</td><td class="line"> </td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">Code* StackFrame::GetSafepointData(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">                                   Address inner_pointer,</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">                                   SafepointEntry* safepoint_entry,</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line">                                   <span class='keyword'>unsigned</span>* stack_slots) {</td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">  InnerPointerToCodeCache::InnerPointerToCodeCacheEntry* entry =</td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">      isolate-&gt;inner_pointer_to_code_cache()-&gt;GetCacheEntry(inner_pointer);</td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">  <span class='keyword'>if</span> (!entry-&gt;safepoint_entry.is_valid()) {</td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">    entry-&gt;safepoint_entry = entry-&gt;code-&gt;GetSafepointEntry(inner_pointer);</td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">    <span class='macro'>DCHECK(entry-&gt;safepoint_entry.is_valid())<span class='expansion'>do { if ((__builtin_expect(!!(!(entry-&gt;safepoint_entry.is_valid<br>())), 0))) { V8_Fatal("../src/frames.cc", 363, "Check failed: %s."<br>, "entry-&gt;safepoint_entry.is_valid()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">    <span class='macro'>DCHECK(entry-&gt;safepoint_entry.Equals(<span class='expansion'>do { if ((__builtin_expect(!!(!(entry-&gt;safepoint_entry.Equals<br>( entry-&gt;code-&gt;GetSafepointEntry(inner_pointer)))), 0))<br>) { V8_Fatal("../src/frames.cc", 366, "Check failed: %s.", "entry-&gt;safepoint_entry.Equals( entry-&gt;code-&gt;GetSafepointEntry(inner_pointer))"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">        <span class='macro'>entry-&gt;code-&gt;GetSafepointEntry(inner_pointer)))<span class='expansion'>do { if ((__builtin_expect(!!(!(entry-&gt;safepoint_entry.Equals<br>( entry-&gt;code-&gt;GetSafepointEntry(inner_pointer)))), 0))<br>) { V8_Fatal("../src/frames.cc", 366, "Check failed: %s.", "entry-&gt;safepoint_entry.Equals( entry-&gt;code-&gt;GetSafepointEntry(inner_pointer))"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN368">368</td><td class="line"> </td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">  <span class='comment'>// Fill in the results and return the code.</span></td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">  Code* code = entry-&gt;code;</td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">  *safepoint_entry = entry-&gt;safepoint_entry;</td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">  *stack_slots = code-&gt;stack_slots();</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">  <span class='keyword'>return</span> code;</td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">}</td></tr>
<tr><td class="num" id="LN375">375</td><td class="line"> </td></tr>
<tr><td class="num" id="LN376">376</td><td class="line"> </td></tr>
<tr><td class="num" id="LN377">377</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN378">378</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>bool</span> GcSafeCodeContains(HeapObject* object, Address addr);</td></tr>
<tr><td class="num" id="LN379">379</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN380">380</td><td class="line"> </td></tr>
<tr><td class="num" id="LN381">381</td><td class="line"> </td></tr>
<tr><td class="num" id="LN382">382</td><td class="line"><span class='keyword'>void</span> StackFrame::IteratePc(ObjectVisitor* v, Address* pc_address,</td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">                           Address* constant_pool_address, Code* holder) {</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">  Address pc = *pc_address;</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">  <span class='macro'>DCHECK(GcSafeCodeContains(holder, pc))<span class='expansion'>do { if ((__builtin_expect(!!(!(GcSafeCodeContains(holder, pc<br>))), 0))) { V8_Fatal("../src/frames.cc", 385, "Check failed: %s."<br>, "GcSafeCodeContains(holder, pc)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">  <span class='keyword'>unsigned</span> pc_offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>unsigned</span>&gt;(pc - holder-&gt;instruction_start());</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">  Object* code = holder;</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">  v-&gt;VisitPointer(&amp;code);</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">  <span class='keyword'>if</span> (code != holder) {</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">    holder = <span class='keyword'>reinterpret_cast</span>&lt;Code*&gt;(code);</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">    pc = holder-&gt;instruction_start() + pc_offset;</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">    *pc_address = pc;</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">    <span class='keyword'>if</span> (FLAG_enable_embedded_constant_pool &amp;&amp; constant_pool_address) {</td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">      *constant_pool_address = holder-&gt;constant_pool();</td></tr>
<tr><td class="num" id="LN395">395</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">}</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line"> </td></tr>
<tr><td class="num" id="LN399">399</td><td class="line"> </td></tr>
<tr><td class="num" id="LN400">400</td><td class="line"><span class='keyword'>void</span> StackFrame::SetReturnAddressLocationResolver(</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">    ReturnAddressLocationResolver resolver) {</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">  <span class='macro'>DCHECK(return_address_location_resolver_ == NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(return_address_location_resolver_<br> == __null)), 0))) { V8_Fatal("../src/frames.cc", 402, "Check failed: %s."<br>, "return_address_location_resolver_ == __null"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">  return_address_location_resolver_ = resolver;</td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">}</td></tr>
<tr><td class="num" id="LN405">405</td><td class="line"> </td></tr>
<tr><td class="num" id="LN406">406</td><td class="line"> </td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">StackFrame::Type StackFrame::ComputeType(<span class='keyword'>const</span> StackFrameIteratorBase* iterator,</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">                                         State* state) {</td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">  <span class='macro'>DCHECK(state-&gt;fp != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(state-&gt;fp != __null)), 0))<br>) { V8_Fatal("../src/frames.cc", 409, "Check failed: %s.", "state-&gt;fp != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line"> </td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">  <span class='keyword'>if</span> (!iterator-&gt;can_access_heap_objects_) {</td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">    <span class='comment'>// TODO(titzer): "can_access_heap_objects" is kind of bogus. It really</span></td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">    <span class='comment'>// means that we are being called from the profiler, which can interrupt</span></td></tr>
<tr><td class="num" id="LN414">414</td><td class="line">    <span class='comment'>// the VM with a signal at any arbitrary instruction, with essentially</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">    <span class='comment'>// anything on the stack. So basically none of these checks are 100%</span></td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">    <span class='comment'>// reliable.</span></td></tr>
<tr><td class="num" id="LN417">417</td><td class="line"><span class='directive'>#if defined(USE_SIMULATOR)</span></td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">    MSAN_MEMORY_IS_INITIALIZED(</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">        state-&gt;fp + StandardFrameConstants::kContextOffset, kPointerSize);</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line">    MSAN_MEMORY_IS_INITIALIZED(</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">        state-&gt;fp + StandardFrameConstants::kMarkerOffset, kPointerSize);</td></tr>
<tr><td class="num" id="LN422">422</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">    <span class='keyword'>if</span> (StandardFrame::IsArgumentsAdaptorFrame(state-&gt;fp)) {</td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">      <span class='comment'>// An adapter frame has a special SMI constant for the context and</span></td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">      <span class='comment'>// is not distinguished through the marker.</span></td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">      <span class='keyword'>return</span> ARGUMENTS_ADAPTOR;</td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">    Object* marker =</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">        Memory::Object_at(state-&gt;fp + StandardFrameConstants::kMarkerOffset);</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">    <span class='keyword'>if</span> (marker-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;StackFrame::Type&gt;(Smi::cast(marker)-&gt;value());</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">      <span class='keyword'>return</span> JAVA_SCRIPT;</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line"> </td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">  <span class='comment'>// Look up the code object to figure out the type of the stack frame.</span></td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">  Code* code_obj = GetContainingCode(iterator-&gt;isolate(), *(state-&gt;pc_address));</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line"> </td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">  Object* marker =</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">      Memory::Object_at(state-&gt;fp + StandardFrameConstants::kMarkerOffset);</td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">  <span class='keyword'>if</span> (code_obj != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">    <span class='keyword'>switch</span> (code_obj-&gt;kind()) {</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">      <span class='keyword'>case</span> Code::FUNCTION:</td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">        <span class='keyword'>return</span> JAVA_SCRIPT;</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">      <span class='keyword'>case</span> Code::OPTIMIZED_FUNCTION:</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">        <span class='keyword'>return</span> OPTIMIZED;</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">      <span class='keyword'>case</span> Code::WASM_FUNCTION:</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">        <span class='keyword'>return</span> STUB;</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">      <span class='keyword'>case</span> Code::BUILTIN:</td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">        <span class='keyword'>if</span> (!marker-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">          <span class='keyword'>if</span> (StandardFrame::IsArgumentsAdaptorFrame(state-&gt;fp)) {</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">            <span class='comment'>// An adapter frame has a special SMI constant for the context and</span></td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">            <span class='comment'>// is not distinguished through the marker.</span></td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">            <span class='keyword'>return</span> ARGUMENTS_ADAPTOR;</td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">          } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">            <span class='comment'>// The interpreter entry trampoline has a non-SMI marker.</span></td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">            <span class='macro'>DCHECK(code_obj-&gt;is_interpreter_entry_trampoline() ||<span class='expansion'>do { if ((__builtin_expect(!!(!(code_obj-&gt;is_interpreter_entry_trampoline<br>() || code_obj-&gt;is_interpreter_enter_bytecode_dispatch()))<br>, 0))) { V8_Fatal("../src/frames.cc", 459, "Check failed: %s."<br>, "code_obj-&gt;is_interpreter_entry_trampoline() || code_obj-&gt;is_interpreter_enter_bytecode_dispatch()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">                   <span class='macro'>code_obj-&gt;is_interpreter_enter_bytecode_dispatch())<span class='expansion'>do { if ((__builtin_expect(!!(!(code_obj-&gt;is_interpreter_entry_trampoline<br>() || code_obj-&gt;is_interpreter_enter_bytecode_dispatch()))<br>, 0))) { V8_Fatal("../src/frames.cc", 459, "Check failed: %s."<br>, "code_obj-&gt;is_interpreter_entry_trampoline() || code_obj-&gt;is_interpreter_enter_bytecode_dispatch()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">            <span class='keyword'>return</span> INTERPRETED;</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">        <span class='keyword'>break</span>;  <span class='comment'>// Marker encodes the frame type.</span></td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">      <span class='keyword'>case</span> Code::HANDLER:</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">        <span class='keyword'>if</span> (!marker-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">          <span class='comment'>// Only hydrogen code stub handlers can have a non-SMI marker.</span></td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">          <span class='macro'>DCHECK(code_obj-&gt;is_hydrogen_stub())<span class='expansion'>do { if ((__builtin_expect(!!(!(code_obj-&gt;is_hydrogen_stub<br>())), 0))) { V8_Fatal("../src/frames.cc", 467, "Check failed: %s."<br>, "code_obj-&gt;is_hydrogen_stub()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">          <span class='keyword'>return</span> OPTIMIZED;</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN470">470</td><td class="line">        <span class='keyword'>break</span>;  <span class='comment'>// Marker encodes the frame type.</span></td></tr>
<tr><td class="num" id="LN471">471</td><td class="line">      <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN472">472</td><td class="line">        <span class='keyword'>break</span>;  <span class='comment'>// Marker encodes the frame type.</span></td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line"> </td></tr>
<tr><td class="num" id="LN476">476</td><td class="line">  <span class='comment'>// Didn't find a code object, or the code kind wasn't specific enough.</span></td></tr>
<tr><td class="num" id="LN477">477</td><td class="line">  <span class='comment'>// The marker should encode the frame type.</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;StackFrame::Type&gt;(Smi::cast(marker)-&gt;value());</td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">}</td></tr>
<tr><td class="num" id="LN480">480</td><td class="line"> </td></tr>
<tr><td class="num" id="LN481">481</td><td class="line"> </td></tr>
<tr><td class="num" id="LN482">482</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN483">483</td><td class="line"><span class='keyword'>bool</span> StackFrame::can_access_heap_objects() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN484">484</td><td class="line">  <span class='keyword'>return</span> iterator_-&gt;can_access_heap_objects_;</td></tr>
<tr><td class="num" id="LN485">485</td><td class="line">}</td></tr>
<tr><td class="num" id="LN486">486</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN487">487</td><td class="line"> </td></tr>
<tr><td class="num" id="LN488">488</td><td class="line"> </td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">StackFrame::Type StackFrame::GetCallerState(State* state) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN490">490</td><td class="line">  ComputeCallerState(state);</td></tr>
<tr><td class="num" id="LN491">491</td><td class="line">  <span class='keyword'>return</span> ComputeType(iterator_, state);</td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">}</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line"> </td></tr>
<tr><td class="num" id="LN494">494</td><td class="line"> </td></tr>
<tr><td class="num" id="LN495">495</td><td class="line">Address StackFrame::UnpaddedFP() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN496">496</td><td class="line"><span class='directive'>#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X87</span></td></tr>
<tr><td class="num" id="LN497">497</td><td class="line">  <span class='keyword'>if</span> (!is_optimized()) <span class='keyword'>return</span> fp();</td></tr>
<tr><td class="num" id="LN498">498</td><td class="line">  int32_t alignment_state = Memory::int32_at(</td></tr>
<tr><td class="num" id="LN499">499</td><td class="line">    fp() + JavaScriptFrameConstants::kDynamicAlignmentStateOffset);</td></tr>
<tr><td class="num" id="LN500">500</td><td class="line"> </td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">  <span class='keyword'>return</span> (alignment_state == kAlignmentPaddingPushed) ?</td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">    (fp() + kPointerSize) : fp();</td></tr>
<tr><td class="num" id="LN503">503</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN504">504</td><td class="line">  <span class='keyword'>return</span> fp();</td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">}</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line"> </td></tr>
<tr><td class="num" id="LN508">508</td><td class="line"> </td></tr>
<tr><td class="num" id="LN509">509</td><td class="line">Code* EntryFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN510">510</td><td class="line">  <span class='keyword'>return</span> isolate()-&gt;heap()-&gt;js_entry_code();</td></tr>
<tr><td class="num" id="LN511">511</td><td class="line">}</td></tr>
<tr><td class="num" id="LN512">512</td><td class="line"> </td></tr>
<tr><td class="num" id="LN513">513</td><td class="line"> </td></tr>
<tr><td class="num" id="LN514">514</td><td class="line"><span class='keyword'>void</span> EntryFrame::ComputeCallerState(State* state) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">  GetCallerState(state);</td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">}</td></tr>
<tr><td class="num" id="LN517">517</td><td class="line"> </td></tr>
<tr><td class="num" id="LN518">518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN519">519</td><td class="line"><span class='keyword'>void</span> EntryFrame::SetCallerFp(Address caller_fp) {</td></tr>
<tr><td class="num" id="LN520">520</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = EntryFrameConstants::kCallerFPOffset;</td></tr>
<tr><td class="num" id="LN521">521</td><td class="line">  Memory::Address_at(<span class='keyword'>this</span>-&gt;fp() + offset) = caller_fp;</td></tr>
<tr><td class="num" id="LN522">522</td><td class="line">}</td></tr>
<tr><td class="num" id="LN523">523</td><td class="line"> </td></tr>
<tr><td class="num" id="LN524">524</td><td class="line"> </td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">StackFrame::Type EntryFrame::GetCallerState(State* state) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = EntryFrameConstants::kCallerFPOffset;</td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">  Address fp = Memory::Address_at(<span class='keyword'>this</span>-&gt;fp() + offset);</td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">  <span class='keyword'>return</span> ExitFrame::GetStateForFramePointer(fp, state);</td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">}</td></tr>
<tr><td class="num" id="LN530">530</td><td class="line"> </td></tr>
<tr><td class="num" id="LN531">531</td><td class="line"> </td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">Code* EntryConstructFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">  <span class='keyword'>return</span> isolate()-&gt;heap()-&gt;js_construct_entry_code();</td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">}</td></tr>
<tr><td class="num" id="LN535">535</td><td class="line"> </td></tr>
<tr><td class="num" id="LN536">536</td><td class="line"> </td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">Object*&amp; ExitFrame::code_slot() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = ExitFrameConstants::kCodeOffset;</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">  <span class='keyword'>return</span> Memory::Object_at(fp() + offset);</td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">}</td></tr>
<tr><td class="num" id="LN541">541</td><td class="line"> </td></tr>
<tr><td class="num" id="LN542">542</td><td class="line"> </td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">Code* ExitFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>reinterpret_cast</span>&lt;Code*&gt;(code_slot());</td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">}</td></tr>
<tr><td class="num" id="LN546">546</td><td class="line"> </td></tr>
<tr><td class="num" id="LN547">547</td><td class="line"> </td></tr>
<tr><td class="num" id="LN548">548</td><td class="line"><span class='keyword'>void</span> ExitFrame::ComputeCallerState(State* state) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">  <span class='comment'>// Set up the caller state.</span></td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">  state-&gt;sp = caller_sp();</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">  state-&gt;fp = Memory::Address_at(fp() + ExitFrameConstants::kCallerFPOffset);</td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">  state-&gt;pc_address = ResolveReturnAddressLocation(</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(fp() + ExitFrameConstants::kCallerPCOffset));</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">  <span class='keyword'>if</span> (FLAG_enable_embedded_constant_pool) {</td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">    state-&gt;constant_pool_address = <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(</td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">        fp() + ExitFrameConstants::kConstantPoolOffset);</td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN558">558</td><td class="line">}</td></tr>
<tr><td class="num" id="LN559">559</td><td class="line"> </td></tr>
<tr><td class="num" id="LN560">560</td><td class="line"> </td></tr>
<tr><td class="num" id="LN561">561</td><td class="line"><span class='keyword'>void</span> ExitFrame::SetCallerFp(Address caller_fp) {</td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">  Memory::Address_at(fp() + ExitFrameConstants::kCallerFPOffset) = caller_fp;</td></tr>
<tr><td class="num" id="LN563">563</td><td class="line">}</td></tr>
<tr><td class="num" id="LN564">564</td><td class="line"> </td></tr>
<tr><td class="num" id="LN565">565</td><td class="line"> </td></tr>
<tr><td class="num" id="LN566">566</td><td class="line"><span class='keyword'>void</span> ExitFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">  <span class='comment'>// The arguments are traversed as part of the expression stack of</span></td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">  <span class='comment'>// the calling frame.</span></td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), LookupCode());</td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">  v-&gt;VisitPointer(&amp;code_slot());</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">}</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line"> </td></tr>
<tr><td class="num" id="LN573">573</td><td class="line"> </td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">Address ExitFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">  <span class='keyword'>return</span> fp() + ExitFrameConstants::kCallerSPDisplacement;</td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">}</td></tr>
<tr><td class="num" id="LN577">577</td><td class="line"> </td></tr>
<tr><td class="num" id="LN578">578</td><td class="line"> </td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">StackFrame::Type ExitFrame::GetStateForFramePointer(Address fp, State* state) {</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">  <span class='keyword'>if</span> (fp == 0) <span class='keyword'>return</span> NONE;</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">  Address sp = ComputeStackPointer(fp);</td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">  FillState(fp, sp, state);</td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">  <span class='macro'>DCHECK(*state-&gt;pc_address != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(*state-&gt;pc_address != __null<br>)), 0))) { V8_Fatal("../src/frames.cc", 583, "Check failed: %s."<br>, "*state-&gt;pc_address != __null"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">  <span class='keyword'>return</span> EXIT;</td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">}</td></tr>
<tr><td class="num" id="LN586">586</td><td class="line"> </td></tr>
<tr><td class="num" id="LN587">587</td><td class="line"> </td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">Address ExitFrame::ComputeStackPointer(Address fp) {</td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">  <span class='keyword'>return</span> Memory::Address_at(fp + ExitFrameConstants::kSPOffset);</td></tr>
<tr><td class="num" id="LN590">590</td><td class="line">}</td></tr>
<tr><td class="num" id="LN591">591</td><td class="line"> </td></tr>
<tr><td class="num" id="LN592">592</td><td class="line"> </td></tr>
<tr><td class="num" id="LN593">593</td><td class="line"><span class='keyword'>void</span> ExitFrame::FillState(Address fp, Address sp, State* state) {</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">  state-&gt;sp = sp;</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">  state-&gt;fp = fp;</td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">  state-&gt;pc_address = ResolveReturnAddressLocation(</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(sp - 1 * kPCOnStackSize));</td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">  <span class='comment'>// The constant pool recorded in the exit frame is not associated</span></td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">  <span class='comment'>// with the pc in this state (the return address into a C entry</span></td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">  <span class='comment'>// stub).  ComputeCallerState will retrieve the constant pool</span></td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">  <span class='comment'>// together with the associated caller pc.</span></td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">  state-&gt;constant_pool_address = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">}</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line"> </td></tr>
<tr><td class="num" id="LN605">605</td><td class="line"> </td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">Address StandardFrame::GetExpressionAddress(<span class='keyword'>int</span> n) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = StandardFrameConstants::kExpressionsOffset;</td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">  <span class='keyword'>return</span> fp() + offset - n * kPointerSize;</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">}</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN611">611</td><td class="line">Address InterpretedFrame::GetExpressionAddress(<span class='keyword'>int</span> n) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = InterpreterFrameConstants::kExpressionsOffset;</td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">  <span class='keyword'>return</span> fp() + offset - n * kPointerSize;</td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">}</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN616">616</td><td class="line"><span class='keyword'>int</span> StandardFrame::ComputeExpressionsCount() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">  Address base = GetExpressionAddress(0);</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">  Address limit = sp() - kPointerSize;</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">  <span class='macro'>DCHECK(base &gt;= limit)<span class='expansion'>do { if ((__builtin_expect(!!(!(base &gt;= limit)), 0))) { V8_Fatal<br>("../src/frames.cc", 619, "Check failed: %s.", "base &gt;= limit"<br>); } } while (0)</span></span>;  <span class='comment'>// stack grows downwards</span></td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">  <span class='comment'>// Include register-allocated locals in number of expressions.</span></td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;((base - limit) / kPointerSize);</td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">}</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line"> </td></tr>
<tr><td class="num" id="LN624">624</td><td class="line"> </td></tr>
<tr><td class="num" id="LN625">625</td><td class="line"><span class='keyword'>void</span> StandardFrame::ComputeCallerState(State* state) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">  state-&gt;sp = caller_sp();</td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">  state-&gt;fp = caller_fp();</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">  state-&gt;pc_address = ResolveReturnAddressLocation(</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(ComputePCAddress(fp())));</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">  state-&gt;constant_pool_address =</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;Address*&gt;(ComputeConstantPoolAddress(fp()));</td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">}</td></tr>
<tr><td class="num" id="LN633">633</td><td class="line"> </td></tr>
<tr><td class="num" id="LN634">634</td><td class="line"> </td></tr>
<tr><td class="num" id="LN635">635</td><td class="line"><span class='keyword'>void</span> StandardFrame::SetCallerFp(Address caller_fp) {</td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">  Memory::Address_at(fp() + StandardFrameConstants::kCallerFPOffset) =</td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">      caller_fp;</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">}</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line"> </td></tr>
<tr><td class="num" id="LN640">640</td><td class="line"> </td></tr>
<tr><td class="num" id="LN641">641</td><td class="line"><span class='keyword'>void</span> StandardFrame::IterateCompiledFrame(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">  <span class='comment'>// Make sure that we're not doing "safe" stack frame iteration. We cannot</span></td></tr>
<tr><td class="num" id="LN643">643</td><td class="line">  <span class='comment'>// possibly find pointers in optimized frames in that state.</span></td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">  <span class='macro'>DCHECK(can_access_heap_objects())<span class='expansion'>do { if ((__builtin_expect(!!(!(can_access_heap_objects())), 0<br>))) { V8_Fatal("../src/frames.cc", 644, "Check failed: %s.", "can_access_heap_objects()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line"> </td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">  <span class='comment'>// Compute the safepoint information.</span></td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">  <span class='keyword'>unsigned</span> stack_slots = 0;</td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">  SafepointEntry safepoint_entry;</td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">  Code* code = StackFrame::GetSafepointData(</td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">      isolate(), pc(), &amp;safepoint_entry, &amp;stack_slots);</td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">  <span class='keyword'>unsigned</span> slot_space =</td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">      stack_slots * kPointerSize - StandardFrameConstants::kFixedFrameSize;</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line"> </td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">  <span class='comment'>// Visit the outgoing parameters.</span></td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">  Object** parameters_base = &amp;Memory::Object_at(sp());</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">  Object** parameters_limit = &amp;Memory::Object_at(</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">      fp() + JavaScriptFrameConstants::kFunctionOffset - slot_space);</td></tr>
<tr><td class="num" id="LN658">658</td><td class="line"> </td></tr>
<tr><td class="num" id="LN659">659</td><td class="line">  <span class='comment'>// Visit the parameters that may be on top of the saved registers.</span></td></tr>
<tr><td class="num" id="LN660">660</td><td class="line">  <span class='keyword'>if</span> (safepoint_entry.argument_count() &gt; 0) {</td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">    v-&gt;VisitPointers(parameters_base,</td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">                     parameters_base + safepoint_entry.argument_count());</td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">    parameters_base += safepoint_entry.argument_count();</td></tr>
<tr><td class="num" id="LN664">664</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN665">665</td><td class="line"> </td></tr>
<tr><td class="num" id="LN666">666</td><td class="line">  <span class='comment'>// Skip saved double registers.</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line">  <span class='keyword'>if</span> (safepoint_entry.has_doubles()) {</td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">    <span class='comment'>// Number of doubles not known at snapshot time.</span></td></tr>
<tr><td class="num" id="LN669">669</td><td class="line">    <span class='macro'>DCHECK(!isolate()-&gt;serializer_enabled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate()-&gt;serializer_enabled<br>())), 0))) { V8_Fatal("../src/frames.cc", 669, "Check failed: %s."<br>, "!isolate()-&gt;serializer_enabled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">    parameters_base +=</td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">        RegisterConfiguration::ArchDefault(RegisterConfiguration::CRANKSHAFT)</td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">            -&gt;num_allocatable_double_registers() *</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">        kDoubleSize / kPointerSize;</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line"> </td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">  <span class='comment'>// Visit the registers that contain pointers if any.</span></td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">  <span class='keyword'>if</span> (safepoint_entry.HasRegisters()) {</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> i = kNumSafepointRegisters - 1; i &gt;=0; i--) {</td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">      <span class='keyword'>if</span> (safepoint_entry.HasRegisterAt(i)) {</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">        <span class='keyword'>int</span> reg_stack_index = MacroAssembler::SafepointRegisterStackIndex(i);</td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">        v-&gt;VisitPointer(parameters_base + reg_stack_index);</td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">    <span class='comment'>// Skip the words containing the register values.</span></td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">    parameters_base += kNumSafepointRegisters;</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN687">687</td><td class="line"> </td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">  <span class='comment'>// We're done dealing with the register bits.</span></td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">  uint8_t* safepoint_bits = safepoint_entry.bits();</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">  safepoint_bits += kNumSafepointRegisters &gt;&gt; kBitsPerByteLog2;</td></tr>
<tr><td class="num" id="LN691">691</td><td class="line"> </td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">  <span class='comment'>// Visit the rest of the parameters.</span></td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">  v-&gt;VisitPointers(parameters_base, parameters_limit);</td></tr>
<tr><td class="num" id="LN694">694</td><td class="line"> </td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">  <span class='comment'>// Visit pointer spill slots and locals.</span></td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> index = 0; index &lt; stack_slots; index++) {</td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">    <span class='keyword'>int</span> byte_index = index &gt;&gt; kBitsPerByteLog2;</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">    <span class='keyword'>int</span> bit_index = index &amp; (kBitsPerByte - 1);</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">    <span class='keyword'>if</span> ((safepoint_bits[byte_index] &amp; (1U &lt;&lt; bit_index)) != 0) {</td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">      v-&gt;VisitPointer(parameters_limit + index);</td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN703">703</td><td class="line"> </td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">  <span class='comment'>// Visit the return address in the callee and incoming arguments.</span></td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), code);</td></tr>
<tr><td class="num" id="LN706">706</td><td class="line"> </td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">  <span class='comment'>// Visit the context in stub frame and JavaScript frame.</span></td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">  <span class='comment'>// Visit the function in JavaScript frame.</span></td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">  Object** fixed_base = &amp;Memory::Object_at(</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">      fp() + StandardFrameConstants::kMarkerOffset);</td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">  Object** fixed_limit = &amp;Memory::Object_at(fp());</td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">  v-&gt;VisitPointers(fixed_base, fixed_limit);</td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">}</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line"> </td></tr>
<tr><td class="num" id="LN715">715</td><td class="line"> </td></tr>
<tr><td class="num" id="LN716">716</td><td class="line"><span class='keyword'>void</span> StubFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">  IterateCompiledFrame(v);</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">}</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line"> </td></tr>
<tr><td class="num" id="LN720">720</td><td class="line"> </td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">Code* StubFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;Code*&gt;(isolate()-&gt;FindCodeObject(pc()));</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">}</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line"> </td></tr>
<tr><td class="num" id="LN725">725</td><td class="line"> </td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">Address StubFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">  <span class='keyword'>return</span> fp() + ExitFrameConstants::kCallerSPDisplacement;</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">}</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line"> </td></tr>
<tr><td class="num" id="LN730">730</td><td class="line"> </td></tr>
<tr><td class="num" id="LN731">731</td><td class="line"><span class='keyword'>int</span> StubFrame::GetNumberOfIncomingArguments() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">}</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line"> </td></tr>
<tr><td class="num" id="LN735">735</td><td class="line"> </td></tr>
<tr><td class="num" id="LN736">736</td><td class="line"><span class='keyword'>void</span> OptimizedFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">  IterateCompiledFrame(v);</td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">}</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line"> </td></tr>
<tr><td class="num" id="LN740">740</td><td class="line"> </td></tr>
<tr><td class="num" id="LN741">741</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::SetParameterValue(<span class='keyword'>int</span> index, Object* value) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">  Memory::Object_at(GetParameterSlot(index)) = value;</td></tr>
<tr><td class="num" id="LN743">743</td><td class="line">}</td></tr>
<tr><td class="num" id="LN744">744</td><td class="line"> </td></tr>
<tr><td class="num" id="LN745">745</td><td class="line"> </td></tr>
<tr><td class="num" id="LN746">746</td><td class="line"><span class='keyword'>bool</span> JavaScriptFrame::IsConstructor() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN747">747</td><td class="line">  Address fp = caller_fp();</td></tr>
<tr><td class="num" id="LN748">748</td><td class="line">  <span class='keyword'>if</span> (has_adapted_arguments()) {</td></tr>
<tr><td class="num" id="LN749">749</td><td class="line">    <span class='comment'>// Skip the arguments adaptor frame and look at the real caller.</span></td></tr>
<tr><td class="num" id="LN750">750</td><td class="line">    fp = Memory::Address_at(fp + StandardFrameConstants::kCallerFPOffset);</td></tr>
<tr><td class="num" id="LN751">751</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line">  <span class='keyword'>return</span> IsConstructFrame(fp);</td></tr>
<tr><td class="num" id="LN753">753</td><td class="line">}</td></tr>
<tr><td class="num" id="LN754">754</td><td class="line"> </td></tr>
<tr><td class="num" id="LN755">755</td><td class="line"> </td></tr>
<tr><td class="num" id="LN756">756</td><td class="line"><span class='keyword'>bool</span> JavaScriptFrame::HasInlinedFrames() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">  List&lt;JSFunction*&gt; functions(1);</td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">  GetFunctions(&amp;functions);</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">  <span class='keyword'>return</span> functions.length() &gt; 1;</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">}</td></tr>
<tr><td class="num" id="LN761">761</td><td class="line"> </td></tr>
<tr><td class="num" id="LN762">762</td><td class="line"> </td></tr>
<tr><td class="num" id="LN763">763</td><td class="line"><span class='keyword'>int</span> JavaScriptFrame::GetArgumentsLength() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN764">764</td><td class="line">  <span class='comment'>// If there is an arguments adaptor frame get the arguments length from it.</span></td></tr>
<tr><td class="num" id="LN765">765</td><td class="line">  <span class='keyword'>if</span> (has_adapted_arguments()) {</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line">    <span class='keyword'>return</span> ArgumentsAdaptorFrame::GetLength(caller_fp());</td></tr>
<tr><td class="num" id="LN767">767</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN768">768</td><td class="line">    <span class='keyword'>return</span> GetNumberOfIncomingArguments();</td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">}</td></tr>
<tr><td class="num" id="LN771">771</td><td class="line"> </td></tr>
<tr><td class="num" id="LN772">772</td><td class="line"> </td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">Code* JavaScriptFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">  <span class='keyword'>return</span> function()-&gt;code();</td></tr>
<tr><td class="num" id="LN775">775</td><td class="line">}</td></tr>
<tr><td class="num" id="LN776">776</td><td class="line"> </td></tr>
<tr><td class="num" id="LN777">777</td><td class="line"> </td></tr>
<tr><td class="num" id="LN778">778</td><td class="line"><span class='keyword'>int</span> JavaScriptFrame::GetNumberOfIncomingArguments() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN779">779</td><td class="line">  <span class='macro'>DCHECK(can_access_heap_objects() &amp;&amp;<span class='expansion'>do { if ((__builtin_expect(!!(!(can_access_heap_objects() &amp;&amp;<br> isolate()-&gt;heap()-&gt;gc_state() == Heap::NOT_IN_GC)), 0)<br>)) { V8_Fatal("../src/frames.cc", 780, "Check failed: %s.", "can_access_heap_objects() &amp;&amp; isolate()-&gt;heap()-&gt;gc_state() == Heap::NOT_IN_GC"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN780">780</td><td class="line">         <span class='macro'>isolate()-&gt;heap()-&gt;gc_state() == Heap::NOT_IN_GC)<span class='expansion'>do { if ((__builtin_expect(!!(!(can_access_heap_objects() &amp;&amp;<br> isolate()-&gt;heap()-&gt;gc_state() == Heap::NOT_IN_GC)), 0)<br>)) { V8_Fatal("../src/frames.cc", 780, "Check failed: %s.", "can_access_heap_objects() &amp;&amp; isolate()-&gt;heap()-&gt;gc_state() == Heap::NOT_IN_GC"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN781">781</td><td class="line"> </td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">  <span class='keyword'>return</span> function()-&gt;shared()-&gt;internal_formal_parameter_count();</td></tr>
<tr><td class="num" id="LN783">783</td><td class="line">}</td></tr>
<tr><td class="num" id="LN784">784</td><td class="line"> </td></tr>
<tr><td class="num" id="LN785">785</td><td class="line"> </td></tr>
<tr><td class="num" id="LN786">786</td><td class="line">Address JavaScriptFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN787">787</td><td class="line">  <span class='keyword'>return</span> fp() + StandardFrameConstants::kCallerSPOffset;</td></tr>
<tr><td class="num" id="LN788">788</td><td class="line">}</td></tr>
<tr><td class="num" id="LN789">789</td><td class="line"> </td></tr>
<tr><td class="num" id="LN790">790</td><td class="line"> </td></tr>
<tr><td class="num" id="LN791">791</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::GetFunctions(List&lt;JSFunction*&gt;* functions) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">  <span class='macro'>DCHECK(functions-&gt;length() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(functions-&gt;length() == 0))<br>, 0))) { V8_Fatal("../src/frames.cc", 792, "Check failed: %s."<br>, "functions-&gt;length() == 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">  functions-&gt;Add(function());</td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">}</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line"> </td></tr>
<tr><td class="num" id="LN796">796</td><td class="line"> </td></tr>
<tr><td class="num" id="LN797">797</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::Summarize(List&lt;FrameSummary&gt;* functions) {</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">  <span class='macro'>DCHECK(functions-&gt;length() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(functions-&gt;length() == 0))<br>, 0))) { V8_Fatal("../src/frames.cc", 798, "Check failed: %s."<br>, "functions-&gt;length() == 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">  Code* code = LookupCode();</td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">  <span class='keyword'>int</span> offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(pc() - code-&gt;instruction_start());</td></tr>
<tr><td class="num" id="LN801">801</td><td class="line">  AbstractCode* abstract_code = AbstractCode::cast(code);</td></tr>
<tr><td class="num" id="LN802">802</td><td class="line">  FrameSummary summary(receiver(), function(), abstract_code, offset,</td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">                       IsConstructor());</td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">  functions-&gt;Add(summary);</td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">}</td></tr>
<tr><td class="num" id="LN806">806</td><td class="line"> </td></tr>
<tr><td class="num" id="LN807">807</td><td class="line"><span class='keyword'>int</span> JavaScriptFrame::LookupExceptionHandlerInTable(</td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">    <span class='keyword'>int</span>* stack_depth, HandlerTable::CatchPrediction* prediction) {</td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">  Code* code = LookupCode();</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">  <span class='macro'>DCHECK(!code-&gt;is_optimized_code())<span class='expansion'>do { if ((__builtin_expect(!!(!(!code-&gt;is_optimized_code()<br>)), 0))) { V8_Fatal("../src/frames.cc", 810, "Check failed: %s."<br>, "!code-&gt;is_optimized_code()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">  HandlerTable* table = HandlerTable::cast(code-&gt;handler_table());</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">  <span class='keyword'>int</span> pc_offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(pc() - code-&gt;entry());</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">  <span class='keyword'>return</span> table-&gt;LookupRange(pc_offset, stack_depth, prediction);</td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">}</td></tr>
<tr><td class="num" id="LN815">815</td><td class="line"> </td></tr>
<tr><td class="num" id="LN816">816</td><td class="line"> </td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::PrintFunctionAndOffset(JSFunction* function, Code* code,</td></tr>
<tr><td class="num" id="LN818">818</td><td class="line">                                             Address pc, FILE* file,</td></tr>
<tr><td class="num" id="LN819">819</td><td class="line">                                             <span class='keyword'>bool</span> print_line_number) {</td></tr>
<tr><td class="num" id="LN820">820</td><td class="line">  PrintF(file, <span class='string_literal'>"%s"</span>, function-&gt;IsOptimized() ? <span class='string_literal'>"*"</span> : <span class='string_literal'>"~"</span>);</td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">  function-&gt;PrintName(file);</td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">  <span class='keyword'>int</span> code_offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(pc - code-&gt;instruction_start());</td></tr>
<tr><td class="num" id="LN823">823</td><td class="line">  PrintF(file, <span class='string_literal'>"+%d"</span>, code_offset);</td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">  <span class='keyword'>if</span> (print_line_number) {</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line">    SharedFunctionInfo* shared = function-&gt;shared();</td></tr>
<tr><td class="num" id="LN826">826</td><td class="line">    <span class='keyword'>int</span> source_pos = code-&gt;SourcePosition(code_offset);</td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">    Object* maybe_script = shared-&gt;script();</td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">    <span class='keyword'>if</span> (maybe_script-&gt;IsScript()) {</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">      Script* script = Script::cast(maybe_script);</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">      <span class='keyword'>int</span> line = script-&gt;GetLineNumber(source_pos) + 1;</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">      Object* script_name_raw = script-&gt;name();</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">      <span class='keyword'>if</span> (script_name_raw-&gt;IsString()) {</td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">        String* script_name = String::cast(script-&gt;name());</td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">        base::SmartArrayPointer&lt;<span class='keyword'>char</span>&gt; c_script_name =</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">            script_name-&gt;ToCString(DISALLOW_NULLS, ROBUST_STRING_TRAVERSAL);</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">        PrintF(file, <span class='string_literal'>" at %s:%d"</span>, c_script_name.get(), line);</td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">        PrintF(file, <span class='string_literal'>" at &lt;unknown&gt;:%d"</span>, line);</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">      PrintF(file, <span class='string_literal'>" at &lt;unknown&gt;:&lt;unknown&gt;"</span>);</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">}</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line"> </td></tr>
<tr><td class="num" id="LN846">846</td><td class="line"> </td></tr>
<tr><td class="num" id="LN847">847</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::PrintTop(Isolate* isolate, FILE* file, <span class='keyword'>bool</span> print_args,</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">                               <span class='keyword'>bool</span> print_line_number) {</td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">  <span class='comment'>// constructor calls</span></td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">  DisallowHeapAllocation no_allocation;</td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">  JavaScriptFrameIterator it(isolate);</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">  <span class='keyword'>while</span> (!it.done()) {</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">    <span class='keyword'>if</span> (it.frame()-&gt;is_java_script()) {</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">      JavaScriptFrame* frame = it.frame();</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">      <span class='keyword'>if</span> (frame-&gt;IsConstructor()) PrintF(file, <span class='string_literal'>"new "</span>);</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">      PrintFunctionAndOffset(frame-&gt;function(), frame-&gt;unchecked_code(),</td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">                             frame-&gt;pc(), file, print_line_number);</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">      <span class='keyword'>if</span> (print_args) {</td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">        <span class='comment'>// function arguments</span></td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">        <span class='comment'>// (we are intentionally only printing the actually</span></td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">        <span class='comment'>// supplied parameters, not all parameters required)</span></td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">        PrintF(file, <span class='string_literal'>"(this="</span>);</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">        frame-&gt;receiver()-&gt;ShortPrint(file);</td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">        <span class='keyword'>const</span> <span class='keyword'>int</span> length = frame-&gt;ComputeParametersCount();</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">        <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; length; i++) {</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">          PrintF(file, <span class='string_literal'>", "</span>);</td></tr>
<tr><td class="num" id="LN867">867</td><td class="line">          frame-&gt;GetParameter(i)-&gt;ShortPrint(file);</td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">        PrintF(file, <span class='string_literal'>")"</span>);</td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN872">872</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">    it.Advance();</td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">}</td></tr>
<tr><td class="num" id="LN876">876</td><td class="line"> </td></tr>
<tr><td class="num" id="LN877">877</td><td class="line"> </td></tr>
<tr><td class="num" id="LN878">878</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::SaveOperandStack(FixedArray* store) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN879">879</td><td class="line">  <span class='keyword'>int</span> operands_count = store-&gt;length();</td></tr>
<tr><td class="num" id="LN880">880</td><td class="line">  <span class='macro'>DCHECK_LE(operands_count, ComputeOperandsCount())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (operands_count<br>), (ComputeOperandsCount()), "operands_count" " " "&lt;=" " "<br> "ComputeOperandsCount()")) { V8_Fatal("../src/frames.cc", 880<br>, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN881">881</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; operands_count; i++) {</td></tr>
<tr><td class="num" id="LN882">882</td><td class="line">    store-&gt;set(i, GetOperand(i));</td></tr>
<tr><td class="num" id="LN883">883</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN884">884</td><td class="line">}</td></tr>
<tr><td class="num" id="LN885">885</td><td class="line"> </td></tr>
<tr><td class="num" id="LN886">886</td><td class="line"> </td></tr>
<tr><td class="num" id="LN887">887</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::RestoreOperandStack(FixedArray* store) {</td></tr>
<tr><td class="num" id="LN888">888</td><td class="line">  <span class='keyword'>int</span> operands_count = store-&gt;length();</td></tr>
<tr><td class="num" id="LN889">889</td><td class="line">  <span class='macro'>DCHECK_LE(operands_count, ComputeOperandsCount())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (operands_count<br>), (ComputeOperandsCount()), "operands_count" " " "&lt;=" " "<br> "ComputeOperandsCount()")) { V8_Fatal("../src/frames.cc", 889<br>, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN890">890</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; operands_count; i++) {</td></tr>
<tr><td class="num" id="LN891">891</td><td class="line">    <span class='macro'>DCHECK_EQ(GetOperand(i), isolate()-&gt;heap()-&gt;the_hole_value())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (GetOperand<br>(i)), (isolate()-&gt;heap()-&gt;the_hole_value()), "GetOperand(i)"<br> " " "==" " " "isolate()-&gt;heap()-&gt;the_hole_value()")) {<br> V8_Fatal("../src/frames.cc", 891, "Check failed: %s.", _msg-&gt;<br>c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN892">892</td><td class="line">    Memory::Object_at(GetOperandSlot(i)) = store-&gt;get(i);</td></tr>
<tr><td class="num" id="LN893">893</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN894">894</td><td class="line">}</td></tr>
<tr><td class="num" id="LN895">895</td><td class="line"> </td></tr>
<tr><td class="num" id="LN896">896</td><td class="line">FrameSummary::FrameSummary(Object* receiver, JSFunction* function,</td></tr>
<tr><td class="num" id="LN897">897</td><td class="line">                           AbstractCode* abstract_code, <span class='keyword'>int</span> code_offset,</td></tr>
<tr><td class="num" id="LN898">898</td><td class="line">                           <span class='keyword'>bool</span> is_constructor)</td></tr>
<tr><td class="num" id="LN899">899</td><td class="line">    : receiver_(receiver, function-&gt;GetIsolate()),</td></tr>
<tr><td class="num" id="LN900">900</td><td class="line">      function_(function),</td></tr>
<tr><td class="num" id="LN901">901</td><td class="line">      abstract_code_(abstract_code),</td></tr>
<tr><td class="num" id="LN902">902</td><td class="line">      code_offset_(code_offset),</td></tr>
<tr><td class="num" id="LN903">903</td><td class="line">      is_constructor_(is_constructor) {}</td></tr>
<tr><td class="num" id="LN904">904</td><td class="line"> </td></tr>
<tr><td class="num" id="LN905">905</td><td class="line"><span class='keyword'>void</span> FrameSummary::Print() {</td></tr>
<tr><td class="num" id="LN906">906</td><td class="line">  PrintF(<span class='string_literal'>"receiver: "</span>);</td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">  receiver_-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">  PrintF(<span class='string_literal'>"\nfunction: "</span>);</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">  function_-&gt;shared()-&gt;DebugName()-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">  PrintF(<span class='string_literal'>"\ncode: "</span>);</td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">  abstract_code_-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line">  <span class='keyword'>if</span> (abstract_code_-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN913">913</td><td class="line">    Code* code = abstract_code_-&gt;GetCode();</td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">    <span class='keyword'>if</span> (code-&gt;kind() == Code::FUNCTION) PrintF(<span class='string_literal'>" UNOPT "</span>);</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">    <span class='keyword'>if</span> (code-&gt;kind() == Code::OPTIMIZED_FUNCTION) PrintF(<span class='string_literal'>" OPT "</span>);</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN917">917</td><td class="line">    PrintF(<span class='string_literal'>" BYTECODE "</span>);</td></tr>
<tr><td class="num" id="LN918">918</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN919">919</td><td class="line">  PrintF(<span class='string_literal'>"\npc: %d\n"</span>, code_offset_);</td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">}</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line"> </td></tr>
<tr><td class="num" id="LN922">922</td><td class="line"> </td></tr>
<tr><td class="num" id="LN923">923</td><td class="line"><span class='keyword'>void</span> OptimizedFrame::Summarize(List&lt;FrameSummary&gt;* frames) {</td></tr>
<tr><td class="num" id="LN924">924</td><td class="line">  <span class='macro'>DCHECK(frames-&gt;length() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(frames-&gt;length() == 0)), 0<br>))) { V8_Fatal("../src/frames.cc", 924, "Check failed: %s.", "frames-&gt;length() == 0"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN925">925</td><td class="line">  <span class='macro'>DCHECK(is_optimized())<span class='expansion'>do { if ((__builtin_expect(!!(!(is_optimized())), 0))) { V8_Fatal<br>("../src/frames.cc", 925, "Check failed: %s.", "is_optimized()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN926">926</td><td class="line"> </td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">  <span class='comment'>// Delegate to JS frame in absence of turbofan deoptimization.</span></td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">  <span class='comment'>// TODO(turbofan): Revisit once we support deoptimization across the board.</span></td></tr>
<tr><td class="num" id="LN929">929</td><td class="line">  <span class='keyword'>if</span> (LookupCode()-&gt;is_turbofanned() &amp;&amp; function()-&gt;shared()-&gt;asm_function() &amp;&amp;</td></tr>
<tr><td class="num" id="LN930">930</td><td class="line">      !FLAG_turbo_asm_deoptimization) {</td></tr>
<tr><td class="num" id="LN931">931</td><td class="line">    <span class='keyword'>return</span> JavaScriptFrame::Summarize(frames);</td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN933">933</td><td class="line"> </td></tr>
<tr><td class="num" id="LN934">934</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN935">935</td><td class="line">  <span class='keyword'>int</span> deopt_index = Safepoint::kNoDeoptimizationIndex;</td></tr>
<tr><td class="num" id="LN936">936</td><td class="line">  DeoptimizationInputData* <span class='keyword'>const</span> data = GetDeoptimizationData(&amp;deopt_index);</td></tr>
<tr><td class="num" id="LN937">937</td><td class="line">  FixedArray* <span class='keyword'>const</span> literal_array = data-&gt;LiteralArray();</td></tr>
<tr><td class="num" id="LN938">938</td><td class="line"> </td></tr>
<tr><td class="num" id="LN939">939</td><td class="line">  TranslationIterator it(data-&gt;TranslationByteArray(),</td></tr>
<tr><td class="num" id="LN940">940</td><td class="line">                         data-&gt;TranslationIndex(deopt_index)-&gt;value());</td></tr>
<tr><td class="num" id="LN941">941</td><td class="line">  Translation::Opcode frame_opcode =</td></tr>
<tr><td class="num" id="LN942">942</td><td class="line">      <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN943">943</td><td class="line">  <span class='macro'>DCHECK_EQ(Translation::BEGIN, frame_opcode)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (Translation<br>::BEGIN), (frame_opcode), "Translation::BEGIN" " " "==" " " "frame_opcode"<br>)) { V8_Fatal("../src/frames.cc", 943, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN944">944</td><td class="line">  it.Next();  <span class='comment'>// Drop frame count.</span></td></tr>
<tr><td class="num" id="LN945">945</td><td class="line">  <span class='keyword'>int</span> jsframe_count = it.Next();</td></tr>
<tr><td class="num" id="LN946">946</td><td class="line"> </td></tr>
<tr><td class="num" id="LN947">947</td><td class="line">  <span class='comment'>// We create the summary in reverse order because the frames</span></td></tr>
<tr><td class="num" id="LN948">948</td><td class="line">  <span class='comment'>// in the deoptimization translation are ordered bottom-to-top.</span></td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">  <span class='keyword'>bool</span> is_constructor = IsConstructor();</td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">  <span class='keyword'>while</span> (jsframe_count != 0) {</td></tr>
<tr><td class="num" id="LN951">951</td><td class="line">    frame_opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN952">952</td><td class="line">    <span class='keyword'>if</span> (frame_opcode == Translation::JS_FRAME ||</td></tr>
<tr><td class="num" id="LN953">953</td><td class="line">        frame_opcode == Translation::INTERPRETED_FRAME) {</td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">      jsframe_count--;</td></tr>
<tr><td class="num" id="LN955">955</td><td class="line">      BailoutId <span class='keyword'>const</span> ast_id = BailoutId(it.Next());</td></tr>
<tr><td class="num" id="LN956">956</td><td class="line">      SharedFunctionInfo* <span class='keyword'>const</span> shared_info =</td></tr>
<tr><td class="num" id="LN957">957</td><td class="line">          SharedFunctionInfo::cast(literal_array-&gt;get(it.Next()));</td></tr>
<tr><td class="num" id="LN958">958</td><td class="line">      it.Next();  <span class='comment'>// Skip height.</span></td></tr>
<tr><td class="num" id="LN959">959</td><td class="line"> </td></tr>
<tr><td class="num" id="LN960">960</td><td class="line">      <span class='comment'>// The translation commands are ordered and the function is always</span></td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">      <span class='comment'>// at the first position, and the receiver is next.</span></td></tr>
<tr><td class="num" id="LN962">962</td><td class="line">      Translation::Opcode opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN963">963</td><td class="line"> </td></tr>
<tr><td class="num" id="LN964">964</td><td class="line">      <span class='comment'>// Get the correct function in the optimized frame.</span></td></tr>
<tr><td class="num" id="LN965">965</td><td class="line">      JSFunction* function;</td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">      <span class='keyword'>if</span> (opcode == Translation::LITERAL) {</td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">        function = JSFunction::cast(literal_array-&gt;get(it.Next()));</td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">        <span class='macro'>CHECK_EQ(opcode, Translation::STACK_SLOT)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (opcode<br>), (Translation::STACK_SLOT), "opcode" " " "==" " " "Translation::STACK_SLOT"<br>)) { V8_Fatal("../src/frames.cc", 969, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">        function = JSFunction::cast(StackSlotAt(it.Next()));</td></tr>
<tr><td class="num" id="LN971">971</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">      <span class='macro'>DCHECK_EQ(shared_info, function-&gt;shared())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (shared_info<br>), (function-&gt;shared()), "shared_info" " " "==" " " "function-&gt;shared()"<br>)) { V8_Fatal("../src/frames.cc", 972, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN973">973</td><td class="line"> </td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">      <span class='comment'>// If we are at a call, the receiver is always in a stack slot.</span></td></tr>
<tr><td class="num" id="LN975">975</td><td class="line">      <span class='comment'>// Otherwise we are not guaranteed to get the receiver value.</span></td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">      opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN977">977</td><td class="line"> </td></tr>
<tr><td class="num" id="LN978">978</td><td class="line">      <span class='comment'>// Get the correct receiver in the optimized frame.</span></td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">      Object* receiver;</td></tr>
<tr><td class="num" id="LN980">980</td><td class="line">      <span class='keyword'>if</span> (opcode == Translation::LITERAL) {</td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">        receiver = literal_array-&gt;get(it.Next());</td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (opcode == Translation::STACK_SLOT) {</td></tr>
<tr><td class="num" id="LN983">983</td><td class="line">        receiver = StackSlotAt(it.Next());</td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">        <span class='comment'>// The receiver is not in a stack slot nor in a literal.  We give up.</span></td></tr>
<tr><td class="num" id="LN986">986</td><td class="line">        it.Skip(Translation::NumberOfOperandsFor(opcode));</td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">        <span class='comment'>// TODO(3029): Materializing a captured object (or duplicated</span></td></tr>
<tr><td class="num" id="LN988">988</td><td class="line">        <span class='comment'>// object) is hard, we return undefined for now. This breaks the</span></td></tr>
<tr><td class="num" id="LN989">989</td><td class="line">        <span class='comment'>// produced stack trace, as constructor frames aren't marked as</span></td></tr>
<tr><td class="num" id="LN990">990</td><td class="line">        <span class='comment'>// such anymore.</span></td></tr>
<tr><td class="num" id="LN991">991</td><td class="line">        receiver = isolate()-&gt;heap()-&gt;undefined_value();</td></tr>
<tr><td class="num" id="LN992">992</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN993">993</td><td class="line"> </td></tr>
<tr><td class="num" id="LN994">994</td><td class="line">      AbstractCode* abstract_code;</td></tr>
<tr><td class="num" id="LN995">995</td><td class="line"> </td></tr>
<tr><td class="num" id="LN996">996</td><td class="line">      <span class='keyword'>unsigned</span> code_offset;</td></tr>
<tr><td class="num" id="LN997">997</td><td class="line">      <span class='keyword'>if</span> (frame_opcode == Translation::JS_FRAME) {</td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">        Code* code = shared_info-&gt;code();</td></tr>
<tr><td class="num" id="LN999">999</td><td class="line">        DeoptimizationOutputData* <span class='keyword'>const</span> output_data =</td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line">            DeoptimizationOutputData::cast(code-&gt;deoptimization_data());</td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line">        <span class='keyword'>unsigned</span> <span class='keyword'>const</span> entry =</td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line">            Deoptimizer::GetOutputInfo(output_data, ast_id, shared_info);</td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line">        code_offset = FullCodeGenerator::PcField::decode(entry);</td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line">        abstract_code = AbstractCode::cast(code);</td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line">        <span class='comment'>// TODO(rmcilroy): Modify FrameSummary to enable us to summarize</span></td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line">        <span class='comment'>// based on the BytecodeArray and bytecode offset.</span></td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line">        <span class='macro'>DCHECK_EQ(frame_opcode, Translation::INTERPRETED_FRAME)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (frame_opcode<br>), (Translation::INTERPRETED_FRAME), "frame_opcode" " " "==" " "<br> "Translation::INTERPRETED_FRAME")) { V8_Fatal("../src/frames.cc"<br>, 1008, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line">        code_offset = 0;</td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line">        abstract_code = AbstractCode::cast(shared_info-&gt;bytecode_array());</td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line">      FrameSummary summary(receiver, function, abstract_code, code_offset,</td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">                           is_constructor);</td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">      frames-&gt;Add(summary);</td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">      is_constructor = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (frame_opcode == Translation::CONSTRUCT_STUB_FRAME) {</td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line">      <span class='comment'>// The next encountered JS_FRAME will be marked as a constructor call.</span></td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line">      it.Skip(Translation::NumberOfOperandsFor(frame_opcode));</td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line">      <span class='macro'>DCHECK(!is_constructor)<span class='expansion'>do { if ((__builtin_expect(!!(!(!is_constructor)), 0))) { V8_Fatal<br>("../src/frames.cc", 1019, "Check failed: %s.", "!is_constructor"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">      is_constructor = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line">      <span class='comment'>// Skip over operands to advance to the next opcode.</span></td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line">      it.Skip(Translation::NumberOfOperandsFor(frame_opcode));</td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line">  <span class='macro'>DCHECK(!is_constructor)<span class='expansion'>do { if ((__builtin_expect(!!(!(!is_constructor)), 0))) { V8_Fatal<br>("../src/frames.cc", 1026, "Check failed: %s.", "!is_constructor"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line"><span class='keyword'>int</span> OptimizedFrame::LookupExceptionHandlerInTable(</td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line">    <span class='keyword'>int</span>* stack_slots, HandlerTable::CatchPrediction* prediction) {</td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line">  Code* code = LookupCode();</td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line">  <span class='macro'>DCHECK(code-&gt;is_optimized_code())<span class='expansion'>do { if ((__builtin_expect(!!(!(code-&gt;is_optimized_code())<br>), 0))) { V8_Fatal("../src/frames.cc", 1033, "Check failed: %s."<br>, "code-&gt;is_optimized_code()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line">  HandlerTable* table = HandlerTable::cast(code-&gt;handler_table());</td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line">  <span class='keyword'>int</span> pc_offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(pc() - code-&gt;entry());</td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line">  <span class='keyword'>if</span> (stack_slots) *stack_slots = code-&gt;stack_slots();</td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">  <span class='keyword'>return</span> table-&gt;LookupReturn(pc_offset, prediction);</td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line">DeoptimizationInputData* OptimizedFrame::GetDeoptimizationData(</td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line">    <span class='keyword'>int</span>* deopt_index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line">  <span class='macro'>DCHECK(is_optimized())<span class='expansion'>do { if ((__builtin_expect(!!(!(is_optimized())), 0))) { V8_Fatal<br>("../src/frames.cc", 1043, "Check failed: %s.", "is_optimized()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line">  JSFunction* opt_function = function();</td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line">  Code* code = opt_function-&gt;code();</td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line">  <span class='comment'>// The code object may have been replaced by lazy deoptimization. Fall</span></td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line">  <span class='comment'>// back to a slow search in this case to find the original optimized</span></td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line">  <span class='comment'>// code object.</span></td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line">  <span class='keyword'>if</span> (!code-&gt;contains(pc())) {</td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line">    code = isolate()-&gt;inner_pointer_to_code_cache()-&gt;</td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line">        GcSafeFindCodeForInnerPointer(pc());</td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line">  <span class='macro'>DCHECK(code != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(code != __null)), 0))) { V8_Fatal<br>("../src/frames.cc", 1055, "Check failed: %s.", "code != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line">  <span class='macro'>DCHECK(code-&gt;kind() == Code::OPTIMIZED_FUNCTION)<span class='expansion'>do { if ((__builtin_expect(!!(!(code-&gt;kind() == Code::OPTIMIZED_FUNCTION<br>)), 0))) { V8_Fatal("../src/frames.cc", 1056, "Check failed: %s."<br>, "code-&gt;kind() == Code::OPTIMIZED_FUNCTION"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line">  SafepointEntry safepoint_entry = code-&gt;GetSafepointEntry(pc());</td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line">  *deopt_index = safepoint_entry.deoptimization_index();</td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line">  <span class='macro'>DCHECK(*deopt_index != Safepoint::kNoDeoptimizationIndex)<span class='expansion'>do { if ((__builtin_expect(!!(!(*deopt_index != Safepoint::kNoDeoptimizationIndex<br>)), 0))) { V8_Fatal("../src/frames.cc", 1060, "Check failed: %s."<br>, "*deopt_index != Safepoint::kNoDeoptimizationIndex"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line">  <span class='keyword'>return</span> DeoptimizationInputData::cast(code-&gt;deoptimization_data());</td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line"><span class='keyword'>void</span> OptimizedFrame::GetFunctions(List&lt;JSFunction*&gt;* functions) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line">  <span class='macro'>DCHECK(functions-&gt;length() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(functions-&gt;length() == 0))<br>, 0))) { V8_Fatal("../src/frames.cc", 1067, "Check failed: %s."<br>, "functions-&gt;length() == 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line">  <span class='macro'>DCHECK(is_optimized())<span class='expansion'>do { if ((__builtin_expect(!!(!(is_optimized())), 0))) { V8_Fatal<br>("../src/frames.cc", 1068, "Check failed: %s.", "is_optimized()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line">  <span class='comment'>// Delegate to JS frame in absence of turbofan deoptimization.</span></td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line">  <span class='comment'>// TODO(turbofan): Revisit once we support deoptimization across the board.</span></td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line">  <span class='keyword'>if</span> (LookupCode()-&gt;is_turbofanned() &amp;&amp; function()-&gt;shared()-&gt;asm_function() &amp;&amp;</td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line">      !FLAG_turbo_asm_deoptimization) {</td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line">    <span class='keyword'>return</span> JavaScriptFrame::GetFunctions(functions);</td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line">  <span class='keyword'>int</span> deopt_index = Safepoint::kNoDeoptimizationIndex;</td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line">  DeoptimizationInputData* <span class='keyword'>const</span> data = GetDeoptimizationData(&amp;deopt_index);</td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">  FixedArray* <span class='keyword'>const</span> literal_array = data-&gt;LiteralArray();</td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">  TranslationIterator it(data-&gt;TranslationByteArray(),</td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line">                         data-&gt;TranslationIndex(deopt_index)-&gt;value());</td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">  Translation::Opcode opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">  <span class='macro'>DCHECK_EQ(Translation::BEGIN, opcode)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (Translation<br>::BEGIN), (opcode), "Translation::BEGIN" " " "==" " " "opcode"<br>)) { V8_Fatal("../src/frames.cc", 1085, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line">  it.Next();  <span class='comment'>// Skip frame count.</span></td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">  <span class='keyword'>int</span> jsframe_count = it.Next();</td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">  <span class='comment'>// We insert the frames in reverse order because the frames</span></td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line">  <span class='comment'>// in the deoptimization translation are ordered bottom-to-top.</span></td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">  <span class='keyword'>while</span> (jsframe_count != 0) {</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">    opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line">    <span class='comment'>// Skip over operands to advance to the next opcode.</span></td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line">    it.Skip(Translation::NumberOfOperandsFor(opcode));</td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line">    <span class='keyword'>if</span> (opcode == Translation::JS_FRAME ||</td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line">        opcode == Translation::INTERPRETED_FRAME) {</td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line">      jsframe_count--;</td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line">      <span class='comment'>// The translation commands are ordered and the function is always at the</span></td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">      <span class='comment'>// first position.</span></td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line">      opcode = <span class='keyword'>static_cast</span>&lt;Translation::Opcode&gt;(it.Next());</td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line">      <span class='comment'>// Get the correct function in the optimized frame.</span></td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">      Object* function;</td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">      <span class='keyword'>if</span> (opcode == Translation::LITERAL) {</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line">        function = literal_array-&gt;get(it.Next());</td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line">        <span class='macro'>CHECK_EQ(Translation::STACK_SLOT, opcode)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (Translation<br>::STACK_SLOT), (opcode), "Translation::STACK_SLOT" " " "==" " "<br> "opcode")) { V8_Fatal("../src/frames.cc", 1108, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line">        function = StackSlotAt(it.Next());</td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line">      functions-&gt;Add(JSFunction::cast(function));</td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line"><span class='keyword'>int</span> OptimizedFrame::StackSlotOffsetRelativeToFp(<span class='keyword'>int</span> slot_index) {</td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line">  <span class='keyword'>return</span> StandardFrameConstants::kCallerSPOffset -</td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line">         ((slot_index + 1) * kPointerSize);</td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line">Object* OptimizedFrame::StackSlotAt(<span class='keyword'>int</span> index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line">  <span class='keyword'>return</span> Memory::Object_at(fp() + StackSlotOffsetRelativeToFp(index));</td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line"><span class='keyword'>int</span> InterpretedFrame::LookupExceptionHandlerInTable(</td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line">    <span class='keyword'>int</span>* context_register, HandlerTable::CatchPrediction* prediction) {</td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line">  BytecodeArray* bytecode = function()-&gt;shared()-&gt;bytecode_array();</td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line">  HandlerTable* table = HandlerTable::cast(bytecode-&gt;handler_table());</td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line">  <span class='keyword'>int</span> pc_offset = GetBytecodeOffset() + 1;  <span class='comment'>// Point after current bytecode.</span></td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line">  <span class='keyword'>return</span> table-&gt;LookupRange(pc_offset, context_register, prediction);</td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line"><span class='keyword'>int</span> InterpretedFrame::GetBytecodeOffset() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> index = InterpreterFrameConstants::kBytecodeOffsetExpressionIndex;</td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">  <span class='macro'>DCHECK_EQ(<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1139, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kBytecodeOffsetFromFp,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1139, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1139, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line">  <span class='keyword'>int</span> raw_offset = Smi::cast(GetExpression(index))-&gt;value();</td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line">  <span class='keyword'>return</span> raw_offset - BytecodeArray::kHeaderSize + kHeapObjectTag;</td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line"><span class='keyword'>void</span> InterpretedFrame::PatchBytecodeOffset(<span class='keyword'>int</span> new_offset) {</td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> index = InterpreterFrameConstants::kBytecodeOffsetExpressionIndex;</td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">  <span class='macro'>DCHECK_EQ(<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1148, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kBytecodeOffsetFromFp,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1148, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeOffsetFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeOffsetFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1148, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line">  <span class='keyword'>int</span> raw_offset = new_offset + BytecodeArray::kHeaderSize - kHeapObjectTag;</td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line">  SetExpression(index, Smi::FromInt(raw_offset));</td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">Object* InterpretedFrame::GetBytecodeArray() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> index = InterpreterFrameConstants::kBytecodeArrayExpressionIndex;</td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">  <span class='macro'>DCHECK_EQ(<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1157, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kBytecodeArrayFromFp,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1157, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1157, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line">  <span class='keyword'>return</span> GetExpression(index);</td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line"><span class='keyword'>void</span> InterpretedFrame::PatchBytecodeArray(Object* bytecode_array) {</td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> index = InterpreterFrameConstants::kBytecodeArrayExpressionIndex;</td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line">  <span class='macro'>DCHECK_EQ(<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1165, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kBytecodeArrayFromFp,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1165, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kBytecodeArrayFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kBytecodeArrayFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1165, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line">  SetExpression(index, bytecode_array);</td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line">Object* InterpretedFrame::GetInterpreterRegister(<span class='keyword'>int</span> register_index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> index = InterpreterFrameConstants::kRegisterFileExpressionIndex;</td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line">  <span class='macro'>DCHECK_EQ(<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kRegisterFilePointerFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kRegisterFilePointerFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1173, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kRegisterFilePointerFromFp,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kRegisterFilePointerFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kRegisterFilePointerFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1173, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">      <span class='macro'>InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (InterpreterFrameConstants<br>::kRegisterFilePointerFromFp), (InterpreterFrameConstants::kExpressionsOffset<br> - index * kPointerSize), "InterpreterFrameConstants::kRegisterFilePointerFromFp"<br> " " "==" " " "InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize"<br>)) { V8_Fatal("../src/frames.cc", 1173, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">  <span class='keyword'>return</span> GetExpression(index + register_index);</td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line"><span class='keyword'>void</span> InterpretedFrame::Summarize(List&lt;FrameSummary&gt;* functions) {</td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line">  <span class='macro'>DCHECK(functions-&gt;length() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(functions-&gt;length() == 0))<br>, 0))) { V8_Fatal("../src/frames.cc", 1178, "Check failed: %s."<br>, "functions-&gt;length() == 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">  AbstractCode* abstract_code =</td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line">      AbstractCode::cast(function()-&gt;shared()-&gt;bytecode_array());</td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line">  FrameSummary summary(receiver(), function(), abstract_code,</td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line">                       GetBytecodeOffset(), IsConstructor());</td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line">  functions-&gt;Add(summary);</td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line"><span class='keyword'>int</span> ArgumentsAdaptorFrame::GetNumberOfIncomingArguments() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line">  <span class='keyword'>return</span> Smi::cast(GetExpression(0))-&gt;value();</td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line">Address ArgumentsAdaptorFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line">  <span class='keyword'>return</span> fp() + StandardFrameConstants::kCallerSPOffset;</td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line"><span class='keyword'>int</span> ArgumentsAdaptorFrame::GetLength(Address fp) {</td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = ArgumentsAdaptorFrameConstants::kLengthOffset;</td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line">  <span class='keyword'>return</span> Smi::cast(Memory::Object_at(fp + offset))-&gt;value();</td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line">Code* ArgumentsAdaptorFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line">  <span class='keyword'>return</span> isolate()-&gt;builtins()-&gt;builtin(</td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line">      Builtins::kArgumentsAdaptorTrampoline);</td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line">Address InternalFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line">  <span class='comment'>// Internal frames have no arguments. The stack pointer of the</span></td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line">  <span class='comment'>// caller is at a fixed offset from the frame pointer.</span></td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line">  <span class='keyword'>return</span> fp() + StandardFrameConstants::kCallerSPOffset;</td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line">Code* InternalFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = InternalFrameConstants::kCodeOffset;</td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line">  Object* code = Memory::Object_at(fp() + offset);</td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line">  <span class='macro'>DCHECK(code != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(code != __null)), 0))) { V8_Fatal<br>("../src/frames.cc", 1214, "Check failed: %s.", "code != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>reinterpret_cast</span>&lt;Code*&gt;(code);</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line"><span class='keyword'>void</span> StackFrame::PrintIndex(StringStream* accumulator,</td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">                            PrintMode mode,</td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line">                            <span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line">  accumulator-&gt;Add((mode == OVERVIEW) ? <span class='string_literal'>"%5d: "</span> : <span class='string_literal'>"[%d]: "</span>, index);</td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line"><span class='keyword'>namespace</span> {</td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line"><span class='keyword'>void</span> PrintFunctionSource(StringStream* accumulator, SharedFunctionInfo* shared,</td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line">                         Code* code) {</td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">  <span class='keyword'>if</span> (FLAG_max_stack_trace_source_length != 0 &amp;&amp; code != <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line">    std::ostringstream os;</td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line">    os &lt;&lt; <span class='string_literal'>"--------- s o u r c e   c o d e ---------\n"</span></td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line">       &lt;&lt; SourceCodeOf(shared, FLAG_max_stack_trace_source_length)</td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line">       &lt;&lt; <span class='string_literal'>"\n-----------------------------------------\n"</span>;</td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">    accumulator-&gt;Add(os.str().c_str());</td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line">}  <span class='comment'>// namespace</span></td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::Print(StringStream* accumulator,</td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">                            PrintMode mode,</td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line">                            <span class='keyword'>int</span> index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">  Object* receiver = <span class='keyword'>this</span>-&gt;receiver();</td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">  JSFunction* function = <span class='keyword'>this</span>-&gt;function();</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line">  accumulator-&gt;PrintSecurityTokenIfChanged(function);</td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">  PrintIndex(accumulator, mode, index);</td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line">  Code* code = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line">  <span class='keyword'>if</span> (IsConstructor()) accumulator-&gt;Add(<span class='string_literal'>"new "</span>);</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path1" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">1</div></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path2" title="Next event (2)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line">  accumulator-&gt;PrintFunction(function, receiver, &amp;code);</td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line">  <span class='comment'>// Get scope information for nicer output, if possible. If code is NULL, or</span></td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line">  <span class='comment'>// doesn't contain scope info, scope_info will return 0 for the number of</span></td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line">  <span class='comment'>// parameters, stack local variables, context local variables, stack slots,</span></td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line">  <span class='comment'>// or context slots.</span></td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line">  SharedFunctionInfo* shared = function-&gt;shared();</td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line">  ScopeInfo* scope_info = shared-&gt;scope_info();</td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line">  Object* script_obj = shared-&gt;script();</td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line">  <span class='keyword'>if</span> (script_obj-&gt;IsScript()) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path2" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">2</div></td><td><div class="PathNav"><a href="#Path1" title="Previous event (1)">&#x2190;</a></div></td></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path3" title="Next event (3)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line">    Script* script = Script::cast(script_obj);</td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>" ["</span>);</td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line">    accumulator-&gt;PrintName(script-&gt;name());</td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line">    Address pc = <span class='keyword'>this</span>-&gt;pc();</td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line">    <span class='keyword'>if</span> (code != <span class='macro'>NULL<span class='expansion'>__null</span></span> &amp;&amp; code-&gt;kind() == Code::FUNCTION &amp;&amp;</td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line">        pc &gt;= code-&gt;instruction_start() &amp;&amp; pc &lt; code-&gt;instruction_end()) {</td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line">      <span class='keyword'>int</span> offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(pc - code-&gt;instruction_start());</td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line">      <span class='keyword'>int</span> source_pos = code-&gt;SourcePosition(offset);</td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line">      <span class='keyword'>int</span> line = script-&gt;GetLineNumber(source_pos) + 1;</td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>":%d"</span>, line);</td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line">      <span class='keyword'>int</span> function_start_pos = shared-&gt;start_position();</td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line">      <span class='keyword'>int</span> line = script-&gt;GetLineNumber(function_start_pos) + 1;</td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>":~%d"</span>, line);</td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"] [pc=%p] "</span>, pc);</td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>"(this=%o"</span>, receiver);</td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line">  <span class='comment'>// Print the parameters.</span></td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line">  <span class='keyword'>int</span> parameters_count = ComputeParametersCount();</td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; <span class="mrange">i &lt; parameters_count</span>; i++) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path3" class="msg msgEvent" style="margin-left:19ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">3</div></td><td><div class="PathNav"><a href="#Path2" title="Previous event (2)">&#x2190;</a></div></td></td><td>Assuming 'i' is &gt;= 'parameters_count'</td><td><div class="PathNav"><a href="#Path4" title="Next event (4)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num"></td><td class="line"><div id="Path4" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">4</div></td><td><div class="PathNav"><a href="#Path3" title="Previous event (3)">&#x2190;</a></div></td></td><td>Loop condition is false. Execution continues on line 1301</td><td><div class="PathNav"><a href="#Path5" title="Next event (5)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>","</span>);</td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line">    <span class='comment'>// If we have a name for the parameter we print it. Nameless</span></td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line">    <span class='comment'>// parameters are either because we have more actual parameters</span></td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">    <span class='comment'>// than formal parameters or because we have no scope information.</span></td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line">    <span class='keyword'>if</span> (i &lt; scope_info-&gt;ParameterCount()) {</td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">      accumulator-&gt;PrintName(scope_info-&gt;ParameterName(i));</td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>"="</span>);</td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"%o"</span>, GetParameter(i));</td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>")"</span>);</td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line">  <span class='keyword'>if</span> (mode == OVERVIEW) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path5" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">5</div></td><td><div class="PathNav"><a href="#Path4" title="Previous event (4)">&#x2190;</a></div></td></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path6" title="Next event (6)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line">  <span class='keyword'>if</span> (is_optimized()) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path6" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">6</div></td><td><div class="PathNav"><a href="#Path5" title="Previous event (5)">&#x2190;</a></div></td></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path7" title="Next event (7)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>" {\n// optimized frame\n"</span>);</td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line">    PrintFunctionSource(accumulator, shared, code);</td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"}\n"</span>);</td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>" {\n"</span>);</td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line">  <span class='comment'>// Compute the number of locals and expression stack elements.</span></td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line">  <span class='keyword'>int</span> stack_locals_count = scope_info-&gt;StackLocalCount();</td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line">  <span class='keyword'>int</span> heap_locals_count = scope_info-&gt;ContextLocalCount();</td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line">  <span class='keyword'>int</span> expressions_count = ComputeExpressionsCount();</td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line">  <span class='comment'>// Print stack-allocated local variables.</span></td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line">  <span class='keyword'>if</span> (stack_locals_count &gt; 0) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path7" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">7</div></td><td><div class="PathNav"><a href="#Path6" title="Previous event (6)">&#x2190;</a></div></td></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path8" title="Next event (8)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  // stack-allocated locals\n"</span>);</td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; stack_locals_count; i++) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path8" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">8</div></td><td><div class="PathNav"><a href="#Path7" title="Previous event (7)">&#x2190;</a></div></td></td><td>Loop condition is false. Execution continues on line 1336</td><td><div class="PathNav"><a href="#Path9" title="Next event (9)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  var "</span>);</td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line">    accumulator-&gt;PrintName(scope_info-&gt;StackLocalName(i));</td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>" = "</span>);</td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line">    <span class='keyword'>if</span> (i &lt; expressions_count) {</td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>"%o"</span>, GetExpression(i));</td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>"// no expression found - inconsistent frame?"</span>);</td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line">  <span class='comment'>// Try to get hold of the context of this frame.</span></td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line">  <span class="mrange">Context* context</span> = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path9" class="msg msgEvent" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">9</div></td><td><div class="PathNav"><a href="#Path8" title="Previous event (8)">&#x2190;</a></div></td></td><td>'context' initialized to a null pointer value</td><td><div class="PathNav"><a href="#EndPath" title="Next event (10)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line">  <span class='keyword'>if</span> (<span class='keyword'>this</span>-&gt;context() != <span class='macro'>NULL<span class='expansion'>__null</span></span> &amp;&amp; <span class='keyword'>this</span>-&gt;context()-&gt;IsContext()) {</td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line">    context = Context::cast(<span class='keyword'>this</span>-&gt;context());</td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line">  <span class='keyword'>while</span> (<span class="mrange">context</span>-&gt;IsWithContext()) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:10ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">10</div></td><td><div class="PathNav"><a href="#Path9" title="Previous event (9)">&#x2190;</a></div></td></td><td>Called C++ object pointer is null</td></tr></table></div></td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line">    context = context-&gt;previous();</td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line">    <span class='macro'>DCHECK(context != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(context != __null)), 0))) { V8_Fatal<br>("../src/frames.cc", 1342, "Check failed: %s.", "context != __null"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line">  <span class='comment'>// Print heap-allocated local variables.</span></td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line">  <span class='keyword'>if</span> (heap_locals_count &gt; 0) {</td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  // heap-allocated locals\n"</span>);</td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; heap_locals_count; i++) {</td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  var "</span>);</td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line">    accumulator-&gt;PrintName(scope_info-&gt;ContextLocalName(i));</td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>" = "</span>);</td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line">    <span class='keyword'>if</span> (context != <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line">      <span class='keyword'>int</span> index = Context::MIN_CONTEXT_SLOTS + i;</td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line">      <span class='keyword'>if</span> (index &lt; context-&gt;length()) {</td></tr>
<tr><td class="num" id="LN1356">1356</td><td class="line">        accumulator-&gt;Add(<span class='string_literal'>"%o"</span>, context-&gt;get(index));</td></tr>
<tr><td class="num" id="LN1357">1357</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1358">1358</td><td class="line">        accumulator-&gt;Add(</td></tr>
<tr><td class="num" id="LN1359">1359</td><td class="line">            <span class='string_literal'>"// warning: missing context slot - inconsistent frame?"</span>);</td></tr>
<tr><td class="num" id="LN1360">1360</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1361">1361</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1362">1362</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>"// warning: no context found - inconsistent frame?"</span>);</td></tr>
<tr><td class="num" id="LN1363">1363</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1364">1364</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1365">1365</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1366">1366</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1367">1367</td><td class="line">  <span class='comment'>// Print the expression stack.</span></td></tr>
<tr><td class="num" id="LN1368">1368</td><td class="line">  <span class='keyword'>int</span> expressions_start = stack_locals_count;</td></tr>
<tr><td class="num" id="LN1369">1369</td><td class="line">  <span class='keyword'>if</span> (expressions_start &lt; expressions_count) {</td></tr>
<tr><td class="num" id="LN1370">1370</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  // expression stack (top to bottom)\n"</span>);</td></tr>
<tr><td class="num" id="LN1371">1371</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1372">1372</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = expressions_count - 1; i &gt;= expressions_start; i--) {</td></tr>
<tr><td class="num" id="LN1373">1373</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  [%02d] : %o\n"</span>, i, GetExpression(i));</td></tr>
<tr><td class="num" id="LN1374">1374</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1375">1375</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1376">1376</td><td class="line">  PrintFunctionSource(accumulator, shared, code);</td></tr>
<tr><td class="num" id="LN1377">1377</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1378">1378</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>"}\n\n"</span>);</td></tr>
<tr><td class="num" id="LN1379">1379</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1380">1380</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1381">1381</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1382">1382</td><td class="line"><span class='keyword'>void</span> ArgumentsAdaptorFrame::Print(StringStream* accumulator,</td></tr>
<tr><td class="num" id="LN1383">1383</td><td class="line">                                  PrintMode mode,</td></tr>
<tr><td class="num" id="LN1384">1384</td><td class="line">                                  <span class='keyword'>int</span> index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1385">1385</td><td class="line">  <span class='keyword'>int</span> actual = ComputeParametersCount();</td></tr>
<tr><td class="num" id="LN1386">1386</td><td class="line">  <span class='keyword'>int</span> expected = -1;</td></tr>
<tr><td class="num" id="LN1387">1387</td><td class="line">  JSFunction* function = <span class='keyword'>this</span>-&gt;function();</td></tr>
<tr><td class="num" id="LN1388">1388</td><td class="line">  expected = function-&gt;shared()-&gt;internal_formal_parameter_count();</td></tr>
<tr><td class="num" id="LN1389">1389</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1390">1390</td><td class="line">  PrintIndex(accumulator, mode, index);</td></tr>
<tr><td class="num" id="LN1391">1391</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>"arguments adaptor frame: %d-&gt;%d"</span>, actual, expected);</td></tr>
<tr><td class="num" id="LN1392">1392</td><td class="line">  <span class='keyword'>if</span> (mode == OVERVIEW) {</td></tr>
<tr><td class="num" id="LN1393">1393</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1394">1394</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1395">1395</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1396">1396</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>" {\n"</span>);</td></tr>
<tr><td class="num" id="LN1397">1397</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1398">1398</td><td class="line">  <span class='comment'>// Print actual arguments.</span></td></tr>
<tr><td class="num" id="LN1399">1399</td><td class="line">  <span class='keyword'>if</span> (actual &gt; 0) accumulator-&gt;Add(<span class='string_literal'>"  // actual arguments\n"</span>);</td></tr>
<tr><td class="num" id="LN1400">1400</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; actual; i++) {</td></tr>
<tr><td class="num" id="LN1401">1401</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"  [%02d] : %o"</span>, i, GetParameter(i));</td></tr>
<tr><td class="num" id="LN1402">1402</td><td class="line">    <span class='keyword'>if</span> (expected != -1 &amp;&amp; i &gt;= expected) {</td></tr>
<tr><td class="num" id="LN1403">1403</td><td class="line">      accumulator-&gt;Add(<span class='string_literal'>"  // not passed to callee"</span>);</td></tr>
<tr><td class="num" id="LN1404">1404</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1405">1405</td><td class="line">    accumulator-&gt;Add(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1406">1406</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1407">1407</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1408">1408</td><td class="line">  accumulator-&gt;Add(<span class='string_literal'>"}\n\n"</span>);</td></tr>
<tr><td class="num" id="LN1409">1409</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1410">1410</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1411">1411</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1412">1412</td><td class="line"><span class='keyword'>void</span> EntryFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1413">1413</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), LookupCode());</td></tr>
<tr><td class="num" id="LN1414">1414</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1415">1415</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1416">1416</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1417">1417</td><td class="line"><span class='keyword'>void</span> StandardFrame::IterateExpressions(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1418">1418</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = StandardFrameConstants::kLastObjectOffset;</td></tr>
<tr><td class="num" id="LN1419">1419</td><td class="line">  Object** base = &amp;Memory::Object_at(sp());</td></tr>
<tr><td class="num" id="LN1420">1420</td><td class="line">  Object** limit = &amp;Memory::Object_at(fp() + offset) + 1;</td></tr>
<tr><td class="num" id="LN1421">1421</td><td class="line">  v-&gt;VisitPointers(base, limit);</td></tr>
<tr><td class="num" id="LN1422">1422</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1423">1423</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1424">1424</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1425">1425</td><td class="line"><span class='keyword'>void</span> JavaScriptFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1426">1426</td><td class="line">  IterateExpressions(v);</td></tr>
<tr><td class="num" id="LN1427">1427</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), LookupCode());</td></tr>
<tr><td class="num" id="LN1428">1428</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1429">1429</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1430">1430</td><td class="line"><span class='keyword'>void</span> InternalFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1431">1431</td><td class="line">  <span class='comment'>// Internal frames only have object pointers on the expression stack</span></td></tr>
<tr><td class="num" id="LN1432">1432</td><td class="line">  <span class='comment'>// as they never have any arguments.</span></td></tr>
<tr><td class="num" id="LN1433">1433</td><td class="line">  IterateExpressions(v);</td></tr>
<tr><td class="num" id="LN1434">1434</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), LookupCode());</td></tr>
<tr><td class="num" id="LN1435">1435</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1436">1436</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1437">1437</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1438">1438</td><td class="line"><span class='keyword'>void</span> StubFailureTrampolineFrame::Iterate(ObjectVisitor* v) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1439">1439</td><td class="line">  Object** base = &amp;Memory::Object_at(sp());</td></tr>
<tr><td class="num" id="LN1440">1440</td><td class="line">  Object** limit = &amp;Memory::Object_at(fp() +</td></tr>
<tr><td class="num" id="LN1441">1441</td><td class="line">                                      kFirstRegisterParameterFrameOffset);</td></tr>
<tr><td class="num" id="LN1442">1442</td><td class="line">  v-&gt;VisitPointers(base, limit);</td></tr>
<tr><td class="num" id="LN1443">1443</td><td class="line">  base = &amp;Memory::Object_at(fp() + StandardFrameConstants::kMarkerOffset);</td></tr>
<tr><td class="num" id="LN1444">1444</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> offset = StandardFrameConstants::kLastObjectOffset;</td></tr>
<tr><td class="num" id="LN1445">1445</td><td class="line">  limit = &amp;Memory::Object_at(fp() + offset) + 1;</td></tr>
<tr><td class="num" id="LN1446">1446</td><td class="line">  v-&gt;VisitPointers(base, limit);</td></tr>
<tr><td class="num" id="LN1447">1447</td><td class="line">  IteratePc(v, pc_address(), constant_pool_address(), LookupCode());</td></tr>
<tr><td class="num" id="LN1448">1448</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1449">1449</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1450">1450</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1451">1451</td><td class="line">Address StubFailureTrampolineFrame::GetCallerStackPointer() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1452">1452</td><td class="line">  <span class='keyword'>return</span> fp() + StandardFrameConstants::kCallerSPOffset;</td></tr>
<tr><td class="num" id="LN1453">1453</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1454">1454</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1455">1455</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1456">1456</td><td class="line">Code* StubFailureTrampolineFrame::unchecked_code() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1457">1457</td><td class="line">  Code* trampoline;</td></tr>
<tr><td class="num" id="LN1458">1458</td><td class="line">  StubFailureTrampolineStub(isolate(), NOT_JS_FUNCTION_STUB_MODE).</td></tr>
<tr><td class="num" id="LN1459">1459</td><td class="line">      FindCodeInCache(&amp;trampoline);</td></tr>
<tr><td class="num" id="LN1460">1460</td><td class="line">  <span class='keyword'>if</span> (trampoline-&gt;contains(pc())) {</td></tr>
<tr><td class="num" id="LN1461">1461</td><td class="line">    <span class='keyword'>return</span> trampoline;</td></tr>
<tr><td class="num" id="LN1462">1462</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1463">1463</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1464">1464</td><td class="line">  StubFailureTrampolineStub(isolate(), JS_FUNCTION_STUB_MODE).</td></tr>
<tr><td class="num" id="LN1465">1465</td><td class="line">      FindCodeInCache(&amp;trampoline);</td></tr>
<tr><td class="num" id="LN1466">1466</td><td class="line">  <span class='keyword'>if</span> (trampoline-&gt;contains(pc())) {</td></tr>
<tr><td class="num" id="LN1467">1467</td><td class="line">    <span class='keyword'>return</span> trampoline;</td></tr>
<tr><td class="num" id="LN1468">1468</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1469">1469</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1470">1470</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/frames.cc", 1470, "unreachable code")</span></span>;</td></tr>
<tr><td class="num" id="LN1471">1471</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1472">1472</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1473">1473</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1474">1474</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1475">1475</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN1476">1476</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1477">1477</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1478">1478</td><td class="line">JavaScriptFrame* StackFrameLocator::FindJavaScriptFrame(<span class='keyword'>int</span> n) {</td></tr>
<tr><td class="num" id="LN1479">1479</td><td class="line">  <span class='macro'>DCHECK(n &gt;= 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(n &gt;= 0)), 0))) { V8_Fatal(<br>"../src/frames.cc", 1479, "Check failed: %s.", "n &gt;= 0"); }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1480">1480</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt;= n; i++) {</td></tr>
<tr><td class="num" id="LN1481">1481</td><td class="line">    <span class='keyword'>while</span> (!iterator_.frame()-&gt;is_java_script()) iterator_.Advance();</td></tr>
<tr><td class="num" id="LN1482">1482</td><td class="line">    <span class='keyword'>if</span> (i == n) <span class='keyword'>return</span> JavaScriptFrame::cast(iterator_.frame());</td></tr>
<tr><td class="num" id="LN1483">1483</td><td class="line">    iterator_.Advance();</td></tr>
<tr><td class="num" id="LN1484">1484</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1485">1485</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/frames.cc", 1485, "unreachable code")</span></span>;</td></tr>
<tr><td class="num" id="LN1486">1486</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1487">1487</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1488">1488</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1489">1489</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1490">1490</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN1491">1491</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1492">1492</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1493">1493</td><td class="line"><span class='keyword'>static</span> Map* GcSafeMapOfCodeSpaceObject(HeapObject* object) {</td></tr>
<tr><td class="num" id="LN1494">1494</td><td class="line">  MapWord map_word = object-&gt;map_word();</td></tr>
<tr><td class="num" id="LN1495">1495</td><td class="line">  <span class='keyword'>return</span> map_word.IsForwardingAddress() ?</td></tr>
<tr><td class="num" id="LN1496">1496</td><td class="line">      map_word.ToForwardingAddress()-&gt;map() : map_word.ToMap();</td></tr>
<tr><td class="num" id="LN1497">1497</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1498">1498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1499">1499</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1500">1500</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> GcSafeSizeOfCodeSpaceObject(HeapObject* object) {</td></tr>
<tr><td class="num" id="LN1501">1501</td><td class="line">  <span class='keyword'>return</span> object-&gt;SizeFromMap(GcSafeMapOfCodeSpaceObject(object));</td></tr>
<tr><td class="num" id="LN1502">1502</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1503">1503</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1504">1504</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1505">1505</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1506">1506</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>bool</span> GcSafeCodeContains(HeapObject* code, Address addr) {</td></tr>
<tr><td class="num" id="LN1507">1507</td><td class="line">  Map* map = GcSafeMapOfCodeSpaceObject(code);</td></tr>
<tr><td class="num" id="LN1508">1508</td><td class="line">  <span class='macro'>DCHECK(map == code-&gt;GetHeap()-&gt;code_map())<span class='expansion'>do { if ((__builtin_expect(!!(!(map == code-&gt;GetHeap()-&gt;<br>code_map())), 0))) { V8_Fatal("../src/frames.cc", 1508, "Check failed: %s."<br>, "map == code-&gt;GetHeap()-&gt;code_map()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1509">1509</td><td class="line">  Address start = code-&gt;address();</td></tr>
<tr><td class="num" id="LN1510">1510</td><td class="line">  Address end = code-&gt;address() + code-&gt;SizeFromMap(map);</td></tr>
<tr><td class="num" id="LN1511">1511</td><td class="line">  <span class='keyword'>return</span> start &lt;= addr &amp;&amp; addr &lt; end;</td></tr>
<tr><td class="num" id="LN1512">1512</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1513">1513</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1514">1514</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1515">1515</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1516">1516</td><td class="line">Code* InnerPointerToCodeCache::GcSafeCastToCode(HeapObject* object,</td></tr>
<tr><td class="num" id="LN1517">1517</td><td class="line">                                                Address inner_pointer) {</td></tr>
<tr><td class="num" id="LN1518">1518</td><td class="line">  Code* code = <span class='keyword'>reinterpret_cast</span>&lt;Code*&gt;(object);</td></tr>
<tr><td class="num" id="LN1519">1519</td><td class="line">  <span class='macro'>DCHECK(code != NULL &amp;&amp; GcSafeCodeContains(code, inner_pointer))<span class='expansion'>do { if ((__builtin_expect(!!(!(code != __null &amp;&amp; GcSafeCodeContains<br>(code, inner_pointer))), 0))) { V8_Fatal("../src/frames.cc", 1519<br>, "Check failed: %s.", "code != __null &amp;&amp; GcSafeCodeContains(code, inner_pointer)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1520">1520</td><td class="line">  <span class='keyword'>return</span> code;</td></tr>
<tr><td class="num" id="LN1521">1521</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1522">1522</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1523">1523</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1524">1524</td><td class="line">Code* InnerPointerToCodeCache::GcSafeFindCodeForInnerPointer(</td></tr>
<tr><td class="num" id="LN1525">1525</td><td class="line">    Address inner_pointer) {</td></tr>
<tr><td class="num" id="LN1526">1526</td><td class="line">  Heap* heap = isolate_-&gt;heap();</td></tr>
<tr><td class="num" id="LN1527">1527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1528">1528</td><td class="line">  <span class='comment'>// Check if the inner pointer points into a large object chunk.</span></td></tr>
<tr><td class="num" id="LN1529">1529</td><td class="line">  LargePage* large_page = heap-&gt;lo_space()-&gt;FindPage(inner_pointer);</td></tr>
<tr><td class="num" id="LN1530">1530</td><td class="line">  <span class='keyword'>if</span> (large_page != <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN1531">1531</td><td class="line">    <span class='keyword'>return</span> GcSafeCastToCode(large_page-&gt;GetObject(), inner_pointer);</td></tr>
<tr><td class="num" id="LN1532">1532</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1533">1533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1534">1534</td><td class="line">  <span class='keyword'>if</span> (!heap-&gt;code_space()-&gt;Contains(inner_pointer)) {</td></tr>
<tr><td class="num" id="LN1535">1535</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1536">1536</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1537">1537</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1538">1538</td><td class="line">  <span class='comment'>// Iterate through the page until we reach the end or find an object starting</span></td></tr>
<tr><td class="num" id="LN1539">1539</td><td class="line">  <span class='comment'>// after the inner pointer.</span></td></tr>
<tr><td class="num" id="LN1540">1540</td><td class="line">  Page* page = Page::FromAddress(inner_pointer);</td></tr>
<tr><td class="num" id="LN1541">1541</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1542">1542</td><td class="line">  <span class='macro'>DCHECK_EQ(page-&gt;owner(), heap-&gt;code_space())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (page-&gt;<br>owner()), (heap-&gt;code_space()), "page-&gt;owner()" " " "=="<br> " " "heap-&gt;code_space()")) { V8_Fatal("../src/frames.cc",<br> 1542, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1543">1543</td><td class="line">  heap-&gt;mark_compact_collector()-&gt;SweepOrWaitUntilSweepingCompleted(page);</td></tr>
<tr><td class="num" id="LN1544">1544</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1545">1545</td><td class="line">  Address addr = page-&gt;skip_list()-&gt;StartFor(inner_pointer);</td></tr>
<tr><td class="num" id="LN1546">1546</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1547">1547</td><td class="line">  Address top = heap-&gt;code_space()-&gt;top();</td></tr>
<tr><td class="num" id="LN1548">1548</td><td class="line">  Address limit = heap-&gt;code_space()-&gt;limit();</td></tr>
<tr><td class="num" id="LN1549">1549</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1550">1550</td><td class="line">  <span class='keyword'>while</span> (<span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN1551">1551</td><td class="line">    <span class='keyword'>if</span> (addr == top &amp;&amp; addr != limit) {</td></tr>
<tr><td class="num" id="LN1552">1552</td><td class="line">      addr = limit;</td></tr>
<tr><td class="num" id="LN1553">1553</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1554">1554</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1555">1555</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1556">1556</td><td class="line">    HeapObject* obj = HeapObject::FromAddress(addr);</td></tr>
<tr><td class="num" id="LN1557">1557</td><td class="line">    <span class='keyword'>int</span> obj_size = GcSafeSizeOfCodeSpaceObject(obj);</td></tr>
<tr><td class="num" id="LN1558">1558</td><td class="line">    Address next_addr = addr + obj_size;</td></tr>
<tr><td class="num" id="LN1559">1559</td><td class="line">    <span class='keyword'>if</span> (next_addr &gt; inner_pointer) <span class='keyword'>return</span> GcSafeCastToCode(obj, inner_pointer);</td></tr>
<tr><td class="num" id="LN1560">1560</td><td class="line">    addr = next_addr;</td></tr>
<tr><td class="num" id="LN1561">1561</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1562">1562</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1563">1563</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1564">1564</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1565">1565</td><td class="line">InnerPointerToCodeCache::InnerPointerToCodeCacheEntry*</td></tr>
<tr><td class="num" id="LN1566">1566</td><td class="line">    InnerPointerToCodeCache::GetCacheEntry(Address inner_pointer) {</td></tr>
<tr><td class="num" id="LN1567">1567</td><td class="line">  isolate_-&gt;counters()-&gt;pc_to_code()-&gt;Increment();</td></tr>
<tr><td class="num" id="LN1568">1568</td><td class="line">  <span class='macro'>DCHECK(base::bits::IsPowerOfTwo32(kInnerPointerToCodeCacheSize))<span class='expansion'>do { if ((__builtin_expect(!!(!(base::bits::IsPowerOfTwo32(kInnerPointerToCodeCacheSize<br>))), 0))) { V8_Fatal("../src/frames.cc", 1568, "Check failed: %s."<br>, "base::bits::IsPowerOfTwo32(kInnerPointerToCodeCacheSize)")<br>; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1569">1569</td><td class="line">  uint32_t hash = ComputeIntegerHash(ObjectAddressForHashing(inner_pointer),</td></tr>
<tr><td class="num" id="LN1570">1570</td><td class="line">                                     v8::internal::kZeroHashSeed);</td></tr>
<tr><td class="num" id="LN1571">1571</td><td class="line">  uint32_t index = hash &amp; (kInnerPointerToCodeCacheSize - 1);</td></tr>
<tr><td class="num" id="LN1572">1572</td><td class="line">  InnerPointerToCodeCacheEntry* entry = cache(index);</td></tr>
<tr><td class="num" id="LN1573">1573</td><td class="line">  <span class='keyword'>if</span> (entry-&gt;inner_pointer == inner_pointer) {</td></tr>
<tr><td class="num" id="LN1574">1574</td><td class="line">    isolate_-&gt;counters()-&gt;pc_to_code_cached()-&gt;Increment();</td></tr>
<tr><td class="num" id="LN1575">1575</td><td class="line">    <span class='macro'>DCHECK(entry-&gt;code == GcSafeFindCodeForInnerPointer(inner_pointer))<span class='expansion'>do { if ((__builtin_expect(!!(!(entry-&gt;code == GcSafeFindCodeForInnerPointer<br>(inner_pointer))), 0))) { V8_Fatal("../src/frames.cc", 1575, "Check failed: %s."<br>, "entry-&gt;code == GcSafeFindCodeForInnerPointer(inner_pointer)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1576">1576</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1577">1577</td><td class="line">    <span class='comment'>// Because this code may be interrupted by a profiling signal that</span></td></tr>
<tr><td class="num" id="LN1578">1578</td><td class="line">    <span class='comment'>// also queries the cache, we cannot update inner_pointer before the code</span></td></tr>
<tr><td class="num" id="LN1579">1579</td><td class="line">    <span class='comment'>// has been set. Otherwise, we risk trying to use a cache entry before</span></td></tr>
<tr><td class="num" id="LN1580">1580</td><td class="line">    <span class='comment'>// the code has been computed.</span></td></tr>
<tr><td class="num" id="LN1581">1581</td><td class="line">    entry-&gt;code = GcSafeFindCodeForInnerPointer(inner_pointer);</td></tr>
<tr><td class="num" id="LN1582">1582</td><td class="line">    entry-&gt;safepoint_entry.Reset();</td></tr>
<tr><td class="num" id="LN1583">1583</td><td class="line">    entry-&gt;inner_pointer = inner_pointer;</td></tr>
<tr><td class="num" id="LN1584">1584</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1585">1585</td><td class="line">  <span class='keyword'>return</span> entry;</td></tr>
<tr><td class="num" id="LN1586">1586</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1587">1587</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1588">1588</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1589">1589</td><td class="line"><span class='comment'>// -------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN1590">1590</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1591">1591</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1592">1592</td><td class="line"><span class='keyword'>int</span> NumRegs(RegList reglist) { <span class='keyword'>return</span> base::bits::CountPopulation(reglist); }</td></tr>
<tr><td class="num" id="LN1593">1593</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1594">1594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1595">1595</td><td class="line"><span class='keyword'>struct</span> JSCallerSavedCodeData {</td></tr>
<tr><td class="num" id="LN1596">1596</td><td class="line">  <span class='keyword'>int</span> reg_code[kNumJSCallerSaved];</td></tr>
<tr><td class="num" id="LN1597">1597</td><td class="line">};</td></tr>
<tr><td class="num" id="LN1598">1598</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1599">1599</td><td class="line">JSCallerSavedCodeData caller_saved_code_data;</td></tr>
<tr><td class="num" id="LN1600">1600</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1601">1601</td><td class="line"><span class='keyword'>void</span> SetUpJSCallerSavedCodeData() {</td></tr>
<tr><td class="num" id="LN1602">1602</td><td class="line">  <span class='keyword'>int</span> i = 0;</td></tr>
<tr><td class="num" id="LN1603">1603</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> r = 0; r &lt; kNumRegs; r++)</td></tr>
<tr><td class="num" id="LN1604">1604</td><td class="line">    <span class='keyword'>if</span> ((kJSCallerSaved &amp; (1 &lt;&lt; r)) != 0)</td></tr>
<tr><td class="num" id="LN1605">1605</td><td class="line">      caller_saved_code_data.reg_code[i++] = r;</td></tr>
<tr><td class="num" id="LN1606">1606</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1607">1607</td><td class="line">  <span class='macro'>DCHECK(i == kNumJSCallerSaved)<span class='expansion'>do { if ((__builtin_expect(!!(!(i == kNumJSCallerSaved)), 0))<br>) { V8_Fatal("../src/frames.cc", 1607, "Check failed: %s.", "i == kNumJSCallerSaved"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1608">1608</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1609">1609</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1610">1610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1611">1611</td><td class="line"><span class='keyword'>int</span> JSCallerSavedCode(<span class='keyword'>int</span> n) {</td></tr>
<tr><td class="num" id="LN1612">1612</td><td class="line">  <span class='macro'>DCHECK(0 &lt;= n &amp;&amp; n &lt; kNumJSCallerSaved)<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= n &amp;&amp; n &lt; kNumJSCallerSaved<br>)), 0))) { V8_Fatal("../src/frames.cc", 1612, "Check failed: %s."<br>, "0 &lt;= n &amp;&amp; n &lt; kNumJSCallerSaved"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1613">1613</td><td class="line">  <span class='keyword'>return</span> caller_saved_code_data.reg_code[n];</td></tr>
<tr><td class="num" id="LN1614">1614</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1615">1615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1616">1616</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1617">1617</td><td class="line"><span class='directive'>#define DEFINE_WRAPPER(type, field)                              \</span></td></tr>
<tr><td class="num" id="LN1618">1618</td><td class="line"><span class='directive'>class field##_Wrapper : public ZoneObject {                      \</span></td></tr>
<tr><td class="num" id="LN1619">1619</td><td class="line"> <span class='directive'>public:  /* NOLINT */                                           \</span></td></tr>
<tr><td class="num" id="LN1620">1620</td><td class="line">  <span class='directive'>field##_Wrapper(const field&amp; original) : frame_(original) {    \</span></td></tr>
<tr><td class="num" id="LN1621">1621</td><td class="line">  <span class='directive'>}                                                              \</span></td></tr>
<tr><td class="num" id="LN1622">1622</td><td class="line">  <span class='directive'>field frame_;                                                  \</span></td></tr>
<tr><td class="num" id="LN1623">1623</td><td class="line"><span class='directive'>};</span></td></tr>
<tr><td class="num" id="LN1624">1624</td><td class="line"><span class='macro'>STACK_FRAME_TYPE_LIST(DEFINE_WRAPPER)<span class='expansion'>DEFINE_WRAPPER(ENTRY, EntryFrame) DEFINE_WRAPPER(ENTRY_CONSTRUCT<br>, EntryConstructFrame) DEFINE_WRAPPER(EXIT, ExitFrame) DEFINE_WRAPPER<br>(JAVA_SCRIPT, JavaScriptFrame) DEFINE_WRAPPER(OPTIMIZED, OptimizedFrame<br>) DEFINE_WRAPPER(INTERPRETED, InterpretedFrame) DEFINE_WRAPPER<br>(STUB, StubFrame) DEFINE_WRAPPER(STUB_FAILURE_TRAMPOLINE, StubFailureTrampolineFrame<br>) DEFINE_WRAPPER(INTERNAL, InternalFrame) DEFINE_WRAPPER(CONSTRUCT<br>, ConstructFrame) DEFINE_WRAPPER(ARGUMENTS_ADAPTOR, ArgumentsAdaptorFrame<br>)</span></span></td></tr>
<tr><td class="num" id="LN1625">1625</td><td class="line"><span class='directive'>#undef DEFINE_WRAPPER</span></td></tr>
<tr><td class="num" id="LN1626">1626</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1627">1627</td><td class="line"><span class='keyword'>static</span> StackFrame* AllocateFrameCopy(StackFrame* frame, Zone* zone) {</td></tr>
<tr><td class="num" id="LN1628">1628</td><td class="line"><span class='directive'>#define FRAME_TYPE_CASE(type, field) \</span></td></tr>
<tr><td class="num" id="LN1629">1629</td><td class="line">  <span class='directive'>case StackFrame::type: { \</span></td></tr>
<tr><td class="num" id="LN1630">1630</td><td class="line">    <span class='directive'>field##_Wrapper* wrapper = \</span></td></tr>
<tr><td class="num" id="LN1631">1631</td><td class="line">        <span class='directive'>new(zone) field##_Wrapper(*(reinterpret_cast&lt;field*&gt;(frame))); \</span></td></tr>
<tr><td class="num" id="LN1632">1632</td><td class="line">    <span class='directive'>return &amp;wrapper-&gt;frame_; \</span></td></tr>
<tr><td class="num" id="LN1633">1633</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr><td class="num" id="LN1634">1634</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1635">1635</td><td class="line">  <span class='keyword'>switch</span> (frame-&gt;type()) {</td></tr>
<tr><td class="num" id="LN1636">1636</td><td class="line">    <span class='macro'>STACK_FRAME_TYPE_LIST(FRAME_TYPE_CASE)<span class='expansion'>FRAME_TYPE_CASE(ENTRY, EntryFrame) FRAME_TYPE_CASE(ENTRY_CONSTRUCT<br>, EntryConstructFrame) FRAME_TYPE_CASE(EXIT, ExitFrame) FRAME_TYPE_CASE<br>(JAVA_SCRIPT, JavaScriptFrame) FRAME_TYPE_CASE(OPTIMIZED, OptimizedFrame<br>) FRAME_TYPE_CASE(INTERPRETED, InterpretedFrame) FRAME_TYPE_CASE<br>(STUB, StubFrame) FRAME_TYPE_CASE(STUB_FAILURE_TRAMPOLINE, StubFailureTrampolineFrame<br>) FRAME_TYPE_CASE(INTERNAL, InternalFrame) FRAME_TYPE_CASE(CONSTRUCT<br>, ConstructFrame) FRAME_TYPE_CASE(ARGUMENTS_ADAPTOR, ArgumentsAdaptorFrame<br>)</span></span></td></tr>
<tr><td class="num" id="LN1637">1637</td><td class="line">    <span class='keyword'>default</span>: <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/frames.cc", 1637, "unreachable code")</span></span>;</td></tr>
<tr><td class="num" id="LN1638">1638</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1639">1639</td><td class="line"><span class='directive'>#undef FRAME_TYPE_CASE</span></td></tr>
<tr><td class="num" id="LN1640">1640</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1641">1641</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1642">1642</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1643">1643</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1644">1644</td><td class="line">Vector&lt;StackFrame*&gt; CreateStackMap(Isolate* isolate, Zone* zone) {</td></tr>
<tr><td class="num" id="LN1645">1645</td><td class="line">  ZoneList&lt;StackFrame*&gt; list(10, zone);</td></tr>
<tr><td class="num" id="LN1646">1646</td><td class="line">  <span class='keyword'>for</span> (StackFrameIterator it(isolate); !it.done(); it.Advance()) {</td></tr>
<tr><td class="num" id="LN1647">1647</td><td class="line">    StackFrame* frame = AllocateFrameCopy(it.frame(), zone);</td></tr>
<tr><td class="num" id="LN1648">1648</td><td class="line">    list.Add(frame, zone);</td></tr>
<tr><td class="num" id="LN1649">1649</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1650">1650</td><td class="line">  <span class='keyword'>return</span> list.ToVector();</td></tr>
<tr><td class="num" id="LN1651">1651</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1652">1652</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1653">1653</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1654">1654</td><td class="line">}  <span class='comment'>// namespace internal</span></td></tr>
<tr><td class="num" id="LN1655">1655</td><td class="line">}  <span class='comment'>// namespace v8</span></td></tr>
</table></body></html>

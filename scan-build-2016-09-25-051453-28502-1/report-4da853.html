<!doctype html>
<html>
<head>
<title>../third_party/icu/source/i18n/decNumber.c</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000;   border-radius:5px;  box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndex { border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Value stored to 'bits' is never read -->

<!-- BUGTYPE Dead assignment -->

<!-- BUGCATEGORY Dead store -->

<!-- BUGFILE /home/haha/code/v8_5_0/v8/out/../third_party/icu/source/i18n/decNumber.c -->

<!-- FILENAME decNumber.c -->

<!-- FUNCTIONNAME decAddOp -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 8eba24bb595dff41da04eea6540906d8 -->

<!-- BUGLINE 3903 -->

<!-- BUGCOLUMN 7 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>out/../third_party/icu/source/i18n/decNumber.c</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 3903, column 7</a></td></tr>
<tr><td class="rowname">Description:</td><td>Value stored to 'bits' is never read</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"><span class='comment'>/* Decimal Number arithmetic module                                   */</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"><span class='comment'>/* Copyright (c) IBM Corporation, 2000-2014.  All rights reserved.    */</span></td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"><span class='comment'>/* This software is made available under the terms of the             */</span></td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"><span class='comment'>/* ICU License -- ICU 1.8.1 and later.                                */</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"><span class='comment'>/* The description and User's Guide ("The decNumber C Library") for   */</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"><span class='comment'>/* this software is called decNumber.pdf.  This document is           */</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"><span class='comment'>/* available, together with arithmetic and format specifications,     */</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"><span class='comment'>/* testcases, and Web links, on the General Decimal Arithmetic page.  */</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='comment'>/* Please send comments, suggestions, and corrections to the author:  */</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"><span class='comment'>/*   mfc@uk.ibm.com                                                   */</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"><span class='comment'>/*   Mike Cowlishaw, IBM Fellow                                       */</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"><span class='comment'>/*   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         */</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"> </td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='comment'>/* Modified version, for use from within ICU.</span></td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"> <span class='comment'>*    Renamed public functions, to avoid an unwanted export of the</span> </td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"> <span class='comment'>*    standard names from the ICU library.</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"> <span class='comment'>*    Use ICU's uprv_malloc() and uprv_free()</span></td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"> <span class='comment'>*    Revert comment syntax to plain C</span></td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"> <span class='comment'>*    Remove a few compiler warnings.</span></td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"><span class='comment'>/* This module comprises the routines for arbitrary-precision General */</span></td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='comment'>/* Decimal Arithmetic as defined in the specification which may be    */</span></td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"><span class='comment'>/* found on the General Decimal Arithmetic pages.  It implements both */</span></td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"><span class='comment'>/* the full ('extended') arithmetic and the simpler ('subset')        */</span></td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"><span class='comment'>/* arithmetic.                                                        */</span></td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='comment'>/* Usage notes:                                                       */</span></td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN39">39</td><td class="line"><span class='comment'>/* 1. This code is ANSI C89 except:                                   */</span></td></tr>
<tr><td class="num" id="LN40">40</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"><span class='comment'>/*    a) C99 line comments (double forward slash) are used.  (Most C  */</span></td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"><span class='comment'>/*       compilers accept these.  If yours does not, a simple script  */</span></td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"><span class='comment'>/*       can be used to convert them to ANSI C comments.)             */</span></td></tr>
<tr><td class="num" id="LN44">44</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN45">45</td><td class="line"><span class='comment'>/*    b) Types from C99 stdint.h are used.  If you do not have this   */</span></td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"><span class='comment'>/*       header file, see the User's Guide section of the decNumber   */</span></td></tr>
<tr><td class="num" id="LN47">47</td><td class="line"><span class='comment'>/*       documentation; this lists the necessary definitions.         */</span></td></tr>
<tr><td class="num" id="LN48">48</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN49">49</td><td class="line"><span class='comment'>/*    c) If DECDPUN&gt;4 or DECUSE64=1, the C99 64-bit int64_t and       */</span></td></tr>
<tr><td class="num" id="LN50">50</td><td class="line"><span class='comment'>/*       uint64_t types may be used.  To avoid these, set DECUSE64=0  */</span></td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"><span class='comment'>/*       and DECDPUN&lt;=4 (see documentation).                          */</span></td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line"><span class='comment'>/*    The code also conforms to C99 restrictions; in particular,      */</span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line"><span class='comment'>/*    strict aliasing rules are observed.                             */</span></td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"><span class='comment'>/* 2. The decNumber format which this library uses is optimized for   */</span></td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"><span class='comment'>/*    efficient processing of relatively short numbers; in particular */</span></td></tr>
<tr><td class="num" id="LN58">58</td><td class="line"><span class='comment'>/*    it allows the use of fixed sized structures and minimizes copy  */</span></td></tr>
<tr><td class="num" id="LN59">59</td><td class="line"><span class='comment'>/*    and move operations.  It does, however, support arbitrary       */</span></td></tr>
<tr><td class="num" id="LN60">60</td><td class="line"><span class='comment'>/*    precision (up to 999,999,999 digits) and arbitrary exponent     */</span></td></tr>
<tr><td class="num" id="LN61">61</td><td class="line"><span class='comment'>/*    range (Emax in the range 0 through 999,999,999 and Emin in the  */</span></td></tr>
<tr><td class="num" id="LN62">62</td><td class="line"><span class='comment'>/*    range -999,999,999 through 0).  Mathematical functions (for     */</span></td></tr>
<tr><td class="num" id="LN63">63</td><td class="line"><span class='comment'>/*    example decNumberExp) as identified below are restricted more   */</span></td></tr>
<tr><td class="num" id="LN64">64</td><td class="line"><span class='comment'>/*    tightly: digits, emax, and -emin in the context must be &lt;=      */</span></td></tr>
<tr><td class="num" id="LN65">65</td><td class="line"><span class='comment'>/*    DEC_MAX_MATH (999999), and their operand(s) must be within      */</span></td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"><span class='comment'>/*    these bounds.                                                   */</span></td></tr>
<tr><td class="num" id="LN67">67</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN68">68</td><td class="line"><span class='comment'>/* 3. Logical functions are further restricted; their operands must   */</span></td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"><span class='comment'>/*    be finite, positive, have an exponent of zero, and all digits   */</span></td></tr>
<tr><td class="num" id="LN70">70</td><td class="line"><span class='comment'>/*    must be either 0 or 1.  The result will only contain digits     */</span></td></tr>
<tr><td class="num" id="LN71">71</td><td class="line"><span class='comment'>/*    which are 0 or 1 (and will have exponent=0 and a sign of 0).    */</span></td></tr>
<tr><td class="num" id="LN72">72</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN73">73</td><td class="line"><span class='comment'>/* 4. Operands to operator functions are never modified unless they   */</span></td></tr>
<tr><td class="num" id="LN74">74</td><td class="line"><span class='comment'>/*    are also specified to be the result number (which is always     */</span></td></tr>
<tr><td class="num" id="LN75">75</td><td class="line"><span class='comment'>/*    permitted).  Other than that case, operands must not overlap.   */</span></td></tr>
<tr><td class="num" id="LN76">76</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN77">77</td><td class="line"><span class='comment'>/* 5. Error handling: the type of the error is ORed into the status   */</span></td></tr>
<tr><td class="num" id="LN78">78</td><td class="line"><span class='comment'>/*    flags in the current context (decContext structure).  The       */</span></td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"><span class='comment'>/*    SIGFPE signal is then raised if the corresponding trap-enabler  */</span></td></tr>
<tr><td class="num" id="LN80">80</td><td class="line"><span class='comment'>/*    flag in the decContext is set (is 1).                           */</span></td></tr>
<tr><td class="num" id="LN81">81</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN82">82</td><td class="line"><span class='comment'>/*    It is the responsibility of the caller to clear the status      */</span></td></tr>
<tr><td class="num" id="LN83">83</td><td class="line"><span class='comment'>/*    flags as required.                                              */</span></td></tr>
<tr><td class="num" id="LN84">84</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN85">85</td><td class="line"><span class='comment'>/*    The result of any routine which returns a number will always    */</span></td></tr>
<tr><td class="num" id="LN86">86</td><td class="line"><span class='comment'>/*    be a valid number (which may be a special value, such as an     */</span></td></tr>
<tr><td class="num" id="LN87">87</td><td class="line"><span class='comment'>/*    Infinity or NaN).                                               */</span></td></tr>
<tr><td class="num" id="LN88">88</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN89">89</td><td class="line"><span class='comment'>/* 6. The decNumber format is not an exchangeable concrete            */</span></td></tr>
<tr><td class="num" id="LN90">90</td><td class="line"><span class='comment'>/*    representation as it comprises fields which may be machine-     */</span></td></tr>
<tr><td class="num" id="LN91">91</td><td class="line"><span class='comment'>/*    dependent (packed or unpacked, or special length, for example). */</span></td></tr>
<tr><td class="num" id="LN92">92</td><td class="line"><span class='comment'>/*    Canonical conversions to and from strings are provided; other   */</span></td></tr>
<tr><td class="num" id="LN93">93</td><td class="line"><span class='comment'>/*    conversions are available in separate modules.                  */</span></td></tr>
<tr><td class="num" id="LN94">94</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN95">95</td><td class="line"><span class='comment'>/* 7. Normally, input operands are assumed to be valid.  Set DECCHECK */</span></td></tr>
<tr><td class="num" id="LN96">96</td><td class="line"><span class='comment'>/*    to 1 for extended operand checking (including NULL operands).   */</span></td></tr>
<tr><td class="num" id="LN97">97</td><td class="line"><span class='comment'>/*    Results are undefined if a badly-formed structure (or a NULL    */</span></td></tr>
<tr><td class="num" id="LN98">98</td><td class="line"><span class='comment'>/*    pointer to a structure) is provided, though with DECCHECK       */</span></td></tr>
<tr><td class="num" id="LN99">99</td><td class="line"><span class='comment'>/*    enabled the operator routines are protected against exceptions. */</span></td></tr>
<tr><td class="num" id="LN100">100</td><td class="line"><span class='comment'>/*    (Except if the result pointer is NULL, which is unrecoverable.) */</span></td></tr>
<tr><td class="num" id="LN101">101</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN102">102</td><td class="line"><span class='comment'>/*    However, the routines will never cause exceptions if they are   */</span></td></tr>
<tr><td class="num" id="LN103">103</td><td class="line"><span class='comment'>/*    given well-formed operands, even if the value of the operands   */</span></td></tr>
<tr><td class="num" id="LN104">104</td><td class="line"><span class='comment'>/*    is inappropriate for the operation and DECCHECK is not set.     */</span></td></tr>
<tr><td class="num" id="LN105">105</td><td class="line"><span class='comment'>/*    (Except for SIGFPE, as and where documented.)                   */</span></td></tr>
<tr><td class="num" id="LN106">106</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN107">107</td><td class="line"><span class='comment'>/* 8. Subset arithmetic is available only if DECSUBSET is set to 1.   */</span></td></tr>
<tr><td class="num" id="LN108">108</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN109">109</td><td class="line"><span class='comment'>/* Implementation notes for maintenance of this module:               */</span></td></tr>
<tr><td class="num" id="LN110">110</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN111">111</td><td class="line"><span class='comment'>/* 1. Storage leak protection:  Routines which use malloc are not     */</span></td></tr>
<tr><td class="num" id="LN112">112</td><td class="line"><span class='comment'>/*    permitted to use return for fastpath or error exits (i.e.,      */</span></td></tr>
<tr><td class="num" id="LN113">113</td><td class="line"><span class='comment'>/*    they follow strict structured programming conventions).         */</span></td></tr>
<tr><td class="num" id="LN114">114</td><td class="line"><span class='comment'>/*    Instead they have a do{}while(0); construct surrounding the     */</span></td></tr>
<tr><td class="num" id="LN115">115</td><td class="line"><span class='comment'>/*    code which is protected -- break may be used to exit this.      */</span></td></tr>
<tr><td class="num" id="LN116">116</td><td class="line"><span class='comment'>/*    Other routines can safely use the return statement inline.      */</span></td></tr>
<tr><td class="num" id="LN117">117</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN118">118</td><td class="line"><span class='comment'>/*    Storage leak accounting can be enabled using DECALLOC.          */</span></td></tr>
<tr><td class="num" id="LN119">119</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN120">120</td><td class="line"><span class='comment'>/* 2. All loops use the for(;;) construct.  Any do construct does     */</span></td></tr>
<tr><td class="num" id="LN121">121</td><td class="line"><span class='comment'>/*    not loop; it is for allocation protection as just described.    */</span></td></tr>
<tr><td class="num" id="LN122">122</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN123">123</td><td class="line"><span class='comment'>/* 3. Setting status in the context must always be the very last      */</span></td></tr>
<tr><td class="num" id="LN124">124</td><td class="line"><span class='comment'>/*    action in a routine, as non-0 status may raise a trap and hence */</span></td></tr>
<tr><td class="num" id="LN125">125</td><td class="line"><span class='comment'>/*    the call to set status may not return (if the handler uses long */</span></td></tr>
<tr><td class="num" id="LN126">126</td><td class="line"><span class='comment'>/*    jump).  Therefore all cleanup must be done first.  In general,  */</span></td></tr>
<tr><td class="num" id="LN127">127</td><td class="line"><span class='comment'>/*    to achieve this status is accumulated and is only applied just  */</span></td></tr>
<tr><td class="num" id="LN128">128</td><td class="line"><span class='comment'>/*    before return by calling decContextSetStatus (via decStatus).   */</span></td></tr>
<tr><td class="num" id="LN129">129</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN130">130</td><td class="line"><span class='comment'>/*    Routines which allocate storage cannot, in general, use the     */</span></td></tr>
<tr><td class="num" id="LN131">131</td><td class="line"><span class='comment'>/*    'top level' routines which could cause a non-returning          */</span></td></tr>
<tr><td class="num" id="LN132">132</td><td class="line"><span class='comment'>/*    transfer of control.  The decXxxxOp routines are safe (do not   */</span></td></tr>
<tr><td class="num" id="LN133">133</td><td class="line"><span class='comment'>/*    call decStatus even if traps are set in the context) and should */</span></td></tr>
<tr><td class="num" id="LN134">134</td><td class="line"><span class='comment'>/*    be used instead (they are also a little faster).                */</span></td></tr>
<tr><td class="num" id="LN135">135</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN136">136</td><td class="line"><span class='comment'>/* 4. Exponent checking is minimized by allowing the exponent to      */</span></td></tr>
<tr><td class="num" id="LN137">137</td><td class="line"><span class='comment'>/*    grow outside its limits during calculations, provided that      */</span></td></tr>
<tr><td class="num" id="LN138">138</td><td class="line"><span class='comment'>/*    the decFinalize function is called later.  Multiplication and   */</span></td></tr>
<tr><td class="num" id="LN139">139</td><td class="line"><span class='comment'>/*    division, and intermediate calculations in exponentiation,      */</span></td></tr>
<tr><td class="num" id="LN140">140</td><td class="line"><span class='comment'>/*    require more careful checks because of the risk of 31-bit       */</span></td></tr>
<tr><td class="num" id="LN141">141</td><td class="line"><span class='comment'>/*    overflow (the most negative valid exponent is -1999999997, for  */</span></td></tr>
<tr><td class="num" id="LN142">142</td><td class="line"><span class='comment'>/*    a 999999999-digit number with adjusted exponent of -999999999). */</span></td></tr>
<tr><td class="num" id="LN143">143</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN144">144</td><td class="line"><span class='comment'>/* 5. Rounding is deferred until finalization of results, with any    */</span></td></tr>
<tr><td class="num" id="LN145">145</td><td class="line"><span class='comment'>/*    'off to the right' data being represented as a single digit     */</span></td></tr>
<tr><td class="num" id="LN146">146</td><td class="line"><span class='comment'>/*    residue (in the range -1 through 9).  This avoids any double-   */</span></td></tr>
<tr><td class="num" id="LN147">147</td><td class="line"><span class='comment'>/*    rounding when more than one shortening takes place (for         */</span></td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"><span class='comment'>/*    example, when a result is subnormal).                           */</span></td></tr>
<tr><td class="num" id="LN149">149</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"><span class='comment'>/* 6. The digits count is allowed to rise to a multiple of DECDPUN    */</span></td></tr>
<tr><td class="num" id="LN151">151</td><td class="line"><span class='comment'>/*    during many operations, so whole Units are handled and exact    */</span></td></tr>
<tr><td class="num" id="LN152">152</td><td class="line"><span class='comment'>/*    accounting of digits is not needed.  The correct digits value   */</span></td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"><span class='comment'>/*    is found by decGetDigits, which accounts for leading zeros.     */</span></td></tr>
<tr><td class="num" id="LN154">154</td><td class="line"><span class='comment'>/*    This must be called before any rounding if the number of digits */</span></td></tr>
<tr><td class="num" id="LN155">155</td><td class="line"><span class='comment'>/*    is not known exactly.                                           */</span></td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN157">157</td><td class="line"><span class='comment'>/* 7. The multiply-by-reciprocal 'trick' is used for partitioning     */</span></td></tr>
<tr><td class="num" id="LN158">158</td><td class="line"><span class='comment'>/*    numbers up to four digits, using appropriate constants.  This   */</span></td></tr>
<tr><td class="num" id="LN159">159</td><td class="line"><span class='comment'>/*    is not useful for longer numbers because overflow of 32 bits    */</span></td></tr>
<tr><td class="num" id="LN160">160</td><td class="line"><span class='comment'>/*    would lead to 4 multiplies, which is almost as expensive as     */</span></td></tr>
<tr><td class="num" id="LN161">161</td><td class="line"><span class='comment'>/*    a divide (unless a floating-point or 64-bit multiply is         */</span></td></tr>
<tr><td class="num" id="LN162">162</td><td class="line"><span class='comment'>/*    assumed to be available).                                       */</span></td></tr>
<tr><td class="num" id="LN163">163</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN164">164</td><td class="line"><span class='comment'>/* 8. Unusual abbreviations that may be used in the commentary:       */</span></td></tr>
<tr><td class="num" id="LN165">165</td><td class="line"><span class='comment'>/*      lhs -- left hand side (operand, of an operation)              */</span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line"><span class='comment'>/*      lsd -- least significant digit (of coefficient)               */</span></td></tr>
<tr><td class="num" id="LN167">167</td><td class="line"><span class='comment'>/*      lsu -- least significant Unit (of coefficient)                */</span></td></tr>
<tr><td class="num" id="LN168">168</td><td class="line"><span class='comment'>/*      msd -- most significant digit (of coefficient)                */</span></td></tr>
<tr><td class="num" id="LN169">169</td><td class="line"><span class='comment'>/*      msi -- most significant item (in an array)                    */</span></td></tr>
<tr><td class="num" id="LN170">170</td><td class="line"><span class='comment'>/*      msu -- most significant Unit (of coefficient)                 */</span></td></tr>
<tr><td class="num" id="LN171">171</td><td class="line"><span class='comment'>/*      rhs -- right hand side (operand, of an operation)             */</span></td></tr>
<tr><td class="num" id="LN172">172</td><td class="line"><span class='comment'>/*      +ve -- positive                                               */</span></td></tr>
<tr><td class="num" id="LN173">173</td><td class="line"><span class='comment'>/*      -ve -- negative                                               */</span></td></tr>
<tr><td class="num" id="LN174">174</td><td class="line"><span class='comment'>/*      **  -- raise to the power                                     */</span></td></tr>
<tr><td class="num" id="LN175">175</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN176">176</td><td class="line"> </td></tr>
<tr><td class="num" id="LN177">177</td><td class="line"><span class='directive'>#include &lt;stdlib.h&gt;                /* for malloc, free, etc.  */</span></td></tr>
<tr><td class="num" id="LN178">178</td><td class="line"><span class='comment'>/*  #include &lt;stdio.h&gt;   */</span>        <span class='comment'>/* for printf [if needed]  */</span></td></tr>
<tr><td class="num" id="LN179">179</td><td class="line"><span class='directive'>#include &lt;string.h&gt;                /* for strcpy  */</span></td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"><span class='directive'>#include &lt;ctype.h&gt;                 /* for lower  */</span></td></tr>
<tr><td class="num" id="LN181">181</td><td class="line"><span class='directive'>#include "cmemory.h"               /* for uprv_malloc, etc., in ICU */</span></td></tr>
<tr><td class="num" id="LN182">182</td><td class="line"><span class='directive'>#include "decNumber.h"             /* base number library  */</span></td></tr>
<tr><td class="num" id="LN183">183</td><td class="line"><span class='directive'>#include "decNumberLocal.h"        /* decNumber local types, etc.  */</span></td></tr>
<tr><td class="num" id="LN184">184</td><td class="line"><span class='directive'>#include "uassert.h"</span></td></tr>
<tr><td class="num" id="LN185">185</td><td class="line"> </td></tr>
<tr><td class="num" id="LN186">186</td><td class="line"><span class='comment'>/* Constants */</span></td></tr>
<tr><td class="num" id="LN187">187</td><td class="line"><span class='comment'>/* Public lookup table used by the D2U macro  */</span></td></tr>
<tr><td class="num" id="LN188">188</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> d2utable[<span class='macro'>DECMAXD2U<span class='expansion'>49</span></span>+1]=<span class='macro'>D2UTABLE<span class='expansion'>{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17, 18,19,20,21,22,<br>23,24,25,26,27,28,29,30,31,32, 33,34,35,36,37,38,39,40,41,42,<br>43,44,45,46,47, 48,49}</span></span>;</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line"> </td></tr>
<tr><td class="num" id="LN190">190</td><td class="line"><span class='directive'>#define <span class='macro'>DECVERB<span class='expansion'>1</span></span>     1              /* set to 1 for verbose DECCHECK  */</span></td></tr>
<tr><td class="num" id="LN191">191</td><td class="line"><span class='directive'>#define <span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>      DECPOWERS      /* old internal name  */</span></td></tr>
<tr><td class="num" id="LN192">192</td><td class="line"> </td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"><span class='comment'>/* Local constants  */</span></td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"><span class='directive'>#define <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>      0x80           /* Divide operators  */</span></td></tr>
<tr><td class="num" id="LN195">195</td><td class="line"><span class='directive'>#define <span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>   0x40           /* ..  */</span></td></tr>
<tr><td class="num" id="LN196">196</td><td class="line"><span class='directive'>#define <span class='macro'>DIVIDEINT<span class='expansion'>0x20</span></span>   0x20           /* ..  */</span></td></tr>
<tr><td class="num" id="LN197">197</td><td class="line"><span class='directive'>#define <span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>     0x10           /* ..  */</span></td></tr>
<tr><td class="num" id="LN198">198</td><td class="line"><span class='directive'>#define <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>     0x01           /* Compare operators  */</span></td></tr>
<tr><td class="num" id="LN199">199</td><td class="line"><span class='directive'>#define <span class='macro'>COMPMAX<span class='expansion'>0x02</span></span>     0x02           /* ..  */</span></td></tr>
<tr><td class="num" id="LN200">200</td><td class="line"><span class='directive'>#define <span class='macro'>COMPMIN<span class='expansion'>0x03</span></span>     0x03           /* ..  */</span></td></tr>
<tr><td class="num" id="LN201">201</td><td class="line"><span class='directive'>#define <span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>   0x04           /* ..  */</span></td></tr>
<tr><td class="num" id="LN202">202</td><td class="line"><span class='directive'>#define <span class='macro'>COMPNAN<span class='expansion'>0x05</span></span>     0x05           /* .. [NaN processing]  */</span></td></tr>
<tr><td class="num" id="LN203">203</td><td class="line"><span class='directive'>#define <span class='macro'>COMPSIG<span class='expansion'>0x06</span></span>     0x06           /* .. [signaling COMPARE]  */</span></td></tr>
<tr><td class="num" id="LN204">204</td><td class="line"><span class='directive'>#define <span class='macro'>COMPMAXMAG<span class='expansion'>0x07</span></span>  0x07           /* ..  */</span></td></tr>
<tr><td class="num" id="LN205">205</td><td class="line"><span class='directive'>#define <span class='macro'>COMPMINMAG<span class='expansion'>0x08</span></span>  0x08           /* ..  */</span></td></tr>
<tr><td class="num" id="LN206">206</td><td class="line"> </td></tr>
<tr><td class="num" id="LN207">207</td><td class="line"><span class='directive'>#define <span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>     0x40000000    /* local status: sNaN signal  */</span></td></tr>
<tr><td class="num" id="LN208">208</td><td class="line"><span class='directive'>#define <span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>  (<span class='macro'>Int<span class='expansion'>int32_t</span></span>)0x80000000    /* most-negative Int; error indicator  */</span></td></tr>
<tr><td class="num" id="LN209">209</td><td class="line"><span class='comment'>/* Next two indicate an integer &gt;= 10**6, and its parity (bottom bit)  */</span></td></tr>
<tr><td class="num" id="LN210">210</td><td class="line"><span class='directive'>#define <span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span> (<span class='macro'>Int<span class='expansion'>int32_t</span></span>)0x80000002</span></td></tr>
<tr><td class="num" id="LN211">211</td><td class="line"><span class='directive'>#define <span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span>  (<span class='macro'>Int<span class='expansion'>int32_t</span></span>)0x80000003</span></td></tr>
<tr><td class="num" id="LN212">212</td><td class="line"> </td></tr>
<tr><td class="num" id="LN213">213</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> uarrone[1]={1};   <span class='comment'>/* Unit array of 1, used for incrementing  */</span></td></tr>
<tr><td class="num" id="LN214">214</td><td class="line"> </td></tr>
<tr><td class="num" id="LN215">215</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN216">216</td><td class="line"><span class='comment'>/* round-for-reround digits                                           */</span></td></tr>
<tr><td class="num" id="LN217">217</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN218">218</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN219">219</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> DECSTICKYTAB[10]={1,1,2,3,4,6,6,7,8,9}; <span class='comment'>/* used if sticky */</span></td></tr>
<tr><td class="num" id="LN220">220</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN221">221</td><td class="line"> </td></tr>
<tr><td class="num" id="LN222">222</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN223">223</td><td class="line"><span class='comment'>/* Powers of ten (powers[n]==10**n, 0&lt;=n&lt;=9)                          */</span></td></tr>
<tr><td class="num" id="LN224">224</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN225">225</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> DECPOWERS[10]={1, 10, 100, 1000, 10000, 100000, 1000000,</td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">                          10000000, 100000000, 1000000000};</td></tr>
<tr><td class="num" id="LN227">227</td><td class="line"> </td></tr>
<tr><td class="num" id="LN228">228</td><td class="line"> </td></tr>
<tr><td class="num" id="LN229">229</td><td class="line"><span class='comment'>/* Granularity-dependent code */</span></td></tr>
<tr><td class="num" id="LN230">230</td><td class="line"><span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN231">231</td><td class="line">  <span class='directive'>#define <span class='macro'>eInt<span class='expansion'>int32_t</span></span>  <span class='macro'>Int<span class='expansion'>int32_t</span></span>           /* extended integer  */</span></td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">  <span class='directive'>#define <span class='macro'>ueInt<span class='expansion'>uint32_t</span></span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>          /* unsigned extended integer  */</span></td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">  <span class='comment'>/* Constant multipliers for divide-by-power-of five using reciprocal  */</span></td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">  <span class='comment'>/* multiply, after removing powers of 2 by shifting, and final shift  */</span></td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">  <span class='comment'>/* of 17 [we only need up to **4]  */</span></td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> multies[]={131073, 26215, 5243, 1049, 210};</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">  <span class='comment'>/* QUOT10 -- macro to return the quotient of unit u divided by 10**n  */</span></td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">  <span class='directive'>#define <span class='macro'>QUOT10(u, n)<span class='expansion'>((((uint32_t)(u)&gt;&gt;(n))*multies[n])&gt;&gt;17)</span></span> ((((<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)(u)&gt;&gt;(n))*multies[n])&gt;&gt;17)</span></td></tr>
<tr><td class="num" id="LN239">239</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">  <span class='comment'>/* For DECDPUN&gt;4 non-ANSI-89 64-bit types are needed.  */</span></td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">  <span class='directive'>#if !<span class='macro'>DECUSE64<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">    <span class='directive'>#error decNumber.c: <span class='macro'>DECUSE64<span class='expansion'>1</span></span> must be 1 when <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;4</span></td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">  <span class='directive'>#define <span class='macro'>eInt<span class='expansion'>int32_t</span></span>  <span class='macro'>Long<span class='expansion'>int64_t</span></span>          /* extended integer  */</span></td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">  <span class='directive'>#define <span class='macro'>ueInt<span class='expansion'>uint32_t</span></span> <span class='macro'>uLong<span class='expansion'>uint64_t</span></span>         /* unsigned extended integer  */</span></td></tr>
<tr><td class="num" id="LN246">246</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN247">247</td><td class="line"> </td></tr>
<tr><td class="num" id="LN248">248</td><td class="line"><span class='comment'>/* Local routines */</span></td></tr>
<tr><td class="num" id="LN249">249</td><td class="line"><span class='keyword'>static</span> decNumber * decAddOp(decNumber *, <span class='keyword'>const</span> decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">                              decContext *, <span class='macro'>uByte<span class='expansion'>uint8_t</span></span>, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>        decBiStr(<span class='keyword'>const</span> <span class='keyword'>char</span> *, <span class='keyword'>const</span> <span class='keyword'>char</span> *, <span class='keyword'>const</span> <span class='keyword'>char</span> *);</td></tr>
<tr><td class="num" id="LN252">252</td><td class="line"><span class='keyword'>static</span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>        decCheckMath(<span class='keyword'>const</span> decNumber *, decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decApplyRound(decNumber *, decContext *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decCompare(<span class='keyword'>const</span> decNumber *lhs, <span class='keyword'>const</span> decNumber *rhs, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line"><span class='keyword'>static</span> decNumber * decCompareOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">                              <span class='keyword'>const</span> decNumber *, decContext *,</td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">                              <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN258">258</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decCopyFit(decNumber *, <span class='keyword'>const</span> decNumber *, decContext *,</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">                              <span class='macro'>Int<span class='expansion'>int32_t</span></span> *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line"><span class='keyword'>static</span> decNumber * decDecap(decNumber *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line"><span class='keyword'>static</span> decNumber * decDivideOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">                              <span class='keyword'>const</span> decNumber *, decContext *, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN263">263</td><td class="line"><span class='keyword'>static</span> decNumber * decExpOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">                              decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decFinalize(decNumber *, decContext *, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN266">266</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decGetDigits(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN267">267</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decGetInt(<span class='keyword'>const</span> decNumber *);</td></tr>
<tr><td class="num" id="LN268">268</td><td class="line"><span class='keyword'>static</span> decNumber * decLnOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">                              decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line"><span class='keyword'>static</span> decNumber * decMultiplyOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">                              <span class='keyword'>const</span> decNumber *, decContext *,</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line">                              <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN273">273</td><td class="line"><span class='keyword'>static</span> decNumber * decNaNs(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN274">274</td><td class="line">                              <span class='keyword'>const</span> decNumber *, decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN275">275</td><td class="line"><span class='keyword'>static</span> decNumber * decQuantizeOp(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">                              <span class='keyword'>const</span> decNumber *, decContext *, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>,</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">                              <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN278">278</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decReverse(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *);</td></tr>
<tr><td class="num" id="LN279">279</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decSetCoeff(decNumber *, decContext *, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *,</td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">                              <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decSetMaxValue(decNumber *, decContext *);</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decSetOverflow(decNumber *, decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decSetSubnormal(decNumber *, decContext *, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN284">284</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decShiftToLeast(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decShiftToMost(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN286">286</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decStatus(decNumber *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>, decContext *);</td></tr>
<tr><td class="num" id="LN287">287</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        decToString(<span class='keyword'>const</span> decNumber *, <span class='keyword'>char</span>[], <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN288">288</td><td class="line"><span class='keyword'>static</span> decNumber * decTrim(decNumber *, decContext *, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN289">289</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decUnitAddSub(<span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span>,</td></tr>
<tr><td class="num" id="LN290">290</td><td class="line">                              <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN291">291</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span>         decUnitCompare(<span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN292">292</td><td class="line"> </td></tr>
<tr><td class="num" id="LN293">293</td><td class="line"><span class='directive'>#if !<span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line"><span class='comment'>/* decFinish == decFinalize when no subset arithmetic needed */</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line"><span class='directive'>#define <span class='macro'>decFinish(a,b,c,d)<span class='expansion'>decFinalize(a,b,c,d)</span></span> decFinalize(a,b,c,d)</span></td></tr>
<tr><td class="num" id="LN296">296</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN297">297</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>        <span class='macro'>decFinish(decNumber *, decContext *, Int *, uInt *)<span class='expansion'>decFinalize(decNumber *,decContext *,int32_t *,uint32_t *)</span></span>;</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line"><span class='keyword'>static</span> decNumber * decRoundOperand(<span class='keyword'>const</span> decNumber *, decContext *, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *);</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN300">300</td><td class="line"> </td></tr>
<tr><td class="num" id="LN301">301</td><td class="line"><span class='comment'>/* Local macros */</span></td></tr>
<tr><td class="num" id="LN302">302</td><td class="line"><span class='comment'>/* masked special-values bits  */</span></td></tr>
<tr><td class="num" id="LN303">303</td><td class="line"><span class='directive'>#define <span class='macro'>SPECIALARG<span class='expansion'>(rhs-&gt;bits &amp; (0x40|0x20|0x10))</span></span>  (rhs-&gt;bits &amp; <span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>)</span></td></tr>
<tr><td class="num" id="LN304">304</td><td class="line"><span class='directive'>#define <span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span> ((lhs-&gt;bits | rhs-&gt;bits) &amp; <span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>)</span></td></tr>
<tr><td class="num" id="LN305">305</td><td class="line"> </td></tr>
<tr><td class="num" id="LN306">306</td><td class="line"><span class='comment'>/* For use in ICU */</span></td></tr>
<tr><td class="num" id="LN307">307</td><td class="line"><span class='directive'>#define <span class='macro'>malloc(a)<span class='expansion'>uprv_malloc_54(a)</span></span> <span class='macro'>uprv_malloc<span class='expansion'>uprv_malloc_54</span></span>(a)</span></td></tr>
<tr><td class="num" id="LN308">308</td><td class="line"><span class='directive'>#define <span class='macro'>free(a)<span class='expansion'>uprv_free_54(a)</span></span> <span class='macro'>uprv_free<span class='expansion'>uprv_free_54</span></span>(a)</span></td></tr>
<tr><td class="num" id="LN309">309</td><td class="line"> </td></tr>
<tr><td class="num" id="LN310">310</td><td class="line"><span class='comment'>/* Diagnostic macros, etc. */</span></td></tr>
<tr><td class="num" id="LN311">311</td><td class="line"><span class='directive'>#if <span class='macro'>DECALLOC<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN312">312</td><td class="line"><span class='comment'>/* Handle malloc/free accounting.  If enabled, our accountable routines  */</span></td></tr>
<tr><td class="num" id="LN313">313</td><td class="line"><span class='comment'>/* are used; otherwise the code just goes straight to the system malloc  */</span></td></tr>
<tr><td class="num" id="LN314">314</td><td class="line"><span class='comment'>/* and free routines.  */</span></td></tr>
<tr><td class="num" id="LN315">315</td><td class="line"><span class='directive'>#define <span class='macro'>malloc(a)<span class='expansion'>uprv_malloc_54(a)</span></span> decMalloc(a)</span></td></tr>
<tr><td class="num" id="LN316">316</td><td class="line"><span class='directive'>#define <span class='macro'>free(a)<span class='expansion'>uprv_free_54(a)</span></span> decFree(a)</span></td></tr>
<tr><td class="num" id="LN317">317</td><td class="line"><span class='directive'>#define DECFENCE 0x5a              /* corruption detector  */</span></td></tr>
<tr><td class="num" id="LN318">318</td><td class="line"><span class='comment'>/* 'Our' malloc and free:  */</span></td></tr>
<tr><td class="num" id="LN319">319</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> *decMalloc(size_t);</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span>  decFree(<span class='keyword'>void</span> *);</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line"><span class='macro'>uInt<span class='expansion'>uint32_t</span></span> decAllocBytes=0;              <span class='comment'>/* count of bytes allocated  */</span></td></tr>
<tr><td class="num" id="LN322">322</td><td class="line"><span class='comment'>/* Note that DECALLOC code only checks for storage buffer overflow.  */</span></td></tr>
<tr><td class="num" id="LN323">323</td><td class="line"><span class='comment'>/* To check for memory leaks, the decAllocBytes variable must be  */</span></td></tr>
<tr><td class="num" id="LN324">324</td><td class="line"><span class='comment'>/* checked to be 0 at appropriate times (e.g., after the test  */</span></td></tr>
<tr><td class="num" id="LN325">325</td><td class="line"><span class='comment'>/* harness completes a set of tests).  This checking may be unreliable  */</span></td></tr>
<tr><td class="num" id="LN326">326</td><td class="line"><span class='comment'>/* if the testing is done in a multi-thread environment.  */</span></td></tr>
<tr><td class="num" id="LN327">327</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN328">328</td><td class="line"> </td></tr>
<tr><td class="num" id="LN329">329</td><td class="line"><span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN330">330</td><td class="line"><span class='comment'>/* Optional checking routines.  Enabling these means that decNumber  */</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line"><span class='comment'>/* and decContext operands to operator routines are checked for  */</span></td></tr>
<tr><td class="num" id="LN332">332</td><td class="line"><span class='comment'>/* correctness.  This roughly doubles the execution time of the  */</span></td></tr>
<tr><td class="num" id="LN333">333</td><td class="line"><span class='comment'>/* fastest routines (and adds 600+ bytes), so should not normally be  */</span></td></tr>
<tr><td class="num" id="LN334">334</td><td class="line"><span class='comment'>/* used in 'production'.  */</span></td></tr>
<tr><td class="num" id="LN335">335</td><td class="line"><span class='comment'>/* decCheckInexact is used to check that inexact results have a full  */</span></td></tr>
<tr><td class="num" id="LN336">336</td><td class="line"><span class='comment'>/* complement of digits (where appropriate -- this is not the case  */</span></td></tr>
<tr><td class="num" id="LN337">337</td><td class="line"><span class='comment'>/* for Quantize, for example)  */</span></td></tr>
<tr><td class="num" id="LN338">338</td><td class="line"><span class='directive'>#define DECUNRESU ((decNumber *)(void *)0xffffffff)</span></td></tr>
<tr><td class="num" id="LN339">339</td><td class="line"><span class='directive'>#define DECUNUSED ((const decNumber *)(void *)0xffffffff)</span></td></tr>
<tr><td class="num" id="LN340">340</td><td class="line"><span class='directive'>#define DECUNCONT ((decContext *)(void *)(0xffffffff))</span></td></tr>
<tr><td class="num" id="LN341">341</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> decCheckOperands(decNumber *, <span class='keyword'>const</span> decNumber *,</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">                             <span class='keyword'>const</span> decNumber *, decContext *);</td></tr>
<tr><td class="num" id="LN343">343</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> decCheckNumber(<span class='keyword'>const</span> decNumber *);</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decCheckInexact(<span class='keyword'>const</span> decNumber *, decContext *);</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN346">346</td><td class="line"> </td></tr>
<tr><td class="num" id="LN347">347</td><td class="line"><span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN348">348</td><td class="line"><span class='comment'>/* Optional trace/debugging routines (may or may not be used)  */</span></td></tr>
<tr><td class="num" id="LN349">349</td><td class="line"><span class='keyword'>void</span> decNumberShow(<span class='keyword'>const</span> decNumber *);  <span class='comment'>/* displays the components of a number  */</span></td></tr>
<tr><td class="num" id="LN350">350</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decDumpAr(<span class='keyword'>char</span>, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *, <span class='macro'>Int<span class='expansion'>int32_t</span></span>);</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN352">352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN353">353</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN354">354</td><td class="line"><span class='comment'>/* Conversions                                                        */</span></td></tr>
<tr><td class="num" id="LN355">355</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN356">356</td><td class="line"> </td></tr>
<tr><td class="num" id="LN357">357</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN358">358</td><td class="line"><span class='comment'>/* from-int32 -- conversion from Int or uInt                          */</span></td></tr>
<tr><td class="num" id="LN359">359</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN360">360</td><td class="line"><span class='comment'>/*  dn is the decNumber to receive the integer                        */</span></td></tr>
<tr><td class="num" id="LN361">361</td><td class="line"><span class='comment'>/*  in or uin is the integer to be converted                          */</span></td></tr>
<tr><td class="num" id="LN362">362</td><td class="line"><span class='comment'>/*  returns dn                                                        */</span></td></tr>
<tr><td class="num" id="LN363">363</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN364">364</td><td class="line"><span class='comment'>/* No error is possible.                                              */</span></td></tr>
<tr><td class="num" id="LN365">365</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN366">366</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(decNumber *dn, <span class='macro'>Int<span class='expansion'>int32_t</span></span> in) {</td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> unsig;</td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">  <span class='keyword'>if</span> (in&gt;=0) unsig=in;</td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">   <span class='keyword'>else</span> {                               <span class='comment'>/* negative (possibly BADINT)  */</span></td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">    <span class='keyword'>if</span> (in==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) unsig=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)1073741824*2; <span class='comment'>/* special case  */</span></td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">     <span class='keyword'>else</span> unsig=-in;                    <span class='comment'>/* invert  */</span></td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">  <span class='comment'>/* in is now positive  */</span></td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">  <span class='macro'>uprv_decNumberFromUInt32<span class='expansion'>uprv_decNumberFromUInt32_54</span></span>(dn, unsig);</td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">  <span class='keyword'>if</span> (in&lt;0) dn-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;            <span class='comment'>/* sign needed  */</span></td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">  } <span class='comment'>/* decNumberFromInt32  */</span></td></tr>
<tr><td class="num" id="LN378">378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN379">379</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberFromUInt32<span class='expansion'>uprv_decNumberFromUInt32_54</span></span>(decNumber *dn, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> uin) {</td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                             <span class='comment'>/* work pointer  */</span></td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);                    <span class='comment'>/* clean  */</span></td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">  <span class='keyword'>if</span> (uin==0) <span class='keyword'>return</span> dn;                <span class='comment'>/* [or decGetDigits bad call]  */</span></td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">  <span class='keyword'>for</span> (up=dn-&gt;lsu; uin&gt;0; up++) {</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">    *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(uin%(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">    uin=uin/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">  dn-&gt;digits=decGetDigits(dn-&gt;lsu, up-dn-&gt;lsu);</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">  } <span class='comment'>/* decNumberFromUInt32  */</span></td></tr>
<tr><td class="num" id="LN390">390</td><td class="line"> </td></tr>
<tr><td class="num" id="LN391">391</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN392">392</td><td class="line"><span class='comment'>/* to-int32 -- conversion to Int or uInt                              */</span></td></tr>
<tr><td class="num" id="LN393">393</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN394">394</td><td class="line"><span class='comment'>/*  dn is the decNumber to convert                                    */</span></td></tr>
<tr><td class="num" id="LN395">395</td><td class="line"><span class='comment'>/*  set is the context for reporting errors                           */</span></td></tr>
<tr><td class="num" id="LN396">396</td><td class="line"><span class='comment'>/*  returns the converted decNumber, or 0 if Invalid is set           */</span></td></tr>
<tr><td class="num" id="LN397">397</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN398">398</td><td class="line"><span class='comment'>/* Invalid is set if the decNumber does not have exponent==0 or if    */</span></td></tr>
<tr><td class="num" id="LN399">399</td><td class="line"><span class='comment'>/* it is a NaN, Infinite, or out-of-range.                            */</span></td></tr>
<tr><td class="num" id="LN400">400</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN401">401</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> U_EXPORT2 <span class='macro'>uprv_decNumberToInt32<span class='expansion'>uprv_decNumberToInt32_54</span></span>(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, dn, set)) <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN405">405</td><td class="line"> </td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">  <span class='comment'>/* special or too many digits, or bad exponent  */</span></td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span> || dn-&gt;digits&gt;10 || dn-&gt;exponent!=0) ; <span class='comment'>/* bad  */</span></td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* is a finite integer with 10 or fewer digits  */</span></td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> d;                         <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">    <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> hi=0, lo;                 <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">    up=dn-&gt;lsu;                    <span class='comment'>/* -&gt; lsu  */</span></td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">    lo=*up;                        <span class='comment'>/* get 1 to 9 digits  */</span></td></tr>
<tr><td class="num" id="LN414">414</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1                  /* split to higher  */</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">      hi=lo/10;</td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">      lo=lo%10;</td></tr>
<tr><td class="num" id="LN417">417</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">    up++;</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">    <span class='comment'>/* collect remaining Units, if any, into hi  */</span></td></tr>
<tr><td class="num" id="LN420">420</td><td class="line">    <span class='keyword'>for</span> (d=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; d&lt;dn-&gt;digits; up++, d+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) hi+=*up*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[d-1];</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">    <span class='comment'>/* now low has the lsd, hi the remainder  */</span></td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">    <span class='keyword'>if</span> (hi&gt;214748364 || (hi==214748364 &amp;&amp; lo&gt;7)) { <span class='comment'>/* out of range?  */</span></td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">      <span class='comment'>/* most-negative is a reprieve  */</span></td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">      <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span> &amp;&amp; hi==214748364 &amp;&amp; lo==8) <span class='keyword'>return</span> 0x80000000;</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">      <span class='comment'>/* bad -- drop through  */</span></td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* in-range always  */</span></td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> i=<span class='macro'>X10(hi)<span class='expansion'>(((hi)&lt;&lt;1)+((hi)&lt;&lt;3))</span></span>+lo;</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">      <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>) <span class='keyword'>return</span> -i;</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">      <span class='keyword'>return</span> i;</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">    } <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">  <span class='macro'>uprv_decContextSetStatus<span class='expansion'>uprv_decContextSetStatus_54</span></span>(set, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>); <span class='comment'>/* [may not return]  */</span></td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">  } <span class='comment'>/* decNumberToInt32  */</span></td></tr>
<tr><td class="num" id="LN436">436</td><td class="line"> </td></tr>
<tr><td class="num" id="LN437">437</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> U_EXPORT2 <span class='macro'>uprv_decNumberToUInt32<span class='expansion'>uprv_decNumberToUInt32_54</span></span>(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, dn, set)) <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">  <span class='comment'>/* special or too many digits, or bad exponent, or negative (&lt;0)  */</span></td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span> || dn-&gt;digits&gt;10 || dn-&gt;exponent!=0</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">    || (dn-&gt;bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span> &amp;&amp; !<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>));                   <span class='comment'>/* bad  */</span></td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* is a finite integer with 10 or fewer digits  */</span></td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> d;                         <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">    <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> hi=0, lo;                 <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">    up=dn-&gt;lsu;                    <span class='comment'>/* -&gt; lsu  */</span></td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">    lo=*up;                        <span class='comment'>/* get 1 to 9 digits  */</span></td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1                  /* split to higher  */</span></td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">      hi=lo/10;</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">      lo=lo%10;</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">    up++;</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">    <span class='comment'>/* collect remaining Units, if any, into hi  */</span></td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">    <span class='keyword'>for</span> (d=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; d&lt;dn-&gt;digits; up++, d+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) hi+=*up*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[d-1];</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line"> </td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">    <span class='comment'>/* now low has the lsd, hi the remainder  */</span></td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">    <span class='keyword'>if</span> (hi&gt;429496729 || (hi==429496729 &amp;&amp; lo&gt;5)) ; <span class='comment'>/* no reprieve possible  */</span></td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>return</span> <span class='macro'>X10(hi)<span class='expansion'>(((hi)&lt;&lt;1)+((hi)&lt;&lt;3))</span></span>+lo;</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">    } <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">  <span class='macro'>uprv_decContextSetStatus<span class='expansion'>uprv_decContextSetStatus_54</span></span>(set, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>); <span class='comment'>/* [may not return]  */</span></td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">  } <span class='comment'>/* decNumberToUInt32  */</span></td></tr>
<tr><td class="num" id="LN465">465</td><td class="line"> </td></tr>
<tr><td class="num" id="LN466">466</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN467">467</td><td class="line"><span class='comment'>/* to-scientific-string -- conversion to numeric string               */</span></td></tr>
<tr><td class="num" id="LN468">468</td><td class="line"><span class='comment'>/* to-engineering-string -- conversion to numeric string              */</span></td></tr>
<tr><td class="num" id="LN469">469</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN470">470</td><td class="line"><span class='comment'>/*   decNumberToString(dn, string);                                   */</span></td></tr>
<tr><td class="num" id="LN471">471</td><td class="line"><span class='comment'>/*   decNumberToEngString(dn, string);                                */</span></td></tr>
<tr><td class="num" id="LN472">472</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN473">473</td><td class="line"><span class='comment'>/*  dn is the decNumber to convert                                    */</span></td></tr>
<tr><td class="num" id="LN474">474</td><td class="line"><span class='comment'>/*  string is the string where the result will be laid out            */</span></td></tr>
<tr><td class="num" id="LN475">475</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN476">476</td><td class="line"><span class='comment'>/*  string must be at least dn-&gt;digits+14 characters long             */</span></td></tr>
<tr><td class="num" id="LN477">477</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line"><span class='comment'>/*  No error is possible, and no status can be set.                   */</span></td></tr>
<tr><td class="num" id="LN479">479</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN480">480</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> <span class='keyword'>char</span> * U_EXPORT2 <span class='macro'>uprv_decNumberToString<span class='expansion'>uprv_decNumberToString_54</span></span>(<span class='keyword'>const</span> decNumber *dn, <span class='keyword'>char</span> *string){</td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">  decToString(dn, string, 0);</td></tr>
<tr><td class="num" id="LN482">482</td><td class="line">  <span class='keyword'>return</span> string;</td></tr>
<tr><td class="num" id="LN483">483</td><td class="line">  } <span class='comment'>/* DecNumberToString  */</span></td></tr>
<tr><td class="num" id="LN484">484</td><td class="line"> </td></tr>
<tr><td class="num" id="LN485">485</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> <span class='keyword'>char</span> * U_EXPORT2 <span class='macro'>uprv_decNumberToEngString<span class='expansion'>uprv_decNumberToEngString_54</span></span>(<span class='keyword'>const</span> decNumber *dn, <span class='keyword'>char</span> *string){</td></tr>
<tr><td class="num" id="LN486">486</td><td class="line">  decToString(dn, string, 1);</td></tr>
<tr><td class="num" id="LN487">487</td><td class="line">  <span class='keyword'>return</span> string;</td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">  } <span class='comment'>/* DecNumberToEngString  */</span></td></tr>
<tr><td class="num" id="LN489">489</td><td class="line"> </td></tr>
<tr><td class="num" id="LN490">490</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN491">491</td><td class="line"><span class='comment'>/* to-number -- conversion from numeric string                        */</span></td></tr>
<tr><td class="num" id="LN492">492</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN493">493</td><td class="line"><span class='comment'>/* decNumberFromString -- convert string to decNumber                 */</span></td></tr>
<tr><td class="num" id="LN494">494</td><td class="line"><span class='comment'>/*   dn        -- the number structure to fill                        */</span></td></tr>
<tr><td class="num" id="LN495">495</td><td class="line"><span class='comment'>/*   chars[]   -- the string to convert ('\0' terminated)             */</span></td></tr>
<tr><td class="num" id="LN496">496</td><td class="line"><span class='comment'>/*   set       -- the context used for processing any error,          */</span></td></tr>
<tr><td class="num" id="LN497">497</td><td class="line"><span class='comment'>/*                determining the maximum precision available         */</span></td></tr>
<tr><td class="num" id="LN498">498</td><td class="line"><span class='comment'>/*                (set.digits), determining the maximum and minimum   */</span></td></tr>
<tr><td class="num" id="LN499">499</td><td class="line"><span class='comment'>/*                exponent (set.emax and set.emin), determining if    */</span></td></tr>
<tr><td class="num" id="LN500">500</td><td class="line"><span class='comment'>/*                extended values are allowed, and checking the       */</span></td></tr>
<tr><td class="num" id="LN501">501</td><td class="line"><span class='comment'>/*                rounding mode if overflow occurs or rounding is     */</span></td></tr>
<tr><td class="num" id="LN502">502</td><td class="line"><span class='comment'>/*                needed.                                             */</span></td></tr>
<tr><td class="num" id="LN503">503</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN504">504</td><td class="line"><span class='comment'>/* The length of the coefficient and the size of the exponent are     */</span></td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"><span class='comment'>/* checked by this routine, so the correct error (Underflow or        */</span></td></tr>
<tr><td class="num" id="LN506">506</td><td class="line"><span class='comment'>/* Overflow) can be reported or rounding applied, as necessary.       */</span></td></tr>
<tr><td class="num" id="LN507">507</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN508">508</td><td class="line"><span class='comment'>/* If bad syntax is detected, the result will be a quiet NaN.         */</span></td></tr>
<tr><td class="num" id="LN509">509</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN510">510</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberFromString<span class='expansion'>uprv_decNumberFromString_54</span></span>(decNumber *dn, <span class='keyword'>const</span> <span class='keyword'>char</span> chars[],</td></tr>
<tr><td class="num" id="LN511">511</td><td class="line">                                decContext *set) {</td></tr>
<tr><td class="num" id="LN512">512</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   exponent=0;                <span class='comment'>/* working exponent [assume 0]  */</span></td></tr>
<tr><td class="num" id="LN513">513</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> bits=0;                    <span class='comment'>/* working flags [assume +ve]  */</span></td></tr>
<tr><td class="num" id="LN514">514</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *res;                      <span class='comment'>/* where result will be built  */</span></td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  resbuff[<span class='macro'>SD2U(DECBUFFER+9)<span class='expansion'>(((36 +9)+1 -1)/1)</span></span>];<span class='comment'>/* local buffer in case need temporary  */</span></td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">                                   <span class='comment'>/* [+9 allows for ln() constants]  */</span></td></tr>
<tr><td class="num" id="LN517">517</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *allocres=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated result, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN518">518</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   d=0;                       <span class='comment'>/* count of digits found in decimal part  */</span></td></tr>
<tr><td class="num" id="LN519">519</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *dotchar=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* where dot was found  */</span></td></tr>
<tr><td class="num" id="LN520">520</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *cfirst=chars;        <span class='comment'>/* -&gt; first character of decimal part  */</span></td></tr>
<tr><td class="num" id="LN521">521</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *last=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;           <span class='comment'>/* -&gt; last digit of decimal part  */</span></td></tr>
<tr><td class="num" id="LN522">522</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *c;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *up;                       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1</span></td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   cut, out;                  <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   residue;                   <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  status=0;                  <span class='comment'>/* error code  */</span></td></tr>
<tr><td class="num" id="LN529">529</td><td class="line"> </td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, DECUNUSED, set))</td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN534">534</td><td class="line"> </td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* status &amp; malloc protection  */</span></td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">    <span class='keyword'>for</span> (c=chars;; c++) {          <span class='comment'>/* -&gt; input character  */</span></td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">      <span class='keyword'>if</span> (*c&gt;='0' &amp;&amp; *c&lt;='9') {    <span class='comment'>/* test for Arabic digit  */</span></td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">        last=c;</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">        d++;                       <span class='comment'>/* count of real digits  */</span></td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">        <span class='keyword'>continue</span>;                  <span class='comment'>/* still in decimal part  */</span></td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">      <span class='keyword'>if</span> (*c=='.' &amp;&amp; dotchar==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) { <span class='comment'>/* first '.'  */</span></td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">        dotchar=c;                 <span class='comment'>/* record offset into decimal part  */</span></td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">        <span class='keyword'>if</span> (c==cfirst) cfirst++;   <span class='comment'>/* first digit must follow  */</span></td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">        <span class='keyword'>continue</span>;}</td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">      <span class='keyword'>if</span> (c==chars) {              <span class='comment'>/* first in string...  */</span></td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">        <span class='keyword'>if</span> (*c=='-') {             <span class='comment'>/* valid - sign  */</span></td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">          cfirst++;</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">          bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;</td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">          <span class='keyword'>continue</span>;}</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">        <span class='keyword'>if</span> (*c=='+') {             <span class='comment'>/* valid + sign  */</span></td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">          cfirst++;</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">          <span class='keyword'>continue</span>;}</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">      <span class='comment'>/* *c is not a digit, or a valid +, -, or '.'  */</span></td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">      } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN558">558</td><td class="line"> </td></tr>
<tr><td class="num" id="LN559">559</td><td class="line">    <span class='keyword'>if</span> (last==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {              <span class='comment'>/* no digits yet  */</span></td></tr>
<tr><td class="num" id="LN560">560</td><td class="line">      status=<span class='macro'>DEC_Conversion_syntax<span class='expansion'>0x00000001</span></span>;<span class='comment'>/* assume the worst  */</span></td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">      <span class='keyword'>if</span> (*c=='\0') <span class='keyword'>break</span>;         <span class='comment'>/* and no more to come...  */</span></td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN563">563</td><td class="line">      <span class='comment'>/* if subset then infinities and NaNs are not allowed  */</span></td></tr>
<tr><td class="num" id="LN564">564</td><td class="line">      <span class='keyword'>if</span> (!set-&gt;extended) <span class='keyword'>break</span>;   <span class='comment'>/* hopeless  */</span></td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">      <span class='comment'>/* Infinities and NaNs are possible, here  */</span></td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">      <span class='keyword'>if</span> (dotchar!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;    <span class='comment'>/* .. unless had a dot  */</span></td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);           <span class='comment'>/* be optimistic  */</span></td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">      <span class='keyword'>if</span> (decBiStr(c, <span class='string_literal'>"infinity"</span>, <span class='string_literal'>"INFINITY"</span>)</td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">       || decBiStr(c, <span class='string_literal'>"inf"</span>, <span class='string_literal'>"INF"</span>)) {</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">        dn-&gt;bits=bits | <span class='macro'>DECINF<span class='expansion'>0x40</span></span>;</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line">        status=0;                  <span class='comment'>/* is OK  */</span></td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">        <span class='keyword'>break</span>; <span class='comment'>/* all done  */</span></td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">      <span class='comment'>/* a NaN expected  */</span></td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">      <span class='comment'>/* 2003.09.10 NaNs are now permitted to have a sign  */</span></td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">      dn-&gt;bits=bits | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>;      <span class='comment'>/* assume simple NaN  */</span></td></tr>
<tr><td class="num" id="LN578">578</td><td class="line">      <span class='keyword'>if</span> (*c=='s' || *c=='S') {    <span class='comment'>/* looks like an sNaN  */</span></td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">        c++;</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">        dn-&gt;bits=bits | <span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>;</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">      <span class='keyword'>if</span> (*c!='n' &amp;&amp; *c!='N') <span class='keyword'>break</span>;    <span class='comment'>/* check caseless "NaN"  */</span></td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">      c++;</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">      <span class='keyword'>if</span> (*c!='a' &amp;&amp; *c!='A') <span class='keyword'>break</span>;    <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">      c++;</td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">      <span class='keyword'>if</span> (*c!='n' &amp;&amp; *c!='N') <span class='keyword'>break</span>;    <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN587">587</td><td class="line">      c++;</td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">      <span class='comment'>/* now either nothing, or nnnn payload, expected  */</span></td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">      <span class='comment'>/* -&gt; start of integer and skip leading 0s [including plain 0]  */</span></td></tr>
<tr><td class="num" id="LN590">590</td><td class="line">      <span class='keyword'>for</span> (cfirst=c; *cfirst=='0';) cfirst++;</td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">      <span class='keyword'>if</span> (*cfirst=='\0') {         <span class='comment'>/* "NaN" or "sNaN", maybe with all 0s  */</span></td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">        status=0;                  <span class='comment'>/* it's good  */</span></td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">        <span class='keyword'>break</span>;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">      <span class='comment'>/* something other than 0s; setup last and d as usual [no dots]  */</span></td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">      <span class='keyword'>for</span> (c=cfirst;; c++, d++) {</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">        <span class='keyword'>if</span> (*c&lt;'0' || *c&gt;'9') <span class='keyword'>break</span>; <span class='comment'>/* test for Arabic digit  */</span></td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">        last=c;</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">      <span class='keyword'>if</span> (*c!='\0') <span class='keyword'>break</span>;         <span class='comment'>/* not all digits  */</span></td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">      <span class='keyword'>if</span> (d&gt;set-&gt;digits-1) {</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">        <span class='comment'>/* [NB: payload in a decNumber can be full length unless  */</span></td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">        <span class='comment'>/* clamped, in which case can only be digits-1]  */</span></td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">        <span class='keyword'>if</span> (set-&gt;clamp) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">        <span class='keyword'>if</span> (d&gt;set-&gt;digits) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">        } <span class='comment'>/* too many digits?  */</span></td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">      <span class='comment'>/* good; drop through to convert the integer to coefficient  */</span></td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">      status=0;                    <span class='comment'>/* syntax is OK  */</span></td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">      bits=dn-&gt;bits;               <span class='comment'>/* for copy-back  */</span></td></tr>
<tr><td class="num" id="LN610">610</td><td class="line">      } <span class='comment'>/* last==NULL  */</span></td></tr>
<tr><td class="num" id="LN611">611</td><td class="line"> </td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>if</span> (*c!='\0') {          <span class='comment'>/* more to process...  */</span></td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">      <span class='comment'>/* had some digits; exponent is only valid sequence now  */</span></td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">      <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> nege;                   <span class='comment'>/* 1=negative exponent  */</span></td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">      <span class='keyword'>const</span> <span class='keyword'>char</span> *firstexp;        <span class='comment'>/* -&gt; first significant exponent digit  */</span></td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">      status=<span class='macro'>DEC_Conversion_syntax<span class='expansion'>0x00000001</span></span>;<span class='comment'>/* assume the worst  */</span></td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">      <span class='keyword'>if</span> (*c!='e' &amp;&amp; *c!='E') <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">      <span class='comment'>/* Found 'e' or 'E' -- now process explicit exponent */</span></td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">      <span class='comment'>/* 1998.07.11: sign no longer required  */</span></td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">      nege=0;</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">      c++;                         <span class='comment'>/* to (possible) sign  */</span></td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">      <span class='keyword'>if</span> (*c=='-') {nege=1; c++;}</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (*c=='+') c++;</td></tr>
<tr><td class="num" id="LN624">624</td><td class="line">      <span class='keyword'>if</span> (*c=='\0') <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN625">625</td><td class="line"> </td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">      <span class='keyword'>for</span> (; *c=='0' &amp;&amp; *(c+1)!='\0';) c++;  <span class='comment'>/* strip insignificant zeros  */</span></td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">      firstexp=c;                            <span class='comment'>/* save exponent digit place  */</span></td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">      <span class='keyword'>for</span> (; ;c++) {</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">        <span class='keyword'>if</span> (*c&lt;'0' || *c&gt;'9') <span class='keyword'>break</span>;         <span class='comment'>/* not a digit  */</span></td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">        exponent=<span class='macro'>X10(exponent)<span class='expansion'>(((exponent)&lt;&lt;1)+((exponent)&lt;&lt;3))</span></span>+(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)*c-(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)'0';</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">        } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">      <span class='comment'>/* if not now on a '\0', *c must not be a digit  */</span></td></tr>
<tr><td class="num" id="LN633">633</td><td class="line">      <span class='keyword'>if</span> (*c!='\0') <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line"> </td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">      <span class='comment'>/* (this next test must be after the syntax checks)  */</span></td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">      <span class='comment'>/* if it was too long the exponent may have wrapped, so check  */</span></td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">      <span class='comment'>/* carefully and set it to a certain overflow if wrap possible  */</span></td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">      <span class='keyword'>if</span> (c&gt;=firstexp+9+1) {</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">        <span class='keyword'>if</span> (c&gt;firstexp+9+1 || *firstexp&gt;'1') exponent=<span class='macro'>DECNUMMAXE<span class='expansion'>999999999</span></span>*2;</td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">        <span class='comment'>/* [up to 1999999999 is OK, for example 1E-1000000998]  */</span></td></tr>
<tr><td class="num" id="LN641">641</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">      <span class='keyword'>if</span> (nege) exponent=-exponent;     <span class='comment'>/* was negative  */</span></td></tr>
<tr><td class="num" id="LN643">643</td><td class="line">      status=0;                         <span class='comment'>/* is OK  */</span></td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">      } <span class='comment'>/* stuff after digits  */</span></td></tr>
<tr><td class="num" id="LN645">645</td><td class="line"> </td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">    <span class='comment'>/* Here when whole string has been inspected; syntax is good  */</span></td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">    <span class='comment'>/* cfirst-&gt;first digit (never dot), last-&gt;last digit (ditto)  */</span></td></tr>
<tr><td class="num" id="LN648">648</td><td class="line"> </td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">    <span class='comment'>/* strip leading zeros/dot [leave final 0 if all 0's]  */</span></td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">    <span class='keyword'>if</span> (*cfirst=='0') {                 <span class='comment'>/* [cfirst has stepped over .]  */</span></td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">      <span class='keyword'>for</span> (c=cfirst; c&lt;last; c++, cfirst++) {</td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">        <span class='keyword'>if</span> (*c=='.') <span class='keyword'>continue</span>;          <span class='comment'>/* ignore dots  */</span></td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">        <span class='keyword'>if</span> (*c!='0') <span class='keyword'>break</span>;             <span class='comment'>/* non-zero found  */</span></td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">        d--;                            <span class='comment'>/* 0 stripped  */</span></td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">        } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">      <span class='comment'>/* make a rapid exit for easy zeros if !extended  */</span></td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">      <span class='keyword'>if</span> (*cfirst=='0' &amp;&amp; !set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);              <span class='comment'>/* clean result  */</span></td></tr>
<tr><td class="num" id="LN660">660</td><td class="line">        <span class='keyword'>break</span>;                          <span class='comment'>/* [could be return]  */</span></td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">      } <span class='comment'>/* at least one leading 0  */</span></td></tr>
<tr><td class="num" id="LN664">664</td><td class="line"> </td></tr>
<tr><td class="num" id="LN665">665</td><td class="line">    <span class='comment'>/* Handle decimal point...  */</span></td></tr>
<tr><td class="num" id="LN666">666</td><td class="line">    <span class='keyword'>if</span> (dotchar!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> &amp;&amp; dotchar&lt;last)  <span class='comment'>/* non-trailing '.' found?  */</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line">      exponent-=(last-dotchar);         <span class='comment'>/* adjust exponent  */</span></td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">    <span class='comment'>/* [we can now ignore the .]  */</span></td></tr>
<tr><td class="num" id="LN669">669</td><td class="line"> </td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">    <span class='comment'>/* OK, the digits string is good.  Assemble in the decNumber, or in  */</span></td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">    <span class='comment'>/* a temporary units array if rounding is needed  */</span></td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">    <span class='keyword'>if</span> (d&lt;=set-&gt;digits) res=dn-&gt;lsu;    <span class='comment'>/* fits into supplied decNumber  */</span></td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* rounding needed  */</span></td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> needbytes=<span class='macro'>D2U(d)<span class='expansion'>((d)&lt;=49?d2utable[d]:((d)+1 -1)/1)</span></span>*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);<span class='comment'>/* bytes needed  */</span></td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">      res=resbuff;                      <span class='comment'>/* assume use local buffer  */</span></td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(resbuff)) { <span class='comment'>/* too big for local  */</span></td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">        allocres=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">        <span class='keyword'>if</span> (allocres==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>; <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">        res=allocres;</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">    <span class='comment'>/* res now -&gt; number lsu, buffer, or allocated storage for Unit array  */</span></td></tr>
<tr><td class="num" id="LN683">683</td><td class="line"> </td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">    <span class='comment'>/* Place the coefficient into the selected Unit array  */</span></td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">    <span class='comment'>/* [this is often 70% of the cost of this function when DECDPUN&gt;1]  */</span></td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1</span></td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">    out=0;                         <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">    up=res+<span class='macro'>D2U(d)<span class='expansion'>((d)&lt;=49?d2utable[d]:((d)+1 -1)/1)</span></span>-1;               <span class='comment'>/* -&gt; msu  */</span></td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">    cut=d-(up-res)*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;        <span class='comment'>/* digits in top unit  */</span></td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">    <span class='keyword'>for</span> (c=cfirst;; c++) {         <span class='comment'>/* along the digits  */</span></td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">      <span class='keyword'>if</span> (*c=='.') <span class='keyword'>continue</span>;       <span class='comment'>/* ignore '.' [don't decrement cut]  */</span></td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">      out=<span class='macro'>X10(out)<span class='expansion'>(((out)&lt;&lt;1)+((out)&lt;&lt;3))</span></span>+(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)*c-(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)'0';</td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">      <span class='keyword'>if</span> (c==last) <span class='keyword'>break</span>;          <span class='comment'>/* done [never get to trailing '.']  */</span></td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">      cut--;</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">      <span class='keyword'>if</span> (cut&gt;0) <span class='keyword'>continue</span>;         <span class='comment'>/* more for this unit  */</span></td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">      *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)out;               <span class='comment'>/* write unit  */</span></td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">      up--;                        <span class='comment'>/* prepare for unit below..  */</span></td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">      cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;                 <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">      out=0;                       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">      } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">    *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)out;                 <span class='comment'>/* write lsu  */</span></td></tr>
<tr><td class="num" id="LN702">702</td><td class="line"> </td></tr>
<tr><td class="num" id="LN703">703</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">    <span class='comment'>/* DECDPUN==1  */</span></td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">    up=res;                        <span class='comment'>/* -&gt; lsu  */</span></td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">    <span class='keyword'>for</span> (c=last; c&gt;=cfirst; c--) { <span class='comment'>/* over each character, from least  */</span></td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">      <span class='keyword'>if</span> (*c=='.') <span class='keyword'>continue</span>;       <span class='comment'>/* ignore . [don't step up]  */</span></td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">      *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)((<span class='macro'>Int<span class='expansion'>int32_t</span></span>)*c-(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)'0');</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">      up++;</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">      } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN712">712</td><td class="line"> </td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">    dn-&gt;bits=bits;</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">    dn-&gt;exponent=exponent;</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">    dn-&gt;digits=d;</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line"> </td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">    <span class='comment'>/* if not in number (too long) shorten into the number  */</span></td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">    <span class='keyword'>if</span> (d&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">      residue=0;</td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">      decSetCoeff(dn, set, res, d, &amp;residue, &amp;status);</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">      <span class='comment'>/* always check for overflow or subnormal and round as needed  */</span></td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">      decFinalize(dn, set, &amp;residue, &amp;status);</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* no rounding, but may still have overflow or subnormal  */</span></td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">      <span class='comment'>/* [these tests are just for performance; finalize repeats them]  */</span></td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">      <span class='keyword'>if</span> ((dn-&gt;exponent-1&lt;set-&gt;emin-dn-&gt;digits)</td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">       || (dn-&gt;exponent-1&gt;set-&gt;emax-set-&gt;digits)) {</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">        residue=0;</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">        decFinalize(dn, set, &amp;residue, &amp;status);</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">    <span class='comment'>/* decNumberShow(dn);  */</span></td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* [for break]  */</span></td></tr>
<tr><td class="num" id="LN734">734</td><td class="line"> </td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">  <span class='keyword'>if</span> (allocres!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocres)<span class='expansion'>uprv_free_54(allocres)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(dn, status, set);</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">  } <span class='comment'>/* decNumberFromString */</span></td></tr>
<tr><td class="num" id="LN739">739</td><td class="line"> </td></tr>
<tr><td class="num" id="LN740">740</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN741">741</td><td class="line"><span class='comment'>/* Operators                                                          */</span></td></tr>
<tr><td class="num" id="LN742">742</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN743">743</td><td class="line"> </td></tr>
<tr><td class="num" id="LN744">744</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN745">745</td><td class="line"><span class='comment'>/* decNumberAbs -- absolute value operator                            */</span></td></tr>
<tr><td class="num" id="LN746">746</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN747">747</td><td class="line"><span class='comment'>/*   This computes C = abs(A)                                         */</span></td></tr>
<tr><td class="num" id="LN748">748</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN749">749</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN750">750</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN751">751</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN752">752</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN753">753</td><td class="line"><span class='comment'>/* See also decNumberCopyAbs for a quiet bitwise version of this.     */</span></td></tr>
<tr><td class="num" id="LN754">754</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN755">755</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN756">756</td><td class="line"><span class='comment'>/* This has the same effect as decNumberPlus unless A is negative,    */</span></td></tr>
<tr><td class="num" id="LN757">757</td><td class="line"><span class='comment'>/* in which case it has the same effect as decNumberMinus.            */</span></td></tr>
<tr><td class="num" id="LN758">758</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN759">759</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberAbs<span class='expansion'>uprv_decNumberAbs_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">                         decContext *set) {</td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">  decNumber dzero;                      <span class='comment'>/* for 0  */</span></td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN763">763</td><td class="line"> </td></tr>
<tr><td class="num" id="LN764">764</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN765">765</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN767">767</td><td class="line"> </td></tr>
<tr><td class="num" id="LN768">768</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dzero);                <span class='comment'>/* set 0  */</span></td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">  dzero.exponent=rhs-&gt;exponent;         <span class='comment'>/* [no coefficient expansion]  */</span></td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">  decAddOp(res, &amp;dzero, rhs, set, (<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(rhs-&gt;bits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>), &amp;status);</td></tr>
<tr><td class="num" id="LN771">771</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN772">772</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN775">775</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN776">776</td><td class="line">  } <span class='comment'>/* decNumberAbs  */</span></td></tr>
<tr><td class="num" id="LN777">777</td><td class="line"> </td></tr>
<tr><td class="num" id="LN778">778</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN779">779</td><td class="line"><span class='comment'>/* decNumberAdd -- add two Numbers                                    */</span></td></tr>
<tr><td class="num" id="LN780">780</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN781">781</td><td class="line"><span class='comment'>/*   This computes C = A + B                                          */</span></td></tr>
<tr><td class="num" id="LN782">782</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN783">783</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X+X)         */</span></td></tr>
<tr><td class="num" id="LN784">784</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN785">785</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN786">786</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN787">787</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN788">788</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN789">789</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN790">790</td><td class="line"><span class='comment'>/* This just calls the routine shared with Subtract                   */</span></td></tr>
<tr><td class="num" id="LN791">791</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberAdd<span class='expansion'>uprv_decNumberAdd_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">  decAddOp(res, lhs, rhs, set, 0, &amp;status);</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">  } <span class='comment'>/* decNumberAdd  */</span></td></tr>
<tr><td class="num" id="LN801">801</td><td class="line"> </td></tr>
<tr><td class="num" id="LN802">802</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN803">803</td><td class="line"><span class='comment'>/* decNumberAnd -- AND two Numbers, digitwise                         */</span></td></tr>
<tr><td class="num" id="LN804">804</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN805">805</td><td class="line"><span class='comment'>/*   This computes C = A &amp; B                                          */</span></td></tr>
<tr><td class="num" id="LN806">806</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN807">807</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X&amp;X)         */</span></td></tr>
<tr><td class="num" id="LN808">808</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN809">809</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN810">810</td><td class="line"><span class='comment'>/*   set is the context (used for result length and error report)     */</span></td></tr>
<tr><td class="num" id="LN811">811</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN812">812</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN813">813</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN814">814</td><td class="line"><span class='comment'>/* Logical function restrictions apply (see above); a NaN is          */</span></td></tr>
<tr><td class="num" id="LN815">815</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN816">816</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberAnd<span class='expansion'>uprv_decNumberAnd_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN818">818</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN819">819</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ua, *ub;                  <span class='comment'>/* -&gt; operands  */</span></td></tr>
<tr><td class="num" id="LN820">820</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msua, *msub;              <span class='comment'>/* -&gt; operand msus  */</span></td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *uc,  *msuc;                     <span class='comment'>/* -&gt; result and its msu  */</span></td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   msudigs;                        <span class='comment'>/* digits in res msu  */</span></td></tr>
<tr><td class="num" id="LN823">823</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN826">826</td><td class="line"> </td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span></td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">   || rhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">    decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line"> </td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">  <span class='comment'>/* operands are valid  */</span></td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">  ua=lhs-&gt;lsu;                          <span class='comment'>/* bottom-up  */</span></td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">  ub=rhs-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">  uc=res-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">  msua=ua+<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of lhs  */</span></td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">  msub=ub+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of rhs  */</span></td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">  msuc=uc+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of result  */</span></td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">  msudigs=<span class='macro'>MSUDIGITS(set-&gt;digits)<span class='expansion'>((set-&gt;digits)-(((set-&gt;digits)&lt;=49?d2utable[set-&gt;<br>digits]:((set-&gt;digits)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">  <span class='keyword'>for</span> (; uc&lt;=msuc; ua++, ub++, uc++) {  <span class='comment'>/* Unit loop  */</span></td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> a, b;                          <span class='comment'>/* extract units  */</span></td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">    <span class='keyword'>if</span> (ua&gt;msua) a=0;</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">     <span class='keyword'>else</span> a=*ua;</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">    <span class='keyword'>if</span> (ub&gt;msub) b=0;</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">     <span class='keyword'>else</span> b=*ub;</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">    *uc=0;                              <span class='comment'>/* can now write back  */</span></td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">    <span class='keyword'>if</span> (a|b) {                          <span class='comment'>/* maybe 1 bits to examine  */</span></td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> i, j;</td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">      *uc=0;                            <span class='comment'>/* can now write back  */</span></td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">      <span class='comment'>/* This loop could be unrolled and/or use BIN2BCD tables  */</span></td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; i++) {</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">        <span class='keyword'>if</span> (a&amp;b&amp;1) *uc=*uc+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[i];  <span class='comment'>/* effect AND  */</span></td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">        j=a%10;</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">        a=a/10;</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">        j|=b%10;</td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">        b=b/10;</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">        <span class='keyword'>if</span> (j&gt;1) {</td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">          decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">          <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">        <span class='keyword'>if</span> (uc==msuc &amp;&amp; i==msudigs-1) <span class='keyword'>break</span>; <span class='comment'>/* just did final digit  */</span></td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">        } <span class='comment'>/* each digit  */</span></td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">      } <span class='comment'>/* both OK  */</span></td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">    } <span class='comment'>/* each unit  */</span></td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">  <span class='comment'>/* [here uc-1 is the msu of the result]  */</span></td></tr>
<tr><td class="num" id="LN867">867</td><td class="line">  res-&gt;digits=decGetDigits(res-&gt;lsu, uc-res-&gt;lsu);</td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">  res-&gt;exponent=0;                      <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">  res-&gt;bits=0;                          <span class='comment'>/* sign=0  */</span></td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">  <span class='keyword'>return</span> res;  <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">  } <span class='comment'>/* decNumberAnd  */</span></td></tr>
<tr><td class="num" id="LN872">872</td><td class="line"> </td></tr>
<tr><td class="num" id="LN873">873</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN874">874</td><td class="line"><span class='comment'>/* decNumberCompare -- compare two Numbers                            */</span></td></tr>
<tr><td class="num" id="LN875">875</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN876">876</td><td class="line"><span class='comment'>/*   This computes C = A ? B                                          */</span></td></tr>
<tr><td class="num" id="LN877">877</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN878">878</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN879">879</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN880">880</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN881">881</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN882">882</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN883">883</td><td class="line"><span class='comment'>/* C must have space for one digit (or NaN).                          */</span></td></tr>
<tr><td class="num" id="LN884">884</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN885">885</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCompare<span class='expansion'>uprv_decNumberCompare_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN886">886</td><td class="line">                             <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN887">887</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN888">888</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN889">889</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN890">890</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN891">891</td><td class="line">  } <span class='comment'>/* decNumberCompare  */</span></td></tr>
<tr><td class="num" id="LN892">892</td><td class="line"> </td></tr>
<tr><td class="num" id="LN893">893</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN894">894</td><td class="line"><span class='comment'>/* decNumberCompareSignal -- compare, signalling on all NaNs          */</span></td></tr>
<tr><td class="num" id="LN895">895</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN896">896</td><td class="line"><span class='comment'>/*   This computes C = A ? B                                          */</span></td></tr>
<tr><td class="num" id="LN897">897</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN898">898</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN899">899</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN900">900</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN901">901</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN902">902</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN903">903</td><td class="line"><span class='comment'>/* C must have space for one digit (or NaN).                          */</span></td></tr>
<tr><td class="num" id="LN904">904</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN905">905</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCompareSignal<span class='expansion'>uprv_decNumberCompareSignal_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN906">906</td><td class="line">                                   <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPSIG<span class='expansion'>0x06</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">  } <span class='comment'>/* decNumberCompareSignal  */</span></td></tr>
<tr><td class="num" id="LN912">912</td><td class="line"> </td></tr>
<tr><td class="num" id="LN913">913</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN914">914</td><td class="line"><span class='comment'>/* decNumberCompareTotal -- compare two Numbers, using total ordering */</span></td></tr>
<tr><td class="num" id="LN915">915</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN916">916</td><td class="line"><span class='comment'>/*   This computes C = A ? B, under total ordering                    */</span></td></tr>
<tr><td class="num" id="LN917">917</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN918">918</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN919">919</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN920">920</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN921">921</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN922">922</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN923">923</td><td class="line"><span class='comment'>/* C must have space for one digit; the result will always be one of  */</span></td></tr>
<tr><td class="num" id="LN924">924</td><td class="line"><span class='comment'>/* -1, 0, or 1.                                                       */</span></td></tr>
<tr><td class="num" id="LN925">925</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN926">926</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCompareTotal<span class='expansion'>uprv_decNumberCompareTotal_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">                                  <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN929">929</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN930">930</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN931">931</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">  } <span class='comment'>/* decNumberCompareTotal  */</span></td></tr>
<tr><td class="num" id="LN933">933</td><td class="line"> </td></tr>
<tr><td class="num" id="LN934">934</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN935">935</td><td class="line"><span class='comment'>/* decNumberCompareTotalMag -- compare, total ordering of magnitudes  */</span></td></tr>
<tr><td class="num" id="LN936">936</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN937">937</td><td class="line"><span class='comment'>/*   This computes C = |A| ? |B|, under total ordering                */</span></td></tr>
<tr><td class="num" id="LN938">938</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN939">939</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN940">940</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN941">941</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN942">942</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN943">943</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN944">944</td><td class="line"><span class='comment'>/* C must have space for one digit; the result will always be one of  */</span></td></tr>
<tr><td class="num" id="LN945">945</td><td class="line"><span class='comment'>/* -1, 0, or 1.                                                       */</span></td></tr>
<tr><td class="num" id="LN946">946</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN947">947</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCompareTotalMag<span class='expansion'>uprv_decNumberCompareTotalMag_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN948">948</td><td class="line">                                     <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> needbytes;                  <span class='comment'>/* for space calculations  */</span></td></tr>
<tr><td class="num" id="LN951">951</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER+1)<span class='expansion'>(((((((36 +1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];<span class='comment'>/* +1 in case DECBUFFER=0  */</span></td></tr>
<tr><td class="num" id="LN952">952</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN953">953</td><td class="line">  decNumber bufb[<span class='macro'>D2N(DECBUFFER+1)<span class='expansion'>(((((((36 +1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">  decNumber *allocbufb=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufb, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN955">955</td><td class="line">  decNumber *a, *b;                <span class='comment'>/* temporary pointers  */</span></td></tr>
<tr><td class="num" id="LN956">956</td><td class="line"> </td></tr>
<tr><td class="num" id="LN957">957</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN958">958</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN959">959</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN960">960</td><td class="line"> </td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">  <span class='keyword'>do</span> {                                  <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN962">962</td><td class="line">    <span class='comment'>/* if either is negative, take a copy and absolute  */</span></td></tr>
<tr><td class="num" id="LN963">963</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) {     <span class='comment'>/* lhs&lt;0  */</span></td></tr>
<tr><td class="num" id="LN964">964</td><td class="line">      a=bufa;</td></tr>
<tr><td class="num" id="LN965">965</td><td class="line">      needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufa)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">        allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">        <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">          status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN971">971</td><td class="line">        a=allocbufa;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN973">973</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(a, lhs);            <span class='comment'>/* copy content  */</span></td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">      a-&gt;bits&amp;=~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                 <span class='comment'>/* .. and clear the sign  */</span></td></tr>
<tr><td class="num" id="LN975">975</td><td class="line">      lhs=a;                            <span class='comment'>/* use copy from here on  */</span></td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN977">977</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {     <span class='comment'>/* rhs&lt;0  */</span></td></tr>
<tr><td class="num" id="LN978">978</td><td class="line">      b=bufb;</td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">      needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN980">980</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufb)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">        allocbufb=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">        <span class='keyword'>if</span> (allocbufb==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN983">983</td><td class="line">          status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">        b=allocbufb;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN986">986</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(b, rhs);            <span class='comment'>/* copy content  */</span></td></tr>
<tr><td class="num" id="LN988">988</td><td class="line">      b-&gt;bits&amp;=~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                 <span class='comment'>/* .. and clear the sign  */</span></td></tr>
<tr><td class="num" id="LN989">989</td><td class="line">      rhs=b;                            <span class='comment'>/* use copy from here on  */</span></td></tr>
<tr><td class="num" id="LN990">990</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN991">991</td><td class="line">    decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN992">992</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN993">993</td><td class="line"> </td></tr>
<tr><td class="num" id="LN994">994</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>; <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN995">995</td><td class="line">  <span class='keyword'>if</span> (allocbufb!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufb)<span class='expansion'>uprv_free_54(allocbufb)</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN996">996</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN997">997</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">  } <span class='comment'>/* decNumberCompareTotalMag  */</span></td></tr>
<tr><td class="num" id="LN999">999</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line"><span class='comment'>/* decNumberDivide -- divide one number by another                    */</span></td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line"><span class='comment'>/*   This computes C = A / B                                          */</span></td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X/X)         */</span></td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberDivide<span class='expansion'>uprv_decNumberDivide_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">                            <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">  decDivideOp(res, lhs, rhs, set, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">  } <span class='comment'>/* decNumberDivide  */</span></td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line"><span class='comment'>/* decNumberDivideInteger -- divide and return integer quotient       */</span></td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line"><span class='comment'>/*   This computes C = A # B, where # is the integer divide operator  */</span></td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X#X)         */</span></td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberDivideInteger<span class='expansion'>uprv_decNumberDivideInteger_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line">                                   <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">  decDivideOp(res, lhs, rhs, set, <span class='macro'>DIVIDEINT<span class='expansion'>0x20</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line">  } <span class='comment'>/* decNumberDivideInteger  */</span></td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line"><span class='comment'>/* decNumberExp -- exponentiation                                     */</span></td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line"><span class='comment'>/*   This computes C = exp(A)                                         */</span></td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line"><span class='comment'>/* Mathematical function restrictions apply (see above); a NaN is     */</span></td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line"><span class='comment'>/* Finite results will always be full precision and Inexact, except   */</span></td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line"><span class='comment'>/* when A is a zero or -Infinity (giving 1 or 0 respectively).        */</span></td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line"><span class='comment'>/* An Inexact result is rounded using DEC_ROUND_HALF_EVEN; it will    */</span></td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line"><span class='comment'>/* This is a wrapper for decExpOp which can handle the slightly wider */</span></td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line"><span class='comment'>/* (double) range needed by Ln (which has to be able to calculate     */</span></td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line"><span class='comment'>/* exp(-a) where a can be the tiniest number (Ntiny).                 */</span></td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberExp<span class='expansion'>uprv_decNumberExp_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line">                         decContext *set) {</td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded rhs allocated  */</span></td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line">  <span class='comment'>/* Check restrictions; these restrictions ensure that if h=8 (see  */</span></td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">  <span class='comment'>/* decExpOp) then the result will either overflow or underflow to 0.  */</span></td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line">  <span class='comment'>/* Other math functions restrict the input range, too, for inverses.  */</span></td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">  <span class='comment'>/* If not violated then carry out the operation.  */</span></td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line">  <span class='keyword'>if</span> (!decCheckMath(rhs, set, &amp;status)) <span class='keyword'>do</span> { <span class='comment'>/* protect allocation  */</span></td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line">      <span class='comment'>/* reduce operand and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line">    decExpOp(res, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;  <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">  <span class='comment'>/* apply significant status  */</span></td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line">  } <span class='comment'>/* decNumberExp  */</span></td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line"><span class='comment'>/* decNumberFMA -- fused multiply add                                 */</span></td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line"><span class='comment'>/*   This computes D = (A * B) + C with only one rounding             */</span></td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line"><span class='comment'>/*   res is D, the result.  D may be A or B or C (e.g., X=FMA(X,X,X)) */</span></td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line"><span class='comment'>/*   fhs is C [far hand side]                                         */</span></td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line"><span class='comment'>/* Mathematical function restrictions apply (see above); a NaN is     */</span></td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberFMA<span class='expansion'>uprv_decNumberFMA_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, <span class='keyword'>const</span> decNumber *fhs,</td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line">                         decContext *set) {</td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line">  decContext dcmul;                <span class='comment'>/* context for the multiplication  */</span></td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> needbytes;                  <span class='comment'>/* for space calculations  */</span></td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER*2+1)<span class='expansion'>(((((((36*2+1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)<br>*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line">  decNumber *acc;                  <span class='comment'>/* accumulator pointer  */</span></td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">  decNumber dzero;                 <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, fhs, DECUNUSED, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line">  <span class='keyword'>do</span> {                                  <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {               <span class='comment'>/* [undefined if subset]  */</span></td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line">      status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">    <span class='comment'>/* Check math restrictions [these ensure no overflow or underflow]  */</span></td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">    <span class='keyword'>if</span> ((!<span class='macro'>decNumberIsSpecial(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> &amp;&amp; decCheckMath(lhs, set, &amp;status))</td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">     || (!<span class='macro'>decNumberIsSpecial(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> &amp;&amp; decCheckMath(rhs, set, &amp;status))</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line">     || (!<span class='macro'>decNumberIsSpecial(fhs)<span class='expansion'>(((fhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> &amp;&amp; decCheckMath(fhs, set, &amp;status))) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line">    <span class='comment'>/* set up context for multiply  */</span></td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line">    dcmul=*set;</td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line">    dcmul.digits=lhs-&gt;digits+rhs-&gt;digits; <span class='comment'>/* just enough  */</span></td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">    <span class='comment'>/* [The above may be an over-estimate for subset arithmetic, but that's OK]  */</span></td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line">    dcmul.emax=<span class='macro'>DEC_MAX_EMAX<span class='expansion'>999999999</span></span>;            <span class='comment'>/* effectively unbounded ..  */</span></td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">    dcmul.emin=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>;            <span class='comment'>/* [thanks to Math restrictions]  */</span></td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line">    <span class='comment'>/* set up decNumber space to receive the result of the multiply  */</span></td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">    acc=bufa;                           <span class='comment'>/* may fit  */</span></td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(dcmul.digits)<span class='expansion'>((dcmul.digits)&lt;=49?d2utable[dcmul.digits]:((dcmul.digits)<br>+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufa)) {       <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line">      allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line">      <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {            <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line">      acc=allocbufa;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line">    <span class='comment'>/* multiply with extended range and necessary precision  */</span></td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line">    <span class='comment'>/*printf("emin=%ld\n", dcmul.emin);  */</span></td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line">    decMultiplyOp(acc, lhs, rhs, &amp;dcmul, &amp;status);</td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line">    <span class='comment'>/* Only Invalid operation (from sNaN or Inf * 0) is possible in  */</span></td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line">    <span class='comment'>/* status; if either is seen than ignore fhs (in case it is  */</span></td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line">    <span class='comment'>/* another sNaN) and set acc to NaN unless we had an sNaN  */</span></td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">    <span class='comment'>/* [decMultiplyOp leaves that to caller]  */</span></td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">    <span class='comment'>/* Note sNaN has to go through addOp to shorten payload if  */</span></td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">    <span class='comment'>/* necessary  */</span></td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">    <span class='keyword'>if</span> ((status&amp;<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>)!=0) {</td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line">      <span class='keyword'>if</span> (!(status&amp;<span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>)) {         <span class='comment'>/* but be true invalid  */</span></td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);             <span class='comment'>/* acc not yet set  */</span></td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line">        res-&gt;bits=<span class='macro'>DECNAN<span class='expansion'>0x20</span></span>;</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dzero);            <span class='comment'>/* make 0 (any non-NaN would do)  */</span></td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line">      fhs=&amp;dzero;                       <span class='comment'>/* use that  */</span></td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line">    <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* multiply was OK  */</span></td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line">      <span class='keyword'>if</span> (status!=0) printf(<span class='string_literal'>"Status=%08lx after FMA multiply\n"</span>, (LI)status);</td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line">    <span class='comment'>/* add the third operand and result -&gt; res, and all is done  */</span></td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line">    decAddOp(res, acc, fhs, set, 0, &amp;status);</td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>; <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line">  } <span class='comment'>/* decNumberFMA  */</span></td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line"><span class='comment'>/* decNumberInvert -- invert a Number, digitwise                      */</span></td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line"><span class='comment'>/*   This computes C = ~A                                             */</span></td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A (e.g., X=~X)                   */</span></td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line"><span class='comment'>/*   set is the context (used for result length and error report)     */</span></td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line"><span class='comment'>/* Logical function restrictions apply (see above); a NaN is          */</span></td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberInvert<span class='expansion'>uprv_decNumberInvert_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">                            decContext *set) {</td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ua, *msua;                <span class='comment'>/* -&gt; operand and its msu  */</span></td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *uc, *msuc;                     <span class='comment'>/* -&gt; result and its msu  */</span></td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   msudigs;                        <span class='comment'>/* digits in res msu  */</span></td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line">  <span class='keyword'>if</span> (rhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line">    decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line">  <span class='comment'>/* operand is valid  */</span></td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line">  ua=rhs-&gt;lsu;                          <span class='comment'>/* bottom-up  */</span></td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line">  uc=res-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">  msua=ua+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of rhs  */</span></td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line">  msuc=uc+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of result  */</span></td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line">  msudigs=<span class='macro'>MSUDIGITS(set-&gt;digits)<span class='expansion'>((set-&gt;digits)-(((set-&gt;digits)&lt;=49?d2utable[set-&gt;<br>digits]:((set-&gt;digits)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line">  <span class='keyword'>for</span> (; uc&lt;=msuc; ua++, uc++) {        <span class='comment'>/* Unit loop  */</span></td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> a;                             <span class='comment'>/* extract unit  */</span></td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>  i, j;                          <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">    <span class='keyword'>if</span> (ua&gt;msua) a=0;</td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line">     <span class='keyword'>else</span> a=*ua;</td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line">    *uc=0;                              <span class='comment'>/* can now write back  */</span></td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line">    <span class='comment'>/* always need to examine all bits in rhs  */</span></td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line">    <span class='comment'>/* This loop could be unrolled and/or use BIN2BCD tables  */</span></td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line">    <span class='keyword'>for</span> (i=0; i&lt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; i++) {</td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line">      <span class='keyword'>if</span> ((~a)&amp;1) *uc=*uc+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[i];   <span class='comment'>/* effect INVERT  */</span></td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line">      j=a%10;</td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">      a=a/10;</td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line">      <span class='keyword'>if</span> (j&gt;1) {</td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line">        decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">        <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line">      <span class='keyword'>if</span> (uc==msuc &amp;&amp; i==msudigs-1) <span class='keyword'>break</span>;   <span class='comment'>/* just did final digit  */</span></td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line">      } <span class='comment'>/* each digit  */</span></td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">    } <span class='comment'>/* each unit  */</span></td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line">  <span class='comment'>/* [here uc-1 is the msu of the result]  */</span></td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line">  res-&gt;digits=decGetDigits(res-&gt;lsu, uc-res-&gt;lsu);</td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line">  res-&gt;exponent=0;                      <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line">  res-&gt;bits=0;                          <span class='comment'>/* sign=0  */</span></td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line">  <span class='keyword'>return</span> res;  <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line">  } <span class='comment'>/* decNumberInvert  */</span></td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line"><span class='comment'>/* decNumberLn -- natural logarithm                                   */</span></td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line"><span class='comment'>/*   This computes C = ln(A)                                          */</span></td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line"><span class='comment'>/* Notable cases:                                                     */</span></td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line"><span class='comment'>/*   A&lt;0 -&gt; Invalid                                                   */</span></td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line"><span class='comment'>/*   A=0 -&gt; -Infinity (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line"><span class='comment'>/*   A=+Infinity -&gt; +Infinity (Exact)                                 */</span></td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line"><span class='comment'>/*   A=1 exactly -&gt; 0 (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line"><span class='comment'>/* Mathematical function restrictions apply (see above); a NaN is     */</span></td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line"><span class='comment'>/* An Inexact result is rounded using DEC_ROUND_HALF_EVEN; it will    */</span></td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line"><span class='comment'>/* This is a wrapper for decLnOp which can handle the slightly wider  */</span></td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line"><span class='comment'>/* (+11) range needed by Ln, Log10, etc. (which may have to be able   */</span></td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line"><span class='comment'>/* to calculate at p+e+2).                                            */</span></td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberLn<span class='expansion'>uprv_decNumberLn_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line">                        decContext *set) {</td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded rhs allocated  */</span></td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">  <span class='comment'>/* Check restrictions; this is a math function; if not violated  */</span></td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line">  <span class='comment'>/* then carry out the operation.  */</span></td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line">  <span class='keyword'>if</span> (!decCheckMath(rhs, set, &amp;status)) <span class='keyword'>do</span> { <span class='comment'>/* protect allocation  */</span></td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line">      <span class='comment'>/* reduce operand and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line">      <span class='comment'>/* special check in subset for rhs=0  */</span></td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                <span class='comment'>/* +/- zeros -&gt; error  */</span></td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line">        status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line">      } <span class='comment'>/* extended=0  */</span></td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line">    decLnOp(res, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;  <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line">  <span class='comment'>/* apply significant status  */</span></td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line">  } <span class='comment'>/* decNumberLn  */</span></td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line"><span class='comment'>/* decNumberLogB - get adjusted exponent, by 754 rules                */</span></td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line"><span class='comment'>/*   This computes C = adjustedexponent(A)                            */</span></td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line"><span class='comment'>/*   set is the context, used only for digits and status              */</span></td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line"><span class='comment'>/* C must have space for 10 digits (A might have 10**9 digits and     */</span></td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line"><span class='comment'>/* an exponent of +999999999, or one digit and an exponent of         */</span></td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line"><span class='comment'>/* -1999999999).                                                      */</span></td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line"><span class='comment'>/* This returns the adjusted exponent of A after (in theory) padding  */</span></td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line"><span class='comment'>/* with zeros on the right to set-&gt;digits digits while keeping the    */</span></td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line"><span class='comment'>/* same value.  The exponent is not limited by emin/emax.             */</span></td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line"><span class='comment'>/* Notable cases:                                                     */</span></td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line"><span class='comment'>/*   A&lt;0 -&gt; Use |A|                                                   */</span></td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line"><span class='comment'>/*   A=0 -&gt; -Infinity (Division by zero)                              */</span></td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line"><span class='comment'>/*   A=Infinite -&gt; +Infinity (Exact)                                  */</span></td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line"><span class='comment'>/*   A=1 exactly -&gt; 0 (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line"><span class='comment'>/*   NaNs are propagated as usual                                     */</span></td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberLogB<span class='expansion'>uprv_decNumberLogB_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line">                          decContext *set) {</td></tr>
<tr><td class="num" id="LN1356">1356</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1357">1357</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1358">1358</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1359">1359</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1360">1360</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1361">1361</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1362">1362</td><td class="line">  <span class='comment'>/* NaNs as usual; Infinities return +Infinity; 0-&gt;oops  */</span></td></tr>
<tr><td class="num" id="LN1363">1363</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1364">1364</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) <span class='macro'>uprv_decNumberCopyAbs<span class='expansion'>uprv_decNumberCopyAbs_54</span></span>(res, rhs);</td></tr>
<tr><td class="num" id="LN1365">1365</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN1366">1366</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);                 <span class='comment'>/* prepare for Infinity  */</span></td></tr>
<tr><td class="num" id="LN1367">1367</td><td class="line">    res-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>|<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;            <span class='comment'>/* -Infinity  */</span></td></tr>
<tr><td class="num" id="LN1368">1368</td><td class="line">    status|=<span class='macro'>DEC_Division_by_zero<span class='expansion'>0x00000002</span></span>;       <span class='comment'>/* as per 754  */</span></td></tr>
<tr><td class="num" id="LN1369">1369</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1370">1370</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* finite non-zero  */</span></td></tr>
<tr><td class="num" id="LN1371">1371</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> ae=rhs-&gt;exponent+rhs-&gt;digits-1; <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN1372">1372</td><td class="line">    <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(res, ae);        <span class='comment'>/* lay it out  */</span></td></tr>
<tr><td class="num" id="LN1373">1373</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1374">1374</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1375">1375</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1376">1376</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1377">1377</td><td class="line">  } <span class='comment'>/* decNumberLogB  */</span></td></tr>
<tr><td class="num" id="LN1378">1378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1379">1379</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1380">1380</td><td class="line"><span class='comment'>/* decNumberLog10 -- logarithm in base 10                             */</span></td></tr>
<tr><td class="num" id="LN1381">1381</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1382">1382</td><td class="line"><span class='comment'>/*   This computes C = log10(A)                                       */</span></td></tr>
<tr><td class="num" id="LN1383">1383</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1384">1384</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1385">1385</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1386">1386</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN1387">1387</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1388">1388</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1389">1389</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1390">1390</td><td class="line"><span class='comment'>/* Notable cases:                                                     */</span></td></tr>
<tr><td class="num" id="LN1391">1391</td><td class="line"><span class='comment'>/*   A&lt;0 -&gt; Invalid                                                   */</span></td></tr>
<tr><td class="num" id="LN1392">1392</td><td class="line"><span class='comment'>/*   A=0 -&gt; -Infinity (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN1393">1393</td><td class="line"><span class='comment'>/*   A=+Infinity -&gt; +Infinity (Exact)                                 */</span></td></tr>
<tr><td class="num" id="LN1394">1394</td><td class="line"><span class='comment'>/*   A=10**n (if n is an integer) -&gt; n (Exact)                        */</span></td></tr>
<tr><td class="num" id="LN1395">1395</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1396">1396</td><td class="line"><span class='comment'>/* Mathematical function restrictions apply (see above); a NaN is     */</span></td></tr>
<tr><td class="num" id="LN1397">1397</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1398">1398</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1399">1399</td><td class="line"><span class='comment'>/* An Inexact result is rounded using DEC_ROUND_HALF_EVEN; it will    */</span></td></tr>
<tr><td class="num" id="LN1400">1400</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN1401">1401</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN1402">1402</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1403">1403</td><td class="line"><span class='comment'>/* This calculates ln(A)/ln(10) using appropriate precision.  For     */</span></td></tr>
<tr><td class="num" id="LN1404">1404</td><td class="line"><span class='comment'>/* ln(A) this is the max(p, rhs-&gt;digits + t) + 3, where p is the      */</span></td></tr>
<tr><td class="num" id="LN1405">1405</td><td class="line"><span class='comment'>/* requested digits and t is the number of digits in the exponent     */</span></td></tr>
<tr><td class="num" id="LN1406">1406</td><td class="line"><span class='comment'>/* (maximum 6).  For ln(10) it is p + 3; this is often handled by the */</span></td></tr>
<tr><td class="num" id="LN1407">1407</td><td class="line"><span class='comment'>/* fastpath in decLnOp.  The final division is done to the requested  */</span></td></tr>
<tr><td class="num" id="LN1408">1408</td><td class="line"><span class='comment'>/* precision.                                                         */</span></td></tr>
<tr><td class="num" id="LN1409">1409</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1410">1410</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN1411">1411</td><td class="line"><span class='directive'>#pragma GCC diagnostic push</span></td></tr>
<tr><td class="num" id="LN1412">1412</td><td class="line"><span class='directive'>#pragma GCC diagnostic ignored "-Warray-bounds"</span></td></tr>
<tr><td class="num" id="LN1413">1413</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1414">1414</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberLog10<span class='expansion'>uprv_decNumberLog10_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1415">1415</td><td class="line">                          decContext *set) {</td></tr>
<tr><td class="num" id="LN1416">1416</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0, ignore=0;         <span class='comment'>/* status accumulators  */</span></td></tr>
<tr><td class="num" id="LN1417">1417</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> needbytes;                  <span class='comment'>/* for space calculations  */</span></td></tr>
<tr><td class="num" id="LN1418">1418</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> p;                           <span class='comment'>/* working precision  */</span></td></tr>
<tr><td class="num" id="LN1419">1419</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> t;                           <span class='comment'>/* digits in exponent of A  */</span></td></tr>
<tr><td class="num" id="LN1420">1420</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1421">1421</td><td class="line">  <span class='comment'>/* buffers for a and b working decimals  */</span></td></tr>
<tr><td class="num" id="LN1422">1422</td><td class="line">  <span class='comment'>/* (adjustment calculator, same size)  */</span></td></tr>
<tr><td class="num" id="LN1423">1423</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER+2)<span class='expansion'>(((((((36 +2)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN1424">1424</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN1425">1425</td><td class="line">  decNumber *a=bufa;               <span class='comment'>/* temporary a  */</span></td></tr>
<tr><td class="num" id="LN1426">1426</td><td class="line">  decNumber bufb[<span class='macro'>D2N(DECBUFFER+2)<span class='expansion'>(((((((36 +2)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN1427">1427</td><td class="line">  decNumber *allocbufb=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufb, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN1428">1428</td><td class="line">  decNumber *b=bufb;               <span class='comment'>/* temporary b  */</span></td></tr>
<tr><td class="num" id="LN1429">1429</td><td class="line">  decNumber bufw[<span class='macro'>D2N(10)<span class='expansion'>(((((((10)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*2-1<br>)/sizeof(decNumber))</span></span>];         <span class='comment'>/* working 2-10 digit number  */</span></td></tr>
<tr><td class="num" id="LN1430">1430</td><td class="line">  decNumber *w=bufw;               <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1431">1431</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1432">1432</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded rhs allocated  */</span></td></tr>
<tr><td class="num" id="LN1433">1433</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1434">1434</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1435">1435</td><td class="line">  decContext aset;                 <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN1436">1436</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1437">1437</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1438">1438</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1439">1439</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1440">1440</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1441">1441</td><td class="line">  <span class='comment'>/* Check restrictions; this is a math function; if not violated  */</span></td></tr>
<tr><td class="num" id="LN1442">1442</td><td class="line">  <span class='comment'>/* then carry out the operation.  */</span></td></tr>
<tr><td class="num" id="LN1443">1443</td><td class="line">  <span class='keyword'>if</span> (!decCheckMath(rhs, set, &amp;status)) <span class='keyword'>do</span> { <span class='comment'>/* protect malloc  */</span></td></tr>
<tr><td class="num" id="LN1444">1444</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1445">1445</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN1446">1446</td><td class="line">      <span class='comment'>/* reduce operand and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN1447">1447</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN1448">1448</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1449">1449</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1450">1450</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN1451">1451</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1452">1452</td><td class="line">      <span class='comment'>/* special check in subset for rhs=0  */</span></td></tr>
<tr><td class="num" id="LN1453">1453</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                <span class='comment'>/* +/- zeros -&gt; error  */</span></td></tr>
<tr><td class="num" id="LN1454">1454</td><td class="line">        status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN1455">1455</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1456">1456</td><td class="line">      } <span class='comment'>/* extended=0  */</span></td></tr>
<tr><td class="num" id="LN1457">1457</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1458">1458</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1459">1459</td><td class="line">    <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;aset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>); <span class='comment'>/* clean context  */</span></td></tr>
<tr><td class="num" id="LN1460">1460</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1461">1461</td><td class="line">    <span class='comment'>/* handle exact powers of 10; only check if +ve finite  */</span></td></tr>
<tr><td class="num" id="LN1462">1462</td><td class="line">    <span class='keyword'>if</span> (!(rhs-&gt;bits&amp;(<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>|<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>)) &amp;&amp; !<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN1463">1463</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> residue=0;               <span class='comment'>/* (no residue)  */</span></td></tr>
<tr><td class="num" id="LN1464">1464</td><td class="line">      <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> copystat=0;             <span class='comment'>/* clean status  */</span></td></tr>
<tr><td class="num" id="LN1465">1465</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1466">1466</td><td class="line">      <span class='comment'>/* round to a single digit...  */</span></td></tr>
<tr><td class="num" id="LN1467">1467</td><td class="line">      aset.digits=1;</td></tr>
<tr><td class="num" id="LN1468">1468</td><td class="line">      decCopyFit(w, rhs, &amp;aset, &amp;residue, &amp;copystat); <span class='comment'>/* copy &amp; shorten  */</span></td></tr>
<tr><td class="num" id="LN1469">1469</td><td class="line">      <span class='comment'>/* if exact and the digit is 1, rhs is a power of 10  */</span></td></tr>
<tr><td class="num" id="LN1470">1470</td><td class="line">      <span class='keyword'>if</span> (!(copystat&amp;<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>) &amp;&amp; w-&gt;lsu[0]==1) {</td></tr>
<tr><td class="num" id="LN1471">1471</td><td class="line">        <span class='comment'>/* the exponent, conveniently, is the power of 10; making  */</span></td></tr>
<tr><td class="num" id="LN1472">1472</td><td class="line">        <span class='comment'>/* this the result needs a little care as it might not fit,  */</span></td></tr>
<tr><td class="num" id="LN1473">1473</td><td class="line">        <span class='comment'>/* so first convert it into the working number, and then move  */</span></td></tr>
<tr><td class="num" id="LN1474">1474</td><td class="line">        <span class='comment'>/* to res  */</span></td></tr>
<tr><td class="num" id="LN1475">1475</td><td class="line">        <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(w, w-&gt;exponent);</td></tr>
<tr><td class="num" id="LN1476">1476</td><td class="line">        residue=0;</td></tr>
<tr><td class="num" id="LN1477">1477</td><td class="line">        decCopyFit(res, w, set, &amp;residue, &amp;status); <span class='comment'>/* copy &amp; round  */</span></td></tr>
<tr><td class="num" id="LN1478">1478</td><td class="line">        <span class='macro'>decFinish(res, set, &amp;residue, &amp;status)<span class='expansion'>decFinalize(res,set,&amp;residue,&amp;status)</span></span>;     <span class='comment'>/* cleanup/set flags  */</span></td></tr>
<tr><td class="num" id="LN1479">1479</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1480">1480</td><td class="line">        } <span class='comment'>/* not a power of 10  */</span></td></tr>
<tr><td class="num" id="LN1481">1481</td><td class="line">      } <span class='comment'>/* not a candidate for exact  */</span></td></tr>
<tr><td class="num" id="LN1482">1482</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1483">1483</td><td class="line">    <span class='comment'>/* simplify the information-content calculation to use 'total  */</span></td></tr>
<tr><td class="num" id="LN1484">1484</td><td class="line">    <span class='comment'>/* number of digits in a, including exponent' as compared to the  */</span></td></tr>
<tr><td class="num" id="LN1485">1485</td><td class="line">    <span class='comment'>/* requested digits, as increasing this will only rarely cost an  */</span></td></tr>
<tr><td class="num" id="LN1486">1486</td><td class="line">    <span class='comment'>/* iteration in ln(a) anyway  */</span></td></tr>
<tr><td class="num" id="LN1487">1487</td><td class="line">    t=6;                                <span class='comment'>/* it can never be &gt;6  */</span></td></tr>
<tr><td class="num" id="LN1488">1488</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1489">1489</td><td class="line">    <span class='comment'>/* allocate space when needed...  */</span></td></tr>
<tr><td class="num" id="LN1490">1490</td><td class="line">    p=(rhs-&gt;digits+t&gt;set-&gt;digits?rhs-&gt;digits+t:set-&gt;digits)+3;</td></tr>
<tr><td class="num" id="LN1491">1491</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(p)<span class='expansion'>((p)&lt;=49?d2utable[p]:((p)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN1492">1492</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufa)) {       <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN1493">1493</td><td class="line">      allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN1494">1494</td><td class="line">      <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {            <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN1495">1495</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN1496">1496</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1497">1497</td><td class="line">      a=allocbufa;                      <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN1498">1498</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1499">1499</td><td class="line">    aset.digits=p;                      <span class='comment'>/* as calculated  */</span></td></tr>
<tr><td class="num" id="LN1500">1500</td><td class="line">    aset.emax=<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>;             <span class='comment'>/* usual bounds  */</span></td></tr>
<tr><td class="num" id="LN1501">1501</td><td class="line">    aset.emin=-<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>;            <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1502">1502</td><td class="line">    aset.clamp=0;                       <span class='comment'>/* and no concrete format  */</span></td></tr>
<tr><td class="num" id="LN1503">1503</td><td class="line">    decLnOp(a, rhs, &amp;aset, &amp;status);    <span class='comment'>/* a=ln(rhs)  */</span></td></tr>
<tr><td class="num" id="LN1504">1504</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1505">1505</td><td class="line">    <span class='comment'>/* skip the division if the result so far is infinite, NaN, or  */</span></td></tr>
<tr><td class="num" id="LN1506">1506</td><td class="line">    <span class='comment'>/* zero, or there was an error; note NaN from sNaN needs copy  */</span></td></tr>
<tr><td class="num" id="LN1507">1507</td><td class="line">    <span class='keyword'>if</span> (status&amp;<span class='macro'>DEC_NaNs<span class='expansion'>(0x00000001 | 0x00000004 | 0x00000008 | 0x00000010 | 0x00000040<br> | 0x00000080)</span></span> &amp;&amp; !(status&amp;<span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>)) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1508">1508</td><td class="line">    <span class='keyword'>if</span> (a-&gt;bits&amp;<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span> || <span class='macro'>ISZERO(a)<span class='expansion'>(*(a)-&gt;lsu==0 &amp;&amp; (a)-&gt;digits==1 &amp;&amp; (((a<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN1509">1509</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, a);            <span class='comment'>/* [will fit]  */</span></td></tr>
<tr><td class="num" id="LN1510">1510</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1511">1511</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1512">1512</td><td class="line">    <span class='comment'>/* for ln(10) an extra 3 digits of precision are needed  */</span></td></tr>
<tr><td class="num" id="LN1513">1513</td><td class="line">    p=set-&gt;digits+3;</td></tr>
<tr><td class="num" id="LN1514">1514</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(p)<span class='expansion'>((p)&lt;=49?d2utable[p]:((p)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN1515">1515</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufb)) {       <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN1516">1516</td><td class="line">      allocbufb=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN1517">1517</td><td class="line">      <span class='keyword'>if</span> (allocbufb==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {            <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN1518">1518</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN1519">1519</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN1520">1520</td><td class="line">      b=allocbufb;                      <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN1521">1521</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1522">1522</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(w);                   <span class='comment'>/* set up 10...  */</span></td></tr>
<tr><td class="num" id="LN1523">1523</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1</span></td></tr>
<tr><td class="num" id="LN1524">1524</td><td class="line">    w-&gt;lsu[1]=1; w-&gt;lsu[0]=0;           <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1525">1525</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN1526">1526</td><td class="line">    w-&gt;lsu[0]=10;                       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1527">1527</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1528">1528</td><td class="line">    w-&gt;digits=2;                        <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1529">1529</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1530">1530</td><td class="line">    aset.digits=p;</td></tr>
<tr><td class="num" id="LN1531">1531</td><td class="line">    decLnOp(b, w, &amp;aset, &amp;ignore);      <span class='comment'>/* b=ln(10)  */</span></td></tr>
<tr><td class="num" id="LN1532">1532</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1533">1533</td><td class="line">    aset.digits=set-&gt;digits;            <span class='comment'>/* for final divide  */</span></td></tr>
<tr><td class="num" id="LN1534">1534</td><td class="line">    decDivideOp(res, a, b, &amp;aset, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;status); <span class='comment'>/* into result  */</span></td></tr>
<tr><td class="num" id="LN1535">1535</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* [for break]  */</span></td></tr>
<tr><td class="num" id="LN1536">1536</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1537">1537</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>; <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN1538">1538</td><td class="line">  <span class='keyword'>if</span> (allocbufb!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufb)<span class='expansion'>uprv_free_54(allocbufb)</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1539">1539</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1540">1540</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;  <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1541">1541</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1542">1542</td><td class="line">  <span class='comment'>/* apply significant status  */</span></td></tr>
<tr><td class="num" id="LN1543">1543</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1544">1544</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1545">1545</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1546">1546</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1547">1547</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1548">1548</td><td class="line">  } <span class='comment'>/* decNumberLog10  */</span></td></tr>
<tr><td class="num" id="LN1549">1549</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN1550">1550</td><td class="line"><span class='directive'>#pragma GCC diagnostic pop</span></td></tr>
<tr><td class="num" id="LN1551">1551</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1552">1552</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1553">1553</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1554">1554</td><td class="line"><span class='comment'>/* decNumberMax -- compare two Numbers and return the maximum         */</span></td></tr>
<tr><td class="num" id="LN1555">1555</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1556">1556</td><td class="line"><span class='comment'>/*   This computes C = A ? B, returning the maximum by 754 rules      */</span></td></tr>
<tr><td class="num" id="LN1557">1557</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1558">1558</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN1559">1559</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1560">1560</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1561">1561</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1562">1562</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1563">1563</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1564">1564</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1565">1565</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMax<span class='expansion'>uprv_decNumberMax_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1566">1566</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1567">1567</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1568">1568</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPMAX<span class='expansion'>0x02</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1569">1569</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1570">1570</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1571">1571</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1572">1572</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1573">1573</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1574">1574</td><td class="line">  } <span class='comment'>/* decNumberMax  */</span></td></tr>
<tr><td class="num" id="LN1575">1575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1576">1576</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1577">1577</td><td class="line"><span class='comment'>/* decNumberMaxMag -- compare and return the maximum by magnitude     */</span></td></tr>
<tr><td class="num" id="LN1578">1578</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1579">1579</td><td class="line"><span class='comment'>/*   This computes C = A ? B, returning the maximum by 754 rules      */</span></td></tr>
<tr><td class="num" id="LN1580">1580</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1581">1581</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN1582">1582</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1583">1583</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1584">1584</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1585">1585</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1586">1586</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1587">1587</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1588">1588</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMaxMag<span class='expansion'>uprv_decNumberMaxMag_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1589">1589</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1590">1590</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1591">1591</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPMAXMAG<span class='expansion'>0x07</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1592">1592</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1593">1593</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1594">1594</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1595">1595</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1596">1596</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1597">1597</td><td class="line">  } <span class='comment'>/* decNumberMaxMag  */</span></td></tr>
<tr><td class="num" id="LN1598">1598</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1599">1599</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1600">1600</td><td class="line"><span class='comment'>/* decNumberMin -- compare two Numbers and return the minimum         */</span></td></tr>
<tr><td class="num" id="LN1601">1601</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1602">1602</td><td class="line"><span class='comment'>/*   This computes C = A ? B, returning the minimum by 754 rules      */</span></td></tr>
<tr><td class="num" id="LN1603">1603</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1604">1604</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN1605">1605</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1606">1606</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1607">1607</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1608">1608</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1609">1609</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1610">1610</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1611">1611</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMin<span class='expansion'>uprv_decNumberMin_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1612">1612</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1613">1613</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1614">1614</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPMIN<span class='expansion'>0x03</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1615">1615</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1616">1616</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1617">1617</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1618">1618</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1619">1619</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1620">1620</td><td class="line">  } <span class='comment'>/* decNumberMin  */</span></td></tr>
<tr><td class="num" id="LN1621">1621</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1622">1622</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1623">1623</td><td class="line"><span class='comment'>/* decNumberMinMag -- compare and return the minimum by magnitude     */</span></td></tr>
<tr><td class="num" id="LN1624">1624</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1625">1625</td><td class="line"><span class='comment'>/*   This computes C = A ? B, returning the minimum by 754 rules      */</span></td></tr>
<tr><td class="num" id="LN1626">1626</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1627">1627</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN1628">1628</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1629">1629</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1630">1630</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1631">1631</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1632">1632</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1633">1633</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1634">1634</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMinMag<span class='expansion'>uprv_decNumberMinMag_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1635">1635</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1636">1636</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1637">1637</td><td class="line">  decCompareOp(res, lhs, rhs, set, <span class='macro'>COMPMINMAG<span class='expansion'>0x08</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1638">1638</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1639">1639</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1640">1640</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1641">1641</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1642">1642</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1643">1643</td><td class="line">  } <span class='comment'>/* decNumberMinMag  */</span></td></tr>
<tr><td class="num" id="LN1644">1644</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1645">1645</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1646">1646</td><td class="line"><span class='comment'>/* decNumberMinus -- prefix minus operator                            */</span></td></tr>
<tr><td class="num" id="LN1647">1647</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1648">1648</td><td class="line"><span class='comment'>/*   This computes C = 0 - A                                          */</span></td></tr>
<tr><td class="num" id="LN1649">1649</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1650">1650</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1651">1651</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1652">1652</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1653">1653</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1654">1654</td><td class="line"><span class='comment'>/* See also decNumberCopyNegate for a quiet bitwise version of this.  */</span></td></tr>
<tr><td class="num" id="LN1655">1655</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1656">1656</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1657">1657</td><td class="line"><span class='comment'>/* Simply use AddOp for the subtract, which will do the necessary.    */</span></td></tr>
<tr><td class="num" id="LN1658">1658</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1659">1659</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMinus<span class='expansion'>uprv_decNumberMinus_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1660">1660</td><td class="line">                           decContext *set) {</td></tr>
<tr><td class="num" id="LN1661">1661</td><td class="line">  decNumber dzero;</td></tr>
<tr><td class="num" id="LN1662">1662</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1663">1663</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1664">1664</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1665">1665</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1666">1666</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1667">1667</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1668">1668</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dzero);                <span class='comment'>/* make 0  */</span></td></tr>
<tr><td class="num" id="LN1669">1669</td><td class="line">  dzero.exponent=rhs-&gt;exponent;         <span class='comment'>/* [no coefficient expansion]  */</span></td></tr>
<tr><td class="num" id="LN1670">1670</td><td class="line">  decAddOp(res, &amp;dzero, rhs, set, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1671">1671</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1672">1672</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1673">1673</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1674">1674</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1675">1675</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1676">1676</td><td class="line">  } <span class='comment'>/* decNumberMinus  */</span></td></tr>
<tr><td class="num" id="LN1677">1677</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1678">1678</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1679">1679</td><td class="line"><span class='comment'>/* decNumberNextMinus -- next towards -Infinity                       */</span></td></tr>
<tr><td class="num" id="LN1680">1680</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1681">1681</td><td class="line"><span class='comment'>/*   This computes C = A - infinitesimal, rounded towards -Infinity   */</span></td></tr>
<tr><td class="num" id="LN1682">1682</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1683">1683</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1684">1684</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1685">1685</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1686">1686</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1687">1687</td><td class="line"><span class='comment'>/* This is a generalization of 754 NextDown.                          */</span></td></tr>
<tr><td class="num" id="LN1688">1688</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1689">1689</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberNextMinus<span class='expansion'>uprv_decNumberNextMinus_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1690">1690</td><td class="line">                               decContext *set) {</td></tr>
<tr><td class="num" id="LN1691">1691</td><td class="line">  decNumber dtiny;                           <span class='comment'>/* constant  */</span></td></tr>
<tr><td class="num" id="LN1692">1692</td><td class="line">  decContext workset=*set;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1693">1693</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                             <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1694">1694</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1695">1695</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1696">1696</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1697">1697</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1698">1698</td><td class="line">  <span class='comment'>/* +Infinity is the special case  */</span></td></tr>
<tr><td class="num" id="LN1699">1699</td><td class="line">  <span class='keyword'>if</span> ((rhs-&gt;bits&amp;(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>))==<span class='macro'>DECINF<span class='expansion'>0x40</span></span>) {</td></tr>
<tr><td class="num" id="LN1700">1700</td><td class="line">    decSetMaxValue(res, set);                <span class='comment'>/* is +ve  */</span></td></tr>
<tr><td class="num" id="LN1701">1701</td><td class="line">    <span class='comment'>/* there is no status to set  */</span></td></tr>
<tr><td class="num" id="LN1702">1702</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1703">1703</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1704">1704</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dtiny);                     <span class='comment'>/* start with 0  */</span></td></tr>
<tr><td class="num" id="LN1705">1705</td><td class="line">  dtiny.lsu[0]=1;                            <span class='comment'>/* make number that is ..  */</span></td></tr>
<tr><td class="num" id="LN1706">1706</td><td class="line">  dtiny.exponent=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>-1;             <span class='comment'>/* .. smaller than tiniest  */</span></td></tr>
<tr><td class="num" id="LN1707">1707</td><td class="line">  workset.round=DEC_ROUND_FLOOR;</td></tr>
<tr><td class="num" id="LN1708">1708</td><td class="line">  decAddOp(res, rhs, &amp;dtiny, &amp;workset, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN1709">1709</td><td class="line">  status&amp;=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>|<span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;    <span class='comment'>/* only sNaN Invalid please  */</span></td></tr>
<tr><td class="num" id="LN1710">1710</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1711">1711</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1712">1712</td><td class="line">  } <span class='comment'>/* decNumberNextMinus  */</span></td></tr>
<tr><td class="num" id="LN1713">1713</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1714">1714</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1715">1715</td><td class="line"><span class='comment'>/* decNumberNextPlus -- next towards +Infinity                        */</span></td></tr>
<tr><td class="num" id="LN1716">1716</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1717">1717</td><td class="line"><span class='comment'>/*   This computes C = A + infinitesimal, rounded towards +Infinity   */</span></td></tr>
<tr><td class="num" id="LN1718">1718</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1719">1719</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1720">1720</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1721">1721</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1722">1722</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1723">1723</td><td class="line"><span class='comment'>/* This is a generalization of 754 NextUp.                            */</span></td></tr>
<tr><td class="num" id="LN1724">1724</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1725">1725</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberNextPlus<span class='expansion'>uprv_decNumberNextPlus_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1726">1726</td><td class="line">                              decContext *set) {</td></tr>
<tr><td class="num" id="LN1727">1727</td><td class="line">  decNumber dtiny;                           <span class='comment'>/* constant  */</span></td></tr>
<tr><td class="num" id="LN1728">1728</td><td class="line">  decContext workset=*set;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1729">1729</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                             <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1730">1730</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1731">1731</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1732">1732</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1733">1733</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1734">1734</td><td class="line">  <span class='comment'>/* -Infinity is the special case  */</span></td></tr>
<tr><td class="num" id="LN1735">1735</td><td class="line">  <span class='keyword'>if</span> ((rhs-&gt;bits&amp;(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>))==(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>)) {</td></tr>
<tr><td class="num" id="LN1736">1736</td><td class="line">    decSetMaxValue(res, set);</td></tr>
<tr><td class="num" id="LN1737">1737</td><td class="line">    res-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                        <span class='comment'>/* negative  */</span></td></tr>
<tr><td class="num" id="LN1738">1738</td><td class="line">    <span class='comment'>/* there is no status to set  */</span></td></tr>
<tr><td class="num" id="LN1739">1739</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1740">1740</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1741">1741</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dtiny);                     <span class='comment'>/* start with 0  */</span></td></tr>
<tr><td class="num" id="LN1742">1742</td><td class="line">  dtiny.lsu[0]=1;                            <span class='comment'>/* make number that is ..  */</span></td></tr>
<tr><td class="num" id="LN1743">1743</td><td class="line">  dtiny.exponent=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>-1;             <span class='comment'>/* .. smaller than tiniest  */</span></td></tr>
<tr><td class="num" id="LN1744">1744</td><td class="line">  workset.round=DEC_ROUND_CEILING;</td></tr>
<tr><td class="num" id="LN1745">1745</td><td class="line">  decAddOp(res, rhs, &amp;dtiny, &amp;workset, 0, &amp;status);</td></tr>
<tr><td class="num" id="LN1746">1746</td><td class="line">  status&amp;=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>|<span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;    <span class='comment'>/* only sNaN Invalid please  */</span></td></tr>
<tr><td class="num" id="LN1747">1747</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1748">1748</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1749">1749</td><td class="line">  } <span class='comment'>/* decNumberNextPlus  */</span></td></tr>
<tr><td class="num" id="LN1750">1750</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1751">1751</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1752">1752</td><td class="line"><span class='comment'>/* decNumberNextToward -- next towards rhs                            */</span></td></tr>
<tr><td class="num" id="LN1753">1753</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1754">1754</td><td class="line"><span class='comment'>/*   This computes C = A +/- infinitesimal, rounded towards           */</span></td></tr>
<tr><td class="num" id="LN1755">1755</td><td class="line"><span class='comment'>/*   +/-Infinity in the direction of B, as per 754-1985 nextafter     */</span></td></tr>
<tr><td class="num" id="LN1756">1756</td><td class="line"><span class='comment'>/*   modified during revision but dropped from 754-2008.              */</span></td></tr>
<tr><td class="num" id="LN1757">1757</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1758">1758</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A or B.                          */</span></td></tr>
<tr><td class="num" id="LN1759">1759</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1760">1760</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1761">1761</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1762">1762</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1763">1763</td><td class="line"><span class='comment'>/* This is a generalization of 754-1985 NextAfter.                    */</span></td></tr>
<tr><td class="num" id="LN1764">1764</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1765">1765</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberNextToward<span class='expansion'>uprv_decNumberNextToward_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1766">1766</td><td class="line">                                <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1767">1767</td><td class="line">  decNumber dtiny;                           <span class='comment'>/* constant  */</span></td></tr>
<tr><td class="num" id="LN1768">1768</td><td class="line">  decContext workset=*set;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1769">1769</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> result;                                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1770">1770</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                             <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1771">1771</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1772">1772</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1773">1773</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1774">1774</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1775">1775</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN1776">1776</td><td class="line">    decNaNs(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1777">1777</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1778">1778</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* Is numeric, so no chance of sNaN Invalid, etc.  */</span></td></tr>
<tr><td class="num" id="LN1779">1779</td><td class="line">    result=decCompare(lhs, rhs, 0);     <span class='comment'>/* sign matters  */</span></td></tr>
<tr><td class="num" id="LN1780">1780</td><td class="line">    <span class='keyword'>if</span> (result==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>; <span class='comment'>/* rare  */</span></td></tr>
<tr><td class="num" id="LN1781">1781</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* valid compare  */</span></td></tr>
<tr><td class="num" id="LN1782">1782</td><td class="line">      <span class='keyword'>if</span> (result==0) <span class='macro'>uprv_decNumberCopySign<span class='expansion'>uprv_decNumberCopySign_54</span></span>(res, lhs, rhs); <span class='comment'>/* easy  */</span></td></tr>
<tr><td class="num" id="LN1783">1783</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* differ: need NextPlus or NextMinus  */</span></td></tr>
<tr><td class="num" id="LN1784">1784</td><td class="line">        <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> sub;                      <span class='comment'>/* add or subtract  */</span></td></tr>
<tr><td class="num" id="LN1785">1785</td><td class="line">        <span class='keyword'>if</span> (result&lt;0) {                 <span class='comment'>/* lhs&lt;rhs, do nextplus  */</span></td></tr>
<tr><td class="num" id="LN1786">1786</td><td class="line">          <span class='comment'>/* -Infinity is the special case  */</span></td></tr>
<tr><td class="num" id="LN1787">1787</td><td class="line">          <span class='keyword'>if</span> ((lhs-&gt;bits&amp;(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>))==(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>)) {</td></tr>
<tr><td class="num" id="LN1788">1788</td><td class="line">            decSetMaxValue(res, set);</td></tr>
<tr><td class="num" id="LN1789">1789</td><td class="line">            res-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;           <span class='comment'>/* negative  */</span></td></tr>
<tr><td class="num" id="LN1790">1790</td><td class="line">            <span class='keyword'>return</span> res;                 <span class='comment'>/* there is no status to set  */</span></td></tr>
<tr><td class="num" id="LN1791">1791</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1792">1792</td><td class="line">          workset.round=DEC_ROUND_CEILING;</td></tr>
<tr><td class="num" id="LN1793">1793</td><td class="line">          sub=0;                        <span class='comment'>/* add, please  */</span></td></tr>
<tr><td class="num" id="LN1794">1794</td><td class="line">          } <span class='comment'>/* plus  */</span></td></tr>
<tr><td class="num" id="LN1795">1795</td><td class="line">         <span class='keyword'>else</span> {                         <span class='comment'>/* lhs&gt;rhs, do nextminus  */</span></td></tr>
<tr><td class="num" id="LN1796">1796</td><td class="line">          <span class='comment'>/* +Infinity is the special case  */</span></td></tr>
<tr><td class="num" id="LN1797">1797</td><td class="line">          <span class='keyword'>if</span> ((lhs-&gt;bits&amp;(<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>))==<span class='macro'>DECINF<span class='expansion'>0x40</span></span>) {</td></tr>
<tr><td class="num" id="LN1798">1798</td><td class="line">            decSetMaxValue(res, set);</td></tr>
<tr><td class="num" id="LN1799">1799</td><td class="line">            <span class='keyword'>return</span> res;                 <span class='comment'>/* there is no status to set  */</span></td></tr>
<tr><td class="num" id="LN1800">1800</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1801">1801</td><td class="line">          workset.round=DEC_ROUND_FLOOR;</td></tr>
<tr><td class="num" id="LN1802">1802</td><td class="line">          sub=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                   <span class='comment'>/* subtract, please  */</span></td></tr>
<tr><td class="num" id="LN1803">1803</td><td class="line">          } <span class='comment'>/* minus  */</span></td></tr>
<tr><td class="num" id="LN1804">1804</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dtiny);          <span class='comment'>/* start with 0  */</span></td></tr>
<tr><td class="num" id="LN1805">1805</td><td class="line">        dtiny.lsu[0]=1;                 <span class='comment'>/* make number that is ..  */</span></td></tr>
<tr><td class="num" id="LN1806">1806</td><td class="line">        dtiny.exponent=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>-1;  <span class='comment'>/* .. smaller than tiniest  */</span></td></tr>
<tr><td class="num" id="LN1807">1807</td><td class="line">        decAddOp(res, lhs, &amp;dtiny, &amp;workset, sub, &amp;status); <span class='comment'>/* + or -  */</span></td></tr>
<tr><td class="num" id="LN1808">1808</td><td class="line">        <span class='comment'>/* turn off exceptions if the result is a normal number  */</span></td></tr>
<tr><td class="num" id="LN1809">1809</td><td class="line">        <span class='comment'>/* (including Nmin), otherwise let all status through  */</span></td></tr>
<tr><td class="num" id="LN1810">1810</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>uprv_decNumberIsNormal<span class='expansion'>uprv_decNumberIsNormal_54</span></span>(res, set)) status=0;</td></tr>
<tr><td class="num" id="LN1811">1811</td><td class="line">        } <span class='comment'>/* unequal  */</span></td></tr>
<tr><td class="num" id="LN1812">1812</td><td class="line">      } <span class='comment'>/* compare OK  */</span></td></tr>
<tr><td class="num" id="LN1813">1813</td><td class="line">    } <span class='comment'>/* numeric  */</span></td></tr>
<tr><td class="num" id="LN1814">1814</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1815">1815</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1816">1816</td><td class="line">  } <span class='comment'>/* decNumberNextToward  */</span></td></tr>
<tr><td class="num" id="LN1817">1817</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1818">1818</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1819">1819</td><td class="line"><span class='comment'>/* decNumberOr -- OR two Numbers, digitwise                           */</span></td></tr>
<tr><td class="num" id="LN1820">1820</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1821">1821</td><td class="line"><span class='comment'>/*   This computes C = A | B                                          */</span></td></tr>
<tr><td class="num" id="LN1822">1822</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1823">1823</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X|X)         */</span></td></tr>
<tr><td class="num" id="LN1824">1824</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1825">1825</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1826">1826</td><td class="line"><span class='comment'>/*   set is the context (used for result length and error report)     */</span></td></tr>
<tr><td class="num" id="LN1827">1827</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1828">1828</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1829">1829</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1830">1830</td><td class="line"><span class='comment'>/* Logical function restrictions apply (see above); a NaN is          */</span></td></tr>
<tr><td class="num" id="LN1831">1831</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1832">1832</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1833">1833</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberOr<span class='expansion'>uprv_decNumberOr_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1834">1834</td><td class="line">                        <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1835">1835</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ua, *ub;                  <span class='comment'>/* -&gt; operands  */</span></td></tr>
<tr><td class="num" id="LN1836">1836</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msua, *msub;              <span class='comment'>/* -&gt; operand msus  */</span></td></tr>
<tr><td class="num" id="LN1837">1837</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *uc, *msuc;                     <span class='comment'>/* -&gt; result and its msu  */</span></td></tr>
<tr><td class="num" id="LN1838">1838</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   msudigs;                        <span class='comment'>/* digits in res msu  */</span></td></tr>
<tr><td class="num" id="LN1839">1839</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1840">1840</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1841">1841</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1842">1842</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1843">1843</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span></td></tr>
<tr><td class="num" id="LN1844">1844</td><td class="line">   || rhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN1845">1845</td><td class="line">    decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN1846">1846</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1847">1847</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1848">1848</td><td class="line">  <span class='comment'>/* operands are valid  */</span></td></tr>
<tr><td class="num" id="LN1849">1849</td><td class="line">  ua=lhs-&gt;lsu;                          <span class='comment'>/* bottom-up  */</span></td></tr>
<tr><td class="num" id="LN1850">1850</td><td class="line">  ub=rhs-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1851">1851</td><td class="line">  uc=res-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1852">1852</td><td class="line">  msua=ua+<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of lhs  */</span></td></tr>
<tr><td class="num" id="LN1853">1853</td><td class="line">  msub=ub+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of rhs  */</span></td></tr>
<tr><td class="num" id="LN1854">1854</td><td class="line">  msuc=uc+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of result  */</span></td></tr>
<tr><td class="num" id="LN1855">1855</td><td class="line">  msudigs=<span class='macro'>MSUDIGITS(set-&gt;digits)<span class='expansion'>((set-&gt;digits)-(((set-&gt;digits)&lt;=49?d2utable[set-&gt;<br>digits]:((set-&gt;digits)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN1856">1856</td><td class="line">  <span class='keyword'>for</span> (; uc&lt;=msuc; ua++, ub++, uc++) {  <span class='comment'>/* Unit loop  */</span></td></tr>
<tr><td class="num" id="LN1857">1857</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> a, b;                          <span class='comment'>/* extract units  */</span></td></tr>
<tr><td class="num" id="LN1858">1858</td><td class="line">    <span class='keyword'>if</span> (ua&gt;msua) a=0;</td></tr>
<tr><td class="num" id="LN1859">1859</td><td class="line">     <span class='keyword'>else</span> a=*ua;</td></tr>
<tr><td class="num" id="LN1860">1860</td><td class="line">    <span class='keyword'>if</span> (ub&gt;msub) b=0;</td></tr>
<tr><td class="num" id="LN1861">1861</td><td class="line">     <span class='keyword'>else</span> b=*ub;</td></tr>
<tr><td class="num" id="LN1862">1862</td><td class="line">    *uc=0;                              <span class='comment'>/* can now write back  */</span></td></tr>
<tr><td class="num" id="LN1863">1863</td><td class="line">    <span class='keyword'>if</span> (a|b) {                          <span class='comment'>/* maybe 1 bits to examine  */</span></td></tr>
<tr><td class="num" id="LN1864">1864</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> i, j;</td></tr>
<tr><td class="num" id="LN1865">1865</td><td class="line">      <span class='comment'>/* This loop could be unrolled and/or use BIN2BCD tables  */</span></td></tr>
<tr><td class="num" id="LN1866">1866</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; i++) {</td></tr>
<tr><td class="num" id="LN1867">1867</td><td class="line">        <span class='keyword'>if</span> ((a|b)&amp;1) *uc=*uc+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[i];     <span class='comment'>/* effect OR  */</span></td></tr>
<tr><td class="num" id="LN1868">1868</td><td class="line">        j=a%10;</td></tr>
<tr><td class="num" id="LN1869">1869</td><td class="line">        a=a/10;</td></tr>
<tr><td class="num" id="LN1870">1870</td><td class="line">        j|=b%10;</td></tr>
<tr><td class="num" id="LN1871">1871</td><td class="line">        b=b/10;</td></tr>
<tr><td class="num" id="LN1872">1872</td><td class="line">        <span class='keyword'>if</span> (j&gt;1) {</td></tr>
<tr><td class="num" id="LN1873">1873</td><td class="line">          decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN1874">1874</td><td class="line">          <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1875">1875</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN1876">1876</td><td class="line">        <span class='keyword'>if</span> (uc==msuc &amp;&amp; i==msudigs-1) <span class='keyword'>break</span>;      <span class='comment'>/* just did final digit  */</span></td></tr>
<tr><td class="num" id="LN1877">1877</td><td class="line">        } <span class='comment'>/* each digit  */</span></td></tr>
<tr><td class="num" id="LN1878">1878</td><td class="line">      } <span class='comment'>/* non-zero  */</span></td></tr>
<tr><td class="num" id="LN1879">1879</td><td class="line">    } <span class='comment'>/* each unit  */</span></td></tr>
<tr><td class="num" id="LN1880">1880</td><td class="line">  <span class='comment'>/* [here uc-1 is the msu of the result]  */</span></td></tr>
<tr><td class="num" id="LN1881">1881</td><td class="line">  res-&gt;digits=decGetDigits(res-&gt;lsu, uc-res-&gt;lsu);</td></tr>
<tr><td class="num" id="LN1882">1882</td><td class="line">  res-&gt;exponent=0;                      <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN1883">1883</td><td class="line">  res-&gt;bits=0;                          <span class='comment'>/* sign=0  */</span></td></tr>
<tr><td class="num" id="LN1884">1884</td><td class="line">  <span class='keyword'>return</span> res;  <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN1885">1885</td><td class="line">  } <span class='comment'>/* decNumberOr  */</span></td></tr>
<tr><td class="num" id="LN1886">1886</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1887">1887</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1888">1888</td><td class="line"><span class='comment'>/* decNumberPlus -- prefix plus operator                              */</span></td></tr>
<tr><td class="num" id="LN1889">1889</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1890">1890</td><td class="line"><span class='comment'>/*   This computes C = 0 + A                                          */</span></td></tr>
<tr><td class="num" id="LN1891">1891</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1892">1892</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN1893">1893</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1894">1894</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1895">1895</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1896">1896</td><td class="line"><span class='comment'>/* See also decNumberCopy for a quiet bitwise version of this.        */</span></td></tr>
<tr><td class="num" id="LN1897">1897</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1898">1898</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1899">1899</td><td class="line"><span class='comment'>/* This simply uses AddOp; Add will take fast path after preparing A. */</span></td></tr>
<tr><td class="num" id="LN1900">1900</td><td class="line"><span class='comment'>/* Performance is a concern here, as this routine is often used to    */</span></td></tr>
<tr><td class="num" id="LN1901">1901</td><td class="line"><span class='comment'>/* check operands and apply rounding and overflow/underflow testing.  */</span></td></tr>
<tr><td class="num" id="LN1902">1902</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1903">1903</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberPlus<span class='expansion'>uprv_decNumberPlus_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN1904">1904</td><td class="line">                          decContext *set) {</td></tr>
<tr><td class="num" id="LN1905">1905</td><td class="line">  decNumber dzero;</td></tr>
<tr><td class="num" id="LN1906">1906</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1907">1907</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1908">1908</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1909">1909</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1910">1910</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1911">1911</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dzero);                <span class='comment'>/* make 0  */</span></td></tr>
<tr><td class="num" id="LN1912">1912</td><td class="line">  dzero.exponent=rhs-&gt;exponent;         <span class='comment'>/* [no coefficient expansion]  */</span></td></tr>
<tr><td class="num" id="LN1913">1913</td><td class="line">  decAddOp(res, &amp;dzero, rhs, set, 0, &amp;status);</td></tr>
<tr><td class="num" id="LN1914">1914</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1915">1915</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1916">1916</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1917">1917</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1918">1918</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1919">1919</td><td class="line">  } <span class='comment'>/* decNumberPlus  */</span></td></tr>
<tr><td class="num" id="LN1920">1920</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1921">1921</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1922">1922</td><td class="line"><span class='comment'>/* decNumberMultiply -- multiply two Numbers                          */</span></td></tr>
<tr><td class="num" id="LN1923">1923</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1924">1924</td><td class="line"><span class='comment'>/*   This computes C = A x B                                          */</span></td></tr>
<tr><td class="num" id="LN1925">1925</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1926">1926</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X+X)         */</span></td></tr>
<tr><td class="num" id="LN1927">1927</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1928">1928</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1929">1929</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1930">1930</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1931">1931</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1932">1932</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1933">1933</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberMultiply<span class='expansion'>uprv_decNumberMultiply_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1934">1934</td><td class="line">                              <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1935">1935</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN1936">1936</td><td class="line">  decMultiplyOp(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN1937">1937</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN1938">1938</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1939">1939</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN1940">1940</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1941">1941</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1942">1942</td><td class="line">  } <span class='comment'>/* decNumberMultiply  */</span></td></tr>
<tr><td class="num" id="LN1943">1943</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1944">1944</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1945">1945</td><td class="line"><span class='comment'>/* decNumberPower -- raise a number to a power                        */</span></td></tr>
<tr><td class="num" id="LN1946">1946</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1947">1947</td><td class="line"><span class='comment'>/*   This computes C = A ** B                                         */</span></td></tr>
<tr><td class="num" id="LN1948">1948</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1949">1949</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X**X)        */</span></td></tr>
<tr><td class="num" id="LN1950">1950</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN1951">1951</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN1952">1952</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN1953">1953</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1954">1954</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN1955">1955</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1956">1956</td><td class="line"><span class='comment'>/* Mathematical function restrictions apply (see above); a NaN is     */</span></td></tr>
<tr><td class="num" id="LN1957">1957</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN1958">1958</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1959">1959</td><td class="line"><span class='comment'>/* However, if 1999999997&lt;=B&lt;=999999999 and B is an integer then the  */</span></td></tr>
<tr><td class="num" id="LN1960">1960</td><td class="line"><span class='comment'>/* restrictions on A and the context are relaxed to the usual bounds, */</span></td></tr>
<tr><td class="num" id="LN1961">1961</td><td class="line"><span class='comment'>/* for compatibility with the earlier (integer power only) version    */</span></td></tr>
<tr><td class="num" id="LN1962">1962</td><td class="line"><span class='comment'>/* of this function.                                                  */</span></td></tr>
<tr><td class="num" id="LN1963">1963</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1964">1964</td><td class="line"><span class='comment'>/* When B is an integer, the result may be exact, even if rounded.    */</span></td></tr>
<tr><td class="num" id="LN1965">1965</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN1966">1966</td><td class="line"><span class='comment'>/* The final result is rounded according to the context; it will      */</span></td></tr>
<tr><td class="num" id="LN1967">1967</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN1968">1968</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN1969">1969</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN1970">1970</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberPower<span class='expansion'>uprv_decNumberPower_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN1971">1971</td><td class="line">                           <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN1972">1972</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1973">1973</td><td class="line">  decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded lhs allocated  */</span></td></tr>
<tr><td class="num" id="LN1974">1974</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* .., rhs  */</span></td></tr>
<tr><td class="num" id="LN1975">1975</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1976">1976</td><td class="line">  decNumber *allocdac=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* -&gt; allocated acc buffer, iff used  */</span></td></tr>
<tr><td class="num" id="LN1977">1977</td><td class="line">  decNumber *allocinv=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* -&gt; allocated 1/x buffer, iff used  */</span></td></tr>
<tr><td class="num" id="LN1978">1978</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   reqdigits=set-&gt;digits;     <span class='comment'>/* requested DIGITS  */</span></td></tr>
<tr><td class="num" id="LN1979">1979</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   n;                         <span class='comment'>/* rhs in binary  */</span></td></tr>
<tr><td class="num" id="LN1980">1980</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>  rhsint=0;                  <span class='comment'>/* 1 if rhs is an integer  */</span></td></tr>
<tr><td class="num" id="LN1981">1981</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>  useint=0;                  <span class='comment'>/* 1 if can use integer calculation  */</span></td></tr>
<tr><td class="num" id="LN1982">1982</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>  isoddint=0;                <span class='comment'>/* 1 if rhs is an integer and odd  */</span></td></tr>
<tr><td class="num" id="LN1983">1983</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   i;                         <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN1984">1984</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1985">1985</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   dropped;                   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN1986">1986</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1987">1987</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  needbytes;                 <span class='comment'>/* buffer size needed  */</span></td></tr>
<tr><td class="num" id="LN1988">1988</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>  seenbit;                   <span class='comment'>/* seen a bit while powering  */</span></td></tr>
<tr><td class="num" id="LN1989">1989</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   residue=0;                 <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN1990">1990</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  status=0;                  <span class='comment'>/* accumulators  */</span></td></tr>
<tr><td class="num" id="LN1991">1991</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> bits=0;                    <span class='comment'>/* result sign if errors  */</span></td></tr>
<tr><td class="num" id="LN1992">1992</td><td class="line">  decContext aset;                 <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN1993">1993</td><td class="line">  decNumber dnOne;                 <span class='comment'>/* work value 1...  */</span></td></tr>
<tr><td class="num" id="LN1994">1994</td><td class="line">  <span class='comment'>/* local accumulator buffer [a decNumber, with digits+elength+1 digits]  */</span></td></tr>
<tr><td class="num" id="LN1995">1995</td><td class="line">  decNumber dacbuff[<span class='macro'>D2N(DECBUFFER+9)<span class='expansion'>(((((((36 +9)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN1996">1996</td><td class="line">  decNumber *dac=dacbuff;          <span class='comment'>/* -&gt; result accumulator  */</span></td></tr>
<tr><td class="num" id="LN1997">1997</td><td class="line">  <span class='comment'>/* same again for possible 1/lhs calculation  */</span></td></tr>
<tr><td class="num" id="LN1998">1998</td><td class="line">  decNumber invbuff[<span class='macro'>D2N(DECBUFFER+9)<span class='expansion'>(((((((36 +9)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN1999">1999</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2000">2000</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2001">2001</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2002">2002</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2003">2003</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2004">2004</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN2005">2005</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2006">2006</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) { <span class='comment'>/* reduce operands and set status, as needed  */</span></td></tr>
<tr><td class="num" id="LN2007">2007</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN2008">2008</td><td class="line">        alloclhs=decRoundOperand(lhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2009">2009</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2010">2010</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN2011">2011</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2012">2012</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN2013">2013</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2014">2014</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2015">2015</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN2016">2016</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2017">2017</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2018">2018</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2019">2019</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN2020">2020</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2021">2021</td><td class="line">    <span class='comment'>/* handle NaNs and rhs Infinity (lhs infinity is harder)  */</span></td></tr>
<tr><td class="num" id="LN2022">2022</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {</td></tr>
<tr><td class="num" id="LN2023">2023</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) { <span class='comment'>/* NaNs  */</span></td></tr>
<tr><td class="num" id="LN2024">2024</td><td class="line">        decNaNs(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2025">2025</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2026">2026</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) {   <span class='comment'>/* rhs Infinity  */</span></td></tr>
<tr><td class="num" id="LN2027">2027</td><td class="line">        <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> rhsneg=rhs-&gt;bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;   <span class='comment'>/* save rhs sign  */</span></td></tr>
<tr><td class="num" id="LN2028">2028</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>    <span class='comment'>/* lhs&lt;0  */</span></td></tr>
<tr><td class="num" id="LN2029">2029</td><td class="line">         &amp;&amp; !<span class='macro'>decNumberIsZero(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>)      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2030">2030</td><td class="line">          status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2031">2031</td><td class="line">         <span class='keyword'>else</span> {                         <span class='comment'>/* lhs &gt;=0  */</span></td></tr>
<tr><td class="num" id="LN2032">2032</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dnOne);        <span class='comment'>/* set up 1  */</span></td></tr>
<tr><td class="num" id="LN2033">2033</td><td class="line">          dnOne.lsu[0]=1;</td></tr>
<tr><td class="num" id="LN2034">2034</td><td class="line">          <span class='macro'>uprv_decNumberCompare<span class='expansion'>uprv_decNumberCompare_54</span></span>(dac, lhs, &amp;dnOne, set); <span class='comment'>/* lhs ? 1  */</span></td></tr>
<tr><td class="num" id="LN2035">2035</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);           <span class='comment'>/* prepare for 0/1/Infinity  */</span></td></tr>
<tr><td class="num" id="LN2036">2036</td><td class="line">          <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dac)<span class='expansion'>(((dac)-&gt;bits&amp;0x80)!=0)</span></span>) {    <span class='comment'>/* lhs&lt;1  */</span></td></tr>
<tr><td class="num" id="LN2037">2037</td><td class="line">            <span class='keyword'>if</span> (rhsneg) res-&gt;bits|=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;   <span class='comment'>/* +Infinity [else is +0]  */</span></td></tr>
<tr><td class="num" id="LN2038">2038</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2039">2039</td><td class="line">           <span class='keyword'>else</span> <span class='keyword'>if</span> (dac-&gt;lsu[0]==0) {        <span class='comment'>/* lhs=1  */</span></td></tr>
<tr><td class="num" id="LN2040">2040</td><td class="line">            <span class='comment'>/* 1**Infinity is inexact, so return fully-padded 1.0000  */</span></td></tr>
<tr><td class="num" id="LN2041">2041</td><td class="line">            <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift=set-&gt;digits-1;</td></tr>
<tr><td class="num" id="LN2042">2042</td><td class="line">            *res-&gt;lsu=1;                     <span class='comment'>/* was 0, make int 1  */</span></td></tr>
<tr><td class="num" id="LN2043">2043</td><td class="line">            res-&gt;digits=decShiftToMost(res-&gt;lsu, 1, shift);</td></tr>
<tr><td class="num" id="LN2044">2044</td><td class="line">            res-&gt;exponent=-shift;            <span class='comment'>/* make 1.0000...  */</span></td></tr>
<tr><td class="num" id="LN2045">2045</td><td class="line">            status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>; <span class='comment'>/* deemed inexact  */</span></td></tr>
<tr><td class="num" id="LN2046">2046</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2047">2047</td><td class="line">           <span class='keyword'>else</span> {                            <span class='comment'>/* lhs&gt;1  */</span></td></tr>
<tr><td class="num" id="LN2048">2048</td><td class="line">            <span class='keyword'>if</span> (!rhsneg) res-&gt;bits|=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;  <span class='comment'>/* +Infinity [else is +0]  */</span></td></tr>
<tr><td class="num" id="LN2049">2049</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2050">2050</td><td class="line">          } <span class='comment'>/* lhs&gt;=0  */</span></td></tr>
<tr><td class="num" id="LN2051">2051</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2052">2052</td><td class="line">      <span class='comment'>/* [lhs infinity drops through]  */</span></td></tr>
<tr><td class="num" id="LN2053">2053</td><td class="line">      } <span class='comment'>/* specials  */</span></td></tr>
<tr><td class="num" id="LN2054">2054</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2055">2055</td><td class="line">    <span class='comment'>/* Original rhs may be an integer that fits and is in range  */</span></td></tr>
<tr><td class="num" id="LN2056">2056</td><td class="line">    n=decGetInt(rhs);</td></tr>
<tr><td class="num" id="LN2057">2057</td><td class="line">    <span class='keyword'>if</span> (n!=<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) {                    <span class='comment'>/* it is an integer  */</span></td></tr>
<tr><td class="num" id="LN2058">2058</td><td class="line">      rhsint=1;                         <span class='comment'>/* record the fact for 1**n  */</span></td></tr>
<tr><td class="num" id="LN2059">2059</td><td class="line">      isoddint=(<span class='macro'>Flag<span class='expansion'>uint8_t</span></span>)n&amp;1;               <span class='comment'>/* [works even if big]  */</span></td></tr>
<tr><td class="num" id="LN2060">2060</td><td class="line">      <span class='keyword'>if</span> (n!=<span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span> &amp;&amp; n!=<span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span>)      <span class='comment'>/* can use integer path?  */</span></td></tr>
<tr><td class="num" id="LN2061">2061</td><td class="line">        useint=1;                       <span class='comment'>/* looks good  */</span></td></tr>
<tr><td class="num" id="LN2062">2062</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2063">2063</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2064">2064</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>        <span class='comment'>/* -x ..  */</span></td></tr>
<tr><td class="num" id="LN2065">2065</td><td class="line">      &amp;&amp; isoddint) bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;         <span class='comment'>/* .. to an odd power  */</span></td></tr>
<tr><td class="num" id="LN2066">2066</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2067">2067</td><td class="line">    <span class='comment'>/* handle LHS infinity  */</span></td></tr>
<tr><td class="num" id="LN2068">2068</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x40)!=0)</span></span>) {     <span class='comment'>/* [NaNs already handled]  */</span></td></tr>
<tr><td class="num" id="LN2069">2069</td><td class="line">      <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> rbits=rhs-&gt;bits;            <span class='comment'>/* save  */</span></td></tr>
<tr><td class="num" id="LN2070">2070</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);               <span class='comment'>/* prepare  */</span></td></tr>
<tr><td class="num" id="LN2071">2071</td><td class="line">      <span class='keyword'>if</span> (n==0) *res-&gt;lsu=1;            <span class='comment'>/* [-]Inf**0 =&gt; 1  */</span></td></tr>
<tr><td class="num" id="LN2072">2072</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2073">2073</td><td class="line">        <span class='comment'>/* -Inf**nonint -&gt; error  */</span></td></tr>
<tr><td class="num" id="LN2074">2074</td><td class="line">        <span class='keyword'>if</span> (!rhsint &amp;&amp; <span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN2075">2075</td><td class="line">          status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;     <span class='comment'>/* -Inf**nonint is error  */</span></td></tr>
<tr><td class="num" id="LN2076">2076</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2077">2077</td><td class="line">        <span class='keyword'>if</span> (!(rbits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>)) bits|=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>; <span class='comment'>/* was not a **-n  */</span></td></tr>
<tr><td class="num" id="LN2078">2078</td><td class="line">        <span class='comment'>/* [otherwise will be 0 or -0]  */</span></td></tr>
<tr><td class="num" id="LN2079">2079</td><td class="line">        res-&gt;bits=bits;</td></tr>
<tr><td class="num" id="LN2080">2080</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2081">2081</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2082">2082</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2083">2083</td><td class="line">    <span class='comment'>/* similarly handle LHS zero  */</span></td></tr>
<tr><td class="num" id="LN2084">2084</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN2085">2085</td><td class="line">      <span class='keyword'>if</span> (n==0) {                            <span class='comment'>/* 0**0 =&gt; Error  */</span></td></tr>
<tr><td class="num" id="LN2086">2086</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2087">2087</td><td class="line">        <span class='keyword'>if</span> (!set-&gt;extended) {                <span class='comment'>/* [unless subset]  */</span></td></tr>
<tr><td class="num" id="LN2088">2088</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN2089">2089</td><td class="line">          *res-&gt;lsu=1;                       <span class='comment'>/* return 1  */</span></td></tr>
<tr><td class="num" id="LN2090">2090</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2091">2091</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2092">2092</td><td class="line">        status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2093">2093</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2094">2094</td><td class="line">       <span class='keyword'>else</span> {                                <span class='comment'>/* 0**x  */</span></td></tr>
<tr><td class="num" id="LN2095">2095</td><td class="line">        <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> rbits=rhs-&gt;bits;               <span class='comment'>/* save  */</span></td></tr>
<tr><td class="num" id="LN2096">2096</td><td class="line">        <span class='keyword'>if</span> (rbits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>) {                <span class='comment'>/* was a 0**(-n)  */</span></td></tr>
<tr><td class="num" id="LN2097">2097</td><td class="line">          <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2098">2098</td><td class="line">          <span class='keyword'>if</span> (!set-&gt;extended) {              <span class='comment'>/* [bad if subset]  */</span></td></tr>
<tr><td class="num" id="LN2099">2099</td><td class="line">            status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2100">2100</td><td class="line">            <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2101">2101</td><td class="line">          <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2102">2102</td><td class="line">          bits|=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;</td></tr>
<tr><td class="num" id="LN2103">2103</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2104">2104</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);                  <span class='comment'>/* prepare  */</span></td></tr>
<tr><td class="num" id="LN2105">2105</td><td class="line">        <span class='comment'>/* [otherwise will be 0 or -0]  */</span></td></tr>
<tr><td class="num" id="LN2106">2106</td><td class="line">        res-&gt;bits=bits;</td></tr>
<tr><td class="num" id="LN2107">2107</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2108">2108</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2109">2109</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2110">2110</td><td class="line">    <span class='comment'>/* here both lhs and rhs are finite; rhs==0 is handled in the  */</span></td></tr>
<tr><td class="num" id="LN2111">2111</td><td class="line">    <span class='comment'>/* integer path.  Next handle the non-integer cases  */</span></td></tr>
<tr><td class="num" id="LN2112">2112</td><td class="line">    <span class='keyword'>if</span> (!useint) {                      <span class='comment'>/* non-integral rhs  */</span></td></tr>
<tr><td class="num" id="LN2113">2113</td><td class="line">      <span class='comment'>/* any -ve lhs is bad, as is either operand or context out of  */</span></td></tr>
<tr><td class="num" id="LN2114">2114</td><td class="line">      <span class='comment'>/* bounds  */</span></td></tr>
<tr><td class="num" id="LN2115">2115</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN2116">2116</td><td class="line">        status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2117">2117</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2118">2118</td><td class="line">      <span class='keyword'>if</span> (decCheckMath(lhs, set, &amp;status)</td></tr>
<tr><td class="num" id="LN2119">2119</td><td class="line">       || decCheckMath(rhs, set, &amp;status)) <span class='keyword'>break</span>; <span class='comment'>/* variable status  */</span></td></tr>
<tr><td class="num" id="LN2120">2120</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2121">2121</td><td class="line">      <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;aset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>); <span class='comment'>/* clean context  */</span></td></tr>
<tr><td class="num" id="LN2122">2122</td><td class="line">      aset.emax=<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>;           <span class='comment'>/* usual bounds  */</span></td></tr>
<tr><td class="num" id="LN2123">2123</td><td class="line">      aset.emin=-<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>;          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2124">2124</td><td class="line">      aset.clamp=0;                     <span class='comment'>/* and no concrete format  */</span></td></tr>
<tr><td class="num" id="LN2125">2125</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2126">2126</td><td class="line">      <span class='comment'>/* calculate the result using exp(ln(lhs)*rhs), which can  */</span></td></tr>
<tr><td class="num" id="LN2127">2127</td><td class="line">      <span class='comment'>/* all be done into the accumulator, dac.  The precision needed  */</span></td></tr>
<tr><td class="num" id="LN2128">2128</td><td class="line">      <span class='comment'>/* is enough to contain the full information in the lhs (which  */</span></td></tr>
<tr><td class="num" id="LN2129">2129</td><td class="line">      <span class='comment'>/* is the total digits, including exponent), or the requested  */</span></td></tr>
<tr><td class="num" id="LN2130">2130</td><td class="line">      <span class='comment'>/* precision, if larger, + 4; 6 is used for the exponent  */</span></td></tr>
<tr><td class="num" id="LN2131">2131</td><td class="line">      <span class='comment'>/* maximum length, and this is also used when it is shorter  */</span></td></tr>
<tr><td class="num" id="LN2132">2132</td><td class="line">      <span class='comment'>/* than the requested digits as it greatly reduces the &gt;0.5 ulp  */</span></td></tr>
<tr><td class="num" id="LN2133">2133</td><td class="line">      <span class='comment'>/* cases at little cost (because Ln doubles digits each  */</span></td></tr>
<tr><td class="num" id="LN2134">2134</td><td class="line">      <span class='comment'>/* iteration so a few extra digits rarely causes an extra  */</span></td></tr>
<tr><td class="num" id="LN2135">2135</td><td class="line">      <span class='comment'>/* iteration)  */</span></td></tr>
<tr><td class="num" id="LN2136">2136</td><td class="line">      aset.digits=<span class='macro'>MAXI(lhs-&gt;digits, set-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;(set-&gt;digits)?(set-&gt;digits):(lhs-&gt;<br>digits))</span></span>+6+4;</td></tr>
<tr><td class="num" id="LN2137">2137</td><td class="line">      } <span class='comment'>/* non-integer rhs  */</span></td></tr>
<tr><td class="num" id="LN2138">2138</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2139">2139</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* rhs is in-range integer  */</span></td></tr>
<tr><td class="num" id="LN2140">2140</td><td class="line">      <span class='keyword'>if</span> (n==0) {                       <span class='comment'>/* x**0 = 1  */</span></td></tr>
<tr><td class="num" id="LN2141">2141</td><td class="line">        <span class='comment'>/* (0**0 was handled above)  */</span></td></tr>
<tr><td class="num" id="LN2142">2142</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);             <span class='comment'>/* result=1  */</span></td></tr>
<tr><td class="num" id="LN2143">2143</td><td class="line">        *res-&gt;lsu=1;                    <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2144">2144</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2145">2145</td><td class="line">      <span class='comment'>/* rhs is a non-zero integer  */</span></td></tr>
<tr><td class="num" id="LN2146">2146</td><td class="line">      <span class='keyword'>if</span> (n&lt;0) n=-n;                    <span class='comment'>/* use abs(n)  */</span></td></tr>
<tr><td class="num" id="LN2147">2147</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2148">2148</td><td class="line">      aset=*set;                        <span class='comment'>/* clone the context  */</span></td></tr>
<tr><td class="num" id="LN2149">2149</td><td class="line">      aset.round=DEC_ROUND_HALF_EVEN;   <span class='comment'>/* internally use balanced  */</span></td></tr>
<tr><td class="num" id="LN2150">2150</td><td class="line">      <span class='comment'>/* calculate the working DIGITS  */</span></td></tr>
<tr><td class="num" id="LN2151">2151</td><td class="line">      aset.digits=reqdigits+(rhs-&gt;digits+rhs-&gt;exponent)+2;</td></tr>
<tr><td class="num" id="LN2152">2152</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2153">2153</td><td class="line">      <span class='keyword'>if</span> (!set-&gt;extended) aset.digits--;     <span class='comment'>/* use classic precision  */</span></td></tr>
<tr><td class="num" id="LN2154">2154</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2155">2155</td><td class="line">      <span class='comment'>/* it's an error if this is more than can be handled  */</span></td></tr>
<tr><td class="num" id="LN2156">2156</td><td class="line">      <span class='keyword'>if</span> (aset.digits&gt;<span class='macro'>DECNUMMAXP<span class='expansion'>999999999</span></span>) {status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>; <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2157">2157</td><td class="line">      } <span class='comment'>/* integer path  */</span></td></tr>
<tr><td class="num" id="LN2158">2158</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2159">2159</td><td class="line">    <span class='comment'>/* aset.digits is the count of digits for the accumulator needed  */</span></td></tr>
<tr><td class="num" id="LN2160">2160</td><td class="line">    <span class='comment'>/* if accumulator is too long for local storage, then allocate  */</span></td></tr>
<tr><td class="num" id="LN2161">2161</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(aset.digits)<span class='expansion'>((aset.digits)&lt;=49?d2utable[aset.digits]:((aset.digits)+1 -<br>1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN2162">2162</td><td class="line">    <span class='comment'>/* [needbytes also used below if 1/lhs needed]  */</span></td></tr>
<tr><td class="num" id="LN2163">2163</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(dacbuff)) {</td></tr>
<tr><td class="num" id="LN2164">2164</td><td class="line">      allocdac=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN2165">2165</td><td class="line">      <span class='keyword'>if</span> (allocdac==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {   <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN2166">2166</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN2167">2167</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2168">2168</td><td class="line">      dac=allocdac;           <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN2169">2169</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2170">2170</td><td class="line">    <span class='comment'>/* here, aset is set up and accumulator is ready for use  */</span></td></tr>
<tr><td class="num" id="LN2171">2171</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2172">2172</td><td class="line">    <span class='keyword'>if</span> (!useint) {                           <span class='comment'>/* non-integral rhs  */</span></td></tr>
<tr><td class="num" id="LN2173">2173</td><td class="line">      <span class='comment'>/* x ** y; special-case x=1 here as it will otherwise always  */</span></td></tr>
<tr><td class="num" id="LN2174">2174</td><td class="line">      <span class='comment'>/* reduce to integer 1; decLnOp has a fastpath which detects  */</span></td></tr>
<tr><td class="num" id="LN2175">2175</td><td class="line">      <span class='comment'>/* the case of x=1  */</span></td></tr>
<tr><td class="num" id="LN2176">2176</td><td class="line">      decLnOp(dac, lhs, &amp;aset, &amp;status);     <span class='comment'>/* dac=ln(lhs)  */</span></td></tr>
<tr><td class="num" id="LN2177">2177</td><td class="line">      <span class='comment'>/* [no error possible, as lhs 0 already handled]  */</span></td></tr>
<tr><td class="num" id="LN2178">2178</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ISZERO(dac)<span class='expansion'>(*(dac)-&gt;lsu==0 &amp;&amp; (dac)-&gt;digits==1 &amp;&amp; (<br>((dac)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                     <span class='comment'>/* x==1, 1.0, etc.  */</span></td></tr>
<tr><td class="num" id="LN2179">2179</td><td class="line">        <span class='comment'>/* need to return fully-padded 1.0000 etc., but rhsint-&gt;1  */</span></td></tr>
<tr><td class="num" id="LN2180">2180</td><td class="line">        *dac-&gt;lsu=1;                         <span class='comment'>/* was 0, make int 1  */</span></td></tr>
<tr><td class="num" id="LN2181">2181</td><td class="line">        <span class='keyword'>if</span> (!rhsint) {                       <span class='comment'>/* add padding  */</span></td></tr>
<tr><td class="num" id="LN2182">2182</td><td class="line">          <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift=set-&gt;digits-1;</td></tr>
<tr><td class="num" id="LN2183">2183</td><td class="line">          dac-&gt;digits=decShiftToMost(dac-&gt;lsu, 1, shift);</td></tr>
<tr><td class="num" id="LN2184">2184</td><td class="line">          dac-&gt;exponent=-shift;              <span class='comment'>/* make 1.0000...  */</span></td></tr>
<tr><td class="num" id="LN2185">2185</td><td class="line">          status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;   <span class='comment'>/* deemed inexact  */</span></td></tr>
<tr><td class="num" id="LN2186">2186</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2187">2187</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2188">2188</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2189">2189</td><td class="line">        decMultiplyOp(dac, dac, rhs, &amp;aset, &amp;status);  <span class='comment'>/* dac=dac*rhs  */</span></td></tr>
<tr><td class="num" id="LN2190">2190</td><td class="line">        decExpOp(dac, dac, &amp;aset, &amp;status);            <span class='comment'>/* dac=exp(dac)  */</span></td></tr>
<tr><td class="num" id="LN2191">2191</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2192">2192</td><td class="line">      <span class='comment'>/* and drop through for final rounding  */</span></td></tr>
<tr><td class="num" id="LN2193">2193</td><td class="line">      } <span class='comment'>/* non-integer rhs  */</span></td></tr>
<tr><td class="num" id="LN2194">2194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2195">2195</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* carry on with integer  */</span></td></tr>
<tr><td class="num" id="LN2196">2196</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dac);               <span class='comment'>/* acc=1  */</span></td></tr>
<tr><td class="num" id="LN2197">2197</td><td class="line">      *dac-&gt;lsu=1;                      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2198">2198</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2199">2199</td><td class="line">      <span class='comment'>/* if a negative power the constant 1 is needed, and if not subset  */</span></td></tr>
<tr><td class="num" id="LN2200">2200</td><td class="line">      <span class='comment'>/* invert the lhs now rather than inverting the result later  */</span></td></tr>
<tr><td class="num" id="LN2201">2201</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {   <span class='comment'>/* was a **-n [hence digits&gt;0]  */</span></td></tr>
<tr><td class="num" id="LN2202">2202</td><td class="line">        decNumber *inv=invbuff;         <span class='comment'>/* asssume use fixed buffer  */</span></td></tr>
<tr><td class="num" id="LN2203">2203</td><td class="line">        <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(&amp;dnOne, dac);     <span class='comment'>/* dnOne=1;  [needed now or later]  */</span></td></tr>
<tr><td class="num" id="LN2204">2204</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2205">2205</td><td class="line">        <span class='keyword'>if</span> (set-&gt;extended) {            <span class='comment'>/* need to calculate 1/lhs  */</span></td></tr>
<tr><td class="num" id="LN2206">2206</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2207">2207</td><td class="line">          <span class='comment'>/* divide lhs into 1, putting result in dac [dac=1/dac]  */</span></td></tr>
<tr><td class="num" id="LN2208">2208</td><td class="line">          decDivideOp(dac, &amp;dnOne, lhs, &amp;aset, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN2209">2209</td><td class="line">          <span class='comment'>/* now locate or allocate space for the inverted lhs  */</span></td></tr>
<tr><td class="num" id="LN2210">2210</td><td class="line">          <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(invbuff)) {</td></tr>
<tr><td class="num" id="LN2211">2211</td><td class="line">            allocinv=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN2212">2212</td><td class="line">            <span class='keyword'>if</span> (allocinv==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {       <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN2213">2213</td><td class="line">              status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN2214">2214</td><td class="line">              <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2215">2215</td><td class="line">            inv=allocinv;               <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN2216">2216</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2217">2217</td><td class="line">          <span class='comment'>/* [inv now points to big-enough buffer or allocated storage]  */</span></td></tr>
<tr><td class="num" id="LN2218">2218</td><td class="line">          <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(inv, dac);      <span class='comment'>/* copy the 1/lhs  */</span></td></tr>
<tr><td class="num" id="LN2219">2219</td><td class="line">          <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(dac, &amp;dnOne);   <span class='comment'>/* restore acc=1  */</span></td></tr>
<tr><td class="num" id="LN2220">2220</td><td class="line">          lhs=inv;                      <span class='comment'>/* .. and go forward with new lhs  */</span></td></tr>
<tr><td class="num" id="LN2221">2221</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2222">2222</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2223">2223</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2224">2224</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2225">2225</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2226">2226</td><td class="line">      <span class='comment'>/* Raise-to-the-power loop...  */</span></td></tr>
<tr><td class="num" id="LN2227">2227</td><td class="line">      seenbit=0;                   <span class='comment'>/* set once a 1-bit is encountered  */</span></td></tr>
<tr><td class="num" id="LN2228">2228</td><td class="line">      <span class='keyword'>for</span> (i=1;;i++){              <span class='comment'>/* for each bit [top bit ignored]  */</span></td></tr>
<tr><td class="num" id="LN2229">2229</td><td class="line">        <span class='comment'>/* abandon if had overflow or terminal underflow  */</span></td></tr>
<tr><td class="num" id="LN2230">2230</td><td class="line">        <span class='keyword'>if</span> (status &amp; (<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>|<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>)) { <span class='comment'>/* interesting?  */</span></td></tr>
<tr><td class="num" id="LN2231">2231</td><td class="line">          <span class='keyword'>if</span> (status&amp;<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span> || <span class='macro'>ISZERO(dac)<span class='expansion'>(*(dac)-&gt;lsu==0 &amp;&amp; (dac)-&gt;digits==1 &amp;&amp; (<br>((dac)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2232">2232</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2233">2233</td><td class="line">        <span class='comment'>/* [the following two lines revealed an optimizer bug in a C++  */</span></td></tr>
<tr><td class="num" id="LN2234">2234</td><td class="line">        <span class='comment'>/* compiler, with symptom: 5**3 -&gt; 25, when n=n+n was used]  */</span></td></tr>
<tr><td class="num" id="LN2235">2235</td><td class="line">        n=n&lt;&lt;1;                    <span class='comment'>/* move next bit to testable position  */</span></td></tr>
<tr><td class="num" id="LN2236">2236</td><td class="line">        <span class='keyword'>if</span> (n&lt;0) {                 <span class='comment'>/* top bit is set  */</span></td></tr>
<tr><td class="num" id="LN2237">2237</td><td class="line">          seenbit=1;               <span class='comment'>/* OK, significant bit seen  */</span></td></tr>
<tr><td class="num" id="LN2238">2238</td><td class="line">          decMultiplyOp(dac, dac, lhs, &amp;aset, &amp;status); <span class='comment'>/* dac=dac*x  */</span></td></tr>
<tr><td class="num" id="LN2239">2239</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2240">2240</td><td class="line">        <span class='keyword'>if</span> (i==31) <span class='keyword'>break</span>;          <span class='comment'>/* that was the last bit  */</span></td></tr>
<tr><td class="num" id="LN2241">2241</td><td class="line">        <span class='keyword'>if</span> (!seenbit) <span class='keyword'>continue</span>;    <span class='comment'>/* no need to square 1  */</span></td></tr>
<tr><td class="num" id="LN2242">2242</td><td class="line">        decMultiplyOp(dac, dac, dac, &amp;aset, &amp;status); <span class='comment'>/* dac=dac*dac [square]  */</span></td></tr>
<tr><td class="num" id="LN2243">2243</td><td class="line">        } <span class='comment'>/*i*/</span> <span class='comment'>/* 32 bits  */</span></td></tr>
<tr><td class="num" id="LN2244">2244</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2245">2245</td><td class="line">      <span class='comment'>/* complete internal overflow or underflow processing  */</span></td></tr>
<tr><td class="num" id="LN2246">2246</td><td class="line">      <span class='keyword'>if</span> (status &amp; (<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>|<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>)) {</td></tr>
<tr><td class="num" id="LN2247">2247</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2248">2248</td><td class="line">        <span class='comment'>/* If subset, and power was negative, reverse the kind of -erflow  */</span></td></tr>
<tr><td class="num" id="LN2249">2249</td><td class="line">        <span class='comment'>/* [1/x not yet done]  */</span></td></tr>
<tr><td class="num" id="LN2250">2250</td><td class="line">        <span class='keyword'>if</span> (!set-&gt;extended &amp;&amp; <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN2251">2251</td><td class="line">          <span class='keyword'>if</span> (status &amp; <span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>)</td></tr>
<tr><td class="num" id="LN2252">2252</td><td class="line">            status^=<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span> | <span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span> | <span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span>;</td></tr>
<tr><td class="num" id="LN2253">2253</td><td class="line">           <span class='keyword'>else</span> { <span class='comment'>/* trickier -- Underflow may or may not be set  */</span></td></tr>
<tr><td class="num" id="LN2254">2254</td><td class="line">            status&amp;=~(<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span> | <span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span>); <span class='comment'>/* [one or both]  */</span></td></tr>
<tr><td class="num" id="LN2255">2255</td><td class="line">            status|=<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>;</td></tr>
<tr><td class="num" id="LN2256">2256</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2257">2257</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2258">2258</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2259">2259</td><td class="line">        dac-&gt;bits=(dac-&gt;bits &amp; ~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>) | bits; <span class='comment'>/* force correct sign  */</span></td></tr>
<tr><td class="num" id="LN2260">2260</td><td class="line">        <span class='comment'>/* round subnormals [to set.digits rather than aset.digits]  */</span></td></tr>
<tr><td class="num" id="LN2261">2261</td><td class="line">        <span class='comment'>/* or set overflow result similarly as required  */</span></td></tr>
<tr><td class="num" id="LN2262">2262</td><td class="line">        decFinalize(dac, set, &amp;residue, &amp;status);</td></tr>
<tr><td class="num" id="LN2263">2263</td><td class="line">        <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, dac);   <span class='comment'>/* copy to result (is now OK length)  */</span></td></tr>
<tr><td class="num" id="LN2264">2264</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2265">2265</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2266">2266</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2267">2267</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2268">2268</td><td class="line">      <span class='keyword'>if</span> (!set-&gt;extended &amp;&amp;                  <span class='comment'>/* subset math  */</span></td></tr>
<tr><td class="num" id="LN2269">2269</td><td class="line">          <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {        <span class='comment'>/* was a **-n [hence digits&gt;0]  */</span></td></tr>
<tr><td class="num" id="LN2270">2270</td><td class="line">        <span class='comment'>/* so divide result into 1 [dac=1/dac]  */</span></td></tr>
<tr><td class="num" id="LN2271">2271</td><td class="line">        decDivideOp(dac, &amp;dnOne, dac, &amp;aset, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN2272">2272</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2273">2273</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2274">2274</td><td class="line">      } <span class='comment'>/* rhs integer path  */</span></td></tr>
<tr><td class="num" id="LN2275">2275</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2276">2276</td><td class="line">    <span class='comment'>/* reduce result to the requested length and copy to result  */</span></td></tr>
<tr><td class="num" id="LN2277">2277</td><td class="line">    decCopyFit(res, dac, set, &amp;residue, &amp;status);</td></tr>
<tr><td class="num" id="LN2278">2278</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, &amp;status)<span class='expansion'>decFinalize(res,set,&amp;residue,&amp;status)</span></span>;  <span class='comment'>/* final cleanup  */</span></td></tr>
<tr><td class="num" id="LN2279">2279</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2280">2280</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) decTrim(res, set, 0, 1, &amp;dropped); <span class='comment'>/* trailing zeros  */</span></td></tr>
<tr><td class="num" id="LN2281">2281</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2282">2282</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN2283">2283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2284">2284</td><td class="line">  <span class='keyword'>if</span> (allocdac!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocdac)<span class='expansion'>uprv_free_54(allocdac)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN2285">2285</td><td class="line">  <span class='keyword'>if</span> (allocinv!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocinv)<span class='expansion'>uprv_free_54(allocinv)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2286">2286</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2287">2287</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2288">2288</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2289">2289</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2290">2290</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2291">2291</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2292">2292</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN2293">2293</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2294">2294</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2295">2295</td><td class="line">  } <span class='comment'>/* decNumberPower  */</span></td></tr>
<tr><td class="num" id="LN2296">2296</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2297">2297</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2298">2298</td><td class="line"><span class='comment'>/* decNumberQuantize -- force exponent to requested value             */</span></td></tr>
<tr><td class="num" id="LN2299">2299</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2300">2300</td><td class="line"><span class='comment'>/*   This computes C = op(A, B), where op adjusts the coefficient     */</span></td></tr>
<tr><td class="num" id="LN2301">2301</td><td class="line"><span class='comment'>/*   of C (by rounding or shifting) such that the exponent (-scale)   */</span></td></tr>
<tr><td class="num" id="LN2302">2302</td><td class="line"><span class='comment'>/*   of C has exponent of B.  The numerical value of C will equal A,  */</span></td></tr>
<tr><td class="num" id="LN2303">2303</td><td class="line"><span class='comment'>/*   except for the effects of any rounding that occurred.            */</span></td></tr>
<tr><td class="num" id="LN2304">2304</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2305">2305</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A or B                           */</span></td></tr>
<tr><td class="num" id="LN2306">2306</td><td class="line"><span class='comment'>/*   lhs is A, the number to adjust                                   */</span></td></tr>
<tr><td class="num" id="LN2307">2307</td><td class="line"><span class='comment'>/*   rhs is B, the number with exponent to match                      */</span></td></tr>
<tr><td class="num" id="LN2308">2308</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2309">2309</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2310">2310</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2311">2311</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2312">2312</td><td class="line"><span class='comment'>/* Unless there is an error or the result is infinite, the exponent   */</span></td></tr>
<tr><td class="num" id="LN2313">2313</td><td class="line"><span class='comment'>/* after the operation is guaranteed to be equal to that of B.        */</span></td></tr>
<tr><td class="num" id="LN2314">2314</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2315">2315</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberQuantize<span class='expansion'>uprv_decNumberQuantize_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2316">2316</td><td class="line">                              <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2317">2317</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2318">2318</td><td class="line">  decQuantizeOp(res, lhs, rhs, set, 1, &amp;status);</td></tr>
<tr><td class="num" id="LN2319">2319</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2320">2320</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2321">2321</td><td class="line">  } <span class='comment'>/* decNumberQuantize  */</span></td></tr>
<tr><td class="num" id="LN2322">2322</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2323">2323</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2324">2324</td><td class="line"><span class='comment'>/* decNumberReduce -- remove trailing zeros                           */</span></td></tr>
<tr><td class="num" id="LN2325">2325</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2326">2326</td><td class="line"><span class='comment'>/*   This computes C = 0 + A, and normalizes the result               */</span></td></tr>
<tr><td class="num" id="LN2327">2327</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2328">2328</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN2329">2329</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2330">2330</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2331">2331</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2332">2332</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2333">2333</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2334">2334</td><td class="line"><span class='comment'>/* Previously known as Normalize  */</span></td></tr>
<tr><td class="num" id="LN2335">2335</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberNormalize<span class='expansion'>uprv_decNumberNormalize_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN2336">2336</td><td class="line">                               decContext *set) {</td></tr>
<tr><td class="num" id="LN2337">2337</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>uprv_decNumberReduce<span class='expansion'>uprv_decNumberReduce_54</span></span>(res, rhs, set);</td></tr>
<tr><td class="num" id="LN2338">2338</td><td class="line">  } <span class='comment'>/* decNumberNormalize  */</span></td></tr>
<tr><td class="num" id="LN2339">2339</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2340">2340</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberReduce<span class='expansion'>uprv_decNumberReduce_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN2341">2341</td><td class="line">                            decContext *set) {</td></tr>
<tr><td class="num" id="LN2342">2342</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2343">2343</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded rhs allocated  */</span></td></tr>
<tr><td class="num" id="LN2344">2344</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2345">2345</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* as usual  */</span></td></tr>
<tr><td class="num" id="LN2346">2346</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  residue=0;                  <span class='comment'>/* as usual  */</span></td></tr>
<tr><td class="num" id="LN2347">2347</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  dropped;                    <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN2348">2348</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2349">2349</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2350">2350</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2351">2351</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2352">2352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2353">2353</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN2354">2354</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2355">2355</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN2356">2356</td><td class="line">      <span class='comment'>/* reduce operand and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN2357">2357</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN2358">2358</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2359">2359</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2360">2360</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN2361">2361</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2362">2362</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2363">2363</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2364">2364</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN2365">2365</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2366">2366</td><td class="line">    <span class='comment'>/* Infinities copy through; NaNs need usual treatment  */</span></td></tr>
<tr><td class="num" id="LN2367">2367</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN2368">2368</td><td class="line">      decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2369">2369</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2370">2370</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2371">2371</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2372">2372</td><td class="line">    <span class='comment'>/* reduce result to the requested length and copy to result  */</span></td></tr>
<tr><td class="num" id="LN2373">2373</td><td class="line">    decCopyFit(res, rhs, set, &amp;residue, &amp;status); <span class='comment'>/* copy &amp; round  */</span></td></tr>
<tr><td class="num" id="LN2374">2374</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, &amp;status)<span class='expansion'>decFinalize(res,set,&amp;residue,&amp;status)</span></span>;       <span class='comment'>/* cleanup/set flags  */</span></td></tr>
<tr><td class="num" id="LN2375">2375</td><td class="line">    decTrim(res, set, 1, 0, &amp;dropped);            <span class='comment'>/* normalize in place  */</span></td></tr>
<tr><td class="num" id="LN2376">2376</td><td class="line">                                                  <span class='comment'>/* [may clamp]  */</span></td></tr>
<tr><td class="num" id="LN2377">2377</td><td class="line">    } <span class='keyword'>while</span>(0);                              <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN2378">2378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2379">2379</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2380">2380</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2381">2381</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2382">2382</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);<span class='comment'>/* then report status  */</span></td></tr>
<tr><td class="num" id="LN2383">2383</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2384">2384</td><td class="line">  } <span class='comment'>/* decNumberReduce  */</span></td></tr>
<tr><td class="num" id="LN2385">2385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2386">2386</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2387">2387</td><td class="line"><span class='comment'>/* decNumberRescale -- force exponent to requested value              */</span></td></tr>
<tr><td class="num" id="LN2388">2388</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2389">2389</td><td class="line"><span class='comment'>/*   This computes C = op(A, B), where op adjusts the coefficient     */</span></td></tr>
<tr><td class="num" id="LN2390">2390</td><td class="line"><span class='comment'>/*   of C (by rounding or shifting) such that the exponent (-scale)   */</span></td></tr>
<tr><td class="num" id="LN2391">2391</td><td class="line"><span class='comment'>/*   of C has the value B.  The numerical value of C will equal A,    */</span></td></tr>
<tr><td class="num" id="LN2392">2392</td><td class="line"><span class='comment'>/*   except for the effects of any rounding that occurred.            */</span></td></tr>
<tr><td class="num" id="LN2393">2393</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2394">2394</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A or B                           */</span></td></tr>
<tr><td class="num" id="LN2395">2395</td><td class="line"><span class='comment'>/*   lhs is A, the number to adjust                                   */</span></td></tr>
<tr><td class="num" id="LN2396">2396</td><td class="line"><span class='comment'>/*   rhs is B, the requested exponent                                 */</span></td></tr>
<tr><td class="num" id="LN2397">2397</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2398">2398</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2399">2399</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2400">2400</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2401">2401</td><td class="line"><span class='comment'>/* Unless there is an error or the result is infinite, the exponent   */</span></td></tr>
<tr><td class="num" id="LN2402">2402</td><td class="line"><span class='comment'>/* after the operation is guaranteed to be equal to B.                */</span></td></tr>
<tr><td class="num" id="LN2403">2403</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2404">2404</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberRescale<span class='expansion'>uprv_decNumberRescale_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2405">2405</td><td class="line">                             <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2406">2406</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2407">2407</td><td class="line">  decQuantizeOp(res, lhs, rhs, set, 0, &amp;status);</td></tr>
<tr><td class="num" id="LN2408">2408</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2409">2409</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2410">2410</td><td class="line">  } <span class='comment'>/* decNumberRescale  */</span></td></tr>
<tr><td class="num" id="LN2411">2411</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2412">2412</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2413">2413</td><td class="line"><span class='comment'>/* decNumberRemainder -- divide and return remainder                  */</span></td></tr>
<tr><td class="num" id="LN2414">2414</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2415">2415</td><td class="line"><span class='comment'>/*   This computes C = A % B                                          */</span></td></tr>
<tr><td class="num" id="LN2416">2416</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2417">2417</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X%X)         */</span></td></tr>
<tr><td class="num" id="LN2418">2418</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2419">2419</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN2420">2420</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2421">2421</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2422">2422</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2423">2423</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2424">2424</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberRemainder<span class='expansion'>uprv_decNumberRemainder_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2425">2425</td><td class="line">                               <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2426">2426</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2427">2427</td><td class="line">  decDivideOp(res, lhs, rhs, set, <span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN2428">2428</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2429">2429</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2430">2430</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN2431">2431</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2432">2432</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2433">2433</td><td class="line">  } <span class='comment'>/* decNumberRemainder  */</span></td></tr>
<tr><td class="num" id="LN2434">2434</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2435">2435</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2436">2436</td><td class="line"><span class='comment'>/* decNumberRemainderNear -- divide and return remainder from nearest */</span></td></tr>
<tr><td class="num" id="LN2437">2437</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2438">2438</td><td class="line"><span class='comment'>/*   This computes C = A % B, where % is the IEEE remainder operator  */</span></td></tr>
<tr><td class="num" id="LN2439">2439</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2440">2440</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X%X)         */</span></td></tr>
<tr><td class="num" id="LN2441">2441</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2442">2442</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN2443">2443</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2444">2444</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2445">2445</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2446">2446</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2447">2447</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberRemainderNear<span class='expansion'>uprv_decNumberRemainderNear_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2448">2448</td><td class="line">                                   <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2449">2449</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2450">2450</td><td class="line">  decDivideOp(res, lhs, rhs, set, <span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN2451">2451</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2452">2452</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2453">2453</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN2454">2454</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2455">2455</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2456">2456</td><td class="line">  } <span class='comment'>/* decNumberRemainderNear  */</span></td></tr>
<tr><td class="num" id="LN2457">2457</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2458">2458</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2459">2459</td><td class="line"><span class='comment'>/* decNumberRotate -- rotate the coefficient of a Number left/right   */</span></td></tr>
<tr><td class="num" id="LN2460">2460</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2461">2461</td><td class="line"><span class='comment'>/*   This computes C = A rot B  (in base ten and rotating set-&gt;digits */</span></td></tr>
<tr><td class="num" id="LN2462">2462</td><td class="line"><span class='comment'>/*   digits).                                                         */</span></td></tr>
<tr><td class="num" id="LN2463">2463</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2464">2464</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=XrotX)       */</span></td></tr>
<tr><td class="num" id="LN2465">2465</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2466">2466</td><td class="line"><span class='comment'>/*   rhs is B, the number of digits to rotate (-ve to right)          */</span></td></tr>
<tr><td class="num" id="LN2467">2467</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2468">2468</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2469">2469</td><td class="line"><span class='comment'>/* The digits of the coefficient of A are rotated to the left (if B   */</span></td></tr>
<tr><td class="num" id="LN2470">2470</td><td class="line"><span class='comment'>/* is positive) or to the right (if B is negative) without adjusting  */</span></td></tr>
<tr><td class="num" id="LN2471">2471</td><td class="line"><span class='comment'>/* the exponent or the sign of A.  If lhs-&gt;digits is less than        */</span></td></tr>
<tr><td class="num" id="LN2472">2472</td><td class="line"><span class='comment'>/* set-&gt;digits the coefficient is padded with zeros on the left       */</span></td></tr>
<tr><td class="num" id="LN2473">2473</td><td class="line"><span class='comment'>/* before the rotate.  Any leading zeros in the result are removed    */</span></td></tr>
<tr><td class="num" id="LN2474">2474</td><td class="line"><span class='comment'>/* as usual.                                                          */</span></td></tr>
<tr><td class="num" id="LN2475">2475</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2476">2476</td><td class="line"><span class='comment'>/* B must be an integer (q=0) and in the range -set-&gt;digits through   */</span></td></tr>
<tr><td class="num" id="LN2477">2477</td><td class="line"><span class='comment'>/* +set-&gt;digits.                                                      */</span></td></tr>
<tr><td class="num" id="LN2478">2478</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2479">2479</td><td class="line"><span class='comment'>/* NaNs are propagated as usual.  Infinities are unaffected (but      */</span></td></tr>
<tr><td class="num" id="LN2480">2480</td><td class="line"><span class='comment'>/* B must be valid).  No status is set unless B is invalid or an      */</span></td></tr>
<tr><td class="num" id="LN2481">2481</td><td class="line"><span class='comment'>/* operand is an sNaN.                                                */</span></td></tr>
<tr><td class="num" id="LN2482">2482</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2483">2483</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberRotate<span class='expansion'>uprv_decNumberRotate_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2484">2484</td><td class="line">                           <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2485">2485</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;              <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2486">2486</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  rotate;                <span class='comment'>/* rhs as an Int  */</span></td></tr>
<tr><td class="num" id="LN2487">2487</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2488">2488</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2489">2489</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2490">2490</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2491">2491</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2492">2492</td><td class="line">  <span class='comment'>/* NaNs propagate as normal  */</span></td></tr>
<tr><td class="num" id="LN2493">2493</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>)</td></tr>
<tr><td class="num" id="LN2494">2494</td><td class="line">    decNaNs(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2495">2495</td><td class="line">   <span class='comment'>/* rhs must be an integer  */</span></td></tr>
<tr><td class="num" id="LN2496">2496</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span> || rhs-&gt;exponent!=0)</td></tr>
<tr><td class="num" id="LN2497">2497</td><td class="line">    status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2498">2498</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* both numeric, rhs is an integer  */</span></td></tr>
<tr><td class="num" id="LN2499">2499</td><td class="line">    rotate=decGetInt(rhs);                   <span class='comment'>/* [cannot fail]  */</span></td></tr>
<tr><td class="num" id="LN2500">2500</td><td class="line">    <span class='keyword'>if</span> (rotate==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>                       <span class='comment'>/* something bad ..  */</span></td></tr>
<tr><td class="num" id="LN2501">2501</td><td class="line">     || rotate==<span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span> || rotate==<span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span>    <span class='comment'>/* .. very big ..  */</span></td></tr>
<tr><td class="num" id="LN2502">2502</td><td class="line">     || abs(rotate)&gt;set-&gt;digits)             <span class='comment'>/* .. or out of range  */</span></td></tr>
<tr><td class="num" id="LN2503">2503</td><td class="line">      status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2504">2504</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* rhs is OK  */</span></td></tr>
<tr><td class="num" id="LN2505">2505</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);</td></tr>
<tr><td class="num" id="LN2506">2506</td><td class="line">      <span class='comment'>/* convert -ve rotate to equivalent positive rotation  */</span></td></tr>
<tr><td class="num" id="LN2507">2507</td><td class="line">      <span class='keyword'>if</span> (rotate&lt;0) rotate=set-&gt;digits+rotate;</td></tr>
<tr><td class="num" id="LN2508">2508</td><td class="line">      <span class='keyword'>if</span> (rotate!=0 &amp;&amp; rotate!=set-&gt;digits   <span class='comment'>/* zero or full rotation  */</span></td></tr>
<tr><td class="num" id="LN2509">2509</td><td class="line">       &amp;&amp; !<span class='macro'>decNumberIsInfinite(res)<span class='expansion'>(((res)-&gt;bits&amp;0x40)!=0)</span></span>) {       <span class='comment'>/* lhs was infinite  */</span></td></tr>
<tr><td class="num" id="LN2510">2510</td><td class="line">        <span class='comment'>/* left-rotate to do; 0 &lt; rotate &lt; set-&gt;digits  */</span></td></tr>
<tr><td class="num" id="LN2511">2511</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> units, shift;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN2512">2512</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> msudigits;                      <span class='comment'>/* digits in result msu  */</span></td></tr>
<tr><td class="num" id="LN2513">2513</td><td class="line">        <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msu=res-&gt;lsu+<span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>-1;    <span class='comment'>/* current msu  */</span></td></tr>
<tr><td class="num" id="LN2514">2514</td><td class="line">        <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msumax=res-&gt;lsu+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>-1; <span class='comment'>/* rotation msu  */</span></td></tr>
<tr><td class="num" id="LN2515">2515</td><td class="line">        <span class='keyword'>for</span> (msu++; msu&lt;=msumax; msu++) *msu=0;   <span class='comment'>/* ensure high units=0  */</span></td></tr>
<tr><td class="num" id="LN2516">2516</td><td class="line">        res-&gt;digits=set-&gt;digits;                  <span class='comment'>/* now full-length  */</span></td></tr>
<tr><td class="num" id="LN2517">2517</td><td class="line">        msudigits=<span class='macro'>MSUDIGITS(res-&gt;digits)<span class='expansion'>((res-&gt;digits)-(((res-&gt;digits)&lt;=49?d2utable[res-&gt;<br>digits]:((res-&gt;digits)+1 -1)/1)-1)*1)</span></span>;         <span class='comment'>/* actual digits in msu  */</span></td></tr>
<tr><td class="num" id="LN2518">2518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2519">2519</td><td class="line">        <span class='comment'>/* rotation here is done in-place, in three steps  */</span></td></tr>
<tr><td class="num" id="LN2520">2520</td><td class="line">        <span class='comment'>/* 1. shift all to least up to one unit to unit-align final  */</span></td></tr>
<tr><td class="num" id="LN2521">2521</td><td class="line">        <span class='comment'>/*    lsd [any digits shifted out are rotated to the left,  */</span></td></tr>
<tr><td class="num" id="LN2522">2522</td><td class="line">        <span class='comment'>/*    abutted to the original msd (which may require split)]  */</span></td></tr>
<tr><td class="num" id="LN2523">2523</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2524">2524</td><td class="line">        <span class='comment'>/*    [if there are no whole units left to rotate, the  */</span></td></tr>
<tr><td class="num" id="LN2525">2525</td><td class="line">        <span class='comment'>/*    rotation is now complete]  */</span></td></tr>
<tr><td class="num" id="LN2526">2526</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2527">2527</td><td class="line">        <span class='comment'>/* 2. shift to least, from below the split point only, so that  */</span></td></tr>
<tr><td class="num" id="LN2528">2528</td><td class="line">        <span class='comment'>/*    the final msd is in the right place in its Unit [any  */</span></td></tr>
<tr><td class="num" id="LN2529">2529</td><td class="line">        <span class='comment'>/*    digits shifted out will fit exactly in the current msu,  */</span></td></tr>
<tr><td class="num" id="LN2530">2530</td><td class="line">        <span class='comment'>/*    left aligned, no split required]  */</span></td></tr>
<tr><td class="num" id="LN2531">2531</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2532">2532</td><td class="line">        <span class='comment'>/* 3. rotate all the units by reversing left part, right  */</span></td></tr>
<tr><td class="num" id="LN2533">2533</td><td class="line">        <span class='comment'>/*    part, and then whole  */</span></td></tr>
<tr><td class="num" id="LN2534">2534</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2535">2535</td><td class="line">        <span class='comment'>/* example: rotate right 8 digits (2 units + 2), DECDPUN=3.  */</span></td></tr>
<tr><td class="num" id="LN2536">2536</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2537">2537</td><td class="line">        <span class='comment'>/*   start: 00a bcd efg hij klm npq  */</span></td></tr>
<tr><td class="num" id="LN2538">2538</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2539">2539</td><td class="line">        <span class='comment'>/*      1a  000 0ab cde fgh|ijk lmn [pq saved]  */</span></td></tr>
<tr><td class="num" id="LN2540">2540</td><td class="line">        <span class='comment'>/*      1b  00p qab cde fgh|ijk lmn  */</span></td></tr>
<tr><td class="num" id="LN2541">2541</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2542">2542</td><td class="line">        <span class='comment'>/*      2a  00p qab cde fgh|00i jkl [mn saved]  */</span></td></tr>
<tr><td class="num" id="LN2543">2543</td><td class="line">        <span class='comment'>/*      2b  mnp qab cde fgh|00i jkl  */</span></td></tr>
<tr><td class="num" id="LN2544">2544</td><td class="line">        <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2545">2545</td><td class="line">        <span class='comment'>/*      3a  fgh cde qab mnp|00i jkl  */</span></td></tr>
<tr><td class="num" id="LN2546">2546</td><td class="line">        <span class='comment'>/*      3b  fgh cde qab mnp|jkl 00i  */</span></td></tr>
<tr><td class="num" id="LN2547">2547</td><td class="line">        <span class='comment'>/*      3c  00i jkl mnp qab cde fgh  */</span></td></tr>
<tr><td class="num" id="LN2548">2548</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2549">2549</td><td class="line">        <span class='comment'>/* Step 1: amount to shift is the partial right-rotate count  */</span></td></tr>
<tr><td class="num" id="LN2550">2550</td><td class="line">        rotate=set-&gt;digits-rotate;      <span class='comment'>/* make it right-rotate  */</span></td></tr>
<tr><td class="num" id="LN2551">2551</td><td class="line">        units=rotate/<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;           <span class='comment'>/* whole units to rotate  */</span></td></tr>
<tr><td class="num" id="LN2552">2552</td><td class="line">        shift=rotate%<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;           <span class='comment'>/* left-over digits count  */</span></td></tr>
<tr><td class="num" id="LN2553">2553</td><td class="line">        <span class='keyword'>if</span> (shift&gt;0) {                  <span class='comment'>/* not an exact number of units  */</span></td></tr>
<tr><td class="num" id="LN2554">2554</td><td class="line">          <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> save=res-&gt;lsu[0]%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[shift];    <span class='comment'>/* save low digit(s)  */</span></td></tr>
<tr><td class="num" id="LN2555">2555</td><td class="line">          decShiftToLeast(res-&gt;lsu, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>, shift);</td></tr>
<tr><td class="num" id="LN2556">2556</td><td class="line">          <span class='keyword'>if</span> (shift&gt;msudigits) {        <span class='comment'>/* msumax-1 needs &gt;0 digits  */</span></td></tr>
<tr><td class="num" id="LN2557">2557</td><td class="line">            <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> rem=save%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[shift-msudigits];<span class='comment'>/* split save  */</span></td></tr>
<tr><td class="num" id="LN2558">2558</td><td class="line">            *msumax=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(save/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[shift-msudigits]); <span class='comment'>/* and insert  */</span></td></tr>
<tr><td class="num" id="LN2559">2559</td><td class="line">            *(msumax-1)=*(msumax-1)</td></tr>
<tr><td class="num" id="LN2560">2560</td><td class="line">                       +(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(rem*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-(shift-msudigits)]); <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2561">2561</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2562">2562</td><td class="line">           <span class='keyword'>else</span> { <span class='comment'>/* all fits in msumax  */</span></td></tr>
<tr><td class="num" id="LN2563">2563</td><td class="line">            *msumax=*msumax+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(save*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[msudigits-shift]); <span class='comment'>/* [maybe *1]  */</span></td></tr>
<tr><td class="num" id="LN2564">2564</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2565">2565</td><td class="line">          } <span class='comment'>/* digits shift needed  */</span></td></tr>
<tr><td class="num" id="LN2566">2566</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2567">2567</td><td class="line">        <span class='comment'>/* If whole units to rotate...  */</span></td></tr>
<tr><td class="num" id="LN2568">2568</td><td class="line">        <span class='keyword'>if</span> (units&gt;0) {                  <span class='comment'>/* some to do  */</span></td></tr>
<tr><td class="num" id="LN2569">2569</td><td class="line">          <span class='comment'>/* Step 2: the units to touch are the whole ones in rotate,  */</span></td></tr>
<tr><td class="num" id="LN2570">2570</td><td class="line">          <span class='comment'>/*   if any, and the shift is DECDPUN-msudigits (which may be  */</span></td></tr>
<tr><td class="num" id="LN2571">2571</td><td class="line">          <span class='comment'>/*   0, again)  */</span></td></tr>
<tr><td class="num" id="LN2572">2572</td><td class="line">          shift=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-msudigits;</td></tr>
<tr><td class="num" id="LN2573">2573</td><td class="line">          <span class='keyword'>if</span> (shift&gt;0) {                <span class='comment'>/* not an exact number of units  */</span></td></tr>
<tr><td class="num" id="LN2574">2574</td><td class="line">            <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> save=res-&gt;lsu[0]%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[shift];  <span class='comment'>/* save low digit(s)  */</span></td></tr>
<tr><td class="num" id="LN2575">2575</td><td class="line">            decShiftToLeast(res-&gt;lsu, units, shift);</td></tr>
<tr><td class="num" id="LN2576">2576</td><td class="line">            *msumax=*msumax+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(save*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[msudigits]);</td></tr>
<tr><td class="num" id="LN2577">2577</td><td class="line">            } <span class='comment'>/* partial shift needed  */</span></td></tr>
<tr><td class="num" id="LN2578">2578</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2579">2579</td><td class="line">          <span class='comment'>/* Step 3: rotate the units array using triple reverse  */</span></td></tr>
<tr><td class="num" id="LN2580">2580</td><td class="line">          <span class='comment'>/* (reversing is easy and fast)  */</span></td></tr>
<tr><td class="num" id="LN2581">2581</td><td class="line">          decReverse(res-&gt;lsu+units, msumax);     <span class='comment'>/* left part  */</span></td></tr>
<tr><td class="num" id="LN2582">2582</td><td class="line">          decReverse(res-&gt;lsu, res-&gt;lsu+units-1); <span class='comment'>/* right part  */</span></td></tr>
<tr><td class="num" id="LN2583">2583</td><td class="line">          decReverse(res-&gt;lsu, msumax);           <span class='comment'>/* whole  */</span></td></tr>
<tr><td class="num" id="LN2584">2584</td><td class="line">          } <span class='comment'>/* whole units to rotate  */</span></td></tr>
<tr><td class="num" id="LN2585">2585</td><td class="line">        <span class='comment'>/* the rotation may have left an undetermined number of zeros  */</span></td></tr>
<tr><td class="num" id="LN2586">2586</td><td class="line">        <span class='comment'>/* on the left, so true length needs to be calculated  */</span></td></tr>
<tr><td class="num" id="LN2587">2587</td><td class="line">        res-&gt;digits=decGetDigits(res-&gt;lsu, msumax-res-&gt;lsu+1);</td></tr>
<tr><td class="num" id="LN2588">2588</td><td class="line">        } <span class='comment'>/* rotate needed  */</span></td></tr>
<tr><td class="num" id="LN2589">2589</td><td class="line">      } <span class='comment'>/* rhs OK  */</span></td></tr>
<tr><td class="num" id="LN2590">2590</td><td class="line">    } <span class='comment'>/* numerics  */</span></td></tr>
<tr><td class="num" id="LN2591">2591</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2592">2592</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2593">2593</td><td class="line">  } <span class='comment'>/* decNumberRotate  */</span></td></tr>
<tr><td class="num" id="LN2594">2594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2595">2595</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2596">2596</td><td class="line"><span class='comment'>/* decNumberSameQuantum -- test for equal exponents                   */</span></td></tr>
<tr><td class="num" id="LN2597">2597</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2598">2598</td><td class="line"><span class='comment'>/*   res is the result number, which will contain either 0 or 1       */</span></td></tr>
<tr><td class="num" id="LN2599">2599</td><td class="line"><span class='comment'>/*   lhs is a number to test                                          */</span></td></tr>
<tr><td class="num" id="LN2600">2600</td><td class="line"><span class='comment'>/*   rhs is the second (usually a pattern)                            */</span></td></tr>
<tr><td class="num" id="LN2601">2601</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2602">2602</td><td class="line"><span class='comment'>/* No errors are possible and no context is needed.                   */</span></td></tr>
<tr><td class="num" id="LN2603">2603</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2604">2604</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberSameQuantum<span class='expansion'>uprv_decNumberSameQuantum_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2605">2605</td><td class="line">                                 <span class='keyword'>const</span> decNumber *rhs) {</td></tr>
<tr><td class="num" id="LN2606">2606</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> ret=0;                      <span class='comment'>/* return value  */</span></td></tr>
<tr><td class="num" id="LN2607">2607</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2608">2608</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2609">2609</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, DECUNCONT)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2610">2610</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2611">2611</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2612">2612</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {</td></tr>
<tr><td class="num" id="LN2613">2613</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> &amp;&amp; <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) ret=1;</td></tr>
<tr><td class="num" id="LN2614">2614</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x40)!=0)</span></span> &amp;&amp; <span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) ret=1;</td></tr>
<tr><td class="num" id="LN2615">2615</td><td class="line">     <span class='comment'>/* [anything else with a special gives 0]  */</span></td></tr>
<tr><td class="num" id="LN2616">2616</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2617">2617</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (lhs-&gt;exponent==rhs-&gt;exponent) ret=1;</td></tr>
<tr><td class="num" id="LN2618">2618</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2619">2619</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);              <span class='comment'>/* OK to overwrite an operand now  */</span></td></tr>
<tr><td class="num" id="LN2620">2620</td><td class="line">  *res-&gt;lsu=ret;</td></tr>
<tr><td class="num" id="LN2621">2621</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2622">2622</td><td class="line">  } <span class='comment'>/* decNumberSameQuantum  */</span></td></tr>
<tr><td class="num" id="LN2623">2623</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2624">2624</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2625">2625</td><td class="line"><span class='comment'>/* decNumberScaleB -- multiply by a power of 10                       */</span></td></tr>
<tr><td class="num" id="LN2626">2626</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2627">2627</td><td class="line"><span class='comment'>/* This computes C = A x 10**B where B is an integer (q=0) with       */</span></td></tr>
<tr><td class="num" id="LN2628">2628</td><td class="line"><span class='comment'>/* maximum magnitude 2*(emax+digits)                                  */</span></td></tr>
<tr><td class="num" id="LN2629">2629</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2630">2630</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A or B                           */</span></td></tr>
<tr><td class="num" id="LN2631">2631</td><td class="line"><span class='comment'>/*   lhs is A, the number to adjust                                   */</span></td></tr>
<tr><td class="num" id="LN2632">2632</td><td class="line"><span class='comment'>/*   rhs is B, the requested power of ten to use                      */</span></td></tr>
<tr><td class="num" id="LN2633">2633</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2634">2634</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2635">2635</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2636">2636</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2637">2637</td><td class="line"><span class='comment'>/* The result may underflow or overflow.                              */</span></td></tr>
<tr><td class="num" id="LN2638">2638</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2639">2639</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberScaleB<span class='expansion'>uprv_decNumberScaleB_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2640">2640</td><td class="line">                            <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2641">2641</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  reqexp;                <span class='comment'>/* requested exponent change [B]  */</span></td></tr>
<tr><td class="num" id="LN2642">2642</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;              <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2643">2643</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  residue;               <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN2644">2644</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2645">2645</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2646">2646</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2647">2647</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2648">2648</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2649">2649</td><td class="line">  <span class='comment'>/* Handle special values except lhs infinite  */</span></td></tr>
<tr><td class="num" id="LN2650">2650</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>)</td></tr>
<tr><td class="num" id="LN2651">2651</td><td class="line">    decNaNs(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2652">2652</td><td class="line">    <span class='comment'>/* rhs must be an integer  */</span></td></tr>
<tr><td class="num" id="LN2653">2653</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span> || rhs-&gt;exponent!=0)</td></tr>
<tr><td class="num" id="LN2654">2654</td><td class="line">    status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2655">2655</td><td class="line">   <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2656">2656</td><td class="line">    <span class='comment'>/* lhs is a number; rhs is a finite with q==0  */</span></td></tr>
<tr><td class="num" id="LN2657">2657</td><td class="line">    reqexp=decGetInt(rhs);                   <span class='comment'>/* [cannot fail]  */</span></td></tr>
<tr><td class="num" id="LN2658">2658</td><td class="line">    <span class='keyword'>if</span> (reqexp==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>                       <span class='comment'>/* something bad ..  */</span></td></tr>
<tr><td class="num" id="LN2659">2659</td><td class="line">     || reqexp==<span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span> || reqexp==<span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span>    <span class='comment'>/* .. very big ..  */</span></td></tr>
<tr><td class="num" id="LN2660">2660</td><td class="line">     || abs(reqexp)&gt;(2*(set-&gt;digits+set-&gt;emax))) <span class='comment'>/* .. or out of range  */</span></td></tr>
<tr><td class="num" id="LN2661">2661</td><td class="line">      status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2662">2662</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* rhs is OK  */</span></td></tr>
<tr><td class="num" id="LN2663">2663</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);               <span class='comment'>/* all done if infinite lhs  */</span></td></tr>
<tr><td class="num" id="LN2664">2664</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>decNumberIsInfinite(res)<span class='expansion'>(((res)-&gt;bits&amp;0x40)!=0)</span></span>) {       <span class='comment'>/* prepare to scale  */</span></td></tr>
<tr><td class="num" id="LN2665">2665</td><td class="line">        res-&gt;exponent+=reqexp;               <span class='comment'>/* adjust the exponent  */</span></td></tr>
<tr><td class="num" id="LN2666">2666</td><td class="line">        residue=0;</td></tr>
<tr><td class="num" id="LN2667">2667</td><td class="line">        decFinalize(res, set, &amp;residue, &amp;status); <span class='comment'>/* .. and check  */</span></td></tr>
<tr><td class="num" id="LN2668">2668</td><td class="line">        } <span class='comment'>/* finite LHS  */</span></td></tr>
<tr><td class="num" id="LN2669">2669</td><td class="line">      } <span class='comment'>/* rhs OK  */</span></td></tr>
<tr><td class="num" id="LN2670">2670</td><td class="line">    } <span class='comment'>/* rhs finite  */</span></td></tr>
<tr><td class="num" id="LN2671">2671</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2672">2672</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2673">2673</td><td class="line">  } <span class='comment'>/* decNumberScaleB  */</span></td></tr>
<tr><td class="num" id="LN2674">2674</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2675">2675</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2676">2676</td><td class="line"><span class='comment'>/* decNumberShift -- shift the coefficient of a Number left or right  */</span></td></tr>
<tr><td class="num" id="LN2677">2677</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2678">2678</td><td class="line"><span class='comment'>/*   This computes C = A &lt;&lt; B or C = A &gt;&gt; -B  (in base ten).          */</span></td></tr>
<tr><td class="num" id="LN2679">2679</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2680">2680</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X&lt;&lt;X)        */</span></td></tr>
<tr><td class="num" id="LN2681">2681</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2682">2682</td><td class="line"><span class='comment'>/*   rhs is B, the number of digits to shift (-ve to right)           */</span></td></tr>
<tr><td class="num" id="LN2683">2683</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN2684">2684</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2685">2685</td><td class="line"><span class='comment'>/* The digits of the coefficient of A are shifted to the left (if B   */</span></td></tr>
<tr><td class="num" id="LN2686">2686</td><td class="line"><span class='comment'>/* is positive) or to the right (if B is negative) without adjusting  */</span></td></tr>
<tr><td class="num" id="LN2687">2687</td><td class="line"><span class='comment'>/* the exponent or the sign of A.                                     */</span></td></tr>
<tr><td class="num" id="LN2688">2688</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2689">2689</td><td class="line"><span class='comment'>/* B must be an integer (q=0) and in the range -set-&gt;digits through   */</span></td></tr>
<tr><td class="num" id="LN2690">2690</td><td class="line"><span class='comment'>/* +set-&gt;digits.                                                      */</span></td></tr>
<tr><td class="num" id="LN2691">2691</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2692">2692</td><td class="line"><span class='comment'>/* NaNs are propagated as usual.  Infinities are unaffected (but      */</span></td></tr>
<tr><td class="num" id="LN2693">2693</td><td class="line"><span class='comment'>/* B must be valid).  No status is set unless B is invalid or an      */</span></td></tr>
<tr><td class="num" id="LN2694">2694</td><td class="line"><span class='comment'>/* operand is an sNaN.                                                */</span></td></tr>
<tr><td class="num" id="LN2695">2695</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2696">2696</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberShift<span class='expansion'>uprv_decNumberShift_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN2697">2697</td><td class="line">                           <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN2698">2698</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;              <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN2699">2699</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  shift;                 <span class='comment'>/* rhs as an Int  */</span></td></tr>
<tr><td class="num" id="LN2700">2700</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2701">2701</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2702">2702</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2703">2703</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2704">2704</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2705">2705</td><td class="line">  <span class='comment'>/* NaNs propagate as normal  */</span></td></tr>
<tr><td class="num" id="LN2706">2706</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>)</td></tr>
<tr><td class="num" id="LN2707">2707</td><td class="line">    decNaNs(res, lhs, rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2708">2708</td><td class="line">   <span class='comment'>/* rhs must be an integer  */</span></td></tr>
<tr><td class="num" id="LN2709">2709</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span> || rhs-&gt;exponent!=0)</td></tr>
<tr><td class="num" id="LN2710">2710</td><td class="line">    status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2711">2711</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* both numeric, rhs is an integer  */</span></td></tr>
<tr><td class="num" id="LN2712">2712</td><td class="line">    shift=decGetInt(rhs);                    <span class='comment'>/* [cannot fail]  */</span></td></tr>
<tr><td class="num" id="LN2713">2713</td><td class="line">    <span class='keyword'>if</span> (shift==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>                        <span class='comment'>/* something bad ..  */</span></td></tr>
<tr><td class="num" id="LN2714">2714</td><td class="line">     || shift==<span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span> || shift==<span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span>      <span class='comment'>/* .. very big ..  */</span></td></tr>
<tr><td class="num" id="LN2715">2715</td><td class="line">     || abs(shift)&gt;set-&gt;digits)              <span class='comment'>/* .. or out of range  */</span></td></tr>
<tr><td class="num" id="LN2716">2716</td><td class="line">      status=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2717">2717</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* rhs is OK  */</span></td></tr>
<tr><td class="num" id="LN2718">2718</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);</td></tr>
<tr><td class="num" id="LN2719">2719</td><td class="line">      <span class='keyword'>if</span> (shift!=0 &amp;&amp; !<span class='macro'>decNumberIsInfinite(res)<span class='expansion'>(((res)-&gt;bits&amp;0x40)!=0)</span></span>) { <span class='comment'>/* something to do  */</span></td></tr>
<tr><td class="num" id="LN2720">2720</td><td class="line">        <span class='keyword'>if</span> (shift&gt;0) {                       <span class='comment'>/* to left  */</span></td></tr>
<tr><td class="num" id="LN2721">2721</td><td class="line">          <span class='keyword'>if</span> (shift==set-&gt;digits) {          <span class='comment'>/* removing all  */</span></td></tr>
<tr><td class="num" id="LN2722">2722</td><td class="line">            *res-&gt;lsu=0;                     <span class='comment'>/* so place 0  */</span></td></tr>
<tr><td class="num" id="LN2723">2723</td><td class="line">            res-&gt;digits=1;                   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2724">2724</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2725">2725</td><td class="line">           <span class='keyword'>else</span> {                            <span class='comment'>/*  */</span></td></tr>
<tr><td class="num" id="LN2726">2726</td><td class="line">            <span class='comment'>/* first remove leading digits if necessary  */</span></td></tr>
<tr><td class="num" id="LN2727">2727</td><td class="line">            <span class='keyword'>if</span> (res-&gt;digits+shift&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN2728">2728</td><td class="line">              decDecap(res, res-&gt;digits+shift-set-&gt;digits);</td></tr>
<tr><td class="num" id="LN2729">2729</td><td class="line">              <span class='comment'>/* that updated res-&gt;digits; may have gone to 1 (for a  */</span></td></tr>
<tr><td class="num" id="LN2730">2730</td><td class="line">              <span class='comment'>/* single digit or for zero  */</span></td></tr>
<tr><td class="num" id="LN2731">2731</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN2732">2732</td><td class="line">            <span class='keyword'>if</span> (res-&gt;digits&gt;1 || *res-&gt;lsu)  <span class='comment'>/* if non-zero..  */</span></td></tr>
<tr><td class="num" id="LN2733">2733</td><td class="line">              res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, shift);</td></tr>
<tr><td class="num" id="LN2734">2734</td><td class="line">            } <span class='comment'>/* partial left  */</span></td></tr>
<tr><td class="num" id="LN2735">2735</td><td class="line">          } <span class='comment'>/* left  */</span></td></tr>
<tr><td class="num" id="LN2736">2736</td><td class="line">         <span class='keyword'>else</span> { <span class='comment'>/* to right  */</span></td></tr>
<tr><td class="num" id="LN2737">2737</td><td class="line">          <span class='keyword'>if</span> (-shift&gt;=res-&gt;digits) {         <span class='comment'>/* discarding all  */</span></td></tr>
<tr><td class="num" id="LN2738">2738</td><td class="line">            *res-&gt;lsu=0;                     <span class='comment'>/* so place 0  */</span></td></tr>
<tr><td class="num" id="LN2739">2739</td><td class="line">            res-&gt;digits=1;                   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2740">2740</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2741">2741</td><td class="line">           <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2742">2742</td><td class="line">            decShiftToLeast(res-&gt;lsu, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>, -shift);</td></tr>
<tr><td class="num" id="LN2743">2743</td><td class="line">            res-&gt;digits-=(-shift);</td></tr>
<tr><td class="num" id="LN2744">2744</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2745">2745</td><td class="line">          } <span class='comment'>/* to right  */</span></td></tr>
<tr><td class="num" id="LN2746">2746</td><td class="line">        } <span class='comment'>/* non-0 non-Inf shift  */</span></td></tr>
<tr><td class="num" id="LN2747">2747</td><td class="line">      } <span class='comment'>/* rhs OK  */</span></td></tr>
<tr><td class="num" id="LN2748">2748</td><td class="line">    } <span class='comment'>/* numerics  */</span></td></tr>
<tr><td class="num" id="LN2749">2749</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN2750">2750</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2751">2751</td><td class="line">  } <span class='comment'>/* decNumberShift  */</span></td></tr>
<tr><td class="num" id="LN2752">2752</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2753">2753</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2754">2754</td><td class="line"><span class='comment'>/* decNumberSquareRoot -- square root operator                        */</span></td></tr>
<tr><td class="num" id="LN2755">2755</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2756">2756</td><td class="line"><span class='comment'>/*   This computes C = squareroot(A)                                  */</span></td></tr>
<tr><td class="num" id="LN2757">2757</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2758">2758</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN2759">2759</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN2760">2760</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN2761">2761</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2762">2762</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN2763">2763</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2764">2764</td><td class="line"><span class='comment'>/* This uses the following varying-precision algorithm in:            */</span></td></tr>
<tr><td class="num" id="LN2765">2765</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2766">2766</td><td class="line"><span class='comment'>/*   Properly Rounded Variable Precision Square Root, T. E. Hull and  */</span></td></tr>
<tr><td class="num" id="LN2767">2767</td><td class="line"><span class='comment'>/*   A. Abrham, ACM Transactions on Mathematical Software, Vol 11 #3, */</span></td></tr>
<tr><td class="num" id="LN2768">2768</td><td class="line"><span class='comment'>/*   pp229-237, ACM, September 1985.                                  */</span></td></tr>
<tr><td class="num" id="LN2769">2769</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2770">2770</td><td class="line"><span class='comment'>/* The square-root is calculated using Newton's method, after which   */</span></td></tr>
<tr><td class="num" id="LN2771">2771</td><td class="line"><span class='comment'>/* a check is made to ensure the result is correctly rounded.         */</span></td></tr>
<tr><td class="num" id="LN2772">2772</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2773">2773</td><td class="line"><span class='comment'>/* % [Reformatted original Numerical Turing source code follows.]     */</span></td></tr>
<tr><td class="num" id="LN2774">2774</td><td class="line"><span class='comment'>/* function sqrt(x : real) : real                                     */</span></td></tr>
<tr><td class="num" id="LN2775">2775</td><td class="line"><span class='comment'>/* % sqrt(x) returns the properly rounded approximation to the square */</span></td></tr>
<tr><td class="num" id="LN2776">2776</td><td class="line"><span class='comment'>/* % root of x, in the precision of the calling environment, or it    */</span></td></tr>
<tr><td class="num" id="LN2777">2777</td><td class="line"><span class='comment'>/* % fails if x &lt; 0.                                                  */</span></td></tr>
<tr><td class="num" id="LN2778">2778</td><td class="line"><span class='comment'>/* % t e hull and a abrham, august, 1984                              */</span></td></tr>
<tr><td class="num" id="LN2779">2779</td><td class="line"><span class='comment'>/* if x &lt;= 0 then                                                     */</span></td></tr>
<tr><td class="num" id="LN2780">2780</td><td class="line"><span class='comment'>/*   if x &lt; 0 then                                                    */</span></td></tr>
<tr><td class="num" id="LN2781">2781</td><td class="line"><span class='comment'>/*     assert false                                                   */</span></td></tr>
<tr><td class="num" id="LN2782">2782</td><td class="line"><span class='comment'>/*   else                                                             */</span></td></tr>
<tr><td class="num" id="LN2783">2783</td><td class="line"><span class='comment'>/*     result 0                                                       */</span></td></tr>
<tr><td class="num" id="LN2784">2784</td><td class="line"><span class='comment'>/*   end if                                                           */</span></td></tr>
<tr><td class="num" id="LN2785">2785</td><td class="line"><span class='comment'>/* end if                                                             */</span></td></tr>
<tr><td class="num" id="LN2786">2786</td><td class="line"><span class='comment'>/* var f := setexp(x, 0)  % fraction part of x   [0.1 &lt;= x &lt; 1]       */</span></td></tr>
<tr><td class="num" id="LN2787">2787</td><td class="line"><span class='comment'>/* var e := getexp(x)     % exponent part of x                        */</span></td></tr>
<tr><td class="num" id="LN2788">2788</td><td class="line"><span class='comment'>/* var approx : real                                                  */</span></td></tr>
<tr><td class="num" id="LN2789">2789</td><td class="line"><span class='comment'>/* if e mod 2 = 0  then                                               */</span></td></tr>
<tr><td class="num" id="LN2790">2790</td><td class="line"><span class='comment'>/*   approx := .259 + .819 * f   % approx to root of f                */</span></td></tr>
<tr><td class="num" id="LN2791">2791</td><td class="line"><span class='comment'>/* else                                                               */</span></td></tr>
<tr><td class="num" id="LN2792">2792</td><td class="line"><span class='comment'>/*   f := f/l0                   % adjustments                        */</span></td></tr>
<tr><td class="num" id="LN2793">2793</td><td class="line"><span class='comment'>/*   e := e + 1                  %   for odd                          */</span></td></tr>
<tr><td class="num" id="LN2794">2794</td><td class="line"><span class='comment'>/*   approx := .0819 + 2.59 * f  %   exponent                         */</span></td></tr>
<tr><td class="num" id="LN2795">2795</td><td class="line"><span class='comment'>/* end if                                                             */</span></td></tr>
<tr><td class="num" id="LN2796">2796</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2797">2797</td><td class="line"><span class='comment'>/* var p:= 3                                                          */</span></td></tr>
<tr><td class="num" id="LN2798">2798</td><td class="line"><span class='comment'>/* const maxp := currentprecision + 2                                 */</span></td></tr>
<tr><td class="num" id="LN2799">2799</td><td class="line"><span class='comment'>/* loop                                                               */</span></td></tr>
<tr><td class="num" id="LN2800">2800</td><td class="line"><span class='comment'>/*   p := min(2*p - 2, maxp)     % p = 4,6,10, . . . , maxp           */</span></td></tr>
<tr><td class="num" id="LN2801">2801</td><td class="line"><span class='comment'>/*   precision p                                                      */</span></td></tr>
<tr><td class="num" id="LN2802">2802</td><td class="line"><span class='comment'>/*   approx := .5 * (approx + f/approx)                               */</span></td></tr>
<tr><td class="num" id="LN2803">2803</td><td class="line"><span class='comment'>/*   exit when p = maxp                                               */</span></td></tr>
<tr><td class="num" id="LN2804">2804</td><td class="line"><span class='comment'>/* end loop                                                           */</span></td></tr>
<tr><td class="num" id="LN2805">2805</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN2806">2806</td><td class="line"><span class='comment'>/* % approx is now within 1 ulp of the properly rounded square root   */</span></td></tr>
<tr><td class="num" id="LN2807">2807</td><td class="line"><span class='comment'>/* % of f; to ensure proper rounding, compare squares of (approx -    */</span></td></tr>
<tr><td class="num" id="LN2808">2808</td><td class="line"><span class='comment'>/* % l/2 ulp) and (approx + l/2 ulp) with f.                          */</span></td></tr>
<tr><td class="num" id="LN2809">2809</td><td class="line"><span class='comment'>/* p := currentprecision                                              */</span></td></tr>
<tr><td class="num" id="LN2810">2810</td><td class="line"><span class='comment'>/* begin                                                              */</span></td></tr>
<tr><td class="num" id="LN2811">2811</td><td class="line"><span class='comment'>/*   precision p + 2                                                  */</span></td></tr>
<tr><td class="num" id="LN2812">2812</td><td class="line"><span class='comment'>/*   const approxsubhalf := approx - setexp(.5, -p)                   */</span></td></tr>
<tr><td class="num" id="LN2813">2813</td><td class="line"><span class='comment'>/*   if mulru(approxsubhalf, approxsubhalf) &gt; f then                  */</span></td></tr>
<tr><td class="num" id="LN2814">2814</td><td class="line"><span class='comment'>/*     approx := approx - setexp(.l, -p + 1)                          */</span></td></tr>
<tr><td class="num" id="LN2815">2815</td><td class="line"><span class='comment'>/*   else                                                             */</span></td></tr>
<tr><td class="num" id="LN2816">2816</td><td class="line"><span class='comment'>/*     const approxaddhalf := approx + setexp(.5, -p)                 */</span></td></tr>
<tr><td class="num" id="LN2817">2817</td><td class="line"><span class='comment'>/*     if mulrd(approxaddhalf, approxaddhalf) &lt; f then                */</span></td></tr>
<tr><td class="num" id="LN2818">2818</td><td class="line"><span class='comment'>/*       approx := approx + setexp(.l, -p + 1)                        */</span></td></tr>
<tr><td class="num" id="LN2819">2819</td><td class="line"><span class='comment'>/*     end if                                                         */</span></td></tr>
<tr><td class="num" id="LN2820">2820</td><td class="line"><span class='comment'>/*   end if                                                           */</span></td></tr>
<tr><td class="num" id="LN2821">2821</td><td class="line"><span class='comment'>/* end                                                                */</span></td></tr>
<tr><td class="num" id="LN2822">2822</td><td class="line"><span class='comment'>/* result setexp(approx, e div 2)  % fix exponent                     */</span></td></tr>
<tr><td class="num" id="LN2823">2823</td><td class="line"><span class='comment'>/* end sqrt                                                           */</span></td></tr>
<tr><td class="num" id="LN2824">2824</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN2825">2825</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN2826">2826</td><td class="line"><span class='directive'>#pragma GCC diagnostic push</span></td></tr>
<tr><td class="num" id="LN2827">2827</td><td class="line"><span class='directive'>#pragma GCC diagnostic ignored "-Warray-bounds"</span></td></tr>
<tr><td class="num" id="LN2828">2828</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2829">2829</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberSquareRoot<span class='expansion'>uprv_decNumberSquareRoot_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN2830">2830</td><td class="line">                                decContext *set) {</td></tr>
<tr><td class="num" id="LN2831">2831</td><td class="line">  decContext workset, approxset;   <span class='comment'>/* work contexts  */</span></td></tr>
<tr><td class="num" id="LN2832">2832</td><td class="line">  decNumber dzero;                 <span class='comment'>/* used for constant zero  */</span></td></tr>
<tr><td class="num" id="LN2833">2833</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  maxp;                       <span class='comment'>/* largest working precision  */</span></td></tr>
<tr><td class="num" id="LN2834">2834</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  workp;                      <span class='comment'>/* working precision  */</span></td></tr>
<tr><td class="num" id="LN2835">2835</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  residue=0;                  <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN2836">2836</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0, ignore=0;         <span class='comment'>/* status accumulators  */</span></td></tr>
<tr><td class="num" id="LN2837">2837</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> rstatus;                    <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2838">2838</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  exp;                        <span class='comment'>/* working exponent  */</span></td></tr>
<tr><td class="num" id="LN2839">2839</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  ideal;                      <span class='comment'>/* ideal (preferred) exponent  */</span></td></tr>
<tr><td class="num" id="LN2840">2840</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  needbytes;                  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN2841">2841</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  dropped;                    <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2842">2842</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2843">2843</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2844">2844</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded rhs allocated  */</span></td></tr>
<tr><td class="num" id="LN2845">2845</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2846">2846</td><td class="line">  <span class='comment'>/* buffer for f [needs +1 in case DECBUFFER 0]  */</span></td></tr>
<tr><td class="num" id="LN2847">2847</td><td class="line">  decNumber buff[<span class='macro'>D2N(DECBUFFER+1)<span class='expansion'>(((((((36 +1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN2848">2848</td><td class="line">  <span class='comment'>/* buffer for a [needs +2 to match likely maxp]  */</span></td></tr>
<tr><td class="num" id="LN2849">2849</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER+2)<span class='expansion'>(((((((36 +2)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN2850">2850</td><td class="line">  <span class='comment'>/* buffer for temporary, b [must be same size as a]  */</span></td></tr>
<tr><td class="num" id="LN2851">2851</td><td class="line">  decNumber bufb[<span class='macro'>D2N(DECBUFFER+2)<span class='expansion'>(((((((36 +2)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*<br>2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN2852">2852</td><td class="line">  decNumber *allocbuff=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated buff, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN2853">2853</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN2854">2854</td><td class="line">  decNumber *allocbufb=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufb, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN2855">2855</td><td class="line">  decNumber *f=buff;               <span class='comment'>/* reduced fraction  */</span></td></tr>
<tr><td class="num" id="LN2856">2856</td><td class="line">  decNumber *a=bufa;               <span class='comment'>/* approximation to result  */</span></td></tr>
<tr><td class="num" id="LN2857">2857</td><td class="line">  decNumber *b=bufb;               <span class='comment'>/* intermediate result  */</span></td></tr>
<tr><td class="num" id="LN2858">2858</td><td class="line">  <span class='comment'>/* buffer for temporary variable, up to 3 digits  */</span></td></tr>
<tr><td class="num" id="LN2859">2859</td><td class="line">  decNumber buft[<span class='macro'>D2N(3)<span class='expansion'>(((((((3)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*2-1)<br>/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN2860">2860</td><td class="line">  decNumber *t=buft;               <span class='comment'>/* up-to-3-digit constant or work  */</span></td></tr>
<tr><td class="num" id="LN2861">2861</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2862">2862</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2863">2863</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2864">2864</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2865">2865</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2866">2866</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN2867">2867</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN2868">2868</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN2869">2869</td><td class="line">      <span class='comment'>/* reduce operand and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN2870">2870</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN2871">2871</td><td class="line">        allocrhs=decRoundOperand(rhs, set, &amp;status);</td></tr>
<tr><td class="num" id="LN2872">2872</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2873">2873</td><td class="line">        <span class='comment'>/* [Note: 'f' allocation below could reuse this buffer if  */</span></td></tr>
<tr><td class="num" id="LN2874">2874</td><td class="line">        <span class='comment'>/* used, but as this is rare they are kept separate for clarity.]  */</span></td></tr>
<tr><td class="num" id="LN2875">2875</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN2876">2876</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2877">2877</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2878">2878</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2879">2879</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN2880">2880</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2881">2881</td><td class="line">    <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN2882">2882</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARG<span class='expansion'>(rhs-&gt;bits &amp; (0x40|0x20|0x10))</span></span>) {</td></tr>
<tr><td class="num" id="LN2883">2883</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) {         <span class='comment'>/* an infinity  */</span></td></tr>
<tr><td class="num" id="LN2884">2884</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2885">2885</td><td class="line">         <span class='keyword'>else</span> <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);        <span class='comment'>/* +Infinity  */</span></td></tr>
<tr><td class="num" id="LN2886">2886</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2887">2887</td><td class="line">       <span class='keyword'>else</span> decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, &amp;status); <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN2888">2888</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2889">2889</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2890">2890</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2891">2891</td><td class="line">    <span class='comment'>/* calculate the ideal (preferred) exponent [floor(exp/2)]  */</span></td></tr>
<tr><td class="num" id="LN2892">2892</td><td class="line">    <span class='comment'>/* [It would be nicer to write: ideal=rhs-&gt;exponent&gt;&gt;1, but this  */</span></td></tr>
<tr><td class="num" id="LN2893">2893</td><td class="line">    <span class='comment'>/* generates a compiler warning.  Generated code is the same.]  */</span></td></tr>
<tr><td class="num" id="LN2894">2894</td><td class="line">    ideal=(rhs-&gt;exponent&amp;~1)/2;         <span class='comment'>/* target  */</span></td></tr>
<tr><td class="num" id="LN2895">2895</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2896">2896</td><td class="line">    <span class='comment'>/* handle zeros  */</span></td></tr>
<tr><td class="num" id="LN2897">2897</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN2898">2898</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);          <span class='comment'>/* could be 0 or -0  */</span></td></tr>
<tr><td class="num" id="LN2899">2899</td><td class="line">      res-&gt;exponent=ideal;              <span class='comment'>/* use the ideal [safe]  */</span></td></tr>
<tr><td class="num" id="LN2900">2900</td><td class="line">      <span class='comment'>/* use decFinish to clamp any out-of-range exponent, etc.  */</span></td></tr>
<tr><td class="num" id="LN2901">2901</td><td class="line">      <span class='macro'>decFinish(res, set, &amp;residue, &amp;status)<span class='expansion'>decFinalize(res,set,&amp;residue,&amp;status)</span></span>;</td></tr>
<tr><td class="num" id="LN2902">2902</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2903">2903</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2904">2904</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2905">2905</td><td class="line">    <span class='comment'>/* any other -x is an oops  */</span></td></tr>
<tr><td class="num" id="LN2906">2906</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN2907">2907</td><td class="line">      status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN2908">2908</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2909">2909</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2910">2910</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2911">2911</td><td class="line">    <span class='comment'>/* space is needed for three working variables  */</span></td></tr>
<tr><td class="num" id="LN2912">2912</td><td class="line">    <span class='comment'>/*   f -- the same precision as the RHS, reduced to 0.01-&gt;0.99...  */</span></td></tr>
<tr><td class="num" id="LN2913">2913</td><td class="line">    <span class='comment'>/*   a -- Hull's approximation -- precision, when assigned, is  */</span></td></tr>
<tr><td class="num" id="LN2914">2914</td><td class="line">    <span class='comment'>/*        currentprecision+1 or the input argument precision,  */</span></td></tr>
<tr><td class="num" id="LN2915">2915</td><td class="line">    <span class='comment'>/*        whichever is larger (+2 for use as temporary)  */</span></td></tr>
<tr><td class="num" id="LN2916">2916</td><td class="line">    <span class='comment'>/*   b -- intermediate temporary result (same size as a)  */</span></td></tr>
<tr><td class="num" id="LN2917">2917</td><td class="line">    <span class='comment'>/* if any is too long for local storage, then allocate  */</span></td></tr>
<tr><td class="num" id="LN2918">2918</td><td class="line">    workp=<span class='macro'>MAXI(set-&gt;digits+1, rhs-&gt;digits)<span class='expansion'>((set-&gt;digits+1)&lt;(rhs-&gt;digits)?(rhs-&gt;digits):(set<br>-&gt;digits+1))</span></span>;  <span class='comment'>/* actual rounding precision  */</span></td></tr>
<tr><td class="num" id="LN2919">2919</td><td class="line">    workp=<span class='macro'>MAXI(workp, 7)<span class='expansion'>((workp)&lt;(7)?(7):(workp))</span></span>;                    <span class='comment'>/* at least 7 for low cases  */</span></td></tr>
<tr><td class="num" id="LN2920">2920</td><td class="line">    maxp=workp+2;                            <span class='comment'>/* largest working precision  */</span></td></tr>
<tr><td class="num" id="LN2921">2921</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2922">2922</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN2923">2923</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(buff)) {</td></tr>
<tr><td class="num" id="LN2924">2924</td><td class="line">      allocbuff=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN2925">2925</td><td class="line">      <span class='keyword'>if</span> (allocbuff==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {  <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN2926">2926</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN2927">2927</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2928">2928</td><td class="line">      f=allocbuff;            <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN2929">2929</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2930">2930</td><td class="line">    <span class='comment'>/* a and b both need to be able to hold a maxp-length number  */</span></td></tr>
<tr><td class="num" id="LN2931">2931</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(maxp)<span class='expansion'>((maxp)&lt;=49?d2utable[maxp]:((maxp)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN2932">2932</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(bufa)) {            <span class='comment'>/* [same applies to b]  */</span></td></tr>
<tr><td class="num" id="LN2933">2933</td><td class="line">      allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN2934">2934</td><td class="line">      allocbufb=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN2935">2935</td><td class="line">      <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> || allocbufb==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {   <span class='comment'>/* hopeless  */</span></td></tr>
<tr><td class="num" id="LN2936">2936</td><td class="line">        status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN2937">2937</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN2938">2938</td><td class="line">      a=allocbufa;            <span class='comment'>/* use the allocated spaces  */</span></td></tr>
<tr><td class="num" id="LN2939">2939</td><td class="line">      b=allocbufb;            <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN2940">2940</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2941">2941</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2942">2942</td><td class="line">    <span class='comment'>/* copy rhs -&gt; f, save exponent, and reduce so 0.1 &lt;= f &lt; 1  */</span></td></tr>
<tr><td class="num" id="LN2943">2943</td><td class="line">    <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(f, rhs);</td></tr>
<tr><td class="num" id="LN2944">2944</td><td class="line">    exp=f-&gt;exponent+f-&gt;digits;               <span class='comment'>/* adjusted to Hull rules  */</span></td></tr>
<tr><td class="num" id="LN2945">2945</td><td class="line">    f-&gt;exponent=-(f-&gt;digits);                <span class='comment'>/* to range  */</span></td></tr>
<tr><td class="num" id="LN2946">2946</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2947">2947</td><td class="line">    <span class='comment'>/* set up working context  */</span></td></tr>
<tr><td class="num" id="LN2948">2948</td><td class="line">    <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;workset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>);</td></tr>
<tr><td class="num" id="LN2949">2949</td><td class="line">    workset.emax=<span class='macro'>DEC_MAX_EMAX<span class='expansion'>999999999</span></span>;</td></tr>
<tr><td class="num" id="LN2950">2950</td><td class="line">    workset.emin=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>;</td></tr>
<tr><td class="num" id="LN2951">2951</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2952">2952</td><td class="line">    <span class='comment'>/* [Until further notice, no error is possible and status bits  */</span></td></tr>
<tr><td class="num" id="LN2953">2953</td><td class="line">    <span class='comment'>/* (Rounded, etc.) should be ignored, not accumulated.]  */</span></td></tr>
<tr><td class="num" id="LN2954">2954</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2955">2955</td><td class="line">    <span class='comment'>/* Calculate initial approximation, and allow for odd exponent  */</span></td></tr>
<tr><td class="num" id="LN2956">2956</td><td class="line">    workset.digits=workp;                    <span class='comment'>/* p for initial calculation  */</span></td></tr>
<tr><td class="num" id="LN2957">2957</td><td class="line">    t-&gt;bits=0; t-&gt;digits=3;</td></tr>
<tr><td class="num" id="LN2958">2958</td><td class="line">    a-&gt;bits=0; a-&gt;digits=3;</td></tr>
<tr><td class="num" id="LN2959">2959</td><td class="line">    <span class='keyword'>if</span> ((exp &amp; 1)==0) {                      <span class='comment'>/* even exponent  */</span></td></tr>
<tr><td class="num" id="LN2960">2960</td><td class="line">      <span class='comment'>/* Set t=0.259, a=0.819  */</span></td></tr>
<tr><td class="num" id="LN2961">2961</td><td class="line">      t-&gt;exponent=-3;</td></tr>
<tr><td class="num" id="LN2962">2962</td><td class="line">      a-&gt;exponent=-3;</td></tr>
<tr><td class="num" id="LN2963">2963</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;=3</span></td></tr>
<tr><td class="num" id="LN2964">2964</td><td class="line">        t-&gt;lsu[0]=259;</td></tr>
<tr><td class="num" id="LN2965">2965</td><td class="line">        a-&gt;lsu[0]=819;</td></tr>
<tr><td class="num" id="LN2966">2966</td><td class="line">      <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==2</span></td></tr>
<tr><td class="num" id="LN2967">2967</td><td class="line">        t-&gt;lsu[0]=59; t-&gt;lsu[1]=2;</td></tr>
<tr><td class="num" id="LN2968">2968</td><td class="line">        a-&gt;lsu[0]=19; a-&gt;lsu[1]=8;</td></tr>
<tr><td class="num" id="LN2969">2969</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN2970">2970</td><td class="line">        t-&gt;lsu[0]=9; t-&gt;lsu[1]=5; t-&gt;lsu[2]=2;</td></tr>
<tr><td class="num" id="LN2971">2971</td><td class="line">        a-&gt;lsu[0]=9; a-&gt;lsu[1]=1; a-&gt;lsu[2]=8;</td></tr>
<tr><td class="num" id="LN2972">2972</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2973">2973</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2974">2974</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* odd exponent  */</span></td></tr>
<tr><td class="num" id="LN2975">2975</td><td class="line">      <span class='comment'>/* Set t=0.0819, a=2.59  */</span></td></tr>
<tr><td class="num" id="LN2976">2976</td><td class="line">      f-&gt;exponent--;                         <span class='comment'>/* f=f/10  */</span></td></tr>
<tr><td class="num" id="LN2977">2977</td><td class="line">      exp++;                                 <span class='comment'>/* e=e+1  */</span></td></tr>
<tr><td class="num" id="LN2978">2978</td><td class="line">      t-&gt;exponent=-4;</td></tr>
<tr><td class="num" id="LN2979">2979</td><td class="line">      a-&gt;exponent=-2;</td></tr>
<tr><td class="num" id="LN2980">2980</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;=3</span></td></tr>
<tr><td class="num" id="LN2981">2981</td><td class="line">        t-&gt;lsu[0]=819;</td></tr>
<tr><td class="num" id="LN2982">2982</td><td class="line">        a-&gt;lsu[0]=259;</td></tr>
<tr><td class="num" id="LN2983">2983</td><td class="line">      <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==2</span></td></tr>
<tr><td class="num" id="LN2984">2984</td><td class="line">        t-&gt;lsu[0]=19; t-&gt;lsu[1]=8;</td></tr>
<tr><td class="num" id="LN2985">2985</td><td class="line">        a-&gt;lsu[0]=59; a-&gt;lsu[1]=2;</td></tr>
<tr><td class="num" id="LN2986">2986</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN2987">2987</td><td class="line">        t-&gt;lsu[0]=9; t-&gt;lsu[1]=1; t-&gt;lsu[2]=8;</td></tr>
<tr><td class="num" id="LN2988">2988</td><td class="line">        a-&gt;lsu[0]=9; a-&gt;lsu[1]=5; a-&gt;lsu[2]=2;</td></tr>
<tr><td class="num" id="LN2989">2989</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2990">2990</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2991">2991</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2992">2992</td><td class="line">    decMultiplyOp(a, a, f, &amp;workset, &amp;ignore);    <span class='comment'>/* a=a*f  */</span></td></tr>
<tr><td class="num" id="LN2993">2993</td><td class="line">    decAddOp(a, a, t, &amp;workset, 0, &amp;ignore);      <span class='comment'>/* ..+t  */</span></td></tr>
<tr><td class="num" id="LN2994">2994</td><td class="line">    <span class='comment'>/* [a is now the initial approximation for sqrt(f), calculated with  */</span></td></tr>
<tr><td class="num" id="LN2995">2995</td><td class="line">    <span class='comment'>/* currentprecision, which is also a's precision.]  */</span></td></tr>
<tr><td class="num" id="LN2996">2996</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2997">2997</td><td class="line">    <span class='comment'>/* the main calculation loop  */</span></td></tr>
<tr><td class="num" id="LN2998">2998</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dzero);                   <span class='comment'>/* make 0  */</span></td></tr>
<tr><td class="num" id="LN2999">2999</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(t);                        <span class='comment'>/* set t = 0.5  */</span></td></tr>
<tr><td class="num" id="LN3000">3000</td><td class="line">    t-&gt;lsu[0]=5;                             <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3001">3001</td><td class="line">    t-&gt;exponent=-1;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3002">3002</td><td class="line">    workset.digits=3;                        <span class='comment'>/* initial p  */</span></td></tr>
<tr><td class="num" id="LN3003">3003</td><td class="line">    <span class='keyword'>for</span> (; workset.digits&lt;maxp;) {</td></tr>
<tr><td class="num" id="LN3004">3004</td><td class="line">      <span class='comment'>/* set p to min(2*p - 2, maxp)  [hence 3; or: 4, 6, 10, ... , maxp]  */</span></td></tr>
<tr><td class="num" id="LN3005">3005</td><td class="line">      workset.digits=<span class='macro'>MINI(workset.digits*2-2, maxp)<span class='expansion'>((workset.digits*2-2)&gt;(maxp)?(maxp):(workset.digits*2-2))</span></span>;</td></tr>
<tr><td class="num" id="LN3006">3006</td><td class="line">      <span class='comment'>/* a = 0.5 * (a + f/a)  */</span></td></tr>
<tr><td class="num" id="LN3007">3007</td><td class="line">      <span class='comment'>/* [calculated at p then rounded to currentprecision]  */</span></td></tr>
<tr><td class="num" id="LN3008">3008</td><td class="line">      decDivideOp(b, f, a, &amp;workset, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;ignore); <span class='comment'>/* b=f/a  */</span></td></tr>
<tr><td class="num" id="LN3009">3009</td><td class="line">      decAddOp(b, b, a, &amp;workset, 0, &amp;ignore);         <span class='comment'>/* b=b+a  */</span></td></tr>
<tr><td class="num" id="LN3010">3010</td><td class="line">      decMultiplyOp(a, b, t, &amp;workset, &amp;ignore);       <span class='comment'>/* a=b*0.5  */</span></td></tr>
<tr><td class="num" id="LN3011">3011</td><td class="line">      } <span class='comment'>/* loop  */</span></td></tr>
<tr><td class="num" id="LN3012">3012</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3013">3013</td><td class="line">    <span class='comment'>/* Here, 0.1 &lt;= a &lt; 1 [Hull], and a has maxp digits  */</span></td></tr>
<tr><td class="num" id="LN3014">3014</td><td class="line">    <span class='comment'>/* now reduce to length, etc.; this needs to be done with a  */</span></td></tr>
<tr><td class="num" id="LN3015">3015</td><td class="line">    <span class='comment'>/* having the correct exponent so as to handle subnormals  */</span></td></tr>
<tr><td class="num" id="LN3016">3016</td><td class="line">    <span class='comment'>/* correctly  */</span></td></tr>
<tr><td class="num" id="LN3017">3017</td><td class="line">    approxset=*set;                          <span class='comment'>/* get emin, emax, etc.  */</span></td></tr>
<tr><td class="num" id="LN3018">3018</td><td class="line">    approxset.round=DEC_ROUND_HALF_EVEN;</td></tr>
<tr><td class="num" id="LN3019">3019</td><td class="line">    a-&gt;exponent+=exp/2;                      <span class='comment'>/* set correct exponent  */</span></td></tr>
<tr><td class="num" id="LN3020">3020</td><td class="line">    rstatus=0;                               <span class='comment'>/* clear status  */</span></td></tr>
<tr><td class="num" id="LN3021">3021</td><td class="line">    residue=0;                               <span class='comment'>/* .. and accumulator  */</span></td></tr>
<tr><td class="num" id="LN3022">3022</td><td class="line">    decCopyFit(a, a, &amp;approxset, &amp;residue, &amp;rstatus);  <span class='comment'>/* reduce (if needed)  */</span></td></tr>
<tr><td class="num" id="LN3023">3023</td><td class="line">    <span class='macro'>decFinish(a, &amp;approxset, &amp;residue, &amp;rstatus)<span class='expansion'>decFinalize(a,&amp;approxset,&amp;residue,&amp;rstatus)</span></span>;      <span class='comment'>/* clean and finalize  */</span></td></tr>
<tr><td class="num" id="LN3024">3024</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3025">3025</td><td class="line">    <span class='comment'>/* Overflow was possible if the input exponent was out-of-range,  */</span></td></tr>
<tr><td class="num" id="LN3026">3026</td><td class="line">    <span class='comment'>/* in which case quit  */</span></td></tr>
<tr><td class="num" id="LN3027">3027</td><td class="line">    <span class='keyword'>if</span> (rstatus&amp;<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>) {</td></tr>
<tr><td class="num" id="LN3028">3028</td><td class="line">      status=rstatus;                        <span class='comment'>/* use the status as-is  */</span></td></tr>
<tr><td class="num" id="LN3029">3029</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, a);                 <span class='comment'>/* copy to result  */</span></td></tr>
<tr><td class="num" id="LN3030">3030</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3031">3031</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3032">3032</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3033">3033</td><td class="line">    <span class='comment'>/* Preserve status except Inexact/Rounded  */</span></td></tr>
<tr><td class="num" id="LN3034">3034</td><td class="line">    status|=(rstatus &amp; ~(<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>|<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>));</td></tr>
<tr><td class="num" id="LN3035">3035</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3036">3036</td><td class="line">    <span class='comment'>/* Carry out the Hull correction  */</span></td></tr>
<tr><td class="num" id="LN3037">3037</td><td class="line">    a-&gt;exponent-=exp/2;                      <span class='comment'>/* back to 0.1-&gt;1  */</span></td></tr>
<tr><td class="num" id="LN3038">3038</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3039">3039</td><td class="line">    <span class='comment'>/* a is now at final precision and within 1 ulp of the properly  */</span></td></tr>
<tr><td class="num" id="LN3040">3040</td><td class="line">    <span class='comment'>/* rounded square root of f; to ensure proper rounding, compare  */</span></td></tr>
<tr><td class="num" id="LN3041">3041</td><td class="line">    <span class='comment'>/* squares of (a - l/2 ulp) and (a + l/2 ulp) with f.  */</span></td></tr>
<tr><td class="num" id="LN3042">3042</td><td class="line">    <span class='comment'>/* Here workset.digits=maxp and t=0.5, and a-&gt;digits determines  */</span></td></tr>
<tr><td class="num" id="LN3043">3043</td><td class="line">    <span class='comment'>/* the ulp  */</span></td></tr>
<tr><td class="num" id="LN3044">3044</td><td class="line">    workset.digits--;                             <span class='comment'>/* maxp-1 is OK now  */</span></td></tr>
<tr><td class="num" id="LN3045">3045</td><td class="line">    t-&gt;exponent=-a-&gt;digits-1;                     <span class='comment'>/* make 0.5 ulp  */</span></td></tr>
<tr><td class="num" id="LN3046">3046</td><td class="line">    decAddOp(b, a, t, &amp;workset, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;ignore); <span class='comment'>/* b = a - 0.5 ulp  */</span></td></tr>
<tr><td class="num" id="LN3047">3047</td><td class="line">    workset.round=DEC_ROUND_UP;</td></tr>
<tr><td class="num" id="LN3048">3048</td><td class="line">    decMultiplyOp(b, b, b, &amp;workset, &amp;ignore);    <span class='comment'>/* b = mulru(b, b)  */</span></td></tr>
<tr><td class="num" id="LN3049">3049</td><td class="line">    decCompareOp(b, f, b, &amp;workset, <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>, &amp;ignore); <span class='comment'>/* b ? f, reversed  */</span></td></tr>
<tr><td class="num" id="LN3050">3050</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(b)<span class='expansion'>(((b)-&gt;bits&amp;0x80)!=0)</span></span>) {                 <span class='comment'>/* f &lt; b [i.e., b &gt; f]  */</span></td></tr>
<tr><td class="num" id="LN3051">3051</td><td class="line">      <span class='comment'>/* this is the more common adjustment, though both are rare  */</span></td></tr>
<tr><td class="num" id="LN3052">3052</td><td class="line">      t-&gt;exponent++;                              <span class='comment'>/* make 1.0 ulp  */</span></td></tr>
<tr><td class="num" id="LN3053">3053</td><td class="line">      t-&gt;lsu[0]=1;                                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3054">3054</td><td class="line">      decAddOp(a, a, t, &amp;workset, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;ignore); <span class='comment'>/* a = a - 1 ulp  */</span></td></tr>
<tr><td class="num" id="LN3055">3055</td><td class="line">      <span class='comment'>/* assign to approx [round to length]  */</span></td></tr>
<tr><td class="num" id="LN3056">3056</td><td class="line">      approxset.emin-=exp/2;                      <span class='comment'>/* adjust to match a  */</span></td></tr>
<tr><td class="num" id="LN3057">3057</td><td class="line">      approxset.emax-=exp/2;</td></tr>
<tr><td class="num" id="LN3058">3058</td><td class="line">      decAddOp(a, &amp;dzero, a, &amp;approxset, 0, &amp;ignore);</td></tr>
<tr><td class="num" id="LN3059">3059</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3060">3060</td><td class="line">     <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3061">3061</td><td class="line">      decAddOp(b, a, t, &amp;workset, 0, &amp;ignore);    <span class='comment'>/* b = a + 0.5 ulp  */</span></td></tr>
<tr><td class="num" id="LN3062">3062</td><td class="line">      workset.round=DEC_ROUND_DOWN;</td></tr>
<tr><td class="num" id="LN3063">3063</td><td class="line">      decMultiplyOp(b, b, b, &amp;workset, &amp;ignore);  <span class='comment'>/* b = mulrd(b, b)  */</span></td></tr>
<tr><td class="num" id="LN3064">3064</td><td class="line">      decCompareOp(b, b, f, &amp;workset, <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>, &amp;ignore);   <span class='comment'>/* b ? f  */</span></td></tr>
<tr><td class="num" id="LN3065">3065</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(b)<span class='expansion'>(((b)-&gt;bits&amp;0x80)!=0)</span></span>) {               <span class='comment'>/* b &lt; f  */</span></td></tr>
<tr><td class="num" id="LN3066">3066</td><td class="line">        t-&gt;exponent++;                            <span class='comment'>/* make 1.0 ulp  */</span></td></tr>
<tr><td class="num" id="LN3067">3067</td><td class="line">        t-&gt;lsu[0]=1;                              <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3068">3068</td><td class="line">        decAddOp(a, a, t, &amp;workset, 0, &amp;ignore);  <span class='comment'>/* a = a + 1 ulp  */</span></td></tr>
<tr><td class="num" id="LN3069">3069</td><td class="line">        <span class='comment'>/* assign to approx [round to length]  */</span></td></tr>
<tr><td class="num" id="LN3070">3070</td><td class="line">        approxset.emin-=exp/2;                    <span class='comment'>/* adjust to match a  */</span></td></tr>
<tr><td class="num" id="LN3071">3071</td><td class="line">        approxset.emax-=exp/2;</td></tr>
<tr><td class="num" id="LN3072">3072</td><td class="line">        decAddOp(a, &amp;dzero, a, &amp;approxset, 0, &amp;ignore);</td></tr>
<tr><td class="num" id="LN3073">3073</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3074">3074</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3075">3075</td><td class="line">    <span class='comment'>/* [no errors are possible in the above, and rounding/inexact during  */</span></td></tr>
<tr><td class="num" id="LN3076">3076</td><td class="line">    <span class='comment'>/* estimation are irrelevant, so status was not accumulated]  */</span></td></tr>
<tr><td class="num" id="LN3077">3077</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3078">3078</td><td class="line">    <span class='comment'>/* Here, 0.1 &lt;= a &lt; 1  (still), so adjust back  */</span></td></tr>
<tr><td class="num" id="LN3079">3079</td><td class="line">    a-&gt;exponent+=exp/2;                      <span class='comment'>/* set correct exponent  */</span></td></tr>
<tr><td class="num" id="LN3080">3080</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3081">3081</td><td class="line">    <span class='comment'>/* count droppable zeros [after any subnormal rounding] by  */</span></td></tr>
<tr><td class="num" id="LN3082">3082</td><td class="line">    <span class='comment'>/* trimming a copy  */</span></td></tr>
<tr><td class="num" id="LN3083">3083</td><td class="line">    <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(b, a);</td></tr>
<tr><td class="num" id="LN3084">3084</td><td class="line">    decTrim(b, set, 1, 1, &amp;dropped);         <span class='comment'>/* [drops trailing zeros]  */</span></td></tr>
<tr><td class="num" id="LN3085">3085</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3086">3086</td><td class="line">    <span class='comment'>/* Set Inexact and Rounded.  The answer can only be exact if  */</span></td></tr>
<tr><td class="num" id="LN3087">3087</td><td class="line">    <span class='comment'>/* it is short enough so that squaring it could fit in workp  */</span></td></tr>
<tr><td class="num" id="LN3088">3088</td><td class="line">    <span class='comment'>/* digits, so this is the only (relatively rare) condition that  */</span></td></tr>
<tr><td class="num" id="LN3089">3089</td><td class="line">    <span class='comment'>/* a careful check is needed  */</span></td></tr>
<tr><td class="num" id="LN3090">3090</td><td class="line">    <span class='keyword'>if</span> (b-&gt;digits*2-1 &gt; workp) {             <span class='comment'>/* cannot fit  */</span></td></tr>
<tr><td class="num" id="LN3091">3091</td><td class="line">      status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;</td></tr>
<tr><td class="num" id="LN3092">3092</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3093">3093</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* could be exact/unrounded  */</span></td></tr>
<tr><td class="num" id="LN3094">3094</td><td class="line">      <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> mstatus=0;                        <span class='comment'>/* local status  */</span></td></tr>
<tr><td class="num" id="LN3095">3095</td><td class="line">      decMultiplyOp(b, b, b, &amp;workset, &amp;mstatus); <span class='comment'>/* try the multiply  */</span></td></tr>
<tr><td class="num" id="LN3096">3096</td><td class="line">      <span class='keyword'>if</span> (mstatus&amp;<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>) {            <span class='comment'>/* result just won't fit  */</span></td></tr>
<tr><td class="num" id="LN3097">3097</td><td class="line">        status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;</td></tr>
<tr><td class="num" id="LN3098">3098</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3099">3099</td><td class="line">       <span class='keyword'>else</span> {                                <span class='comment'>/* plausible  */</span></td></tr>
<tr><td class="num" id="LN3100">3100</td><td class="line">        decCompareOp(t, b, rhs, &amp;workset, <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>, &amp;mstatus); <span class='comment'>/* b ? rhs  */</span></td></tr>
<tr><td class="num" id="LN3101">3101</td><td class="line">        <span class='keyword'>if</span> (!<span class='macro'>ISZERO(t)<span class='expansion'>(*(t)-&gt;lsu==0 &amp;&amp; (t)-&gt;digits==1 &amp;&amp; (((t<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>; <span class='comment'>/* not equal  */</span></td></tr>
<tr><td class="num" id="LN3102">3102</td><td class="line">         <span class='keyword'>else</span> {                              <span class='comment'>/* is Exact  */</span></td></tr>
<tr><td class="num" id="LN3103">3103</td><td class="line">          <span class='comment'>/* here, dropped is the count of trailing zeros in 'a'  */</span></td></tr>
<tr><td class="num" id="LN3104">3104</td><td class="line">          <span class='comment'>/* use closest exponent to ideal...  */</span></td></tr>
<tr><td class="num" id="LN3105">3105</td><td class="line">          <span class='macro'>Int<span class='expansion'>int32_t</span></span> todrop=ideal-a-&gt;exponent;      <span class='comment'>/* most that can be dropped  */</span></td></tr>
<tr><td class="num" id="LN3106">3106</td><td class="line">          <span class='keyword'>if</span> (todrop&lt;0) status|=<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>; <span class='comment'>/* ideally would add 0s  */</span></td></tr>
<tr><td class="num" id="LN3107">3107</td><td class="line">           <span class='keyword'>else</span> {                            <span class='comment'>/* unrounded  */</span></td></tr>
<tr><td class="num" id="LN3108">3108</td><td class="line">            <span class='comment'>/* there are some to drop, but emax may not allow all  */</span></td></tr>
<tr><td class="num" id="LN3109">3109</td><td class="line">            <span class='macro'>Int<span class='expansion'>int32_t</span></span> maxexp=set-&gt;emax-set-&gt;digits+1;</td></tr>
<tr><td class="num" id="LN3110">3110</td><td class="line">            <span class='macro'>Int<span class='expansion'>int32_t</span></span> maxdrop=maxexp-a-&gt;exponent;</td></tr>
<tr><td class="num" id="LN3111">3111</td><td class="line">            <span class='keyword'>if</span> (todrop&gt;maxdrop &amp;&amp; set-&gt;clamp) { <span class='comment'>/* apply clamping  */</span></td></tr>
<tr><td class="num" id="LN3112">3112</td><td class="line">              todrop=maxdrop;</td></tr>
<tr><td class="num" id="LN3113">3113</td><td class="line">              status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN3114">3114</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN3115">3115</td><td class="line">            <span class='keyword'>if</span> (dropped&lt;todrop) {            <span class='comment'>/* clamp to those available  */</span></td></tr>
<tr><td class="num" id="LN3116">3116</td><td class="line">              todrop=dropped;</td></tr>
<tr><td class="num" id="LN3117">3117</td><td class="line">              status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN3118">3118</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN3119">3119</td><td class="line">            <span class='keyword'>if</span> (todrop&gt;0) {                  <span class='comment'>/* have some to drop  */</span></td></tr>
<tr><td class="num" id="LN3120">3120</td><td class="line">              decShiftToLeast(a-&gt;lsu, <span class='macro'>D2U(a-&gt;digits)<span class='expansion'>((a-&gt;digits)&lt;=49?d2utable[a-&gt;digits]:((a-&gt;digits)<br>+1 -1)/1)</span></span>, todrop);</td></tr>
<tr><td class="num" id="LN3121">3121</td><td class="line">              a-&gt;exponent+=todrop;           <span class='comment'>/* maintain numerical value  */</span></td></tr>
<tr><td class="num" id="LN3122">3122</td><td class="line">              a-&gt;digits-=todrop;             <span class='comment'>/* new length  */</span></td></tr>
<tr><td class="num" id="LN3123">3123</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN3124">3124</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3125">3125</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3126">3126</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3127">3127</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3128">3128</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3129">3129</td><td class="line">    <span class='comment'>/* double-check Underflow, as perhaps the result could not have  */</span></td></tr>
<tr><td class="num" id="LN3130">3130</td><td class="line">    <span class='comment'>/* been subnormal (initial argument too big), or it is now Exact  */</span></td></tr>
<tr><td class="num" id="LN3131">3131</td><td class="line">    <span class='keyword'>if</span> (status&amp;<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>) {</td></tr>
<tr><td class="num" id="LN3132">3132</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> ae=rhs-&gt;exponent+rhs-&gt;digits-1;    <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN3133">3133</td><td class="line">      <span class='comment'>/* check if truly subnormal  */</span></td></tr>
<tr><td class="num" id="LN3134">3134</td><td class="line">      <span class='directive'>#if <span class='macro'>DECEXTFLAG<span class='expansion'>1</span></span>                         /* DEC_Subnormal too  */</span></td></tr>
<tr><td class="num" id="LN3135">3135</td><td class="line">        <span class='keyword'>if</span> (ae&gt;=set-&gt;emin*2) status&amp;=~(<span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span>|<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>);</td></tr>
<tr><td class="num" id="LN3136">3136</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN3137">3137</td><td class="line">        <span class='keyword'>if</span> (ae&gt;=set-&gt;emin*2) status&amp;=~<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>;</td></tr>
<tr><td class="num" id="LN3138">3138</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3139">3139</td><td class="line">      <span class='comment'>/* check if truly inexact  */</span></td></tr>
<tr><td class="num" id="LN3140">3140</td><td class="line">      <span class='keyword'>if</span> (!(status&amp;<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>)) status&amp;=~<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>;</td></tr>
<tr><td class="num" id="LN3141">3141</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3142">3142</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3143">3143</td><td class="line">    <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, a);                   <span class='comment'>/* a is now the result  */</span></td></tr>
<tr><td class="num" id="LN3144">3144</td><td class="line">    } <span class='keyword'>while</span>(0);                              <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN3145">3145</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3146">3146</td><td class="line">  <span class='keyword'>if</span> (allocbuff!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbuff)<span class='expansion'>uprv_free_54(allocbuff)</span></span>;      <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN3147">3147</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>;      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3148">3148</td><td class="line">  <span class='keyword'>if</span> (allocbufb!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufb)<span class='expansion'>uprv_free_54(allocbufb)</span></span>;      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3149">3149</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3150">3150</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3151">3151</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3152">3152</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);<span class='comment'>/* then report status  */</span></td></tr>
<tr><td class="num" id="LN3153">3153</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3154">3154</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN3155">3155</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3156">3156</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3157">3157</td><td class="line">  } <span class='comment'>/* decNumberSquareRoot  */</span></td></tr>
<tr><td class="num" id="LN3158">3158</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN3159">3159</td><td class="line"><span class='directive'>#pragma GCC diagnostic pop</span></td></tr>
<tr><td class="num" id="LN3160">3160</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3161">3161</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3162">3162</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3163">3163</td><td class="line"><span class='comment'>/* decNumberSubtract -- subtract two Numbers                          */</span></td></tr>
<tr><td class="num" id="LN3164">3164</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3165">3165</td><td class="line"><span class='comment'>/*   This computes C = A - B                                          */</span></td></tr>
<tr><td class="num" id="LN3166">3166</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3167">3167</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X-X)         */</span></td></tr>
<tr><td class="num" id="LN3168">3168</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3169">3169</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN3170">3170</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN3171">3171</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3172">3172</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3173">3173</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3174">3174</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberSubtract<span class='expansion'>uprv_decNumberSubtract_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN3175">3175</td><td class="line">                              <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN3176">3176</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                        <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN3177">3177</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3178">3178</td><td class="line">  decAddOp(res, lhs, rhs, set, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;status);</td></tr>
<tr><td class="num" id="LN3179">3179</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN3180">3180</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3181">3181</td><td class="line">  decCheckInexact(res, set);</td></tr>
<tr><td class="num" id="LN3182">3182</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3183">3183</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3184">3184</td><td class="line">  } <span class='comment'>/* decNumberSubtract  */</span></td></tr>
<tr><td class="num" id="LN3185">3185</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3186">3186</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3187">3187</td><td class="line"><span class='comment'>/* decNumberToIntegralExact -- round-to-integral-value with InExact   */</span></td></tr>
<tr><td class="num" id="LN3188">3188</td><td class="line"><span class='comment'>/* decNumberToIntegralValue -- round-to-integral-value                */</span></td></tr>
<tr><td class="num" id="LN3189">3189</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3190">3190</td><td class="line"><span class='comment'>/*   res is the result                                                */</span></td></tr>
<tr><td class="num" id="LN3191">3191</td><td class="line"><span class='comment'>/*   rhs is input number                                              */</span></td></tr>
<tr><td class="num" id="LN3192">3192</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN3193">3193</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3194">3194</td><td class="line"><span class='comment'>/* res must have space for any value of rhs.                          */</span></td></tr>
<tr><td class="num" id="LN3195">3195</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3196">3196</td><td class="line"><span class='comment'>/* This implements the IEEE special operators and therefore treats    */</span></td></tr>
<tr><td class="num" id="LN3197">3197</td><td class="line"><span class='comment'>/* special values as valid.  For finite numbers it returns            */</span></td></tr>
<tr><td class="num" id="LN3198">3198</td><td class="line"><span class='comment'>/* rescale(rhs, 0) if rhs-&gt;exponent is &lt;0.                            */</span></td></tr>
<tr><td class="num" id="LN3199">3199</td><td class="line"><span class='comment'>/* Otherwise the result is rhs (so no error is possible, except for   */</span></td></tr>
<tr><td class="num" id="LN3200">3200</td><td class="line"><span class='comment'>/* sNaN).                                                             */</span></td></tr>
<tr><td class="num" id="LN3201">3201</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3202">3202</td><td class="line"><span class='comment'>/* The context is used for rounding mode and status after sNaN, but   */</span></td></tr>
<tr><td class="num" id="LN3203">3203</td><td class="line"><span class='comment'>/* the digits setting is ignored.  The Exact version will signal      */</span></td></tr>
<tr><td class="num" id="LN3204">3204</td><td class="line"><span class='comment'>/* Inexact if the result differs numerically from rhs; the other      */</span></td></tr>
<tr><td class="num" id="LN3205">3205</td><td class="line"><span class='comment'>/* never signals Inexact.                                             */</span></td></tr>
<tr><td class="num" id="LN3206">3206</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3207">3207</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberToIntegralExact<span class='expansion'>uprv_decNumberToIntegralExact_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN3208">3208</td><td class="line">                                     decContext *set) {</td></tr>
<tr><td class="num" id="LN3209">3209</td><td class="line">  decNumber dn;</td></tr>
<tr><td class="num" id="LN3210">3210</td><td class="line">  decContext workset;              <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN3211">3211</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status=0;                   <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN3212">3212</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3213">3213</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3214">3214</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3215">3215</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3216">3216</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3217">3217</td><td class="line">  <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN3218">3218</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>SPECIALARG<span class='expansion'>(rhs-&gt;bits &amp; (0x40|0x20|0x10))</span></span>) {</td></tr>
<tr><td class="num" id="LN3219">3219</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs); <span class='comment'>/* an Infinity  */</span></td></tr>
<tr><td class="num" id="LN3220">3220</td><td class="line">     <span class='keyword'>else</span> decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, &amp;status); <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN3221">3221</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3222">3222</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* finite  */</span></td></tr>
<tr><td class="num" id="LN3223">3223</td><td class="line">    <span class='comment'>/* have a finite number; no error possible (res must be big enough)  */</span></td></tr>
<tr><td class="num" id="LN3224">3224</td><td class="line">    <span class='keyword'>if</span> (rhs-&gt;exponent&gt;=0) <span class='keyword'>return</span> <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);</td></tr>
<tr><td class="num" id="LN3225">3225</td><td class="line">    <span class='comment'>/* that was easy, but if negative exponent there is work to do...  */</span></td></tr>
<tr><td class="num" id="LN3226">3226</td><td class="line">    workset=*set;                  <span class='comment'>/* clone rounding, etc.  */</span></td></tr>
<tr><td class="num" id="LN3227">3227</td><td class="line">    workset.digits=rhs-&gt;digits;    <span class='comment'>/* no length rounding  */</span></td></tr>
<tr><td class="num" id="LN3228">3228</td><td class="line">    workset.traps=0;               <span class='comment'>/* no traps  */</span></td></tr>
<tr><td class="num" id="LN3229">3229</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;dn);            <span class='comment'>/* make a number with exponent 0  */</span></td></tr>
<tr><td class="num" id="LN3230">3230</td><td class="line">    <span class='macro'>uprv_decNumberQuantize<span class='expansion'>uprv_decNumberQuantize_54</span></span>(res, rhs, &amp;dn, &amp;workset);</td></tr>
<tr><td class="num" id="LN3231">3231</td><td class="line">    status|=workset.status;</td></tr>
<tr><td class="num" id="LN3232">3232</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3233">3233</td><td class="line">  <span class='keyword'>if</span> (status!=0) decStatus(res, status, set);</td></tr>
<tr><td class="num" id="LN3234">3234</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3235">3235</td><td class="line">  } <span class='comment'>/* decNumberToIntegralExact  */</span></td></tr>
<tr><td class="num" id="LN3236">3236</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3237">3237</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberToIntegralValue<span class='expansion'>uprv_decNumberToIntegralValue_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN3238">3238</td><td class="line">                                     decContext *set) {</td></tr>
<tr><td class="num" id="LN3239">3239</td><td class="line">  decContext workset=*set;         <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN3240">3240</td><td class="line">  workset.traps=0;                 <span class='comment'>/* no traps  */</span></td></tr>
<tr><td class="num" id="LN3241">3241</td><td class="line">  <span class='macro'>uprv_decNumberToIntegralExact<span class='expansion'>uprv_decNumberToIntegralExact_54</span></span>(res, rhs, &amp;workset);</td></tr>
<tr><td class="num" id="LN3242">3242</td><td class="line">  <span class='comment'>/* this never affects set, except for sNaNs; NaN will have been set  */</span></td></tr>
<tr><td class="num" id="LN3243">3243</td><td class="line">  <span class='comment'>/* or propagated already, so no need to call decStatus  */</span></td></tr>
<tr><td class="num" id="LN3244">3244</td><td class="line">  set-&gt;status|=workset.status&amp;<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN3245">3245</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3246">3246</td><td class="line">  } <span class='comment'>/* decNumberToIntegralValue  */</span></td></tr>
<tr><td class="num" id="LN3247">3247</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3248">3248</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3249">3249</td><td class="line"><span class='comment'>/* decNumberXor -- XOR two Numbers, digitwise                         */</span></td></tr>
<tr><td class="num" id="LN3250">3250</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3251">3251</td><td class="line"><span class='comment'>/*   This computes C = A ^ B                                          */</span></td></tr>
<tr><td class="num" id="LN3252">3252</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3253">3253</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X^X)         */</span></td></tr>
<tr><td class="num" id="LN3254">3254</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3255">3255</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN3256">3256</td><td class="line"><span class='comment'>/*   set is the context (used for result length and error report)     */</span></td></tr>
<tr><td class="num" id="LN3257">3257</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3258">3258</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3259">3259</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3260">3260</td><td class="line"><span class='comment'>/* Logical function restrictions apply (see above); a NaN is          */</span></td></tr>
<tr><td class="num" id="LN3261">3261</td><td class="line"><span class='comment'>/* returned with Invalid_operation if a restriction is violated.      */</span></td></tr>
<tr><td class="num" id="LN3262">3262</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3263">3263</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberXor<span class='expansion'>uprv_decNumberXor_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN3264">3264</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN3265">3265</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ua, *ub;                  <span class='comment'>/* -&gt; operands  */</span></td></tr>
<tr><td class="num" id="LN3266">3266</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msua, *msub;              <span class='comment'>/* -&gt; operand msus  */</span></td></tr>
<tr><td class="num" id="LN3267">3267</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *uc, *msuc;                     <span class='comment'>/* -&gt; result and its msu  */</span></td></tr>
<tr><td class="num" id="LN3268">3268</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   msudigs;                        <span class='comment'>/* digits in res msu  */</span></td></tr>
<tr><td class="num" id="LN3269">3269</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3270">3270</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3271">3271</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3272">3272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3273">3273</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span></td></tr>
<tr><td class="num" id="LN3274">3274</td><td class="line">   || rhs-&gt;exponent!=0 || <span class='macro'>decNumberIsSpecial(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span> || <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN3275">3275</td><td class="line">    decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN3276">3276</td><td class="line">    <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3277">3277</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3278">3278</td><td class="line">  <span class='comment'>/* operands are valid  */</span></td></tr>
<tr><td class="num" id="LN3279">3279</td><td class="line">  ua=lhs-&gt;lsu;                          <span class='comment'>/* bottom-up  */</span></td></tr>
<tr><td class="num" id="LN3280">3280</td><td class="line">  ub=rhs-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3281">3281</td><td class="line">  uc=res-&gt;lsu;                          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3282">3282</td><td class="line">  msua=ua+<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of lhs  */</span></td></tr>
<tr><td class="num" id="LN3283">3283</td><td class="line">  msub=ub+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of rhs  */</span></td></tr>
<tr><td class="num" id="LN3284">3284</td><td class="line">  msuc=uc+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>-1;           <span class='comment'>/* -&gt; msu of result  */</span></td></tr>
<tr><td class="num" id="LN3285">3285</td><td class="line">  msudigs=<span class='macro'>MSUDIGITS(set-&gt;digits)<span class='expansion'>((set-&gt;digits)-(((set-&gt;digits)&lt;=49?d2utable[set-&gt;<br>digits]:((set-&gt;digits)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN3286">3286</td><td class="line">  <span class='keyword'>for</span> (; uc&lt;=msuc; ua++, ub++, uc++) {  <span class='comment'>/* Unit loop  */</span></td></tr>
<tr><td class="num" id="LN3287">3287</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> a, b;                          <span class='comment'>/* extract units  */</span></td></tr>
<tr><td class="num" id="LN3288">3288</td><td class="line">    <span class='keyword'>if</span> (ua&gt;msua) a=0;</td></tr>
<tr><td class="num" id="LN3289">3289</td><td class="line">     <span class='keyword'>else</span> a=*ua;</td></tr>
<tr><td class="num" id="LN3290">3290</td><td class="line">    <span class='keyword'>if</span> (ub&gt;msub) b=0;</td></tr>
<tr><td class="num" id="LN3291">3291</td><td class="line">     <span class='keyword'>else</span> b=*ub;</td></tr>
<tr><td class="num" id="LN3292">3292</td><td class="line">    *uc=0;                              <span class='comment'>/* can now write back  */</span></td></tr>
<tr><td class="num" id="LN3293">3293</td><td class="line">    <span class='keyword'>if</span> (a|b) {                          <span class='comment'>/* maybe 1 bits to examine  */</span></td></tr>
<tr><td class="num" id="LN3294">3294</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> i, j;</td></tr>
<tr><td class="num" id="LN3295">3295</td><td class="line">      <span class='comment'>/* This loop could be unrolled and/or use BIN2BCD tables  */</span></td></tr>
<tr><td class="num" id="LN3296">3296</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; i++) {</td></tr>
<tr><td class="num" id="LN3297">3297</td><td class="line">        <span class='keyword'>if</span> ((a^b)&amp;1) *uc=*uc+(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[i];     <span class='comment'>/* effect XOR  */</span></td></tr>
<tr><td class="num" id="LN3298">3298</td><td class="line">        j=a%10;</td></tr>
<tr><td class="num" id="LN3299">3299</td><td class="line">        a=a/10;</td></tr>
<tr><td class="num" id="LN3300">3300</td><td class="line">        j|=b%10;</td></tr>
<tr><td class="num" id="LN3301">3301</td><td class="line">        b=b/10;</td></tr>
<tr><td class="num" id="LN3302">3302</td><td class="line">        <span class='keyword'>if</span> (j&gt;1) {</td></tr>
<tr><td class="num" id="LN3303">3303</td><td class="line">          decStatus(res, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>, set);</td></tr>
<tr><td class="num" id="LN3304">3304</td><td class="line">          <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3305">3305</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3306">3306</td><td class="line">        <span class='keyword'>if</span> (uc==msuc &amp;&amp; i==msudigs-1) <span class='keyword'>break</span>;      <span class='comment'>/* just did final digit  */</span></td></tr>
<tr><td class="num" id="LN3307">3307</td><td class="line">        } <span class='comment'>/* each digit  */</span></td></tr>
<tr><td class="num" id="LN3308">3308</td><td class="line">      } <span class='comment'>/* non-zero  */</span></td></tr>
<tr><td class="num" id="LN3309">3309</td><td class="line">    } <span class='comment'>/* each unit  */</span></td></tr>
<tr><td class="num" id="LN3310">3310</td><td class="line">  <span class='comment'>/* [here uc-1 is the msu of the result]  */</span></td></tr>
<tr><td class="num" id="LN3311">3311</td><td class="line">  res-&gt;digits=decGetDigits(res-&gt;lsu, uc-res-&gt;lsu);</td></tr>
<tr><td class="num" id="LN3312">3312</td><td class="line">  res-&gt;exponent=0;                      <span class='comment'>/* integer  */</span></td></tr>
<tr><td class="num" id="LN3313">3313</td><td class="line">  res-&gt;bits=0;                          <span class='comment'>/* sign=0  */</span></td></tr>
<tr><td class="num" id="LN3314">3314</td><td class="line">  <span class='keyword'>return</span> res;  <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN3315">3315</td><td class="line">  } <span class='comment'>/* decNumberXor  */</span></td></tr>
<tr><td class="num" id="LN3316">3316</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3317">3317</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3318">3318</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN3319">3319</td><td class="line"><span class='comment'>/* Utility routines                                                   */</span></td></tr>
<tr><td class="num" id="LN3320">3320</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN3321">3321</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3322">3322</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3323">3323</td><td class="line"><span class='comment'>/* decNumberClass -- return the decClass of a decNumber               */</span></td></tr>
<tr><td class="num" id="LN3324">3324</td><td class="line"><span class='comment'>/*   dn -- the decNumber to test                                      */</span></td></tr>
<tr><td class="num" id="LN3325">3325</td><td class="line"><span class='comment'>/*   set -- the context to use for Emin                               */</span></td></tr>
<tr><td class="num" id="LN3326">3326</td><td class="line"><span class='comment'>/*   returns the decClass enum                                        */</span></td></tr>
<tr><td class="num" id="LN3327">3327</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3328">3328</td><td class="line"><span class='keyword'>enum</span> decClass <span class='macro'>uprv_decNumberClass<span class='expansion'>uprv_decNumberClass_54</span></span>(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN3329">3329</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsSpecial(dn)<span class='expansion'>(((dn)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN3330">3330</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsQNaN(dn)<span class='expansion'>(((dn)-&gt;bits&amp;(0x20))!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_QNAN;</td></tr>
<tr><td class="num" id="LN3331">3331</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsSNaN(dn)<span class='expansion'>(((dn)-&gt;bits&amp;(0x10))!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_SNAN;</td></tr>
<tr><td class="num" id="LN3332">3332</td><td class="line">    <span class='comment'>/* must be an infinity  */</span></td></tr>
<tr><td class="num" id="LN3333">3333</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_NEG_INF;</td></tr>
<tr><td class="num" id="LN3334">3334</td><td class="line">    <span class='keyword'>return</span> DEC_CLASS_POS_INF;</td></tr>
<tr><td class="num" id="LN3335">3335</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3336">3336</td><td class="line">  <span class='comment'>/* is finite  */</span></td></tr>
<tr><td class="num" id="LN3337">3337</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>uprv_decNumberIsNormal<span class='expansion'>uprv_decNumberIsNormal_54</span></span>(dn, set)) { <span class='comment'>/* most common  */</span></td></tr>
<tr><td class="num" id="LN3338">3338</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_NEG_NORMAL;</td></tr>
<tr><td class="num" id="LN3339">3339</td><td class="line">    <span class='keyword'>return</span> DEC_CLASS_POS_NORMAL;</td></tr>
<tr><td class="num" id="LN3340">3340</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3341">3341</td><td class="line">  <span class='comment'>/* is subnormal or zero  */</span></td></tr>
<tr><td class="num" id="LN3342">3342</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {    <span class='comment'>/* most common  */</span></td></tr>
<tr><td class="num" id="LN3343">3343</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_NEG_ZERO;</td></tr>
<tr><td class="num" id="LN3344">3344</td><td class="line">    <span class='keyword'>return</span> DEC_CLASS_POS_ZERO;</td></tr>
<tr><td class="num" id="LN3345">3345</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3346">3346</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) <span class='keyword'>return</span> DEC_CLASS_NEG_SUBNORMAL;</td></tr>
<tr><td class="num" id="LN3347">3347</td><td class="line">  <span class='keyword'>return</span> DEC_CLASS_POS_SUBNORMAL;</td></tr>
<tr><td class="num" id="LN3348">3348</td><td class="line">  } <span class='comment'>/* decNumberClass  */</span></td></tr>
<tr><td class="num" id="LN3349">3349</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3350">3350</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3351">3351</td><td class="line"><span class='comment'>/* decNumberClassToString -- convert decClass to a string             */</span></td></tr>
<tr><td class="num" id="LN3352">3352</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3353">3353</td><td class="line"><span class='comment'>/*  eclass is a valid decClass                                        */</span></td></tr>
<tr><td class="num" id="LN3354">3354</td><td class="line"><span class='comment'>/*  returns a constant string describing the class (max 13+1 chars)   */</span></td></tr>
<tr><td class="num" id="LN3355">3355</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3356">3356</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>char</span> *<span class='macro'>uprv_decNumberClassToString<span class='expansion'>uprv_decNumberClassToString_54</span></span>(<span class='keyword'>enum</span> decClass eclass) {</td></tr>
<tr><td class="num" id="LN3357">3357</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_POS_NORMAL)    <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_PN<span class='expansion'>"+Normal"</span></span>;</td></tr>
<tr><td class="num" id="LN3358">3358</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_NEG_NORMAL)    <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_NN<span class='expansion'>"-Normal"</span></span>;</td></tr>
<tr><td class="num" id="LN3359">3359</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_POS_ZERO)      <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_PZ<span class='expansion'>"+Zero"</span></span>;</td></tr>
<tr><td class="num" id="LN3360">3360</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_NEG_ZERO)      <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_NZ<span class='expansion'>"-Zero"</span></span>;</td></tr>
<tr><td class="num" id="LN3361">3361</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_POS_SUBNORMAL) <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_PS<span class='expansion'>"+Subnormal"</span></span>;</td></tr>
<tr><td class="num" id="LN3362">3362</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_NEG_SUBNORMAL) <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_NS<span class='expansion'>"-Subnormal"</span></span>;</td></tr>
<tr><td class="num" id="LN3363">3363</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_POS_INF)       <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_PI<span class='expansion'>"+Infinity"</span></span>;</td></tr>
<tr><td class="num" id="LN3364">3364</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_NEG_INF)       <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_NI<span class='expansion'>"-Infinity"</span></span>;</td></tr>
<tr><td class="num" id="LN3365">3365</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_QNAN)          <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_QN<span class='expansion'>"NaN"</span></span>;</td></tr>
<tr><td class="num" id="LN3366">3366</td><td class="line">  <span class='keyword'>if</span> (eclass==DEC_CLASS_SNAN)          <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_SN<span class='expansion'>"sNaN"</span></span>;</td></tr>
<tr><td class="num" id="LN3367">3367</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>DEC_ClassString_UN<span class='expansion'>"Invalid"</span></span>;           <span class='comment'>/* Unknown  */</span></td></tr>
<tr><td class="num" id="LN3368">3368</td><td class="line">  } <span class='comment'>/* decNumberClassToString  */</span></td></tr>
<tr><td class="num" id="LN3369">3369</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3370">3370</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3371">3371</td><td class="line"><span class='comment'>/* decNumberCopy -- copy a number                                     */</span></td></tr>
<tr><td class="num" id="LN3372">3372</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3373">3373</td><td class="line"><span class='comment'>/*   dest is the target decNumber                                     */</span></td></tr>
<tr><td class="num" id="LN3374">3374</td><td class="line"><span class='comment'>/*   src  is the source decNumber                                     */</span></td></tr>
<tr><td class="num" id="LN3375">3375</td><td class="line"><span class='comment'>/*   returns dest                                                     */</span></td></tr>
<tr><td class="num" id="LN3376">3376</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3377">3377</td><td class="line"><span class='comment'>/* (dest==src is allowed and is a no-op)                              */</span></td></tr>
<tr><td class="num" id="LN3378">3378</td><td class="line"><span class='comment'>/* All fields are updated as required.  This is a utility operation,  */</span></td></tr>
<tr><td class="num" id="LN3379">3379</td><td class="line"><span class='comment'>/* so special values are unchanged and no error is possible.          */</span></td></tr>
<tr><td class="num" id="LN3380">3380</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3381">3381</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(decNumber *dest, <span class='keyword'>const</span> decNumber *src) {</td></tr>
<tr><td class="num" id="LN3382">3382</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3383">3383</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3384">3384</td><td class="line">  <span class='keyword'>if</span> (src==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>return</span> <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dest);</td></tr>
<tr><td class="num" id="LN3385">3385</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3386">3386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3387">3387</td><td class="line">  <span class='keyword'>if</span> (dest==src) <span class='keyword'>return</span> dest;                <span class='comment'>/* no copy required  */</span></td></tr>
<tr><td class="num" id="LN3388">3388</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3389">3389</td><td class="line">  <span class='comment'>/* Use explicit assignments here as structure assignment could copy  */</span></td></tr>
<tr><td class="num" id="LN3390">3390</td><td class="line">  <span class='comment'>/* more than just the lsu (for small DECDPUN).  This would not affect  */</span></td></tr>
<tr><td class="num" id="LN3391">3391</td><td class="line">  <span class='comment'>/* the value of the results, but could disturb test harness spill  */</span></td></tr>
<tr><td class="num" id="LN3392">3392</td><td class="line">  <span class='comment'>/* checking.  */</span></td></tr>
<tr><td class="num" id="LN3393">3393</td><td class="line">  dest-&gt;bits=src-&gt;bits;</td></tr>
<tr><td class="num" id="LN3394">3394</td><td class="line">  dest-&gt;exponent=src-&gt;exponent;</td></tr>
<tr><td class="num" id="LN3395">3395</td><td class="line">  dest-&gt;digits=src-&gt;digits;</td></tr>
<tr><td class="num" id="LN3396">3396</td><td class="line">  dest-&gt;lsu[0]=src-&gt;lsu[0];</td></tr>
<tr><td class="num" id="LN3397">3397</td><td class="line">  <span class='keyword'>if</span> (src-&gt;digits&gt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {                 <span class='comment'>/* more Units to come  */</span></td></tr>
<tr><td class="num" id="LN3398">3398</td><td class="line">    <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *smsup, *s;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3399">3399</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *d;                                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3400">3400</td><td class="line">    <span class='comment'>/* memcpy for the remaining Units would be safe as they cannot  */</span></td></tr>
<tr><td class="num" id="LN3401">3401</td><td class="line">    <span class='comment'>/* overlap.  However, this explicit loop is faster in short cases.  */</span></td></tr>
<tr><td class="num" id="LN3402">3402</td><td class="line">    d=dest-&gt;lsu+1;                           <span class='comment'>/* -&gt; first destination  */</span></td></tr>
<tr><td class="num" id="LN3403">3403</td><td class="line">    smsup=src-&gt;lsu+<span class='macro'>D2U(src-&gt;digits)<span class='expansion'>((src-&gt;digits)&lt;=49?d2utable[src-&gt;digits]:((src-&gt;digits<br>)+1 -1)/1)</span></span>;         <span class='comment'>/* -&gt; source msu+1  */</span></td></tr>
<tr><td class="num" id="LN3404">3404</td><td class="line">    <span class='keyword'>for</span> (s=src-&gt;lsu+1; s&lt;smsup; s++, d++) *d=*s;</td></tr>
<tr><td class="num" id="LN3405">3405</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3406">3406</td><td class="line">  <span class='keyword'>return</span> dest;</td></tr>
<tr><td class="num" id="LN3407">3407</td><td class="line">  } <span class='comment'>/* decNumberCopy  */</span></td></tr>
<tr><td class="num" id="LN3408">3408</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3409">3409</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3410">3410</td><td class="line"><span class='comment'>/* decNumberCopyAbs -- quiet absolute value operator                  */</span></td></tr>
<tr><td class="num" id="LN3411">3411</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3412">3412</td><td class="line"><span class='comment'>/*   This sets C = abs(A)                                             */</span></td></tr>
<tr><td class="num" id="LN3413">3413</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3414">3414</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN3415">3415</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3416">3416</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3417">3417</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3418">3418</td><td class="line"><span class='comment'>/* No exception or error can occur; this is a quiet bitwise operation.*/</span></td></tr>
<tr><td class="num" id="LN3419">3419</td><td class="line"><span class='comment'>/* See also decNumberAbs for a checking version of this.              */</span></td></tr>
<tr><td class="num" id="LN3420">3420</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3421">3421</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCopyAbs<span class='expansion'>uprv_decNumberCopyAbs_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs) {</td></tr>
<tr><td class="num" id="LN3422">3422</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3423">3423</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, DECUNCONT)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3424">3424</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3425">3425</td><td class="line">  <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);</td></tr>
<tr><td class="num" id="LN3426">3426</td><td class="line">  res-&gt;bits&amp;=~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                   <span class='comment'>/* turn off sign  */</span></td></tr>
<tr><td class="num" id="LN3427">3427</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3428">3428</td><td class="line">  } <span class='comment'>/* decNumberCopyAbs  */</span></td></tr>
<tr><td class="num" id="LN3429">3429</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3430">3430</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3431">3431</td><td class="line"><span class='comment'>/* decNumberCopyNegate -- quiet negate value operator                 */</span></td></tr>
<tr><td class="num" id="LN3432">3432</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3433">3433</td><td class="line"><span class='comment'>/*   This sets C = negate(A)                                          */</span></td></tr>
<tr><td class="num" id="LN3434">3434</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3435">3435</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN3436">3436</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3437">3437</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3438">3438</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3439">3439</td><td class="line"><span class='comment'>/* No exception or error can occur; this is a quiet bitwise operation.*/</span></td></tr>
<tr><td class="num" id="LN3440">3440</td><td class="line"><span class='comment'>/* See also decNumberMinus for a checking version of this.            */</span></td></tr>
<tr><td class="num" id="LN3441">3441</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3442">3442</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCopyNegate<span class='expansion'>uprv_decNumberCopyNegate_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *rhs) {</td></tr>
<tr><td class="num" id="LN3443">3443</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3444">3444</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, DECUNCONT)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3445">3445</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3446">3446</td><td class="line">  <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);</td></tr>
<tr><td class="num" id="LN3447">3447</td><td class="line">  res-&gt;bits^=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                    <span class='comment'>/* invert the sign  */</span></td></tr>
<tr><td class="num" id="LN3448">3448</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3449">3449</td><td class="line">  } <span class='comment'>/* decNumberCopyNegate  */</span></td></tr>
<tr><td class="num" id="LN3450">3450</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3451">3451</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3452">3452</td><td class="line"><span class='comment'>/* decNumberCopySign -- quiet copy and set sign operator              */</span></td></tr>
<tr><td class="num" id="LN3453">3453</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3454">3454</td><td class="line"><span class='comment'>/*   This sets C = A with the sign of B                               */</span></td></tr>
<tr><td class="num" id="LN3455">3455</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3456">3456</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN3457">3457</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3458">3458</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN3459">3459</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3460">3460</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3461">3461</td><td class="line"><span class='comment'>/* No exception or error can occur; this is a quiet bitwise operation.*/</span></td></tr>
<tr><td class="num" id="LN3462">3462</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3463">3463</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberCopySign<span class='expansion'>uprv_decNumberCopySign_54</span></span>(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN3464">3464</td><td class="line">                              <span class='keyword'>const</span> decNumber *rhs) {</td></tr>
<tr><td class="num" id="LN3465">3465</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> sign;                           <span class='comment'>/* rhs sign  */</span></td></tr>
<tr><td class="num" id="LN3466">3466</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3467">3467</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, DECUNCONT)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3468">3468</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3469">3469</td><td class="line">  sign=rhs-&gt;bits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;              <span class='comment'>/* save sign bit  */</span></td></tr>
<tr><td class="num" id="LN3470">3470</td><td class="line">  <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);</td></tr>
<tr><td class="num" id="LN3471">3471</td><td class="line">  res-&gt;bits&amp;=~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                   <span class='comment'>/* clear the sign  */</span></td></tr>
<tr><td class="num" id="LN3472">3472</td><td class="line">  res-&gt;bits|=sign;                      <span class='comment'>/* set from rhs  */</span></td></tr>
<tr><td class="num" id="LN3473">3473</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3474">3474</td><td class="line">  } <span class='comment'>/* decNumberCopySign  */</span></td></tr>
<tr><td class="num" id="LN3475">3475</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3476">3476</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3477">3477</td><td class="line"><span class='comment'>/* decNumberGetBCD -- get the coefficient in BCD8                     */</span></td></tr>
<tr><td class="num" id="LN3478">3478</td><td class="line"><span class='comment'>/*   dn is the source decNumber                                       */</span></td></tr>
<tr><td class="num" id="LN3479">3479</td><td class="line"><span class='comment'>/*   bcd is the uInt array that will receive dn-&gt;digits BCD bytes,    */</span></td></tr>
<tr><td class="num" id="LN3480">3480</td><td class="line"><span class='comment'>/*     most-significant at offset 0                                   */</span></td></tr>
<tr><td class="num" id="LN3481">3481</td><td class="line"><span class='comment'>/*   returns bcd                                                      */</span></td></tr>
<tr><td class="num" id="LN3482">3482</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3483">3483</td><td class="line"><span class='comment'>/* bcd must have at least dn-&gt;digits bytes.  No error is possible; if */</span></td></tr>
<tr><td class="num" id="LN3484">3484</td><td class="line"><span class='comment'>/* dn is a NaN or Infinite, digits must be 1 and the coefficient 0.   */</span></td></tr>
<tr><td class="num" id="LN3485">3485</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3486">3486</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> * U_EXPORT2 <span class='macro'>uprv_decNumberGetBCD<span class='expansion'>uprv_decNumberGetBCD_54</span></span>(<span class='keyword'>const</span> decNumber *dn, <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *bcd) {</td></tr>
<tr><td class="num" id="LN3487">3487</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *ub=bcd+dn-&gt;digits-1;      <span class='comment'>/* -&gt; lsd  */</span></td></tr>
<tr><td class="num" id="LN3488">3488</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up=dn-&gt;lsu;          <span class='comment'>/* Unit pointer, -&gt; lsu  */</span></td></tr>
<tr><td class="num" id="LN3489">3489</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3490">3490</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1                   /* trivial simple copy  */</span></td></tr>
<tr><td class="num" id="LN3491">3491</td><td class="line">    <span class='keyword'>for</span> (; ub&gt;=bcd; ub--, up++) *ub=*up;</td></tr>
<tr><td class="num" id="LN3492">3492</td><td class="line">  <span class='directive'>#else                            /* chopping needed  */</span></td></tr>
<tr><td class="num" id="LN3493">3493</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> u=*up;                    <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3494">3494</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;              <span class='comment'>/* downcounter through unit  */</span></td></tr>
<tr><td class="num" id="LN3495">3495</td><td class="line">    <span class='keyword'>for</span> (; ub&gt;=bcd; ub--) {</td></tr>
<tr><td class="num" id="LN3496">3496</td><td class="line">      *ub=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(u%10);           <span class='comment'>/* [*6554 trick inhibits, here]  */</span></td></tr>
<tr><td class="num" id="LN3497">3497</td><td class="line">      u=u/10;</td></tr>
<tr><td class="num" id="LN3498">3498</td><td class="line">      cut--;</td></tr>
<tr><td class="num" id="LN3499">3499</td><td class="line">      <span class='keyword'>if</span> (cut&gt;0) <span class='keyword'>continue</span>;         <span class='comment'>/* more in this unit  */</span></td></tr>
<tr><td class="num" id="LN3500">3500</td><td class="line">      up++;</td></tr>
<tr><td class="num" id="LN3501">3501</td><td class="line">      u=*up;</td></tr>
<tr><td class="num" id="LN3502">3502</td><td class="line">      cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN3503">3503</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3504">3504</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3505">3505</td><td class="line">  <span class='keyword'>return</span> bcd;</td></tr>
<tr><td class="num" id="LN3506">3506</td><td class="line">  } <span class='comment'>/* decNumberGetBCD  */</span></td></tr>
<tr><td class="num" id="LN3507">3507</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3508">3508</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3509">3509</td><td class="line"><span class='comment'>/* decNumberSetBCD -- set (replace) the coefficient from BCD8         */</span></td></tr>
<tr><td class="num" id="LN3510">3510</td><td class="line"><span class='comment'>/*   dn is the target decNumber                                       */</span></td></tr>
<tr><td class="num" id="LN3511">3511</td><td class="line"><span class='comment'>/*   bcd is the uInt array that will source n BCD bytes, most-        */</span></td></tr>
<tr><td class="num" id="LN3512">3512</td><td class="line"><span class='comment'>/*     significant at offset 0                                        */</span></td></tr>
<tr><td class="num" id="LN3513">3513</td><td class="line"><span class='comment'>/*   n is the number of digits in the source BCD array (bcd)          */</span></td></tr>
<tr><td class="num" id="LN3514">3514</td><td class="line"><span class='comment'>/*   returns dn                                                       */</span></td></tr>
<tr><td class="num" id="LN3515">3515</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3516">3516</td><td class="line"><span class='comment'>/* dn must have space for at least n digits.  No error is possible;   */</span></td></tr>
<tr><td class="num" id="LN3517">3517</td><td class="line"><span class='comment'>/* if dn is a NaN, or Infinite, or is to become a zero, n must be 1   */</span></td></tr>
<tr><td class="num" id="LN3518">3518</td><td class="line"><span class='comment'>/* and bcd[0] zero.                                                   */</span></td></tr>
<tr><td class="num" id="LN3519">3519</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3520">3520</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberSetBCD<span class='expansion'>uprv_decNumberSetBCD_54</span></span>(decNumber *dn, <span class='keyword'>const</span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *bcd, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> n) {</td></tr>
<tr><td class="num" id="LN3521">3521</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up=dn-&gt;lsu+<span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>-1;   <span class='comment'>/* -&gt; msu [target pointer]  */</span></td></tr>
<tr><td class="num" id="LN3522">3522</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *ub=bcd;                  <span class='comment'>/* -&gt; source msd  */</span></td></tr>
<tr><td class="num" id="LN3523">3523</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3524">3524</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1                        /* trivial simple copy  */</span></td></tr>
<tr><td class="num" id="LN3525">3525</td><td class="line">    <span class='keyword'>for</span> (; ub&lt;bcd+n; ub++, up--) *up=*ub;</td></tr>
<tr><td class="num" id="LN3526">3526</td><td class="line">  <span class='directive'>#else                                 /* some assembly needed  */</span></td></tr>
<tr><td class="num" id="LN3527">3527</td><td class="line">    <span class='comment'>/* calculate how many digits in msu, and hence first cut  */</span></td></tr>
<tr><td class="num" id="LN3528">3528</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> cut=<span class='macro'>MSUDIGITS(n)<span class='expansion'>((n)-(((n)&lt;=49?d2utable[n]:((n)+1 -1)/1)-1)*1)</span></span>;               <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN3529">3529</td><td class="line">    <span class='keyword'>for</span> (;up&gt;=dn-&gt;lsu; up--) {          <span class='comment'>/* each Unit from msu  */</span></td></tr>
<tr><td class="num" id="LN3530">3530</td><td class="line">      *up=0;                            <span class='comment'>/* will take &lt;=DECDPUN digits  */</span></td></tr>
<tr><td class="num" id="LN3531">3531</td><td class="line">      <span class='keyword'>for</span> (; cut&gt;0; ub++, cut--) *up=<span class='macro'>X10(*up)<span class='expansion'>(((*up)&lt;&lt;1)+((*up)&lt;&lt;3))</span></span>+*ub;</td></tr>
<tr><td class="num" id="LN3532">3532</td><td class="line">      cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;                      <span class='comment'>/* next Unit has all digits  */</span></td></tr>
<tr><td class="num" id="LN3533">3533</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3534">3534</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3535">3535</td><td class="line">  dn-&gt;digits=n;                         <span class='comment'>/* set digit count  */</span></td></tr>
<tr><td class="num" id="LN3536">3536</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN3537">3537</td><td class="line">  } <span class='comment'>/* decNumberSetBCD  */</span></td></tr>
<tr><td class="num" id="LN3538">3538</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3539">3539</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3540">3540</td><td class="line"><span class='comment'>/* decNumberIsNormal -- test normality of a decNumber                 */</span></td></tr>
<tr><td class="num" id="LN3541">3541</td><td class="line"><span class='comment'>/*   dn is the decNumber to test                                      */</span></td></tr>
<tr><td class="num" id="LN3542">3542</td><td class="line"><span class='comment'>/*   set is the context to use for Emin                               */</span></td></tr>
<tr><td class="num" id="LN3543">3543</td><td class="line"><span class='comment'>/*   returns 1 if |dn| is finite and &gt;=Nmin, 0 otherwise              */</span></td></tr>
<tr><td class="num" id="LN3544">3544</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3545">3545</td><td class="line"><span class='macro'>Int<span class='expansion'>int32_t</span></span> <span class='macro'>uprv_decNumberIsNormal<span class='expansion'>uprv_decNumberIsNormal_54</span></span>(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN3546">3546</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> ae;                               <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN3547">3547</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3548">3548</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, dn, set)) <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN3549">3549</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3550">3550</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3551">3551</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsSpecial(dn)<span class='expansion'>(((dn)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span>) <span class='keyword'>return</span> 0; <span class='comment'>/* not finite  */</span></td></tr>
<tr><td class="num" id="LN3552">3552</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>return</span> 0;    <span class='comment'>/* not non-zero  */</span></td></tr>
<tr><td class="num" id="LN3553">3553</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3554">3554</td><td class="line">  ae=dn-&gt;exponent+dn-&gt;digits-1;         <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN3555">3555</td><td class="line">  <span class='keyword'>if</span> (ae&lt;set-&gt;emin) <span class='keyword'>return</span> 0;           <span class='comment'>/* is subnormal  */</span></td></tr>
<tr><td class="num" id="LN3556">3556</td><td class="line">  <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN3557">3557</td><td class="line">  } <span class='comment'>/* decNumberIsNormal  */</span></td></tr>
<tr><td class="num" id="LN3558">3558</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3559">3559</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3560">3560</td><td class="line"><span class='comment'>/* decNumberIsSubnormal -- test subnormality of a decNumber           */</span></td></tr>
<tr><td class="num" id="LN3561">3561</td><td class="line"><span class='comment'>/*   dn is the decNumber to test                                      */</span></td></tr>
<tr><td class="num" id="LN3562">3562</td><td class="line"><span class='comment'>/*   set is the context to use for Emin                               */</span></td></tr>
<tr><td class="num" id="LN3563">3563</td><td class="line"><span class='comment'>/*   returns 1 if |dn| is finite, non-zero, and &lt;Nmin, 0 otherwise    */</span></td></tr>
<tr><td class="num" id="LN3564">3564</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3565">3565</td><td class="line"><span class='macro'>Int<span class='expansion'>int32_t</span></span> <span class='macro'>uprv_decNumberIsSubnormal<span class='expansion'>uprv_decNumberIsSubnormal_54</span></span>(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN3566">3566</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> ae;                               <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN3567">3567</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3568">3568</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, dn, set)) <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN3569">3569</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3570">3570</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3571">3571</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsSpecial(dn)<span class='expansion'>(((dn)-&gt;bits&amp;(0x40|0x20|0x10))!=0)</span></span>) <span class='keyword'>return</span> 0; <span class='comment'>/* not finite  */</span></td></tr>
<tr><td class="num" id="LN3572">3572</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>return</span> 0;    <span class='comment'>/* not non-zero  */</span></td></tr>
<tr><td class="num" id="LN3573">3573</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3574">3574</td><td class="line">  ae=dn-&gt;exponent+dn-&gt;digits-1;         <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN3575">3575</td><td class="line">  <span class='keyword'>if</span> (ae&lt;set-&gt;emin) <span class='keyword'>return</span> 1;           <span class='comment'>/* is subnormal  */</span></td></tr>
<tr><td class="num" id="LN3576">3576</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN3577">3577</td><td class="line">  } <span class='comment'>/* decNumberIsSubnormal  */</span></td></tr>
<tr><td class="num" id="LN3578">3578</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3579">3579</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3580">3580</td><td class="line"><span class='comment'>/* decNumberTrim -- remove insignificant zeros                        */</span></td></tr>
<tr><td class="num" id="LN3581">3581</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3582">3582</td><td class="line"><span class='comment'>/*   dn is the number to trim                                         */</span></td></tr>
<tr><td class="num" id="LN3583">3583</td><td class="line"><span class='comment'>/*   returns dn                                                       */</span></td></tr>
<tr><td class="num" id="LN3584">3584</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3585">3585</td><td class="line"><span class='comment'>/* All fields are updated as required.  This is a utility operation,  */</span></td></tr>
<tr><td class="num" id="LN3586">3586</td><td class="line"><span class='comment'>/* so special values are unchanged and no error is possible.  The     */</span></td></tr>
<tr><td class="num" id="LN3587">3587</td><td class="line"><span class='comment'>/* zeros are removed unconditionally.                                 */</span></td></tr>
<tr><td class="num" id="LN3588">3588</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3589">3589</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberTrim<span class='expansion'>uprv_decNumberTrim_54</span></span>(decNumber *dn) {</td></tr>
<tr><td class="num" id="LN3590">3590</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  dropped;                    <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3591">3591</td><td class="line">  decContext set;                  <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3592">3592</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3593">3593</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, DECUNUSED, dn, DECUNCONT)) <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN3594">3594</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3595">3595</td><td class="line">  <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;set, <span class='macro'>DEC_INIT_BASE<span class='expansion'>0</span></span>);    <span class='comment'>/* clamp=0  */</span></td></tr>
<tr><td class="num" id="LN3596">3596</td><td class="line">  <span class='keyword'>return</span> decTrim(dn, &amp;set, 0, 1, &amp;dropped);</td></tr>
<tr><td class="num" id="LN3597">3597</td><td class="line">  } <span class='comment'>/* decNumberTrim  */</span></td></tr>
<tr><td class="num" id="LN3598">3598</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3599">3599</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3600">3600</td><td class="line"><span class='comment'>/* decNumberVersion -- return the name and version of this module     */</span></td></tr>
<tr><td class="num" id="LN3601">3601</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3602">3602</td><td class="line"><span class='comment'>/* No error is possible.                                              */</span></td></tr>
<tr><td class="num" id="LN3603">3603</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3604">3604</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>char</span> * <span class='macro'>uprv_decNumberVersion<span class='expansion'>uprv_decNumberVersion_54</span></span>(<span class='keyword'>void</span>) {</td></tr>
<tr><td class="num" id="LN3605">3605</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>DECVERSION<span class='expansion'>"decNumber 3.61"</span></span>;</td></tr>
<tr><td class="num" id="LN3606">3606</td><td class="line">  } <span class='comment'>/* decNumberVersion  */</span></td></tr>
<tr><td class="num" id="LN3607">3607</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3608">3608</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3609">3609</td><td class="line"><span class='comment'>/* decNumberZero -- set a number to 0                                 */</span></td></tr>
<tr><td class="num" id="LN3610">3610</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3611">3611</td><td class="line"><span class='comment'>/*   dn is the number to set, with space for one digit                */</span></td></tr>
<tr><td class="num" id="LN3612">3612</td><td class="line"><span class='comment'>/*   returns dn                                                       */</span></td></tr>
<tr><td class="num" id="LN3613">3613</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3614">3614</td><td class="line"><span class='comment'>/* No error is possible.                                              */</span></td></tr>
<tr><td class="num" id="LN3615">3615</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3616">3616</td><td class="line"><span class='comment'>/* Memset is not used as it is much slower in some environments.  */</span></td></tr>
<tr><td class="num" id="LN3617">3617</td><td class="line"><span class='macro'>U_CAPI<span class='expansion'>extern</span></span> decNumber * U_EXPORT2 <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(decNumber *dn) {</td></tr>
<tr><td class="num" id="LN3618">3618</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3619">3619</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3620">3620</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(dn, DECUNUSED, DECUNUSED, DECUNCONT)) <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN3621">3621</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3622">3622</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3623">3623</td><td class="line">  dn-&gt;bits=0;</td></tr>
<tr><td class="num" id="LN3624">3624</td><td class="line">  dn-&gt;exponent=0;</td></tr>
<tr><td class="num" id="LN3625">3625</td><td class="line">  dn-&gt;digits=1;</td></tr>
<tr><td class="num" id="LN3626">3626</td><td class="line">  dn-&gt;lsu[0]=0;</td></tr>
<tr><td class="num" id="LN3627">3627</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN3628">3628</td><td class="line">  } <span class='comment'>/* decNumberZero  */</span></td></tr>
<tr><td class="num" id="LN3629">3629</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3630">3630</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN3631">3631</td><td class="line"><span class='comment'>/* Local routines                                                     */</span></td></tr>
<tr><td class="num" id="LN3632">3632</td><td class="line"><span class='comment'>/* ================================================================== */</span></td></tr>
<tr><td class="num" id="LN3633">3633</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3634">3634</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3635">3635</td><td class="line"><span class='comment'>/* decToString -- lay out a number into a string                      */</span></td></tr>
<tr><td class="num" id="LN3636">3636</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3637">3637</td><td class="line"><span class='comment'>/*   dn     is the number to lay out                                  */</span></td></tr>
<tr><td class="num" id="LN3638">3638</td><td class="line"><span class='comment'>/*   string is where to lay out the number                            */</span></td></tr>
<tr><td class="num" id="LN3639">3639</td><td class="line"><span class='comment'>/*   eng    is 1 if Engineering, 0 if Scientific                      */</span></td></tr>
<tr><td class="num" id="LN3640">3640</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3641">3641</td><td class="line"><span class='comment'>/* string must be at least dn-&gt;digits+14 characters long              */</span></td></tr>
<tr><td class="num" id="LN3642">3642</td><td class="line"><span class='comment'>/* No error is possible.                                              */</span></td></tr>
<tr><td class="num" id="LN3643">3643</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3644">3644</td><td class="line"><span class='comment'>/* Note that this routine can generate a -0 or 0.000.  These are      */</span></td></tr>
<tr><td class="num" id="LN3645">3645</td><td class="line"><span class='comment'>/* never generated in subset to-number or arithmetic, but can occur   */</span></td></tr>
<tr><td class="num" id="LN3646">3646</td><td class="line"><span class='comment'>/* in non-subset arithmetic (e.g., -1*0 or 1.234-1.234).              */</span></td></tr>
<tr><td class="num" id="LN3647">3647</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3648">3648</td><td class="line"><span class='comment'>/* If DECCHECK is enabled the string "?" is returned if a number is  */</span></td></tr>
<tr><td class="num" id="LN3649">3649</td><td class="line"><span class='comment'>/* invalid.  */</span></td></tr>
<tr><td class="num" id="LN3650">3650</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decToString(<span class='keyword'>const</span> decNumber *dn, <span class='keyword'>char</span> *string, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> eng) {</td></tr>
<tr><td class="num" id="LN3651">3651</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> exp=dn-&gt;exponent;       <span class='comment'>/* local copy  */</span></td></tr>
<tr><td class="num" id="LN3652">3652</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> e;                      <span class='comment'>/* E-part value  */</span></td></tr>
<tr><td class="num" id="LN3653">3653</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> pre;                    <span class='comment'>/* digits before the '.'  */</span></td></tr>
<tr><td class="num" id="LN3654">3654</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> cut;                    <span class='comment'>/* for counting digits in a Unit  */</span></td></tr>
<tr><td class="num" id="LN3655">3655</td><td class="line">  <span class='keyword'>char</span> *c=string;             <span class='comment'>/* work [output pointer]  */</span></td></tr>
<tr><td class="num" id="LN3656">3656</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up=dn-&gt;lsu+<span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>-1; <span class='comment'>/* -&gt; msu [input pointer]  */</span></td></tr>
<tr><td class="num" id="LN3657">3657</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> u, pow;                <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3658">3658</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3659">3659</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3660">3660</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(DECUNRESU, dn, DECUNUSED, DECUNCONT)) {</td></tr>
<tr><td class="num" id="LN3661">3661</td><td class="line">    strcpy(string, <span class='string_literal'>"?"</span>);</td></tr>
<tr><td class="num" id="LN3662">3662</td><td class="line">    <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN3663">3663</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3664">3664</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3665">3665</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) {   <span class='comment'>/* Negatives get a minus  */</span></td></tr>
<tr><td class="num" id="LN3666">3666</td><td class="line">    *c='-';</td></tr>
<tr><td class="num" id="LN3667">3667</td><td class="line">    c++;</td></tr>
<tr><td class="num" id="LN3668">3668</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3669">3669</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>) {       <span class='comment'>/* Is a special value  */</span></td></tr>
<tr><td class="num" id="LN3670">3670</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x40)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN3671">3671</td><td class="line">      strcpy(c,   <span class='string_literal'>"Inf"</span>);</td></tr>
<tr><td class="num" id="LN3672">3672</td><td class="line">      strcpy(c+3, <span class='string_literal'>"inity"</span>);</td></tr>
<tr><td class="num" id="LN3673">3673</td><td class="line">      <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN3674">3674</td><td class="line">    <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN3675">3675</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>) {        <span class='comment'>/* signalling NaN  */</span></td></tr>
<tr><td class="num" id="LN3676">3676</td><td class="line">      *c='s';</td></tr>
<tr><td class="num" id="LN3677">3677</td><td class="line">      c++;</td></tr>
<tr><td class="num" id="LN3678">3678</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3679">3679</td><td class="line">    strcpy(c, <span class='string_literal'>"NaN"</span>);</td></tr>
<tr><td class="num" id="LN3680">3680</td><td class="line">    c+=3;                          <span class='comment'>/* step past  */</span></td></tr>
<tr><td class="num" id="LN3681">3681</td><td class="line">    <span class='comment'>/* if not a clean non-zero coefficient, that's all there is in a  */</span></td></tr>
<tr><td class="num" id="LN3682">3682</td><td class="line">    <span class='comment'>/* NaN string  */</span></td></tr>
<tr><td class="num" id="LN3683">3683</td><td class="line">    <span class='keyword'>if</span> (exp!=0 || (*dn-&gt;lsu==0 &amp;&amp; dn-&gt;digits==1)) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN3684">3684</td><td class="line">    <span class='comment'>/* [drop through to add integer]  */</span></td></tr>
<tr><td class="num" id="LN3685">3685</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3686">3686</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3687">3687</td><td class="line">  <span class='comment'>/* calculate how many digits in msu, and hence first cut  */</span></td></tr>
<tr><td class="num" id="LN3688">3688</td><td class="line">  cut=<span class='macro'>MSUDIGITS(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)-(((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits<br>]:((dn-&gt;digits)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* [faster than remainder]  */</span></td></tr>
<tr><td class="num" id="LN3689">3689</td><td class="line">  cut--;                           <span class='comment'>/* power of ten for digit  */</span></td></tr>
<tr><td class="num" id="LN3690">3690</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3691">3691</td><td class="line">  <span class='keyword'>if</span> (exp==0) {                    <span class='comment'>/* simple integer [common fastpath]  */</span></td></tr>
<tr><td class="num" id="LN3692">3692</td><td class="line">    <span class='keyword'>for</span> (;up&gt;=dn-&gt;lsu; up--) {     <span class='comment'>/* each Unit from msu  */</span></td></tr>
<tr><td class="num" id="LN3693">3693</td><td class="line">      u=*up;                       <span class='comment'>/* contains DECDPUN digits to lay out  */</span></td></tr>
<tr><td class="num" id="LN3694">3694</td><td class="line">      <span class='keyword'>for</span> (; cut&gt;=0; c++, cut--) <span class='macro'>TODIGIT(u, cut, c, pow)<span class='expansion'>{ *(c)='0'; pow=DECPOWERS[cut]*2; if ((u)&gt;pow) { pow*=4; if<br> ((u)&gt;=pow) {(u)-=pow; *(c)+=8;} pow/=2; if ((u)&gt;=pow) {<br>(u)-=pow; *(c)+=4;} pow/=2; } if ((u)&gt;=pow) {(u)-=pow; *(c<br>)+=2;} pow/=2; if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;} }</span></span>;</td></tr>
<tr><td class="num" id="LN3695">3695</td><td class="line">      cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1;               <span class='comment'>/* next Unit has all digits  */</span></td></tr>
<tr><td class="num" id="LN3696">3696</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3697">3697</td><td class="line">    *c='\0';                       <span class='comment'>/* terminate the string  */</span></td></tr>
<tr><td class="num" id="LN3698">3698</td><td class="line">    <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN3699">3699</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3700">3700</td><td class="line">  <span class='comment'>/* non-0 exponent -- assume plain form */</span></td></tr>
<tr><td class="num" id="LN3701">3701</td><td class="line">  pre=dn-&gt;digits+exp;              <span class='comment'>/* digits before '.'  */</span></td></tr>
<tr><td class="num" id="LN3702">3702</td><td class="line">  e=0;                             <span class='comment'>/* no E  */</span></td></tr>
<tr><td class="num" id="LN3703">3703</td><td class="line">  <span class='keyword'>if</span> ((exp&gt;0) || (pre&lt;-5)) {       <span class='comment'>/* need exponential form  */</span></td></tr>
<tr><td class="num" id="LN3704">3704</td><td class="line">    e=exp+dn-&gt;digits-1;            <span class='comment'>/* calculate E value  */</span></td></tr>
<tr><td class="num" id="LN3705">3705</td><td class="line">    pre=1;                         <span class='comment'>/* assume one digit before '.'  */</span></td></tr>
<tr><td class="num" id="LN3706">3706</td><td class="line">    <span class='keyword'>if</span> (eng &amp;&amp; (e!=0)) {           <span class='comment'>/* engineering: may need to adjust  */</span></td></tr>
<tr><td class="num" id="LN3707">3707</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> adj;                     <span class='comment'>/* adjustment  */</span></td></tr>
<tr><td class="num" id="LN3708">3708</td><td class="line">      <span class='comment'>/* The C remainder operator is undefined for negative numbers, so  */</span></td></tr>
<tr><td class="num" id="LN3709">3709</td><td class="line">      <span class='comment'>/* a positive remainder calculation must be used here  */</span></td></tr>
<tr><td class="num" id="LN3710">3710</td><td class="line">      <span class='keyword'>if</span> (e&lt;0) {</td></tr>
<tr><td class="num" id="LN3711">3711</td><td class="line">        adj=(-e)%3;</td></tr>
<tr><td class="num" id="LN3712">3712</td><td class="line">        <span class='keyword'>if</span> (adj!=0) adj=3-adj;</td></tr>
<tr><td class="num" id="LN3713">3713</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3714">3714</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* e&gt;0  */</span></td></tr>
<tr><td class="num" id="LN3715">3715</td><td class="line">        adj=e%3;</td></tr>
<tr><td class="num" id="LN3716">3716</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3717">3717</td><td class="line">      e=e-adj;</td></tr>
<tr><td class="num" id="LN3718">3718</td><td class="line">      <span class='comment'>/* if dealing with zero still produce an exponent which is a  */</span></td></tr>
<tr><td class="num" id="LN3719">3719</td><td class="line">      <span class='comment'>/* multiple of three, as expected, but there will only be the  */</span></td></tr>
<tr><td class="num" id="LN3720">3720</td><td class="line">      <span class='comment'>/* one zero before the E, still.  Otherwise note the padding.  */</span></td></tr>
<tr><td class="num" id="LN3721">3721</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) pre+=adj;</td></tr>
<tr><td class="num" id="LN3722">3722</td><td class="line">       <span class='keyword'>else</span> {  <span class='comment'>/* is zero  */</span></td></tr>
<tr><td class="num" id="LN3723">3723</td><td class="line">        <span class='keyword'>if</span> (adj!=0) {              <span class='comment'>/* 0.00Esnn needed  */</span></td></tr>
<tr><td class="num" id="LN3724">3724</td><td class="line">          e=e+3;</td></tr>
<tr><td class="num" id="LN3725">3725</td><td class="line">          pre=-(2-adj);</td></tr>
<tr><td class="num" id="LN3726">3726</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3727">3727</td><td class="line">        } <span class='comment'>/* zero  */</span></td></tr>
<tr><td class="num" id="LN3728">3728</td><td class="line">      } <span class='comment'>/* eng  */</span></td></tr>
<tr><td class="num" id="LN3729">3729</td><td class="line">    } <span class='comment'>/* need exponent  */</span></td></tr>
<tr><td class="num" id="LN3730">3730</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3731">3731</td><td class="line">  <span class='comment'>/* lay out the digits of the coefficient, adding 0s and . as needed */</span></td></tr>
<tr><td class="num" id="LN3732">3732</td><td class="line">  u=*up;</td></tr>
<tr><td class="num" id="LN3733">3733</td><td class="line">  <span class='keyword'>if</span> (pre&gt;0) {                     <span class='comment'>/* xxx.xxx or xx00 (engineering) form  */</span></td></tr>
<tr><td class="num" id="LN3734">3734</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> n=pre;</td></tr>
<tr><td class="num" id="LN3735">3735</td><td class="line">    <span class='keyword'>for</span> (; pre&gt;0; pre--, c++, cut--) {</td></tr>
<tr><td class="num" id="LN3736">3736</td><td class="line">      <span class='keyword'>if</span> (cut&lt;0) {                 <span class='comment'>/* need new Unit  */</span></td></tr>
<tr><td class="num" id="LN3737">3737</td><td class="line">        <span class='keyword'>if</span> (up==dn-&gt;lsu) <span class='keyword'>break</span>;    <span class='comment'>/* out of input digits (pre&gt;digits)  */</span></td></tr>
<tr><td class="num" id="LN3738">3738</td><td class="line">        up--;</td></tr>
<tr><td class="num" id="LN3739">3739</td><td class="line">        cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1;</td></tr>
<tr><td class="num" id="LN3740">3740</td><td class="line">        u=*up;</td></tr>
<tr><td class="num" id="LN3741">3741</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3742">3742</td><td class="line">      <span class='macro'>TODIGIT(u, cut, c, pow)<span class='expansion'>{ *(c)='0'; pow=DECPOWERS[cut]*2; if ((u)&gt;pow) { pow*=4; if<br> ((u)&gt;=pow) {(u)-=pow; *(c)+=8;} pow/=2; if ((u)&gt;=pow) {<br>(u)-=pow; *(c)+=4;} pow/=2; } if ((u)&gt;=pow) {(u)-=pow; *(c<br>)+=2;} pow/=2; if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;} }</span></span>;</td></tr>
<tr><td class="num" id="LN3743">3743</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3744">3744</td><td class="line">    <span class='keyword'>if</span> (n&lt;dn-&gt;digits) {            <span class='comment'>/* more to come, after '.'  */</span></td></tr>
<tr><td class="num" id="LN3745">3745</td><td class="line">      *c='.'; c++;</td></tr>
<tr><td class="num" id="LN3746">3746</td><td class="line">      <span class='keyword'>for</span> (;; c++, cut--) {</td></tr>
<tr><td class="num" id="LN3747">3747</td><td class="line">        <span class='keyword'>if</span> (cut&lt;0) {               <span class='comment'>/* need new Unit  */</span></td></tr>
<tr><td class="num" id="LN3748">3748</td><td class="line">          <span class='keyword'>if</span> (up==dn-&gt;lsu) <span class='keyword'>break</span>;  <span class='comment'>/* out of input digits  */</span></td></tr>
<tr><td class="num" id="LN3749">3749</td><td class="line">          up--;</td></tr>
<tr><td class="num" id="LN3750">3750</td><td class="line">          cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1;</td></tr>
<tr><td class="num" id="LN3751">3751</td><td class="line">          u=*up;</td></tr>
<tr><td class="num" id="LN3752">3752</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3753">3753</td><td class="line">        <span class='macro'>TODIGIT(u, cut, c, pow)<span class='expansion'>{ *(c)='0'; pow=DECPOWERS[cut]*2; if ((u)&gt;pow) { pow*=4; if<br> ((u)&gt;=pow) {(u)-=pow; *(c)+=8;} pow/=2; if ((u)&gt;=pow) {<br>(u)-=pow; *(c)+=4;} pow/=2; } if ((u)&gt;=pow) {(u)-=pow; *(c<br>)+=2;} pow/=2; if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;} }</span></span>;</td></tr>
<tr><td class="num" id="LN3754">3754</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3755">3755</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3756">3756</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>for</span> (; pre&gt;0; pre--, c++) *c='0'; <span class='comment'>/* 0 padding (for engineering) needed  */</span></td></tr>
<tr><td class="num" id="LN3757">3757</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3758">3758</td><td class="line">   <span class='keyword'>else</span> {                          <span class='comment'>/* 0.xxx or 0.000xxx form  */</span></td></tr>
<tr><td class="num" id="LN3759">3759</td><td class="line">    *c='0'; c++;</td></tr>
<tr><td class="num" id="LN3760">3760</td><td class="line">    *c='.'; c++;</td></tr>
<tr><td class="num" id="LN3761">3761</td><td class="line">    <span class='keyword'>for</span> (; pre&lt;0; pre++, c++) *c='0';   <span class='comment'>/* add any 0's after '.'  */</span></td></tr>
<tr><td class="num" id="LN3762">3762</td><td class="line">    <span class='keyword'>for</span> (; ; c++, cut--) {</td></tr>
<tr><td class="num" id="LN3763">3763</td><td class="line">      <span class='keyword'>if</span> (cut&lt;0) {                 <span class='comment'>/* need new Unit  */</span></td></tr>
<tr><td class="num" id="LN3764">3764</td><td class="line">        <span class='keyword'>if</span> (up==dn-&gt;lsu) <span class='keyword'>break</span>;    <span class='comment'>/* out of input digits  */</span></td></tr>
<tr><td class="num" id="LN3765">3765</td><td class="line">        up--;</td></tr>
<tr><td class="num" id="LN3766">3766</td><td class="line">        cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1;</td></tr>
<tr><td class="num" id="LN3767">3767</td><td class="line">        u=*up;</td></tr>
<tr><td class="num" id="LN3768">3768</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3769">3769</td><td class="line">      <span class='macro'>TODIGIT(u, cut, c, pow)<span class='expansion'>{ *(c)='0'; pow=DECPOWERS[cut]*2; if ((u)&gt;pow) { pow*=4; if<br> ((u)&gt;=pow) {(u)-=pow; *(c)+=8;} pow/=2; if ((u)&gt;=pow) {<br>(u)-=pow; *(c)+=4;} pow/=2; } if ((u)&gt;=pow) {(u)-=pow; *(c<br>)+=2;} pow/=2; if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;} }</span></span>;</td></tr>
<tr><td class="num" id="LN3770">3770</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3771">3771</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3772">3772</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3773">3773</td><td class="line">  <span class='comment'>/* Finally add the E-part, if needed.  It will never be 0, has a</span></td></tr>
<tr><td class="num" id="LN3774">3774</td><td class="line">     <span class='comment'>base maximum and minimum of +999999999 through -999999999, but</span></td></tr>
<tr><td class="num" id="LN3775">3775</td><td class="line">     <span class='comment'>could range down to -1999999998 for anormal numbers */</span></td></tr>
<tr><td class="num" id="LN3776">3776</td><td class="line">  <span class='keyword'>if</span> (e!=0) {</td></tr>
<tr><td class="num" id="LN3777">3777</td><td class="line">    <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> had=0;               <span class='comment'>/* 1=had non-zero  */</span></td></tr>
<tr><td class="num" id="LN3778">3778</td><td class="line">    *c='E'; c++;</td></tr>
<tr><td class="num" id="LN3779">3779</td><td class="line">    *c='+'; c++;              <span class='comment'>/* assume positive  */</span></td></tr>
<tr><td class="num" id="LN3780">3780</td><td class="line">    u=e;                      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3781">3781</td><td class="line">    <span class='keyword'>if</span> (e&lt;0) {</td></tr>
<tr><td class="num" id="LN3782">3782</td><td class="line">      *(c-1)='-';             <span class='comment'>/* oops, need -  */</span></td></tr>
<tr><td class="num" id="LN3783">3783</td><td class="line">      u=-e;                   <span class='comment'>/* uInt, please  */</span></td></tr>
<tr><td class="num" id="LN3784">3784</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3785">3785</td><td class="line">    <span class='comment'>/* lay out the exponent [_itoa or equivalent is not ANSI C]  */</span></td></tr>
<tr><td class="num" id="LN3786">3786</td><td class="line">    <span class='keyword'>for</span> (cut=9; cut&gt;=0; cut--) {</td></tr>
<tr><td class="num" id="LN3787">3787</td><td class="line">      <span class='macro'>TODIGIT(u, cut, c, pow)<span class='expansion'>{ *(c)='0'; pow=DECPOWERS[cut]*2; if ((u)&gt;pow) { pow*=4; if<br> ((u)&gt;=pow) {(u)-=pow; *(c)+=8;} pow/=2; if ((u)&gt;=pow) {<br>(u)-=pow; *(c)+=4;} pow/=2; } if ((u)&gt;=pow) {(u)-=pow; *(c<br>)+=2;} pow/=2; if ((u)&gt;=pow) {(u)-=pow; *(c)+=1;} }</span></span>;</td></tr>
<tr><td class="num" id="LN3788">3788</td><td class="line">      <span class='keyword'>if</span> (*c=='0' &amp;&amp; !had) <span class='keyword'>continue</span>;    <span class='comment'>/* skip leading zeros  */</span></td></tr>
<tr><td class="num" id="LN3789">3789</td><td class="line">      had=1;                            <span class='comment'>/* had non-0  */</span></td></tr>
<tr><td class="num" id="LN3790">3790</td><td class="line">      c++;                              <span class='comment'>/* step for next  */</span></td></tr>
<tr><td class="num" id="LN3791">3791</td><td class="line">      } <span class='comment'>/* cut  */</span></td></tr>
<tr><td class="num" id="LN3792">3792</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3793">3793</td><td class="line">  *c='\0';          <span class='comment'>/* terminate the string (all paths)  */</span></td></tr>
<tr><td class="num" id="LN3794">3794</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN3795">3795</td><td class="line">  } <span class='comment'>/* decToString  */</span></td></tr>
<tr><td class="num" id="LN3796">3796</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3797">3797</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3798">3798</td><td class="line"><span class='comment'>/* decAddOp -- add/subtract operation                                 */</span></td></tr>
<tr><td class="num" id="LN3799">3799</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3800">3800</td><td class="line"><span class='comment'>/*   This computes C = A + B                                          */</span></td></tr>
<tr><td class="num" id="LN3801">3801</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3802">3802</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X+X)         */</span></td></tr>
<tr><td class="num" id="LN3803">3803</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN3804">3804</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN3805">3805</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN3806">3806</td><td class="line"><span class='comment'>/*   negate is DECNEG if rhs should be negated, or 0 otherwise        */</span></td></tr>
<tr><td class="num" id="LN3807">3807</td><td class="line"><span class='comment'>/*   status accumulates status for the caller                         */</span></td></tr>
<tr><td class="num" id="LN3808">3808</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3809">3809</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN3810">3810</td><td class="line"><span class='comment'>/* Inexact in status must be 0 for correct Exact zero sign in result  */</span></td></tr>
<tr><td class="num" id="LN3811">3811</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3812">3812</td><td class="line"><span class='comment'>/* If possible, the coefficient is calculated directly into C.        */</span></td></tr>
<tr><td class="num" id="LN3813">3813</td><td class="line"><span class='comment'>/* However, if:                                                       */</span></td></tr>
<tr><td class="num" id="LN3814">3814</td><td class="line"><span class='comment'>/*   -- a digits+1 calculation is needed because the numbers are      */</span></td></tr>
<tr><td class="num" id="LN3815">3815</td><td class="line"><span class='comment'>/*      unaligned and span more than set-&gt;digits digits               */</span></td></tr>
<tr><td class="num" id="LN3816">3816</td><td class="line"><span class='comment'>/*   -- a carry to digits+1 digits looks possible                     */</span></td></tr>
<tr><td class="num" id="LN3817">3817</td><td class="line"><span class='comment'>/*   -- C is the same as A or B, and the result would destructively   */</span></td></tr>
<tr><td class="num" id="LN3818">3818</td><td class="line"><span class='comment'>/*      overlap the A or B coefficient                                */</span></td></tr>
<tr><td class="num" id="LN3819">3819</td><td class="line"><span class='comment'>/* then the result must be calculated into a temporary buffer.  In    */</span></td></tr>
<tr><td class="num" id="LN3820">3820</td><td class="line"><span class='comment'>/* this case a local (stack) buffer is used if possible, and only if  */</span></td></tr>
<tr><td class="num" id="LN3821">3821</td><td class="line"><span class='comment'>/* too long for that does malloc become the final resort.             */</span></td></tr>
<tr><td class="num" id="LN3822">3822</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3823">3823</td><td class="line"><span class='comment'>/* Misalignment is handled as follows:                                */</span></td></tr>
<tr><td class="num" id="LN3824">3824</td><td class="line"><span class='comment'>/*   Apad: (AExp&gt;BExp) Swap operands and proceed as for BExp&gt;AExp.    */</span></td></tr>
<tr><td class="num" id="LN3825">3825</td><td class="line"><span class='comment'>/*   BPad: Apply the padding by a combination of shifting (whole      */</span></td></tr>
<tr><td class="num" id="LN3826">3826</td><td class="line"><span class='comment'>/*         units) and multiplication (part units).                    */</span></td></tr>
<tr><td class="num" id="LN3827">3827</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN3828">3828</td><td class="line"><span class='comment'>/* Addition, especially x=x+1, is speed-critical.                     */</span></td></tr>
<tr><td class="num" id="LN3829">3829</td><td class="line"><span class='comment'>/* The static buffer is larger than might be expected to allow for    */</span></td></tr>
<tr><td class="num" id="LN3830">3830</td><td class="line"><span class='comment'>/* calls from higher-level funtions (notable exp).                    */</span></td></tr>
<tr><td class="num" id="LN3831">3831</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN3832">3832</td><td class="line"><span class='keyword'>static</span> decNumber * decAddOp(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN3833">3833</td><td class="line">                            <span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN3834">3834</td><td class="line">                            <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> negate, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN3835">3835</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3836">3836</td><td class="line">  decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded lhs allocated  */</span></td></tr>
<tr><td class="num" id="LN3837">3837</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* .., rhs  */</span></td></tr>
<tr><td class="num" id="LN3838">3838</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3839">3839</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   rhsshift;                  <span class='comment'>/* working shift (in Units)  */</span></td></tr>
<tr><td class="num" id="LN3840">3840</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   maxdigits;                 <span class='comment'>/* longest logical length  */</span></td></tr>
<tr><td class="num" id="LN3841">3841</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   mult;                      <span class='comment'>/* multiplier  */</span></td></tr>
<tr><td class="num" id="LN3842">3842</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   residue;                   <span class='comment'>/* rounding accumulator  */</span></td></tr>
<tr><td class="num" id="LN3843">3843</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> bits;                      <span class='comment'>/* result bits  */</span></td></tr>
<tr><td class="num" id="LN3844">3844</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span>  diffsign;                  <span class='comment'>/* non-0 if arguments have different sign  */</span></td></tr>
<tr><td class="num" id="LN3845">3845</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *acc;                      <span class='comment'>/* accumulator for result  */</span></td></tr>
<tr><td class="num" id="LN3846">3846</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  accbuff[<span class='macro'>SD2U(DECBUFFER*2+20)<span class='expansion'>(((36*2+20)+1 -1)/1)</span></span>]; <span class='comment'>/* local buffer [*2+20 reduces many  */</span></td></tr>
<tr><td class="num" id="LN3847">3847</td><td class="line">                                   <span class='comment'>/* allocations when called from  */</span></td></tr>
<tr><td class="num" id="LN3848">3848</td><td class="line">                                   <span class='comment'>/* other operations, notable exp]  */</span></td></tr>
<tr><td class="num" id="LN3849">3849</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *allocacc=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated acc buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN3850">3850</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   reqdigits=set-&gt;digits;     <span class='comment'>/* local copy; requested DIGITS  */</span></td></tr>
<tr><td class="num" id="LN3851">3851</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   padding;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3852">3852</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3853">3853</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3854">3854</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN3855">3855</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3856">3856</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3857">3857</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN3858">3858</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3859">3859</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN3860">3860</td><td class="line">      <span class='comment'>/* reduce operands and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN3861">3861</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN3862">3862</td><td class="line">        alloclhs=decRoundOperand(lhs, set, status);</td></tr>
<tr><td class="num" id="LN3863">3863</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3864">3864</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN3865">3865</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3866">3866</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN3867">3867</td><td class="line">        allocrhs=decRoundOperand(rhs, set, status);</td></tr>
<tr><td class="num" id="LN3868">3868</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3869">3869</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN3870">3870</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3871">3871</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3872">3872</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3873">3873</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN3874">3874</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3875">3875</td><td class="line">    <span class='comment'>/* note whether signs differ [used all paths]  */</span></td></tr>
<tr><td class="num" id="LN3876">3876</td><td class="line">    diffsign=(<span class='macro'>Flag<span class='expansion'>uint8_t</span></span>)((lhs-&gt;bits^rhs-&gt;bits^negate)&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);</td></tr>
<tr><td class="num" id="LN3877">3877</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3878">3878</td><td class="line">    <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN3879">3879</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {                  <span class='comment'>/* a special bit set  */</span></td></tr>
<tr><td class="num" id="LN3880">3880</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span> &amp; (<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span> | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>))  <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN3881">3881</td><td class="line">        decNaNs(res, lhs, rhs, set, status);</td></tr>
<tr><td class="num" id="LN3882">3882</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* one or two infinities  */</span></td></tr>
<tr><td class="num" id="LN3883">3883</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x40)!=0)</span></span>) { <span class='comment'>/* LHS is infinity  */</span></td></tr>
<tr><td class="num" id="LN3884">3884</td><td class="line">          <span class='comment'>/* two infinities with different signs is invalid  */</span></td></tr>
<tr><td class="num" id="LN3885">3885</td><td class="line">          <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span> &amp;&amp; diffsign) {</td></tr>
<tr><td class="num" id="LN3886">3886</td><td class="line">            *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN3887">3887</td><td class="line">            <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3888">3888</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3889">3889</td><td class="line">          bits=lhs-&gt;bits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;      <span class='comment'>/* get sign from LHS  */</span></td></tr>
<tr><td class="num" id="LN3890">3890</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3891">3891</td><td class="line">         <span class='keyword'>else</span> bits=(rhs-&gt;bits^negate) &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;<span class='comment'>/* RHS must be Infinity  */</span></td></tr>
<tr><td class="num" id="LN3892">3892</td><td class="line">        bits|=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;</td></tr>
<tr><td class="num" id="LN3893">3893</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN3894">3894</td><td class="line">        res-&gt;bits=bits;                 <span class='comment'>/* set +/- infinity  */</span></td></tr>
<tr><td class="num" id="LN3895">3895</td><td class="line">        } <span class='comment'>/* an infinity  */</span></td></tr>
<tr><td class="num" id="LN3896">3896</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3897">3897</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3898">3898</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3899">3899</td><td class="line">    <span class='comment'>/* Quick exit for add 0s; return the non-0, modified as need be  */</span></td></tr>
<tr><td class="num" id="LN3900">3900</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN3901">3901</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> adjust;                       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3902">3902</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> lexp=lhs-&gt;exponent;           <span class='comment'>/* save in case LHS==RES  */</span></td></tr>
<tr><td class="num" id="LN3903">3903</td><td class="line">      bits=<span class="mrange">lhs-&gt;bits</span>;                   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:7ex">Value stored to 'bits' is never read</div></td></tr>
<tr><td class="num" id="LN3904">3904</td><td class="line">      residue=0;                        <span class='comment'>/* clear accumulator  */</span></td></tr>
<tr><td class="num" id="LN3905">3905</td><td class="line">      decCopyFit(res, rhs, set, &amp;residue, status); <span class='comment'>/* copy (as needed)  */</span></td></tr>
<tr><td class="num" id="LN3906">3906</td><td class="line">      res-&gt;bits^=negate;                <span class='comment'>/* flip if rhs was negated  */</span></td></tr>
<tr><td class="num" id="LN3907">3907</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3908">3908</td><td class="line">      <span class='keyword'>if</span> (set-&gt;extended) {              <span class='comment'>/* exponents on zeros count  */</span></td></tr>
<tr><td class="num" id="LN3909">3909</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3910">3910</td><td class="line">        <span class='comment'>/* exponent will be the lower of the two  */</span></td></tr>
<tr><td class="num" id="LN3911">3911</td><td class="line">        adjust=lexp-res-&gt;exponent;      <span class='comment'>/* adjustment needed [if -ve]  */</span></td></tr>
<tr><td class="num" id="LN3912">3912</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>ISZERO(res)<span class='expansion'>(*(res)-&gt;lsu==0 &amp;&amp; (res)-&gt;digits==1 &amp;&amp; (<br>((res)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {              <span class='comment'>/* both 0: special IEEE 754 rules  */</span></td></tr>
<tr><td class="num" id="LN3913">3913</td><td class="line">          <span class='keyword'>if</span> (adjust&lt;0) res-&gt;exponent=lexp;  <span class='comment'>/* set exponent  */</span></td></tr>
<tr><td class="num" id="LN3914">3914</td><td class="line">          <span class='comment'>/* 0-0 gives +0 unless rounding to -infinity, and -0-0 gives -0  */</span></td></tr>
<tr><td class="num" id="LN3915">3915</td><td class="line">          <span class='keyword'>if</span> (diffsign) {</td></tr>
<tr><td class="num" id="LN3916">3916</td><td class="line">            <span class='keyword'>if</span> (set-&gt;round!=DEC_ROUND_FLOOR) res-&gt;bits=0;</td></tr>
<tr><td class="num" id="LN3917">3917</td><td class="line">             <span class='keyword'>else</span> res-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;     <span class='comment'>/* preserve 0 sign  */</span></td></tr>
<tr><td class="num" id="LN3918">3918</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3919">3919</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3920">3920</td><td class="line">         <span class='keyword'>else</span> { <span class='comment'>/* non-0 res  */</span></td></tr>
<tr><td class="num" id="LN3921">3921</td><td class="line">          <span class='keyword'>if</span> (adjust&lt;0) {     <span class='comment'>/* 0-padding needed  */</span></td></tr>
<tr><td class="num" id="LN3922">3922</td><td class="line">            <span class='keyword'>if</span> ((res-&gt;digits-adjust)&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN3923">3923</td><td class="line">              adjust=res-&gt;digits-set-&gt;digits;     <span class='comment'>/* to fit exactly  */</span></td></tr>
<tr><td class="num" id="LN3924">3924</td><td class="line">              *status|=<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;               <span class='comment'>/* [but exact]  */</span></td></tr>
<tr><td class="num" id="LN3925">3925</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN3926">3926</td><td class="line">            res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, -adjust);</td></tr>
<tr><td class="num" id="LN3927">3927</td><td class="line">            res-&gt;exponent+=adjust;                <span class='comment'>/* set the exponent.  */</span></td></tr>
<tr><td class="num" id="LN3928">3928</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3929">3929</td><td class="line">          } <span class='comment'>/* non-0 res  */</span></td></tr>
<tr><td class="num" id="LN3930">3930</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3931">3931</td><td class="line">        } <span class='comment'>/* extended  */</span></td></tr>
<tr><td class="num" id="LN3932">3932</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3933">3933</td><td class="line">      <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;      <span class='comment'>/* clean and finalize  */</span></td></tr>
<tr><td class="num" id="LN3934">3934</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN3935">3935</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3936">3936</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                  <span class='comment'>/* [lhs is non-zero]  */</span></td></tr>
<tr><td class="num" id="LN3937">3937</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> adjust;                       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN3938">3938</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> rexp=rhs-&gt;exponent;           <span class='comment'>/* save in case RHS==RES  */</span></td></tr>
<tr><td class="num" id="LN3939">3939</td><td class="line">      bits=rhs-&gt;bits;                   <span class='comment'>/* be clean  */</span></td></tr>
<tr><td class="num" id="LN3940">3940</td><td class="line">      residue=0;                        <span class='comment'>/* clear accumulator  */</span></td></tr>
<tr><td class="num" id="LN3941">3941</td><td class="line">      decCopyFit(res, lhs, set, &amp;residue, status); <span class='comment'>/* copy (as needed)  */</span></td></tr>
<tr><td class="num" id="LN3942">3942</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3943">3943</td><td class="line">      <span class='keyword'>if</span> (set-&gt;extended) {              <span class='comment'>/* exponents on zeros count  */</span></td></tr>
<tr><td class="num" id="LN3944">3944</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3945">3945</td><td class="line">        <span class='comment'>/* exponent will be the lower of the two  */</span></td></tr>
<tr><td class="num" id="LN3946">3946</td><td class="line">        <span class='comment'>/* [0-0 case handled above]  */</span></td></tr>
<tr><td class="num" id="LN3947">3947</td><td class="line">        adjust=rexp-res-&gt;exponent;      <span class='comment'>/* adjustment needed [if -ve]  */</span></td></tr>
<tr><td class="num" id="LN3948">3948</td><td class="line">        <span class='keyword'>if</span> (adjust&lt;0) {     <span class='comment'>/* 0-padding needed  */</span></td></tr>
<tr><td class="num" id="LN3949">3949</td><td class="line">          <span class='keyword'>if</span> ((res-&gt;digits-adjust)&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN3950">3950</td><td class="line">            adjust=res-&gt;digits-set-&gt;digits;     <span class='comment'>/* to fit exactly  */</span></td></tr>
<tr><td class="num" id="LN3951">3951</td><td class="line">            *status|=<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;               <span class='comment'>/* [but exact]  */</span></td></tr>
<tr><td class="num" id="LN3952">3952</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3953">3953</td><td class="line">          res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, -adjust);</td></tr>
<tr><td class="num" id="LN3954">3954</td><td class="line">          res-&gt;exponent+=adjust;                <span class='comment'>/* set the exponent.  */</span></td></tr>
<tr><td class="num" id="LN3955">3955</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3956">3956</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN3957">3957</td><td class="line">        } <span class='comment'>/* extended  */</span></td></tr>
<tr><td class="num" id="LN3958">3958</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN3959">3959</td><td class="line">      <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;      <span class='comment'>/* clean and finalize  */</span></td></tr>
<tr><td class="num" id="LN3960">3960</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN3961">3961</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3962">3962</td><td class="line">    <span class='comment'>/* [NB: both fastpath and mainpath code below assume these cases  */</span></td></tr>
<tr><td class="num" id="LN3963">3963</td><td class="line">    <span class='comment'>/* (notably 0-0) have already been handled]  */</span></td></tr>
<tr><td class="num" id="LN3964">3964</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3965">3965</td><td class="line">    <span class='comment'>/* calculate the padding needed to align the operands  */</span></td></tr>
<tr><td class="num" id="LN3966">3966</td><td class="line">    padding=rhs-&gt;exponent-lhs-&gt;exponent;</td></tr>
<tr><td class="num" id="LN3967">3967</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3968">3968</td><td class="line">    <span class='comment'>/* Fastpath cases where the numbers are aligned and normal, the RHS  */</span></td></tr>
<tr><td class="num" id="LN3969">3969</td><td class="line">    <span class='comment'>/* is all in one unit, no operand rounding is needed, and no carry,  */</span></td></tr>
<tr><td class="num" id="LN3970">3970</td><td class="line">    <span class='comment'>/* lengthening, or borrow is needed  */</span></td></tr>
<tr><td class="num" id="LN3971">3971</td><td class="line">    <span class='keyword'>if</span> (padding==0</td></tr>
<tr><td class="num" id="LN3972">3972</td><td class="line">        &amp;&amp; rhs-&gt;digits&lt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span></td></tr>
<tr><td class="num" id="LN3973">3973</td><td class="line">        &amp;&amp; rhs-&gt;exponent&gt;=set-&gt;emin     <span class='comment'>/* [some normals drop through]  */</span></td></tr>
<tr><td class="num" id="LN3974">3974</td><td class="line">        &amp;&amp; rhs-&gt;exponent&lt;=set-&gt;emax-set-&gt;digits+1 <span class='comment'>/* [could clamp]  */</span></td></tr>
<tr><td class="num" id="LN3975">3975</td><td class="line">        &amp;&amp; rhs-&gt;digits&lt;=reqdigits</td></tr>
<tr><td class="num" id="LN3976">3976</td><td class="line">        &amp;&amp; lhs-&gt;digits&lt;=reqdigits) {</td></tr>
<tr><td class="num" id="LN3977">3977</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> partial=*lhs-&gt;lsu;</td></tr>
<tr><td class="num" id="LN3978">3978</td><td class="line">      <span class='keyword'>if</span> (!diffsign) {                  <span class='comment'>/* adding  */</span></td></tr>
<tr><td class="num" id="LN3979">3979</td><td class="line">        partial+=*rhs-&gt;lsu;</td></tr>
<tr><td class="num" id="LN3980">3980</td><td class="line">        <span class='keyword'>if</span> ((partial&lt;=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>)       <span class='comment'>/* result fits in unit  */</span></td></tr>
<tr><td class="num" id="LN3981">3981</td><td class="line">         &amp;&amp; (lhs-&gt;digits&gt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span> ||    <span class='comment'>/* .. and no digits-count change  */</span></td></tr>
<tr><td class="num" id="LN3982">3982</td><td class="line">             partial&lt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[lhs-&gt;digits])) { <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN3983">3983</td><td class="line">          <span class='keyword'>if</span> (res!=lhs) <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);  <span class='comment'>/* not in place  */</span></td></tr>
<tr><td class="num" id="LN3984">3984</td><td class="line">          *res-&gt;lsu=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)partial;      <span class='comment'>/* [copy could have overwritten RHS]  */</span></td></tr>
<tr><td class="num" id="LN3985">3985</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3986">3986</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3987">3987</td><td class="line">        <span class='comment'>/* else drop out for careful add  */</span></td></tr>
<tr><td class="num" id="LN3988">3988</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3989">3989</td><td class="line">       <span class='keyword'>else</span> {                           <span class='comment'>/* signs differ  */</span></td></tr>
<tr><td class="num" id="LN3990">3990</td><td class="line">        partial-=*rhs-&gt;lsu;</td></tr>
<tr><td class="num" id="LN3991">3991</td><td class="line">        <span class='keyword'>if</span> (partial&gt;0) { <span class='comment'>/* no borrow needed, and non-0 result  */</span></td></tr>
<tr><td class="num" id="LN3992">3992</td><td class="line">          <span class='keyword'>if</span> (res!=lhs) <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);  <span class='comment'>/* not in place  */</span></td></tr>
<tr><td class="num" id="LN3993">3993</td><td class="line">          *res-&gt;lsu=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)partial;</td></tr>
<tr><td class="num" id="LN3994">3994</td><td class="line">          <span class='comment'>/* this could have reduced digits [but result&gt;0]  */</span></td></tr>
<tr><td class="num" id="LN3995">3995</td><td class="line">          res-&gt;digits=decGetDigits(res-&gt;lsu, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN3996">3996</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3997">3997</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3998">3998</td><td class="line">        <span class='comment'>/* else drop out for careful subtract  */</span></td></tr>
<tr><td class="num" id="LN3999">3999</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4000">4000</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4001">4001</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4002">4002</td><td class="line">    <span class='comment'>/* Now align (pad) the lhs or rhs so they can be added or  */</span></td></tr>
<tr><td class="num" id="LN4003">4003</td><td class="line">    <span class='comment'>/* subtracted, as necessary.  If one number is much larger than  */</span></td></tr>
<tr><td class="num" id="LN4004">4004</td><td class="line">    <span class='comment'>/* the other (that is, if in plain form there is a least one  */</span></td></tr>
<tr><td class="num" id="LN4005">4005</td><td class="line">    <span class='comment'>/* digit between the lowest digit of one and the highest of the  */</span></td></tr>
<tr><td class="num" id="LN4006">4006</td><td class="line">    <span class='comment'>/* other) padding with up to DIGITS-1 trailing zeros may be  */</span></td></tr>
<tr><td class="num" id="LN4007">4007</td><td class="line">    <span class='comment'>/* needed; then apply rounding (as exotic rounding modes may be  */</span></td></tr>
<tr><td class="num" id="LN4008">4008</td><td class="line">    <span class='comment'>/* affected by the residue).  */</span></td></tr>
<tr><td class="num" id="LN4009">4009</td><td class="line">    rhsshift=0;               <span class='comment'>/* rhs shift to left (padding) in Units  */</span></td></tr>
<tr><td class="num" id="LN4010">4010</td><td class="line">    bits=lhs-&gt;bits;           <span class='comment'>/* assume sign is that of LHS  */</span></td></tr>
<tr><td class="num" id="LN4011">4011</td><td class="line">    mult=1;                   <span class='comment'>/* likely multiplier  */</span></td></tr>
<tr><td class="num" id="LN4012">4012</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4013">4013</td><td class="line">    <span class='comment'>/* [if padding==0 the operands are aligned; no padding is needed]  */</span></td></tr>
<tr><td class="num" id="LN4014">4014</td><td class="line">    <span class='keyword'>if</span> (padding!=0) {</td></tr>
<tr><td class="num" id="LN4015">4015</td><td class="line">      <span class='comment'>/* some padding needed; always pad the RHS, as any required  */</span></td></tr>
<tr><td class="num" id="LN4016">4016</td><td class="line">      <span class='comment'>/* padding can then be effected by a simple combination of  */</span></td></tr>
<tr><td class="num" id="LN4017">4017</td><td class="line">      <span class='comment'>/* shifts and a multiply  */</span></td></tr>
<tr><td class="num" id="LN4018">4018</td><td class="line">      <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> swapped=0;</td></tr>
<tr><td class="num" id="LN4019">4019</td><td class="line">      <span class='keyword'>if</span> (padding&lt;0) {                  <span class='comment'>/* LHS needs the padding  */</span></td></tr>
<tr><td class="num" id="LN4020">4020</td><td class="line">        <span class='keyword'>const</span> decNumber *t;</td></tr>
<tr><td class="num" id="LN4021">4021</td><td class="line">        padding=-padding;               <span class='comment'>/* will be +ve  */</span></td></tr>
<tr><td class="num" id="LN4022">4022</td><td class="line">        bits=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(rhs-&gt;bits^negate); <span class='comment'>/* assumed sign is now that of RHS  */</span></td></tr>
<tr><td class="num" id="LN4023">4023</td><td class="line">        t=lhs; lhs=rhs; rhs=t;</td></tr>
<tr><td class="num" id="LN4024">4024</td><td class="line">        swapped=1;</td></tr>
<tr><td class="num" id="LN4025">4025</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4026">4026</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4027">4027</td><td class="line">      <span class='comment'>/* If, after pad, rhs would be longer than lhs by digits+1 or  */</span></td></tr>
<tr><td class="num" id="LN4028">4028</td><td class="line">      <span class='comment'>/* more then lhs cannot affect the answer, except as a residue,  */</span></td></tr>
<tr><td class="num" id="LN4029">4029</td><td class="line">      <span class='comment'>/* so only need to pad up to a length of DIGITS+1.  */</span></td></tr>
<tr><td class="num" id="LN4030">4030</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits+padding &gt; lhs-&gt;digits+reqdigits+1) {</td></tr>
<tr><td class="num" id="LN4031">4031</td><td class="line">        <span class='comment'>/* The RHS is sufficient  */</span></td></tr>
<tr><td class="num" id="LN4032">4032</td><td class="line">        <span class='comment'>/* for residue use the relative sign indication...  */</span></td></tr>
<tr><td class="num" id="LN4033">4033</td><td class="line">        <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift=reqdigits-rhs-&gt;digits;     <span class='comment'>/* left shift needed  */</span></td></tr>
<tr><td class="num" id="LN4034">4034</td><td class="line">        residue=1;                           <span class='comment'>/* residue for rounding  */</span></td></tr>
<tr><td class="num" id="LN4035">4035</td><td class="line">        <span class='keyword'>if</span> (diffsign) residue=-residue;      <span class='comment'>/* signs differ  */</span></td></tr>
<tr><td class="num" id="LN4036">4036</td><td class="line">        <span class='comment'>/* copy, shortening if necessary  */</span></td></tr>
<tr><td class="num" id="LN4037">4037</td><td class="line">        decCopyFit(res, rhs, set, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4038">4038</td><td class="line">        <span class='comment'>/* if it was already shorter, then need to pad with zeros  */</span></td></tr>
<tr><td class="num" id="LN4039">4039</td><td class="line">        <span class='keyword'>if</span> (shift&gt;0) {</td></tr>
<tr><td class="num" id="LN4040">4040</td><td class="line">          res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, shift);</td></tr>
<tr><td class="num" id="LN4041">4041</td><td class="line">          res-&gt;exponent-=shift;              <span class='comment'>/* adjust the exponent.  */</span></td></tr>
<tr><td class="num" id="LN4042">4042</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4043">4043</td><td class="line">        <span class='comment'>/* flip the result sign if unswapped and rhs was negated  */</span></td></tr>
<tr><td class="num" id="LN4044">4044</td><td class="line">        <span class='keyword'>if</span> (!swapped) res-&gt;bits^=negate;</td></tr>
<tr><td class="num" id="LN4045">4045</td><td class="line">        <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;    <span class='comment'>/* done  */</span></td></tr>
<tr><td class="num" id="LN4046">4046</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4047">4047</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4048">4048</td><td class="line">      <span class='comment'>/* LHS digits may affect result  */</span></td></tr>
<tr><td class="num" id="LN4049">4049</td><td class="line">      rhsshift=<span class='macro'>D2U(padding+1)<span class='expansion'>((padding+1)&lt;=49?d2utable[padding+1]:((padding+1)+1 -1)/1)</span></span>-1;        <span class='comment'>/* this much by Unit shift ..  */</span></td></tr>
<tr><td class="num" id="LN4050">4050</td><td class="line">      mult=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[padding-(rhsshift*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)]; <span class='comment'>/* .. this by multiplication  */</span></td></tr>
<tr><td class="num" id="LN4051">4051</td><td class="line">      } <span class='comment'>/* padding needed  */</span></td></tr>
<tr><td class="num" id="LN4052">4052</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4053">4053</td><td class="line">    <span class='keyword'>if</span> (diffsign) mult=-mult;           <span class='comment'>/* signs differ  */</span></td></tr>
<tr><td class="num" id="LN4054">4054</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4055">4055</td><td class="line">    <span class='comment'>/* determine the longer operand  */</span></td></tr>
<tr><td class="num" id="LN4056">4056</td><td class="line">    maxdigits=rhs-&gt;digits+padding;      <span class='comment'>/* virtual length of RHS  */</span></td></tr>
<tr><td class="num" id="LN4057">4057</td><td class="line">    <span class='keyword'>if</span> (lhs-&gt;digits&gt;maxdigits) maxdigits=lhs-&gt;digits;</td></tr>
<tr><td class="num" id="LN4058">4058</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4059">4059</td><td class="line">    <span class='comment'>/* Decide on the result buffer to use; if possible place directly  */</span></td></tr>
<tr><td class="num" id="LN4060">4060</td><td class="line">    <span class='comment'>/* into result.  */</span></td></tr>
<tr><td class="num" id="LN4061">4061</td><td class="line">    acc=res-&gt;lsu;                       <span class='comment'>/* assume add direct to result  */</span></td></tr>
<tr><td class="num" id="LN4062">4062</td><td class="line">    <span class='comment'>/* If destructive overlap, or the number is too long, or a carry or  */</span></td></tr>
<tr><td class="num" id="LN4063">4063</td><td class="line">    <span class='comment'>/* borrow to DIGITS+1 might be possible, a buffer must be used.  */</span></td></tr>
<tr><td class="num" id="LN4064">4064</td><td class="line">    <span class='comment'>/* [Might be worth more sophisticated tests when maxdigits==reqdigits]  */</span></td></tr>
<tr><td class="num" id="LN4065">4065</td><td class="line">    <span class='keyword'>if</span> ((maxdigits&gt;=reqdigits)          <span class='comment'>/* is, or could be, too large  */</span></td></tr>
<tr><td class="num" id="LN4066">4066</td><td class="line">     || (res==rhs &amp;&amp; rhsshift&gt;0)) {     <span class='comment'>/* destructive overlap  */</span></td></tr>
<tr><td class="num" id="LN4067">4067</td><td class="line">      <span class='comment'>/* buffer needed, choose it; units for maxdigits digits will be  */</span></td></tr>
<tr><td class="num" id="LN4068">4068</td><td class="line">      <span class='comment'>/* needed, +1 Unit for carry or borrow  */</span></td></tr>
<tr><td class="num" id="LN4069">4069</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> need=<span class='macro'>D2U(maxdigits)<span class='expansion'>((maxdigits)&lt;=49?d2utable[maxdigits]:((maxdigits)+1 -1)/1)</span></span>+1;</td></tr>
<tr><td class="num" id="LN4070">4070</td><td class="line">      acc=accbuff;                      <span class='comment'>/* assume use local buffer  */</span></td></tr>
<tr><td class="num" id="LN4071">4071</td><td class="line">      <span class='keyword'>if</span> (need*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)&gt;<span class='keyword'>sizeof</span>(accbuff)) {</td></tr>
<tr><td class="num" id="LN4072">4072</td><td class="line">        <span class='comment'>/* printf("malloc add %ld %ld\n", need, sizeof(accbuff));  */</span></td></tr>
<tr><td class="num" id="LN4073">4073</td><td class="line">        allocacc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc(need*<span class='keyword'>sizeof</span>(Unit))<span class='expansion'>uprv_malloc_54(need*sizeof(uint8_t))</span></span>;</td></tr>
<tr><td class="num" id="LN4074">4074</td><td class="line">        <span class='keyword'>if</span> (allocacc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {           <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN4075">4075</td><td class="line">          *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN4076">4076</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4077">4077</td><td class="line">        acc=allocacc;</td></tr>
<tr><td class="num" id="LN4078">4078</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4079">4079</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4080">4080</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4081">4081</td><td class="line">    res-&gt;bits=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);     <span class='comment'>/* it's now safe to overwrite..  */</span></td></tr>
<tr><td class="num" id="LN4082">4082</td><td class="line">    res-&gt;exponent=lhs-&gt;exponent;        <span class='comment'>/* .. operands (even if aliased)  */</span></td></tr>
<tr><td class="num" id="LN4083">4083</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4084">4084</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4085">4085</td><td class="line">      decDumpAr('A', lhs-&gt;lsu, <span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4086">4086</td><td class="line">      decDumpAr('B', rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4087">4087</td><td class="line">      printf(<span class='string_literal'>"  :h: %ld %ld\n"</span>, rhsshift, mult);</td></tr>
<tr><td class="num" id="LN4088">4088</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4089">4089</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4090">4090</td><td class="line">    <span class='comment'>/* add [A+B*m] or subtract [A+B*(-m)]  */</span></td></tr>
<tr><td class="num" id="LN4091">4091</td><td class="line">    U_ASSERT(rhs-&gt;digits &gt; 0);</td></tr>
<tr><td class="num" id="LN4092">4092</td><td class="line">    U_ASSERT(lhs-&gt;digits &gt; 0);</td></tr>
<tr><td class="num" id="LN4093">4093</td><td class="line">    res-&gt;digits=decUnitAddSub(lhs-&gt;lsu, <span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN4094">4094</td><td class="line">                              rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN4095">4095</td><td class="line">                              rhsshift, acc, mult)</td></tr>
<tr><td class="num" id="LN4096">4096</td><td class="line">               *<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;           <span class='comment'>/* [units -&gt; digits]  */</span></td></tr>
<tr><td class="num" id="LN4097">4097</td><td class="line">    <span class='keyword'>if</span> (res-&gt;digits&lt;0) {           <span class='comment'>/* borrowed...  */</span></td></tr>
<tr><td class="num" id="LN4098">4098</td><td class="line">      res-&gt;digits=-res-&gt;digits;</td></tr>
<tr><td class="num" id="LN4099">4099</td><td class="line">      res-&gt;bits^=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;           <span class='comment'>/* flip the sign  */</span></td></tr>
<tr><td class="num" id="LN4100">4100</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4101">4101</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4102">4102</td><td class="line">      decDumpAr('+', acc, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4103">4103</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4104">4104</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4105">4105</td><td class="line">    <span class='comment'>/* If a buffer was used the result must be copied back, possibly  */</span></td></tr>
<tr><td class="num" id="LN4106">4106</td><td class="line">    <span class='comment'>/* shortening.  (If no buffer was used then the result must have  */</span></td></tr>
<tr><td class="num" id="LN4107">4107</td><td class="line">    <span class='comment'>/* fit, so can't need rounding and residue must be 0.)  */</span></td></tr>
<tr><td class="num" id="LN4108">4108</td><td class="line">    residue=0;                     <span class='comment'>/* clear accumulator  */</span></td></tr>
<tr><td class="num" id="LN4109">4109</td><td class="line">    <span class='keyword'>if</span> (acc!=res-&gt;lsu) {</td></tr>
<tr><td class="num" id="LN4110">4110</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4111">4111</td><td class="line">      <span class='keyword'>if</span> (set-&gt;extended) {         <span class='comment'>/* round from first significant digit  */</span></td></tr>
<tr><td class="num" id="LN4112">4112</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4113">4113</td><td class="line">        <span class='comment'>/* remove leading zeros that were added due to rounding up to  */</span></td></tr>
<tr><td class="num" id="LN4114">4114</td><td class="line">        <span class='comment'>/* integral Units -- before the test for rounding.  */</span></td></tr>
<tr><td class="num" id="LN4115">4115</td><td class="line">        <span class='keyword'>if</span> (res-&gt;digits&gt;reqdigits)</td></tr>
<tr><td class="num" id="LN4116">4116</td><td class="line">          res-&gt;digits=decGetDigits(acc, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4117">4117</td><td class="line">        decSetCoeff(res, set, acc, res-&gt;digits, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4118">4118</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4119">4119</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4120">4120</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* subset arithmetic rounds from original significant digit  */</span></td></tr>
<tr><td class="num" id="LN4121">4121</td><td class="line">        <span class='comment'>/* May have an underestimate.  This only occurs when both  */</span></td></tr>
<tr><td class="num" id="LN4122">4122</td><td class="line">        <span class='comment'>/* numbers fit in DECDPUN digits and are padding with a  */</span></td></tr>
<tr><td class="num" id="LN4123">4123</td><td class="line">        <span class='comment'>/* negative multiple (-10, -100...) and the top digit(s) become  */</span></td></tr>
<tr><td class="num" id="LN4124">4124</td><td class="line">        <span class='comment'>/* 0.  (This only matters when using X3.274 rules where the  */</span></td></tr>
<tr><td class="num" id="LN4125">4125</td><td class="line">        <span class='comment'>/* leading zero could be included in the rounding.)  */</span></td></tr>
<tr><td class="num" id="LN4126">4126</td><td class="line">        <span class='keyword'>if</span> (res-&gt;digits&lt;maxdigits) {</td></tr>
<tr><td class="num" id="LN4127">4127</td><td class="line">          *(acc+<span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>)=0; <span class='comment'>/* ensure leading 0 is there  */</span></td></tr>
<tr><td class="num" id="LN4128">4128</td><td class="line">          res-&gt;digits=maxdigits;</td></tr>
<tr><td class="num" id="LN4129">4129</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4130">4130</td><td class="line">         <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN4131">4131</td><td class="line">          <span class='comment'>/* remove leading zeros that added due to rounding up to  */</span></td></tr>
<tr><td class="num" id="LN4132">4132</td><td class="line">          <span class='comment'>/* integral Units (but only those in excess of the original  */</span></td></tr>
<tr><td class="num" id="LN4133">4133</td><td class="line">          <span class='comment'>/* maxdigits length, unless extended) before test for rounding.  */</span></td></tr>
<tr><td class="num" id="LN4134">4134</td><td class="line">          <span class='keyword'>if</span> (res-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN4135">4135</td><td class="line">            res-&gt;digits=decGetDigits(acc, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4136">4136</td><td class="line">            <span class='keyword'>if</span> (res-&gt;digits&lt;maxdigits) res-&gt;digits=maxdigits;</td></tr>
<tr><td class="num" id="LN4137">4137</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4138">4138</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4139">4139</td><td class="line">        decSetCoeff(res, set, acc, res-&gt;digits, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4140">4140</td><td class="line">        <span class='comment'>/* Now apply rounding if needed before removing leading zeros.  */</span></td></tr>
<tr><td class="num" id="LN4141">4141</td><td class="line">        <span class='comment'>/* This is safe because subnormals are not a possibility  */</span></td></tr>
<tr><td class="num" id="LN4142">4142</td><td class="line">        <span class='keyword'>if</span> (residue!=0) {</td></tr>
<tr><td class="num" id="LN4143">4143</td><td class="line">          decApplyRound(res, set, residue, status);</td></tr>
<tr><td class="num" id="LN4144">4144</td><td class="line">          residue=0;                 <span class='comment'>/* did what needed to be done  */</span></td></tr>
<tr><td class="num" id="LN4145">4145</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4146">4146</td><td class="line">        } <span class='comment'>/* subset  */</span></td></tr>
<tr><td class="num" id="LN4147">4147</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4148">4148</td><td class="line">      } <span class='comment'>/* used buffer  */</span></td></tr>
<tr><td class="num" id="LN4149">4149</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4150">4150</td><td class="line">    <span class='comment'>/* strip leading zeros [these were left on in case of subset subtract]  */</span></td></tr>
<tr><td class="num" id="LN4151">4151</td><td class="line">    res-&gt;digits=decGetDigits(res-&gt;lsu, <span class='macro'>D2U(res-&gt;digits)<span class='expansion'>((res-&gt;digits)&lt;=49?d2utable[res-&gt;digits]:((res-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN4152">4152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4153">4153</td><td class="line">    <span class='comment'>/* apply checks and rounding  */</span></td></tr>
<tr><td class="num" id="LN4154">4154</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;</td></tr>
<tr><td class="num" id="LN4155">4155</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4156">4156</td><td class="line">    <span class='comment'>/* "When the sum of two operands with opposite signs is exactly  */</span></td></tr>
<tr><td class="num" id="LN4157">4157</td><td class="line">    <span class='comment'>/* zero, the sign of that sum shall be '+' in all rounding modes  */</span></td></tr>
<tr><td class="num" id="LN4158">4158</td><td class="line">    <span class='comment'>/* except round toward -Infinity, in which mode that sign shall be  */</span></td></tr>
<tr><td class="num" id="LN4159">4159</td><td class="line">    <span class='comment'>/* '-'."  [Subset zeros also never have '-', set by decFinish.]  */</span></td></tr>
<tr><td class="num" id="LN4160">4160</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(res)<span class='expansion'>(*(res)-&gt;lsu==0 &amp;&amp; (res)-&gt;digits==1 &amp;&amp; (<br>((res)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span> &amp;&amp; diffsign</td></tr>
<tr><td class="num" id="LN4161">4161</td><td class="line">     <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4162">4162</td><td class="line">     &amp;&amp; set-&gt;extended</td></tr>
<tr><td class="num" id="LN4163">4163</td><td class="line">     <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4164">4164</td><td class="line">     &amp;&amp; (*status&amp;<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>)==0) {</td></tr>
<tr><td class="num" id="LN4165">4165</td><td class="line">      <span class='keyword'>if</span> (set-&gt;round==DEC_ROUND_FLOOR) res-&gt;bits|=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;   <span class='comment'>/* sign -  */</span></td></tr>
<tr><td class="num" id="LN4166">4166</td><td class="line">                                  <span class='keyword'>else</span> res-&gt;bits&amp;=~<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;  <span class='comment'>/* sign +  */</span></td></tr>
<tr><td class="num" id="LN4167">4167</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4168">4168</td><td class="line">    } <span class='keyword'>while</span>(0);                              <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN4169">4169</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4170">4170</td><td class="line">  <span class='keyword'>if</span> (allocacc!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocacc)<span class='expansion'>uprv_free_54(allocacc)</span></span>;        <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN4171">4171</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4172">4172</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;        <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4173">4173</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;        <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4174">4174</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4175">4175</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN4176">4176</td><td class="line">  } <span class='comment'>/* decAddOp  */</span></td></tr>
<tr><td class="num" id="LN4177">4177</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4178">4178</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4179">4179</td><td class="line"><span class='comment'>/* decDivideOp -- division operation                                  */</span></td></tr>
<tr><td class="num" id="LN4180">4180</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4181">4181</td><td class="line"><span class='comment'>/*  This routine performs the calculations for all four division      */</span></td></tr>
<tr><td class="num" id="LN4182">4182</td><td class="line"><span class='comment'>/*  operators (divide, divideInteger, remainder, remainderNear).      */</span></td></tr>
<tr><td class="num" id="LN4183">4183</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4184">4184</td><td class="line"><span class='comment'>/*  C=A op B                                                          */</span></td></tr>
<tr><td class="num" id="LN4185">4185</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4186">4186</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X/X)         */</span></td></tr>
<tr><td class="num" id="LN4187">4187</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN4188">4188</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN4189">4189</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN4190">4190</td><td class="line"><span class='comment'>/*   op  is DIVIDE, DIVIDEINT, REMAINDER, or REMNEAR respectively.    */</span></td></tr>
<tr><td class="num" id="LN4191">4191</td><td class="line"><span class='comment'>/*   status is the usual accumulator                                  */</span></td></tr>
<tr><td class="num" id="LN4192">4192</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4193">4193</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN4194">4194</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4195">4195</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4196">4196</td><td class="line"><span class='comment'>/*   The underlying algorithm of this routine is the same as in the   */</span></td></tr>
<tr><td class="num" id="LN4197">4197</td><td class="line"><span class='comment'>/*   1981 S/370 implementation, that is, non-restoring long division  */</span></td></tr>
<tr><td class="num" id="LN4198">4198</td><td class="line"><span class='comment'>/*   with bi-unit (rather than bi-digit) estimation for each unit     */</span></td></tr>
<tr><td class="num" id="LN4199">4199</td><td class="line"><span class='comment'>/*   multiplier.  In this pseudocode overview, complications for the  */</span></td></tr>
<tr><td class="num" id="LN4200">4200</td><td class="line"><span class='comment'>/*   Remainder operators and division residues for exact rounding are */</span></td></tr>
<tr><td class="num" id="LN4201">4201</td><td class="line"><span class='comment'>/*   omitted for clarity.                                             */</span></td></tr>
<tr><td class="num" id="LN4202">4202</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4203">4203</td><td class="line"><span class='comment'>/*     Prepare operands and handle special values                     */</span></td></tr>
<tr><td class="num" id="LN4204">4204</td><td class="line"><span class='comment'>/*     Test for x/0 and then 0/x                                      */</span></td></tr>
<tr><td class="num" id="LN4205">4205</td><td class="line"><span class='comment'>/*     Exp =Exp1 - Exp2                                               */</span></td></tr>
<tr><td class="num" id="LN4206">4206</td><td class="line"><span class='comment'>/*     Exp =Exp +len(var1) -len(var2)                                 */</span></td></tr>
<tr><td class="num" id="LN4207">4207</td><td class="line"><span class='comment'>/*     Sign=Sign1 * Sign2                                             */</span></td></tr>
<tr><td class="num" id="LN4208">4208</td><td class="line"><span class='comment'>/*     Pad accumulator (Var1) to double-length with 0's (pad1)        */</span></td></tr>
<tr><td class="num" id="LN4209">4209</td><td class="line"><span class='comment'>/*     Pad Var2 to same length as Var1                                */</span></td></tr>
<tr><td class="num" id="LN4210">4210</td><td class="line"><span class='comment'>/*     msu2pair/plus=1st 2 or 1 units of var2, +1 to allow for round  */</span></td></tr>
<tr><td class="num" id="LN4211">4211</td><td class="line"><span class='comment'>/*     have=0                                                         */</span></td></tr>
<tr><td class="num" id="LN4212">4212</td><td class="line"><span class='comment'>/*     Do until (have=digits+1 OR residue=0)                          */</span></td></tr>
<tr><td class="num" id="LN4213">4213</td><td class="line"><span class='comment'>/*       if exp&lt;0 then if integer divide/residue then leave           */</span></td></tr>
<tr><td class="num" id="LN4214">4214</td><td class="line"><span class='comment'>/*       this_unit=0                                                  */</span></td></tr>
<tr><td class="num" id="LN4215">4215</td><td class="line"><span class='comment'>/*       Do forever                                                   */</span></td></tr>
<tr><td class="num" id="LN4216">4216</td><td class="line"><span class='comment'>/*          compare numbers                                           */</span></td></tr>
<tr><td class="num" id="LN4217">4217</td><td class="line"><span class='comment'>/*          if &lt;0 then leave inner_loop                               */</span></td></tr>
<tr><td class="num" id="LN4218">4218</td><td class="line"><span class='comment'>/*          if =0 then (* quick exit without subtract *) do           */</span></td></tr>
<tr><td class="num" id="LN4219">4219</td><td class="line"><span class='comment'>/*             this_unit=this_unit+1; output this_unit                */</span></td></tr>
<tr><td class="num" id="LN4220">4220</td><td class="line"><span class='comment'>/*             leave outer_loop; end                                  */</span></td></tr>
<tr><td class="num" id="LN4221">4221</td><td class="line"><span class='comment'>/*          Compare lengths of numbers (mantissae):                   */</span></td></tr>
<tr><td class="num" id="LN4222">4222</td><td class="line"><span class='comment'>/*          If same then tops2=msu2pair -- {units 1&amp;2 of var2}        */</span></td></tr>
<tr><td class="num" id="LN4223">4223</td><td class="line"><span class='comment'>/*                  else tops2=msu2plus -- {0, unit 1 of var2}        */</span></td></tr>
<tr><td class="num" id="LN4224">4224</td><td class="line"><span class='comment'>/*          tops1=first_unit_of_Var1*10**DECDPUN +second_unit_of_var1 */</span></td></tr>
<tr><td class="num" id="LN4225">4225</td><td class="line"><span class='comment'>/*          mult=tops1/tops2  -- Good and safe guess at divisor       */</span></td></tr>
<tr><td class="num" id="LN4226">4226</td><td class="line"><span class='comment'>/*          if mult=0 then mult=1                                     */</span></td></tr>
<tr><td class="num" id="LN4227">4227</td><td class="line"><span class='comment'>/*          this_unit=this_unit+mult                                  */</span></td></tr>
<tr><td class="num" id="LN4228">4228</td><td class="line"><span class='comment'>/*          subtract                                                  */</span></td></tr>
<tr><td class="num" id="LN4229">4229</td><td class="line"><span class='comment'>/*          end inner_loop                                            */</span></td></tr>
<tr><td class="num" id="LN4230">4230</td><td class="line"><span class='comment'>/*        if have\=0 | this_unit\=0 then do                           */</span></td></tr>
<tr><td class="num" id="LN4231">4231</td><td class="line"><span class='comment'>/*          output this_unit                                          */</span></td></tr>
<tr><td class="num" id="LN4232">4232</td><td class="line"><span class='comment'>/*          have=have+1; end                                          */</span></td></tr>
<tr><td class="num" id="LN4233">4233</td><td class="line"><span class='comment'>/*        var2=var2/10                                                */</span></td></tr>
<tr><td class="num" id="LN4234">4234</td><td class="line"><span class='comment'>/*        exp=exp-1                                                   */</span></td></tr>
<tr><td class="num" id="LN4235">4235</td><td class="line"><span class='comment'>/*        end outer_loop                                              */</span></td></tr>
<tr><td class="num" id="LN4236">4236</td><td class="line"><span class='comment'>/*     exp=exp+1   -- set the proper exponent                         */</span></td></tr>
<tr><td class="num" id="LN4237">4237</td><td class="line"><span class='comment'>/*     if have=0 then generate answer=0                               */</span></td></tr>
<tr><td class="num" id="LN4238">4238</td><td class="line"><span class='comment'>/*     Return (Result is defined by Var1)                             */</span></td></tr>
<tr><td class="num" id="LN4239">4239</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4240">4240</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4241">4241</td><td class="line"><span class='comment'>/* Two working buffers are needed during the division; one (digits+   */</span></td></tr>
<tr><td class="num" id="LN4242">4242</td><td class="line"><span class='comment'>/* 1) to accumulate the result, and the other (up to 2*digits+1) for  */</span></td></tr>
<tr><td class="num" id="LN4243">4243</td><td class="line"><span class='comment'>/* long subtractions.  These are acc and var1 respectively.           */</span></td></tr>
<tr><td class="num" id="LN4244">4244</td><td class="line"><span class='comment'>/* var1 is a copy of the lhs coefficient, var2 is the rhs coefficient.*/</span></td></tr>
<tr><td class="num" id="LN4245">4245</td><td class="line"><span class='comment'>/* The static buffers may be larger than might be expected to allow   */</span></td></tr>
<tr><td class="num" id="LN4246">4246</td><td class="line"><span class='comment'>/* for calls from higher-level funtions (notable exp).                */</span></td></tr>
<tr><td class="num" id="LN4247">4247</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4248">4248</td><td class="line"><span class='keyword'>static</span> decNumber * decDivideOp(decNumber *res,</td></tr>
<tr><td class="num" id="LN4249">4249</td><td class="line">                               <span class='keyword'>const</span> decNumber *lhs, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN4250">4250</td><td class="line">                               decContext *set, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> op, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN4251">4251</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4252">4252</td><td class="line">  decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded lhs allocated  */</span></td></tr>
<tr><td class="num" id="LN4253">4253</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* .., rhs  */</span></td></tr>
<tr><td class="num" id="LN4254">4254</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4255">4255</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  accbuff[<span class='macro'>SD2U(DECBUFFER+DECDPUN+10)<span class='expansion'>(((36 +1 +10)+1 -1)/1)</span></span>]; <span class='comment'>/* local buffer  */</span></td></tr>
<tr><td class="num" id="LN4256">4256</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *acc=accbuff;              <span class='comment'>/* -&gt; accumulator array for result  */</span></td></tr>
<tr><td class="num" id="LN4257">4257</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *allocacc=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4258">4258</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *accnext;                  <span class='comment'>/* -&gt; where next digit will go  */</span></td></tr>
<tr><td class="num" id="LN4259">4259</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   acclength;                 <span class='comment'>/* length of acc needed [Units]  */</span></td></tr>
<tr><td class="num" id="LN4260">4260</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   accunits;                  <span class='comment'>/* count of units accumulated  */</span></td></tr>
<tr><td class="num" id="LN4261">4261</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   accdigits;                 <span class='comment'>/* count of digits accumulated  */</span></td></tr>
<tr><td class="num" id="LN4262">4262</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4263">4263</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  varbuff[<span class='macro'>SD2U(DECBUFFER*2+DECDPUN)<span class='expansion'>(((36*2+1)+1 -1)/1)</span></span>];  <span class='comment'>/* buffer for var1  */</span></td></tr>
<tr><td class="num" id="LN4264">4264</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *var1=varbuff;             <span class='comment'>/* -&gt; var1 array for long subtraction  */</span></td></tr>
<tr><td class="num" id="LN4265">4265</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *varalloc=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated buffer, iff used  */</span></td></tr>
<tr><td class="num" id="LN4266">4266</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *msu1;                     <span class='comment'>/* -&gt; msu of var1  */</span></td></tr>
<tr><td class="num" id="LN4267">4267</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4268">4268</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *var2;                <span class='comment'>/* -&gt; var2 array  */</span></td></tr>
<tr><td class="num" id="LN4269">4269</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msu2;                <span class='comment'>/* -&gt; msu of var2  */</span></td></tr>
<tr><td class="num" id="LN4270">4270</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   msu2plus;                  <span class='comment'>/* msu2 plus one [does not vary]  */</span></td></tr>
<tr><td class="num" id="LN4271">4271</td><td class="line">  <span class='macro'>eInt<span class='expansion'>int32_t</span></span>  msu2pair;                  <span class='comment'>/* msu2 pair plus one [does not vary]  */</span></td></tr>
<tr><td class="num" id="LN4272">4272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4273">4273</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   var1units, var2units;      <span class='comment'>/* actual lengths  */</span></td></tr>
<tr><td class="num" id="LN4274">4274</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   var2ulen;                  <span class='comment'>/* logical length (units)  */</span></td></tr>
<tr><td class="num" id="LN4275">4275</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   var1initpad=0;             <span class='comment'>/* var1 initial padding (digits)  */</span></td></tr>
<tr><td class="num" id="LN4276">4276</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   maxdigits;                 <span class='comment'>/* longest LHS or required acc length  */</span></td></tr>
<tr><td class="num" id="LN4277">4277</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   mult;                      <span class='comment'>/* multiplier for subtraction  */</span></td></tr>
<tr><td class="num" id="LN4278">4278</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  thisunit;                  <span class='comment'>/* current unit being accumulated  */</span></td></tr>
<tr><td class="num" id="LN4279">4279</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   residue;                   <span class='comment'>/* for rounding  */</span></td></tr>
<tr><td class="num" id="LN4280">4280</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   reqdigits=set-&gt;digits;     <span class='comment'>/* requested DIGITS  */</span></td></tr>
<tr><td class="num" id="LN4281">4281</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   exponent;                  <span class='comment'>/* working exponent  */</span></td></tr>
<tr><td class="num" id="LN4282">4282</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   maxexponent=0;             <span class='comment'>/* DIVIDE maximum exponent if unrounded  */</span></td></tr>
<tr><td class="num" id="LN4283">4283</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> bits;                      <span class='comment'>/* working sign  */</span></td></tr>
<tr><td class="num" id="LN4284">4284</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *target;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4285">4285</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *source;              <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4286">4286</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  <span class='keyword'>const</span> *pow;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4287">4287</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   shift, cut;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4288">4288</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4289">4289</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   dropped;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4290">4290</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4291">4291</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4292">4292</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4293">4293</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN4294">4294</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4295">4295</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4296">4296</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN4297">4297</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4298">4298</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN4299">4299</td><td class="line">      <span class='comment'>/* reduce operands and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN4300">4300</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN4301">4301</td><td class="line">        alloclhs=decRoundOperand(lhs, set, status);</td></tr>
<tr><td class="num" id="LN4302">4302</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4303">4303</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN4304">4304</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4305">4305</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN4306">4306</td><td class="line">        allocrhs=decRoundOperand(rhs, set, status);</td></tr>
<tr><td class="num" id="LN4307">4307</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4308">4308</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN4309">4309</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4310">4310</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4311">4311</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4312">4312</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN4313">4313</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4314">4314</td><td class="line">    bits=(lhs-&gt;bits^rhs-&gt;bits)&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;  <span class='comment'>/* assumed sign for divisions  */</span></td></tr>
<tr><td class="num" id="LN4315">4315</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4316">4316</td><td class="line">    <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN4317">4317</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {                  <span class='comment'>/* a special bit set  */</span></td></tr>
<tr><td class="num" id="LN4318">4318</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span> &amp; (<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span> | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>)) { <span class='comment'>/* one or two NaNs  */</span></td></tr>
<tr><td class="num" id="LN4319">4319</td><td class="line">        decNaNs(res, lhs, rhs, set, status);</td></tr>
<tr><td class="num" id="LN4320">4320</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4321">4321</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4322">4322</td><td class="line">      <span class='comment'>/* one or two infinities  */</span></td></tr>
<tr><td class="num" id="LN4323">4323</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x40)!=0)</span></span>) {   <span class='comment'>/* LHS (dividend) is infinite  */</span></td></tr>
<tr><td class="num" id="LN4324">4324</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span> || <span class='comment'>/* two infinities are invalid ..  */</span></td></tr>
<tr><td class="num" id="LN4325">4325</td><td class="line">            op &amp; (<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span> | <span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>)) { <span class='comment'>/* as is remainder of infinity  */</span></td></tr>
<tr><td class="num" id="LN4326">4326</td><td class="line">          *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN4327">4327</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4328">4328</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4329">4329</td><td class="line">        <span class='comment'>/* [Note that infinity/0 raises no exceptions]  */</span></td></tr>
<tr><td class="num" id="LN4330">4330</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN4331">4331</td><td class="line">        res-&gt;bits=bits|<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;          <span class='comment'>/* set +/- infinity  */</span></td></tr>
<tr><td class="num" id="LN4332">4332</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4333">4333</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4334">4334</td><td class="line">       <span class='keyword'>else</span> {                           <span class='comment'>/* RHS (divisor) is infinite  */</span></td></tr>
<tr><td class="num" id="LN4335">4335</td><td class="line">        residue=0;</td></tr>
<tr><td class="num" id="LN4336">4336</td><td class="line">        <span class='keyword'>if</span> (op&amp;(<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>|<span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>)) {</td></tr>
<tr><td class="num" id="LN4337">4337</td><td class="line">          <span class='comment'>/* result is [finished clone of] lhs  */</span></td></tr>
<tr><td class="num" id="LN4338">4338</td><td class="line">          decCopyFit(res, lhs, set, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4339">4339</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4340">4340</td><td class="line">         <span class='keyword'>else</span> {  <span class='comment'>/* a division  */</span></td></tr>
<tr><td class="num" id="LN4341">4341</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN4342">4342</td><td class="line">          res-&gt;bits=bits;               <span class='comment'>/* set +/- zero  */</span></td></tr>
<tr><td class="num" id="LN4343">4343</td><td class="line">          <span class='comment'>/* for DIVIDEINT the exponent is always 0.  For DIVIDE, result  */</span></td></tr>
<tr><td class="num" id="LN4344">4344</td><td class="line">          <span class='comment'>/* is a 0 with infinitely negative exponent, clamped to minimum  */</span></td></tr>
<tr><td class="num" id="LN4345">4345</td><td class="line">          <span class='keyword'>if</span> (op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>) {</td></tr>
<tr><td class="num" id="LN4346">4346</td><td class="line">            res-&gt;exponent=set-&gt;emin-set-&gt;digits+1;</td></tr>
<tr><td class="num" id="LN4347">4347</td><td class="line">            *status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN4348">4348</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4349">4349</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4350">4350</td><td class="line">        <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;</td></tr>
<tr><td class="num" id="LN4351">4351</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4352">4352</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4353">4353</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4354">4354</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4355">4355</td><td class="line">    <span class='comment'>/* handle 0 rhs (x/0)  */</span></td></tr>
<tr><td class="num" id="LN4356">4356</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                  <span class='comment'>/* x/0 is always exceptional  */</span></td></tr>
<tr><td class="num" id="LN4357">4357</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN4358">4358</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);             <span class='comment'>/* [after lhs test]  */</span></td></tr>
<tr><td class="num" id="LN4359">4359</td><td class="line">        *status|=<span class='macro'>DEC_Division_undefined<span class='expansion'>0x00000008</span></span>;<span class='comment'>/* 0/0 will become NaN  */</span></td></tr>
<tr><td class="num" id="LN4360">4360</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4361">4361</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN4362">4362</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN4363">4363</td><td class="line">        <span class='keyword'>if</span> (op&amp;(<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>|<span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>)) *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN4364">4364</td><td class="line">         <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN4365">4365</td><td class="line">          *status|=<span class='macro'>DEC_Division_by_zero<span class='expansion'>0x00000002</span></span>; <span class='comment'>/* x/0  */</span></td></tr>
<tr><td class="num" id="LN4366">4366</td><td class="line">          res-&gt;bits=bits|<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;         <span class='comment'>/* .. is +/- Infinity  */</span></td></tr>
<tr><td class="num" id="LN4367">4367</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4368">4368</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4369">4369</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4370">4370</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4371">4371</td><td class="line">    <span class='comment'>/* handle 0 lhs (0/x)  */</span></td></tr>
<tr><td class="num" id="LN4372">4372</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                  <span class='comment'>/* 0/x [x!=0]  */</span></td></tr>
<tr><td class="num" id="LN4373">4373</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4374">4374</td><td class="line">      <span class='keyword'>if</span> (!set-&gt;extended) <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN4375">4375</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN4376">4376</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4377">4377</td><td class="line">        <span class='keyword'>if</span> (op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>) {</td></tr>
<tr><td class="num" id="LN4378">4378</td><td class="line">          residue=0;</td></tr>
<tr><td class="num" id="LN4379">4379</td><td class="line">          exponent=lhs-&gt;exponent-rhs-&gt;exponent; <span class='comment'>/* ideal exponent  */</span></td></tr>
<tr><td class="num" id="LN4380">4380</td><td class="line">          <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);      <span class='comment'>/* [zeros always fit]  */</span></td></tr>
<tr><td class="num" id="LN4381">4381</td><td class="line">          res-&gt;bits=bits;               <span class='comment'>/* sign as computed  */</span></td></tr>
<tr><td class="num" id="LN4382">4382</td><td class="line">          res-&gt;exponent=exponent;       <span class='comment'>/* exponent, too  */</span></td></tr>
<tr><td class="num" id="LN4383">4383</td><td class="line">          decFinalize(res, set, &amp;residue, status);   <span class='comment'>/* check exponent  */</span></td></tr>
<tr><td class="num" id="LN4384">4384</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4385">4385</td><td class="line">         <span class='keyword'>else</span> <span class='keyword'>if</span> (op&amp;<span class='macro'>DIVIDEINT<span class='expansion'>0x20</span></span>) {</td></tr>
<tr><td class="num" id="LN4386">4386</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);           <span class='comment'>/* integer 0  */</span></td></tr>
<tr><td class="num" id="LN4387">4387</td><td class="line">          res-&gt;bits=bits;               <span class='comment'>/* sign as computed  */</span></td></tr>
<tr><td class="num" id="LN4388">4388</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4389">4389</td><td class="line">         <span class='keyword'>else</span> {                         <span class='comment'>/* a remainder  */</span></td></tr>
<tr><td class="num" id="LN4390">4390</td><td class="line">          exponent=rhs-&gt;exponent;       <span class='comment'>/* [save in case overwrite]  */</span></td></tr>
<tr><td class="num" id="LN4391">4391</td><td class="line">          <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);      <span class='comment'>/* [zeros always fit]  */</span></td></tr>
<tr><td class="num" id="LN4392">4392</td><td class="line">          <span class='keyword'>if</span> (exponent&lt;res-&gt;exponent) res-&gt;exponent=exponent; <span class='comment'>/* use lower  */</span></td></tr>
<tr><td class="num" id="LN4393">4393</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4394">4394</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4395">4395</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4396">4396</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4397">4397</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4398">4398</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4399">4399</td><td class="line">    <span class='comment'>/* Precalculate exponent.  This starts off adjusted (and hence fits  */</span></td></tr>
<tr><td class="num" id="LN4400">4400</td><td class="line">    <span class='comment'>/* in 31 bits) and becomes the usual unadjusted exponent as the  */</span></td></tr>
<tr><td class="num" id="LN4401">4401</td><td class="line">    <span class='comment'>/* division proceeds.  The order of evaluation is important, here,  */</span></td></tr>
<tr><td class="num" id="LN4402">4402</td><td class="line">    <span class='comment'>/* to avoid wrap.  */</span></td></tr>
<tr><td class="num" id="LN4403">4403</td><td class="line">    exponent=(lhs-&gt;exponent+lhs-&gt;digits)-(rhs-&gt;exponent+rhs-&gt;digits);</td></tr>
<tr><td class="num" id="LN4404">4404</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4405">4405</td><td class="line">    <span class='comment'>/* If the working exponent is -ve, then some quick exits are  */</span></td></tr>
<tr><td class="num" id="LN4406">4406</td><td class="line">    <span class='comment'>/* possible because the quotient is known to be &lt;1  */</span></td></tr>
<tr><td class="num" id="LN4407">4407</td><td class="line">    <span class='comment'>/* [for REMNEAR, it needs to be &lt; -1, as -0.5 could need work]  */</span></td></tr>
<tr><td class="num" id="LN4408">4408</td><td class="line">    <span class='keyword'>if</span> (exponent&lt;0 &amp;&amp; !(op==<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>)) {</td></tr>
<tr><td class="num" id="LN4409">4409</td><td class="line">      <span class='keyword'>if</span> (op&amp;<span class='macro'>DIVIDEINT<span class='expansion'>0x20</span></span>) {</td></tr>
<tr><td class="num" id="LN4410">4410</td><td class="line">        <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);                  <span class='comment'>/* integer part is 0  */</span></td></tr>
<tr><td class="num" id="LN4411">4411</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4412">4412</td><td class="line">        <span class='keyword'>if</span> (set-&gt;extended)</td></tr>
<tr><td class="num" id="LN4413">4413</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4414">4414</td><td class="line">          res-&gt;bits=bits;                    <span class='comment'>/* set +/- zero  */</span></td></tr>
<tr><td class="num" id="LN4415">4415</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4416">4416</td><td class="line">      <span class='comment'>/* fastpath remainders so long as the lhs has the smaller  */</span></td></tr>
<tr><td class="num" id="LN4417">4417</td><td class="line">      <span class='comment'>/* (or equal) exponent  */</span></td></tr>
<tr><td class="num" id="LN4418">4418</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;exponent&lt;=rhs-&gt;exponent) {</td></tr>
<tr><td class="num" id="LN4419">4419</td><td class="line">        <span class='keyword'>if</span> (op&amp;<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span> || exponent&lt;-1) {</td></tr>
<tr><td class="num" id="LN4420">4420</td><td class="line">          <span class='comment'>/* It is REMAINDER or safe REMNEAR; result is [finished  */</span></td></tr>
<tr><td class="num" id="LN4421">4421</td><td class="line">          <span class='comment'>/* clone of] lhs  (r = x - 0*y)  */</span></td></tr>
<tr><td class="num" id="LN4422">4422</td><td class="line">          residue=0;</td></tr>
<tr><td class="num" id="LN4423">4423</td><td class="line">          decCopyFit(res, lhs, set, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4424">4424</td><td class="line">          <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;</td></tr>
<tr><td class="num" id="LN4425">4425</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4426">4426</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4427">4427</td><td class="line">        <span class='comment'>/* [unsafe REMNEAR drops through]  */</span></td></tr>
<tr><td class="num" id="LN4428">4428</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4429">4429</td><td class="line">      } <span class='comment'>/* fastpaths  */</span></td></tr>
<tr><td class="num" id="LN4430">4430</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4431">4431</td><td class="line">    <span class='comment'>/* Long (slow) division is needed; roll up the sleeves... */</span></td></tr>
<tr><td class="num" id="LN4432">4432</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4433">4433</td><td class="line">    <span class='comment'>/* The accumulator will hold the quotient of the division.  */</span></td></tr>
<tr><td class="num" id="LN4434">4434</td><td class="line">    <span class='comment'>/* If it needs to be too long for stack storage, then allocate.  */</span></td></tr>
<tr><td class="num" id="LN4435">4435</td><td class="line">    acclength=<span class='macro'>D2U(reqdigits+DECDPUN)<span class='expansion'>((reqdigits+1)&lt;=49?d2utable[reqdigits+1]:((reqdigits+1)+1 -<br>1)/1)</span></span>;   <span class='comment'>/* in Units  */</span></td></tr>
<tr><td class="num" id="LN4436">4436</td><td class="line">    <span class='keyword'>if</span> (acclength*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)&gt;<span class='keyword'>sizeof</span>(accbuff)) {</td></tr>
<tr><td class="num" id="LN4437">4437</td><td class="line">      <span class='comment'>/* printf("malloc dvacc %ld units\n", acclength);  */</span></td></tr>
<tr><td class="num" id="LN4438">4438</td><td class="line">      allocacc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc(acclength*<span class='keyword'>sizeof</span>(Unit))<span class='expansion'>uprv_malloc_54(acclength*sizeof(uint8_t))</span></span>;</td></tr>
<tr><td class="num" id="LN4439">4439</td><td class="line">      <span class='keyword'>if</span> (allocacc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {             <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN4440">4440</td><td class="line">        *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN4441">4441</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4442">4442</td><td class="line">      acc=allocacc;                     <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN4443">4443</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4444">4444</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4445">4445</td><td class="line">    <span class='comment'>/* var1 is the padded LHS ready for subtractions.  */</span></td></tr>
<tr><td class="num" id="LN4446">4446</td><td class="line">    <span class='comment'>/* If it needs to be too long for stack storage, then allocate.  */</span></td></tr>
<tr><td class="num" id="LN4447">4447</td><td class="line">    <span class='comment'>/* The maximum units needed for var1 (long subtraction) is:  */</span></td></tr>
<tr><td class="num" id="LN4448">4448</td><td class="line">    <span class='comment'>/* Enough for  */</span></td></tr>
<tr><td class="num" id="LN4449">4449</td><td class="line">    <span class='comment'>/*     (rhs-&gt;digits+reqdigits-1) -- to allow full slide to right  */</span></td></tr>
<tr><td class="num" id="LN4450">4450</td><td class="line">    <span class='comment'>/* or  (lhs-&gt;digits)             -- to allow for long lhs  */</span></td></tr>
<tr><td class="num" id="LN4451">4451</td><td class="line">    <span class='comment'>/* whichever is larger  */</span></td></tr>
<tr><td class="num" id="LN4452">4452</td><td class="line">    <span class='comment'>/*   +1                -- for rounding of slide to right  */</span></td></tr>
<tr><td class="num" id="LN4453">4453</td><td class="line">    <span class='comment'>/*   +1                -- for leading 0s  */</span></td></tr>
<tr><td class="num" id="LN4454">4454</td><td class="line">    <span class='comment'>/*   +1                -- for pre-adjust if a remainder or DIVIDEINT  */</span></td></tr>
<tr><td class="num" id="LN4455">4455</td><td class="line">    <span class='comment'>/* [Note: unused units do not participate in decUnitAddSub data]  */</span></td></tr>
<tr><td class="num" id="LN4456">4456</td><td class="line">    maxdigits=rhs-&gt;digits+reqdigits-1;</td></tr>
<tr><td class="num" id="LN4457">4457</td><td class="line">    <span class='keyword'>if</span> (lhs-&gt;digits&gt;maxdigits) maxdigits=lhs-&gt;digits;</td></tr>
<tr><td class="num" id="LN4458">4458</td><td class="line">    var1units=<span class='macro'>D2U(maxdigits)<span class='expansion'>((maxdigits)&lt;=49?d2utable[maxdigits]:((maxdigits)+1 -1)/1)</span></span>+2;</td></tr>
<tr><td class="num" id="LN4459">4459</td><td class="line">    <span class='comment'>/* allocate a guard unit above msu1 for REMAINDERNEAR  */</span></td></tr>
<tr><td class="num" id="LN4460">4460</td><td class="line">    <span class='keyword'>if</span> (!(op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>)) var1units++;</td></tr>
<tr><td class="num" id="LN4461">4461</td><td class="line">    <span class='keyword'>if</span> ((var1units+1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)&gt;<span class='keyword'>sizeof</span>(varbuff)) {</td></tr>
<tr><td class="num" id="LN4462">4462</td><td class="line">      <span class='comment'>/* printf("malloc dvvar %ld units\n", var1units+1);  */</span></td></tr>
<tr><td class="num" id="LN4463">4463</td><td class="line">      varalloc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc((var1units+1)*<span class='keyword'>sizeof</span>(Unit))<span class='expansion'>uprv_malloc_54((var1units+1)*sizeof(uint8_t))</span></span>;</td></tr>
<tr><td class="num" id="LN4464">4464</td><td class="line">      <span class='keyword'>if</span> (varalloc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {             <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN4465">4465</td><td class="line">        *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN4466">4466</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4467">4467</td><td class="line">      var1=varalloc;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN4468">4468</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4469">4469</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4470">4470</td><td class="line">    <span class='comment'>/* Extend the lhs and rhs to full long subtraction length.  The lhs  */</span></td></tr>
<tr><td class="num" id="LN4471">4471</td><td class="line">    <span class='comment'>/* is truly extended into the var1 buffer, with 0 padding, so a  */</span></td></tr>
<tr><td class="num" id="LN4472">4472</td><td class="line">    <span class='comment'>/* subtract in place is always possible.  The rhs (var2) has  */</span></td></tr>
<tr><td class="num" id="LN4473">4473</td><td class="line">    <span class='comment'>/* virtual padding (implemented by decUnitAddSub).  */</span></td></tr>
<tr><td class="num" id="LN4474">4474</td><td class="line">    <span class='comment'>/* One guard unit was allocated above msu1 for rem=rem+rem in  */</span></td></tr>
<tr><td class="num" id="LN4475">4475</td><td class="line">    <span class='comment'>/* REMAINDERNEAR.  */</span></td></tr>
<tr><td class="num" id="LN4476">4476</td><td class="line">    msu1=var1+var1units-1;              <span class='comment'>/* msu of var1  */</span></td></tr>
<tr><td class="num" id="LN4477">4477</td><td class="line">    source=lhs-&gt;lsu+<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>-1; <span class='comment'>/* msu of input array  */</span></td></tr>
<tr><td class="num" id="LN4478">4478</td><td class="line">    <span class='keyword'>for</span> (target=msu1; source&gt;=lhs-&gt;lsu; source--, target--) *target=*source;</td></tr>
<tr><td class="num" id="LN4479">4479</td><td class="line">    <span class='keyword'>for</span> (; target&gt;=var1; target--) *target=0;</td></tr>
<tr><td class="num" id="LN4480">4480</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4481">4481</td><td class="line">    <span class='comment'>/* rhs (var2) is left-aligned with var1 at the start  */</span></td></tr>
<tr><td class="num" id="LN4482">4482</td><td class="line">    var2ulen=var1units;                 <span class='comment'>/* rhs logical length (units)  */</span></td></tr>
<tr><td class="num" id="LN4483">4483</td><td class="line">    var2units=<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>;         <span class='comment'>/* rhs actual length (units)  */</span></td></tr>
<tr><td class="num" id="LN4484">4484</td><td class="line">    var2=rhs-&gt;lsu;                      <span class='comment'>/* -&gt; rhs array  */</span></td></tr>
<tr><td class="num" id="LN4485">4485</td><td class="line">    msu2=var2+var2units-1;              <span class='comment'>/* -&gt; msu of var2 [never changes]  */</span></td></tr>
<tr><td class="num" id="LN4486">4486</td><td class="line">    <span class='comment'>/* now set up the variables which will be used for estimating the  */</span></td></tr>
<tr><td class="num" id="LN4487">4487</td><td class="line">    <span class='comment'>/* multiplication factor.  If these variables are not exact, add  */</span></td></tr>
<tr><td class="num" id="LN4488">4488</td><td class="line">    <span class='comment'>/* 1 to make sure that the multiplier is never overestimated.  */</span></td></tr>
<tr><td class="num" id="LN4489">4489</td><td class="line">    msu2plus=*msu2;                     <span class='comment'>/* it's value ..  */</span></td></tr>
<tr><td class="num" id="LN4490">4490</td><td class="line">    <span class='keyword'>if</span> (var2units&gt;1) msu2plus++;        <span class='comment'>/* .. +1 if any more  */</span></td></tr>
<tr><td class="num" id="LN4491">4491</td><td class="line">    msu2pair=(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)*msu2*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);<span class='comment'>/* top two pair ..  */</span></td></tr>
<tr><td class="num" id="LN4492">4492</td><td class="line">    <span class='keyword'>if</span> (var2units&gt;1) {                  <span class='comment'>/* .. [else treat 2nd as 0]  */</span></td></tr>
<tr><td class="num" id="LN4493">4493</td><td class="line">      msu2pair+=*(msu2-1);              <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4494">4494</td><td class="line">      <span class='keyword'>if</span> (var2units&gt;2) msu2pair++;      <span class='comment'>/* .. +1 if any more  */</span></td></tr>
<tr><td class="num" id="LN4495">4495</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4496">4496</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4497">4497</td><td class="line">    <span class='comment'>/* The calculation is working in units, which may have leading zeros,  */</span></td></tr>
<tr><td class="num" id="LN4498">4498</td><td class="line">    <span class='comment'>/* but the exponent was calculated on the assumption that they are  */</span></td></tr>
<tr><td class="num" id="LN4499">4499</td><td class="line">    <span class='comment'>/* both left-aligned.  Adjust the exponent to compensate: add the  */</span></td></tr>
<tr><td class="num" id="LN4500">4500</td><td class="line">    <span class='comment'>/* number of leading zeros in var1 msu and subtract those in var2 msu.  */</span></td></tr>
<tr><td class="num" id="LN4501">4501</td><td class="line">    <span class='comment'>/* [This is actually done by counting the digits and negating, as  */</span></td></tr>
<tr><td class="num" id="LN4502">4502</td><td class="line">    <span class='comment'>/* lead1=DECDPUN-digits1, and similarly for lead2.]  */</span></td></tr>
<tr><td class="num" id="LN4503">4503</td><td class="line">    <span class='keyword'>for</span> (pow=&amp;<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[1]; *msu1&gt;=*pow; pow++) exponent--;</td></tr>
<tr><td class="num" id="LN4504">4504</td><td class="line">    <span class='keyword'>for</span> (pow=&amp;<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[1]; *msu2&gt;=*pow; pow++) exponent++;</td></tr>
<tr><td class="num" id="LN4505">4505</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4506">4506</td><td class="line">    <span class='comment'>/* Now, if doing an integer divide or remainder, ensure that  */</span></td></tr>
<tr><td class="num" id="LN4507">4507</td><td class="line">    <span class='comment'>/* the result will be Unit-aligned.  To do this, shift the var1  */</span></td></tr>
<tr><td class="num" id="LN4508">4508</td><td class="line">    <span class='comment'>/* accumulator towards least if need be.  (It's much easier to  */</span></td></tr>
<tr><td class="num" id="LN4509">4509</td><td class="line">    <span class='comment'>/* do this now than to reassemble the residue afterwards, if  */</span></td></tr>
<tr><td class="num" id="LN4510">4510</td><td class="line">    <span class='comment'>/* doing a remainder.)  Also ensure the exponent is not negative.  */</span></td></tr>
<tr><td class="num" id="LN4511">4511</td><td class="line">    <span class='keyword'>if</span> (!(op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>)) {</td></tr>
<tr><td class="num" id="LN4512">4512</td><td class="line">      <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *u;                          <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4513">4513</td><td class="line">      <span class='comment'>/* save the initial 'false' padding of var1, in digits  */</span></td></tr>
<tr><td class="num" id="LN4514">4514</td><td class="line">      var1initpad=(var1units-<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>)*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN4515">4515</td><td class="line">      <span class='comment'>/* Determine the shift to do.  */</span></td></tr>
<tr><td class="num" id="LN4516">4516</td><td class="line">      <span class='keyword'>if</span> (exponent&lt;0) cut=-exponent;</td></tr>
<tr><td class="num" id="LN4517">4517</td><td class="line">       <span class='keyword'>else</span> cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-exponent%<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN4518">4518</td><td class="line">      decShiftToLeast(var1, var1units, cut);</td></tr>
<tr><td class="num" id="LN4519">4519</td><td class="line">      exponent+=cut;                    <span class='comment'>/* maintain numerical value  */</span></td></tr>
<tr><td class="num" id="LN4520">4520</td><td class="line">      var1initpad-=cut;                 <span class='comment'>/* .. and reduce padding  */</span></td></tr>
<tr><td class="num" id="LN4521">4521</td><td class="line">      <span class='comment'>/* clean any most-significant units which were just emptied  */</span></td></tr>
<tr><td class="num" id="LN4522">4522</td><td class="line">      <span class='keyword'>for</span> (u=msu1; cut&gt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; cut-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>, u--) *u=0;</td></tr>
<tr><td class="num" id="LN4523">4523</td><td class="line">      } <span class='comment'>/* align  */</span></td></tr>
<tr><td class="num" id="LN4524">4524</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* is DIVIDE  */</span></td></tr>
<tr><td class="num" id="LN4525">4525</td><td class="line">      maxexponent=lhs-&gt;exponent-rhs-&gt;exponent;    <span class='comment'>/* save  */</span></td></tr>
<tr><td class="num" id="LN4526">4526</td><td class="line">      <span class='comment'>/* optimization: if the first iteration will just produce 0,  */</span></td></tr>
<tr><td class="num" id="LN4527">4527</td><td class="line">      <span class='comment'>/* preadjust to skip it [valid for DIVIDE only]  */</span></td></tr>
<tr><td class="num" id="LN4528">4528</td><td class="line">      <span class='keyword'>if</span> (*msu1&lt;*msu2) {</td></tr>
<tr><td class="num" id="LN4529">4529</td><td class="line">        var2ulen--;                     <span class='comment'>/* shift down  */</span></td></tr>
<tr><td class="num" id="LN4530">4530</td><td class="line">        exponent-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;              <span class='comment'>/* update the exponent  */</span></td></tr>
<tr><td class="num" id="LN4531">4531</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4532">4532</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4533">4533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4534">4534</td><td class="line">    <span class='comment'>/* ---- start the long-division loops ------------------------------  */</span></td></tr>
<tr><td class="num" id="LN4535">4535</td><td class="line">    accunits=0;                         <span class='comment'>/* no units accumulated yet  */</span></td></tr>
<tr><td class="num" id="LN4536">4536</td><td class="line">    accdigits=0;                        <span class='comment'>/* .. or digits  */</span></td></tr>
<tr><td class="num" id="LN4537">4537</td><td class="line">    accnext=acc+acclength-1;            <span class='comment'>/* -&gt; msu of acc [NB: allows digits+1]  */</span></td></tr>
<tr><td class="num" id="LN4538">4538</td><td class="line">    <span class='keyword'>for</span> (;;) {                          <span class='comment'>/* outer forever loop  */</span></td></tr>
<tr><td class="num" id="LN4539">4539</td><td class="line">      thisunit=0;                       <span class='comment'>/* current unit assumed 0  */</span></td></tr>
<tr><td class="num" id="LN4540">4540</td><td class="line">      <span class='comment'>/* find the next unit  */</span></td></tr>
<tr><td class="num" id="LN4541">4541</td><td class="line">      <span class='keyword'>for</span> (;;) {                        <span class='comment'>/* inner forever loop  */</span></td></tr>
<tr><td class="num" id="LN4542">4542</td><td class="line">        <span class='comment'>/* strip leading zero units [from either pre-adjust or from  */</span></td></tr>
<tr><td class="num" id="LN4543">4543</td><td class="line">        <span class='comment'>/* subtract last time around].  Leave at least one unit.  */</span></td></tr>
<tr><td class="num" id="LN4544">4544</td><td class="line">        <span class='keyword'>for</span> (; *msu1==0 &amp;&amp; msu1&gt;var1; msu1--) var1units--;</td></tr>
<tr><td class="num" id="LN4545">4545</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4546">4546</td><td class="line">        <span class='keyword'>if</span> (var1units&lt;var2ulen) <span class='keyword'>break</span>;       <span class='comment'>/* var1 too low for subtract  */</span></td></tr>
<tr><td class="num" id="LN4547">4547</td><td class="line">        <span class='keyword'>if</span> (var1units==var2ulen) {           <span class='comment'>/* unit-by-unit compare needed  */</span></td></tr>
<tr><td class="num" id="LN4548">4548</td><td class="line">          <span class='comment'>/* compare the two numbers, from msu  */</span></td></tr>
<tr><td class="num" id="LN4549">4549</td><td class="line">          <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *pv1, *pv2;</td></tr>
<tr><td class="num" id="LN4550">4550</td><td class="line">          <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> v2;                           <span class='comment'>/* units to compare  */</span></td></tr>
<tr><td class="num" id="LN4551">4551</td><td class="line">          pv2=msu2;                          <span class='comment'>/* -&gt; msu  */</span></td></tr>
<tr><td class="num" id="LN4552">4552</td><td class="line">          <span class='keyword'>for</span> (pv1=msu1; ; pv1--, pv2--) {</td></tr>
<tr><td class="num" id="LN4553">4553</td><td class="line">            <span class='comment'>/* v1=*pv1 -- always OK  */</span></td></tr>
<tr><td class="num" id="LN4554">4554</td><td class="line">            v2=0;                            <span class='comment'>/* assume in padding  */</span></td></tr>
<tr><td class="num" id="LN4555">4555</td><td class="line">            <span class='keyword'>if</span> (pv2&gt;=var2) v2=*pv2;          <span class='comment'>/* in range  */</span></td></tr>
<tr><td class="num" id="LN4556">4556</td><td class="line">            <span class='keyword'>if</span> (*pv1!=v2) <span class='keyword'>break</span>;             <span class='comment'>/* no longer the same  */</span></td></tr>
<tr><td class="num" id="LN4557">4557</td><td class="line">            <span class='keyword'>if</span> (pv1==var1) <span class='keyword'>break</span>;            <span class='comment'>/* done; leave pv1 as is  */</span></td></tr>
<tr><td class="num" id="LN4558">4558</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4559">4559</td><td class="line">          <span class='comment'>/* here when all inspected or a difference seen  */</span></td></tr>
<tr><td class="num" id="LN4560">4560</td><td class="line">          <span class='keyword'>if</span> (*pv1&lt;v2) <span class='keyword'>break</span>;                <span class='comment'>/* var1 too low to subtract  */</span></td></tr>
<tr><td class="num" id="LN4561">4561</td><td class="line">          <span class='keyword'>if</span> (*pv1==v2) {                    <span class='comment'>/* var1 == var2  */</span></td></tr>
<tr><td class="num" id="LN4562">4562</td><td class="line">            <span class='comment'>/* reach here if var1 and var2 are identical; subtraction  */</span></td></tr>
<tr><td class="num" id="LN4563">4563</td><td class="line">            <span class='comment'>/* would increase digit by one, and the residue will be 0 so  */</span></td></tr>
<tr><td class="num" id="LN4564">4564</td><td class="line">            <span class='comment'>/* the calculation is done; leave the loop with residue=0.  */</span></td></tr>
<tr><td class="num" id="LN4565">4565</td><td class="line">            thisunit++;                      <span class='comment'>/* as though subtracted  */</span></td></tr>
<tr><td class="num" id="LN4566">4566</td><td class="line">            *var1=0;                         <span class='comment'>/* set var1 to 0  */</span></td></tr>
<tr><td class="num" id="LN4567">4567</td><td class="line">            var1units=1;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4568">4568</td><td class="line">            <span class='keyword'>break</span>;  <span class='comment'>/* from inner  */</span></td></tr>
<tr><td class="num" id="LN4569">4569</td><td class="line">            } <span class='comment'>/* var1 == var2  */</span></td></tr>
<tr><td class="num" id="LN4570">4570</td><td class="line">          <span class='comment'>/* *pv1&gt;v2.  Prepare for real subtraction; the lengths are equal  */</span></td></tr>
<tr><td class="num" id="LN4571">4571</td><td class="line">          <span class='comment'>/* Estimate the multiplier (there's always a msu1-1)...  */</span></td></tr>
<tr><td class="num" id="LN4572">4572</td><td class="line">          <span class='comment'>/* Bring in two units of var2 to provide a good estimate.  */</span></td></tr>
<tr><td class="num" id="LN4573">4573</td><td class="line">          mult=(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)(((<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)*msu1*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)+*(msu1-1))/msu2pair);</td></tr>
<tr><td class="num" id="LN4574">4574</td><td class="line">          } <span class='comment'>/* lengths the same  */</span></td></tr>
<tr><td class="num" id="LN4575">4575</td><td class="line">         <span class='keyword'>else</span> { <span class='comment'>/* var1units &gt; var2ulen, so subtraction is safe  */</span></td></tr>
<tr><td class="num" id="LN4576">4576</td><td class="line">          <span class='comment'>/* The var2 msu is one unit towards the lsu of the var1 msu,  */</span></td></tr>
<tr><td class="num" id="LN4577">4577</td><td class="line">          <span class='comment'>/* so only one unit for var2 can be used.  */</span></td></tr>
<tr><td class="num" id="LN4578">4578</td><td class="line">          mult=(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)(((<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)*msu1*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)+*(msu1-1))/msu2plus);</td></tr>
<tr><td class="num" id="LN4579">4579</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4580">4580</td><td class="line">        <span class='keyword'>if</span> (mult==0) mult=1;                 <span class='comment'>/* must always be at least 1  */</span></td></tr>
<tr><td class="num" id="LN4581">4581</td><td class="line">        <span class='comment'>/* subtraction needed; var1 is &gt; var2  */</span></td></tr>
<tr><td class="num" id="LN4582">4582</td><td class="line">        thisunit=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(thisunit+mult);      <span class='comment'>/* accumulate  */</span></td></tr>
<tr><td class="num" id="LN4583">4583</td><td class="line">        <span class='comment'>/* subtract var1-var2, into var1; only the overlap needs  */</span></td></tr>
<tr><td class="num" id="LN4584">4584</td><td class="line">        <span class='comment'>/* processing, as this is an in-place calculation  */</span></td></tr>
<tr><td class="num" id="LN4585">4585</td><td class="line">        shift=var2ulen-var2units;</td></tr>
<tr><td class="num" id="LN4586">4586</td><td class="line">        <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4587">4587</td><td class="line">          decDumpAr('1', &amp;var1[shift], var1units-shift);</td></tr>
<tr><td class="num" id="LN4588">4588</td><td class="line">          decDumpAr('2', var2, var2units);</td></tr>
<tr><td class="num" id="LN4589">4589</td><td class="line">          printf(<span class='string_literal'>"m=%ld\n"</span>, -mult);</td></tr>
<tr><td class="num" id="LN4590">4590</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4591">4591</td><td class="line">        decUnitAddSub(&amp;var1[shift], var1units-shift,</td></tr>
<tr><td class="num" id="LN4592">4592</td><td class="line">                      var2, var2units, 0,</td></tr>
<tr><td class="num" id="LN4593">4593</td><td class="line">                      &amp;var1[shift], -mult);</td></tr>
<tr><td class="num" id="LN4594">4594</td><td class="line">        <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4595">4595</td><td class="line">          decDumpAr('#', &amp;var1[shift], var1units-shift);</td></tr>
<tr><td class="num" id="LN4596">4596</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4597">4597</td><td class="line">        <span class='comment'>/* var1 now probably has leading zeros; these are removed at the  */</span></td></tr>
<tr><td class="num" id="LN4598">4598</td><td class="line">        <span class='comment'>/* top of the inner loop.  */</span></td></tr>
<tr><td class="num" id="LN4599">4599</td><td class="line">        } <span class='comment'>/* inner loop  */</span></td></tr>
<tr><td class="num" id="LN4600">4600</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4601">4601</td><td class="line">      <span class='comment'>/* The next unit has been calculated in full; unless it's a  */</span></td></tr>
<tr><td class="num" id="LN4602">4602</td><td class="line">      <span class='comment'>/* leading zero, add to acc  */</span></td></tr>
<tr><td class="num" id="LN4603">4603</td><td class="line">      <span class='keyword'>if</span> (accunits!=0 || thisunit!=0) {      <span class='comment'>/* is first or non-zero  */</span></td></tr>
<tr><td class="num" id="LN4604">4604</td><td class="line">        *accnext=thisunit;                   <span class='comment'>/* store in accumulator  */</span></td></tr>
<tr><td class="num" id="LN4605">4605</td><td class="line">        <span class='comment'>/* account exactly for the new digits  */</span></td></tr>
<tr><td class="num" id="LN4606">4606</td><td class="line">        <span class='keyword'>if</span> (accunits==0) {</td></tr>
<tr><td class="num" id="LN4607">4607</td><td class="line">          accdigits++;                       <span class='comment'>/* at least one  */</span></td></tr>
<tr><td class="num" id="LN4608">4608</td><td class="line">          <span class='keyword'>for</span> (pow=&amp;<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[1]; thisunit&gt;=*pow; pow++) accdigits++;</td></tr>
<tr><td class="num" id="LN4609">4609</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4610">4610</td><td class="line">         <span class='keyword'>else</span> accdigits+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN4611">4611</td><td class="line">        accunits++;                          <span class='comment'>/* update count  */</span></td></tr>
<tr><td class="num" id="LN4612">4612</td><td class="line">        accnext--;                           <span class='comment'>/* ready for next  */</span></td></tr>
<tr><td class="num" id="LN4613">4613</td><td class="line">        <span class='keyword'>if</span> (accdigits&gt;reqdigits) <span class='keyword'>break</span>;      <span class='comment'>/* have enough digits  */</span></td></tr>
<tr><td class="num" id="LN4614">4614</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4615">4615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4616">4616</td><td class="line">      <span class='comment'>/* if the residue is zero, the operation is done (unless divide  */</span></td></tr>
<tr><td class="num" id="LN4617">4617</td><td class="line">      <span class='comment'>/* or divideInteger and still not enough digits yet)  */</span></td></tr>
<tr><td class="num" id="LN4618">4618</td><td class="line">      <span class='keyword'>if</span> (*var1==0 &amp;&amp; var1units==1) {        <span class='comment'>/* residue is 0  */</span></td></tr>
<tr><td class="num" id="LN4619">4619</td><td class="line">        <span class='keyword'>if</span> (op&amp;(<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>|<span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>)) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4620">4620</td><td class="line">        <span class='keyword'>if</span> ((op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>) &amp;&amp; (exponent&lt;=maxexponent)) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4621">4621</td><td class="line">        <span class='comment'>/* [drop through if divideInteger]  */</span></td></tr>
<tr><td class="num" id="LN4622">4622</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4623">4623</td><td class="line">      <span class='comment'>/* also done enough if calculating remainder or integer  */</span></td></tr>
<tr><td class="num" id="LN4624">4624</td><td class="line">      <span class='comment'>/* divide and just did the last ('units') unit  */</span></td></tr>
<tr><td class="num" id="LN4625">4625</td><td class="line">      <span class='keyword'>if</span> (exponent==0 &amp;&amp; !(op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>)) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4626">4626</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4627">4627</td><td class="line">      <span class='comment'>/* to get here, var1 is less than var2, so divide var2 by the per-  */</span></td></tr>
<tr><td class="num" id="LN4628">4628</td><td class="line">      <span class='comment'>/* Unit power of ten and go for the next digit  */</span></td></tr>
<tr><td class="num" id="LN4629">4629</td><td class="line">      var2ulen--;                            <span class='comment'>/* shift down  */</span></td></tr>
<tr><td class="num" id="LN4630">4630</td><td class="line">      exponent-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;                     <span class='comment'>/* update the exponent  */</span></td></tr>
<tr><td class="num" id="LN4631">4631</td><td class="line">      } <span class='comment'>/* outer loop  */</span></td></tr>
<tr><td class="num" id="LN4632">4632</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4633">4633</td><td class="line">    <span class='comment'>/* ---- division is complete ---------------------------------------  */</span></td></tr>
<tr><td class="num" id="LN4634">4634</td><td class="line">    <span class='comment'>/* here: acc      has at least reqdigits+1 of good results (or fewer  */</span></td></tr>
<tr><td class="num" id="LN4635">4635</td><td class="line">    <span class='comment'>/*                if early stop), starting at accnext+1 (its lsu)  */</span></td></tr>
<tr><td class="num" id="LN4636">4636</td><td class="line">    <span class='comment'>/*       var1     has any residue at the stopping point  */</span></td></tr>
<tr><td class="num" id="LN4637">4637</td><td class="line">    <span class='comment'>/*       accunits is the number of digits collected in acc  */</span></td></tr>
<tr><td class="num" id="LN4638">4638</td><td class="line">    <span class='keyword'>if</span> (accunits==0) {             <span class='comment'>/* acc is 0  */</span></td></tr>
<tr><td class="num" id="LN4639">4639</td><td class="line">      accunits=1;                  <span class='comment'>/* show have a unit ..  */</span></td></tr>
<tr><td class="num" id="LN4640">4640</td><td class="line">      accdigits=1;                 <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4641">4641</td><td class="line">      *accnext=0;                  <span class='comment'>/* .. whose value is 0  */</span></td></tr>
<tr><td class="num" id="LN4642">4642</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4643">4643</td><td class="line">     <span class='keyword'>else</span> accnext++;               <span class='comment'>/* back to last placed  */</span></td></tr>
<tr><td class="num" id="LN4644">4644</td><td class="line">    <span class='comment'>/* accnext now -&gt; lowest unit of result  */</span></td></tr>
<tr><td class="num" id="LN4645">4645</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4646">4646</td><td class="line">    residue=0;                     <span class='comment'>/* assume no residue  */</span></td></tr>
<tr><td class="num" id="LN4647">4647</td><td class="line">    <span class='keyword'>if</span> (op&amp;<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>) {</td></tr>
<tr><td class="num" id="LN4648">4648</td><td class="line">      <span class='comment'>/* record the presence of any residue, for rounding  */</span></td></tr>
<tr><td class="num" id="LN4649">4649</td><td class="line">      <span class='keyword'>if</span> (*var1!=0 || var1units&gt;1) residue=1;</td></tr>
<tr><td class="num" id="LN4650">4650</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* no residue  */</span></td></tr>
<tr><td class="num" id="LN4651">4651</td><td class="line">        <span class='comment'>/* Had an exact division; clean up spurious trailing 0s.  */</span></td></tr>
<tr><td class="num" id="LN4652">4652</td><td class="line">        <span class='comment'>/* There will be at most DECDPUN-1, from the final multiply,  */</span></td></tr>
<tr><td class="num" id="LN4653">4653</td><td class="line">        <span class='comment'>/* and then only if the result is non-0 (and even) and the  */</span></td></tr>
<tr><td class="num" id="LN4654">4654</td><td class="line">        <span class='comment'>/* exponent is 'loose'.  */</span></td></tr>
<tr><td class="num" id="LN4655">4655</td><td class="line">        <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1</span></td></tr>
<tr><td class="num" id="LN4656">4656</td><td class="line">        <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> lsu=*accnext;</td></tr>
<tr><td class="num" id="LN4657">4657</td><td class="line">        <span class='keyword'>if</span> (!(lsu&amp;0x01) &amp;&amp; (lsu!=0)) {</td></tr>
<tr><td class="num" id="LN4658">4658</td><td class="line">          <span class='comment'>/* count the trailing zeros  */</span></td></tr>
<tr><td class="num" id="LN4659">4659</td><td class="line">          <span class='macro'>Int<span class='expansion'>int32_t</span></span> drop=0;</td></tr>
<tr><td class="num" id="LN4660">4660</td><td class="line">          <span class='keyword'>for</span> (;; drop++) {    <span class='comment'>/* [will terminate because lsu!=0]  */</span></td></tr>
<tr><td class="num" id="LN4661">4661</td><td class="line">            <span class='keyword'>if</span> (exponent&gt;=maxexponent) <span class='keyword'>break</span>;     <span class='comment'>/* don't chop real 0s  */</span></td></tr>
<tr><td class="num" id="LN4662">4662</td><td class="line">            <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN4663">4663</td><td class="line">              <span class='keyword'>if</span> ((lsu-<span class='macro'>QUOT10(lsu, drop+1)<span class='expansion'>((((uint32_t)(lsu)&gt;&gt;(drop+1))*multies[drop+1])&gt;&gt;17<br>)</span></span></td></tr>
<tr><td class="num" id="LN4664">4664</td><td class="line">                  *<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[drop+1])!=0) <span class='keyword'>break</span>;     <span class='comment'>/* found non-0 digit  */</span></td></tr>
<tr><td class="num" id="LN4665">4665</td><td class="line">            <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN4666">4666</td><td class="line">              <span class='keyword'>if</span> (lsu%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[drop+1]!=0) <span class='keyword'>break</span>;   <span class='comment'>/* found non-0 digit  */</span></td></tr>
<tr><td class="num" id="LN4667">4667</td><td class="line">            <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4668">4668</td><td class="line">            exponent++;</td></tr>
<tr><td class="num" id="LN4669">4669</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4670">4670</td><td class="line">          <span class='keyword'>if</span> (drop&gt;0) {</td></tr>
<tr><td class="num" id="LN4671">4671</td><td class="line">            accunits=decShiftToLeast(accnext, accunits, drop);</td></tr>
<tr><td class="num" id="LN4672">4672</td><td class="line">            accdigits=decGetDigits(accnext, accunits);</td></tr>
<tr><td class="num" id="LN4673">4673</td><td class="line">            accunits=<span class='macro'>D2U(accdigits)<span class='expansion'>((accdigits)&lt;=49?d2utable[accdigits]:((accdigits)+1 -1)/1)</span></span>;</td></tr>
<tr><td class="num" id="LN4674">4674</td><td class="line">            <span class='comment'>/* [exponent was adjusted in the loop]  */</span></td></tr>
<tr><td class="num" id="LN4675">4675</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4676">4676</td><td class="line">          } <span class='comment'>/* neither odd nor 0  */</span></td></tr>
<tr><td class="num" id="LN4677">4677</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4678">4678</td><td class="line">        } <span class='comment'>/* exact divide  */</span></td></tr>
<tr><td class="num" id="LN4679">4679</td><td class="line">      } <span class='comment'>/* divide  */</span></td></tr>
<tr><td class="num" id="LN4680">4680</td><td class="line">     <span class='keyword'>else</span> <span class='comment'>/* op!=DIVIDE */</span> {</td></tr>
<tr><td class="num" id="LN4681">4681</td><td class="line">      <span class='comment'>/* check for coefficient overflow  */</span></td></tr>
<tr><td class="num" id="LN4682">4682</td><td class="line">      <span class='keyword'>if</span> (accdigits+exponent&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN4683">4683</td><td class="line">        *status|=<span class='macro'>DEC_Division_impossible<span class='expansion'>0x00000004</span></span>;</td></tr>
<tr><td class="num" id="LN4684">4684</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4685">4685</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4686">4686</td><td class="line">      <span class='keyword'>if</span> (op &amp; (<span class='macro'>REMAINDER<span class='expansion'>0x40</span></span>|<span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>)) {</td></tr>
<tr><td class="num" id="LN4687">4687</td><td class="line">        <span class='comment'>/* [Here, the exponent will be 0, because var1 was adjusted  */</span></td></tr>
<tr><td class="num" id="LN4688">4688</td><td class="line">        <span class='comment'>/* appropriately.]  */</span></td></tr>
<tr><td class="num" id="LN4689">4689</td><td class="line">        <span class='macro'>Int<span class='expansion'>int32_t</span></span> postshift;                       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4690">4690</td><td class="line">        <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> wasodd=0;                       <span class='comment'>/* integer was odd  */</span></td></tr>
<tr><td class="num" id="LN4691">4691</td><td class="line">        <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *quotlsu;                       <span class='comment'>/* for save  */</span></td></tr>
<tr><td class="num" id="LN4692">4692</td><td class="line">        <span class='macro'>Int<span class='expansion'>int32_t</span></span>  quotdigits;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4693">4693</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4694">4694</td><td class="line">        bits=lhs-&gt;bits;                      <span class='comment'>/* remainder sign is always as lhs  */</span></td></tr>
<tr><td class="num" id="LN4695">4695</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4696">4696</td><td class="line">        <span class='comment'>/* Fastpath when residue is truly 0 is worthwhile [and  */</span></td></tr>
<tr><td class="num" id="LN4697">4697</td><td class="line">        <span class='comment'>/* simplifies the code below]  */</span></td></tr>
<tr><td class="num" id="LN4698">4698</td><td class="line">        <span class='keyword'>if</span> (*var1==0 &amp;&amp; var1units==1) {      <span class='comment'>/* residue is 0  */</span></td></tr>
<tr><td class="num" id="LN4699">4699</td><td class="line">          <span class='macro'>Int<span class='expansion'>int32_t</span></span> exp=lhs-&gt;exponent;             <span class='comment'>/* save min(exponents)  */</span></td></tr>
<tr><td class="num" id="LN4700">4700</td><td class="line">          <span class='keyword'>if</span> (rhs-&gt;exponent&lt;exp) exp=rhs-&gt;exponent;</td></tr>
<tr><td class="num" id="LN4701">4701</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);                <span class='comment'>/* 0 coefficient  */</span></td></tr>
<tr><td class="num" id="LN4702">4702</td><td class="line">          <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4703">4703</td><td class="line">          <span class='keyword'>if</span> (set-&gt;extended)</td></tr>
<tr><td class="num" id="LN4704">4704</td><td class="line">          <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4705">4705</td><td class="line">          res-&gt;exponent=exp;                 <span class='comment'>/* .. with proper exponent  */</span></td></tr>
<tr><td class="num" id="LN4706">4706</td><td class="line">          res-&gt;bits=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);          <span class='comment'>/* [cleaned]  */</span></td></tr>
<tr><td class="num" id="LN4707">4707</td><td class="line">          <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;   <span class='comment'>/* might clamp  */</span></td></tr>
<tr><td class="num" id="LN4708">4708</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4709">4709</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN4710">4710</td><td class="line">        <span class='comment'>/* note if the quotient was odd  */</span></td></tr>
<tr><td class="num" id="LN4711">4711</td><td class="line">        <span class='keyword'>if</span> (*accnext &amp; 0x01) wasodd=1;       <span class='comment'>/* acc is odd  */</span></td></tr>
<tr><td class="num" id="LN4712">4712</td><td class="line">        quotlsu=accnext;                     <span class='comment'>/* save in case need to reinspect  */</span></td></tr>
<tr><td class="num" id="LN4713">4713</td><td class="line">        quotdigits=accdigits;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4714">4714</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4715">4715</td><td class="line">        <span class='comment'>/* treat the residue, in var1, as the value to return, via acc  */</span></td></tr>
<tr><td class="num" id="LN4716">4716</td><td class="line">        <span class='comment'>/* calculate the unused zero digits.  This is the smaller of:  */</span></td></tr>
<tr><td class="num" id="LN4717">4717</td><td class="line">        <span class='comment'>/*   var1 initial padding (saved above)  */</span></td></tr>
<tr><td class="num" id="LN4718">4718</td><td class="line">        <span class='comment'>/*   var2 residual padding, which happens to be given by:  */</span></td></tr>
<tr><td class="num" id="LN4719">4719</td><td class="line">        postshift=var1initpad+exponent-lhs-&gt;exponent+rhs-&gt;exponent;</td></tr>
<tr><td class="num" id="LN4720">4720</td><td class="line">        <span class='comment'>/* [the 'exponent' term accounts for the shifts during divide]  */</span></td></tr>
<tr><td class="num" id="LN4721">4721</td><td class="line">        <span class='keyword'>if</span> (var1initpad&lt;postshift) postshift=var1initpad;</td></tr>
<tr><td class="num" id="LN4722">4722</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4723">4723</td><td class="line">        <span class='comment'>/* shift var1 the requested amount, and adjust its digits  */</span></td></tr>
<tr><td class="num" id="LN4724">4724</td><td class="line">        var1units=decShiftToLeast(var1, var1units, postshift);</td></tr>
<tr><td class="num" id="LN4725">4725</td><td class="line">        accnext=var1;</td></tr>
<tr><td class="num" id="LN4726">4726</td><td class="line">        accdigits=decGetDigits(var1, var1units);</td></tr>
<tr><td class="num" id="LN4727">4727</td><td class="line">        accunits=<span class='macro'>D2U(accdigits)<span class='expansion'>((accdigits)&lt;=49?d2utable[accdigits]:((accdigits)+1 -1)/1)</span></span>;</td></tr>
<tr><td class="num" id="LN4728">4728</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4729">4729</td><td class="line">        exponent=lhs-&gt;exponent;         <span class='comment'>/* exponent is smaller of lhs &amp; rhs  */</span></td></tr>
<tr><td class="num" id="LN4730">4730</td><td class="line">        <span class='keyword'>if</span> (rhs-&gt;exponent&lt;exponent) exponent=rhs-&gt;exponent;</td></tr>
<tr><td class="num" id="LN4731">4731</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4732">4732</td><td class="line">        <span class='comment'>/* Now correct the result if doing remainderNear; if it  */</span></td></tr>
<tr><td class="num" id="LN4733">4733</td><td class="line">        <span class='comment'>/* (looking just at coefficients) is &gt; rhs/2, or == rhs/2 and  */</span></td></tr>
<tr><td class="num" id="LN4734">4734</td><td class="line">        <span class='comment'>/* the integer was odd then the result should be rem-rhs.  */</span></td></tr>
<tr><td class="num" id="LN4735">4735</td><td class="line">        <span class='keyword'>if</span> (op&amp;<span class='macro'>REMNEAR<span class='expansion'>0x10</span></span>) {</td></tr>
<tr><td class="num" id="LN4736">4736</td><td class="line">          <span class='macro'>Int<span class='expansion'>int32_t</span></span> compare, tarunits;        <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4737">4737</td><td class="line">          <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4738">4738</td><td class="line">          <span class='comment'>/* calculate remainder*2 into the var1 buffer (which has  */</span></td></tr>
<tr><td class="num" id="LN4739">4739</td><td class="line">          <span class='comment'>/* 'headroom' of an extra unit and hence enough space)  */</span></td></tr>
<tr><td class="num" id="LN4740">4740</td><td class="line">          <span class='comment'>/* [a dedicated 'double' loop would be faster, here]  */</span></td></tr>
<tr><td class="num" id="LN4741">4741</td><td class="line">          tarunits=decUnitAddSub(accnext, accunits, accnext, accunits,</td></tr>
<tr><td class="num" id="LN4742">4742</td><td class="line">                                 0, accnext, 1);</td></tr>
<tr><td class="num" id="LN4743">4743</td><td class="line">          <span class='comment'>/* decDumpAr('r', accnext, tarunits);  */</span></td></tr>
<tr><td class="num" id="LN4744">4744</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4745">4745</td><td class="line">          <span class='comment'>/* Here, accnext (var1) holds tarunits Units with twice the  */</span></td></tr>
<tr><td class="num" id="LN4746">4746</td><td class="line">          <span class='comment'>/* remainder's coefficient, which must now be compared to the  */</span></td></tr>
<tr><td class="num" id="LN4747">4747</td><td class="line">          <span class='comment'>/* RHS.  The remainder's exponent may be smaller than the RHS's.  */</span></td></tr>
<tr><td class="num" id="LN4748">4748</td><td class="line">          compare=decUnitCompare(accnext, tarunits, rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN4749">4749</td><td class="line">                                 rhs-&gt;exponent-exponent);</td></tr>
<tr><td class="num" id="LN4750">4750</td><td class="line">          <span class='keyword'>if</span> (compare==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) {             <span class='comment'>/* deep trouble  */</span></td></tr>
<tr><td class="num" id="LN4751">4751</td><td class="line">            *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN4752">4752</td><td class="line">            <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4753">4753</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4754">4754</td><td class="line">          <span class='comment'>/* now restore the remainder by dividing by two; the lsu  */</span></td></tr>
<tr><td class="num" id="LN4755">4755</td><td class="line">          <span class='comment'>/* is known to be even.  */</span></td></tr>
<tr><td class="num" id="LN4756">4756</td><td class="line">          <span class='keyword'>for</span> (up=accnext; up&lt;accnext+tarunits; up++) {</td></tr>
<tr><td class="num" id="LN4757">4757</td><td class="line">            <span class='macro'>Int<span class='expansion'>int32_t</span></span> half;              <span class='comment'>/* half to add to lower unit  */</span></td></tr>
<tr><td class="num" id="LN4758">4758</td><td class="line">            half=*up &amp; 0x01;</td></tr>
<tr><td class="num" id="LN4759">4759</td><td class="line">            *up/=2;                <span class='comment'>/* [shift]  */</span></td></tr>
<tr><td class="num" id="LN4760">4760</td><td class="line">            <span class='keyword'>if</span> (!half) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN4761">4761</td><td class="line">            *(up-1)+=(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)/2;</td></tr>
<tr><td class="num" id="LN4762">4762</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4763">4763</td><td class="line">          <span class='comment'>/* [accunits still describes the original remainder length]  */</span></td></tr>
<tr><td class="num" id="LN4764">4764</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4765">4765</td><td class="line">          <span class='keyword'>if</span> (compare&gt;0 || (compare==0 &amp;&amp; wasodd)) { <span class='comment'>/* adjustment needed  */</span></td></tr>
<tr><td class="num" id="LN4766">4766</td><td class="line">            <span class='macro'>Int<span class='expansion'>int32_t</span></span> exp, expunits, exprem;       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4767">4767</td><td class="line">            <span class='comment'>/* This is effectively causing round-up of the quotient,  */</span></td></tr>
<tr><td class="num" id="LN4768">4768</td><td class="line">            <span class='comment'>/* so if it was the rare case where it was full and all  */</span></td></tr>
<tr><td class="num" id="LN4769">4769</td><td class="line">            <span class='comment'>/* nines, it would overflow and hence division-impossible  */</span></td></tr>
<tr><td class="num" id="LN4770">4770</td><td class="line">            <span class='comment'>/* should be raised  */</span></td></tr>
<tr><td class="num" id="LN4771">4771</td><td class="line">            <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> allnines=0;                 <span class='comment'>/* 1 if quotient all nines  */</span></td></tr>
<tr><td class="num" id="LN4772">4772</td><td class="line">            <span class='keyword'>if</span> (quotdigits==reqdigits) {     <span class='comment'>/* could be borderline  */</span></td></tr>
<tr><td class="num" id="LN4773">4773</td><td class="line">              <span class='keyword'>for</span> (up=quotlsu; ; up++) {</td></tr>
<tr><td class="num" id="LN4774">4774</td><td class="line">                <span class='keyword'>if</span> (quotdigits&gt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {</td></tr>
<tr><td class="num" id="LN4775">4775</td><td class="line">                  <span class='keyword'>if</span> (*up!=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>) <span class='keyword'>break</span>;<span class='comment'>/* non-nines  */</span></td></tr>
<tr><td class="num" id="LN4776">4776</td><td class="line">                  }</td></tr>
<tr><td class="num" id="LN4777">4777</td><td class="line">                 <span class='keyword'>else</span> {                      <span class='comment'>/* this is the last Unit  */</span></td></tr>
<tr><td class="num" id="LN4778">4778</td><td class="line">                  <span class='keyword'>if</span> (*up==<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[quotdigits]-1) allnines=1;</td></tr>
<tr><td class="num" id="LN4779">4779</td><td class="line">                  <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4780">4780</td><td class="line">                  }</td></tr>
<tr><td class="num" id="LN4781">4781</td><td class="line">                quotdigits-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;         <span class='comment'>/* checked those digits  */</span></td></tr>
<tr><td class="num" id="LN4782">4782</td><td class="line">                } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN4783">4783</td><td class="line">              } <span class='comment'>/* borderline check  */</span></td></tr>
<tr><td class="num" id="LN4784">4784</td><td class="line">            <span class='keyword'>if</span> (allnines) {</td></tr>
<tr><td class="num" id="LN4785">4785</td><td class="line">              *status|=<span class='macro'>DEC_Division_impossible<span class='expansion'>0x00000004</span></span>;</td></tr>
<tr><td class="num" id="LN4786">4786</td><td class="line">              <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN4787">4787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4788">4788</td><td class="line">            <span class='comment'>/* rem-rhs is needed; the sign will invert.  Again, var1  */</span></td></tr>
<tr><td class="num" id="LN4789">4789</td><td class="line">            <span class='comment'>/* can safely be used for the working Units array.  */</span></td></tr>
<tr><td class="num" id="LN4790">4790</td><td class="line">            exp=rhs-&gt;exponent-exponent;      <span class='comment'>/* RHS padding needed  */</span></td></tr>
<tr><td class="num" id="LN4791">4791</td><td class="line">            <span class='comment'>/* Calculate units and remainder from exponent.  */</span></td></tr>
<tr><td class="num" id="LN4792">4792</td><td class="line">            expunits=exp/<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN4793">4793</td><td class="line">            exprem=exp%<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN4794">4794</td><td class="line">            <span class='comment'>/* subtract [A+B*(-m)]; the result will always be negative  */</span></td></tr>
<tr><td class="num" id="LN4795">4795</td><td class="line">            accunits=-decUnitAddSub(accnext, accunits,</td></tr>
<tr><td class="num" id="LN4796">4796</td><td class="line">                                    rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN4797">4797</td><td class="line">                                    expunits, accnext, -(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[exprem]);</td></tr>
<tr><td class="num" id="LN4798">4798</td><td class="line">            accdigits=decGetDigits(accnext, accunits); <span class='comment'>/* count digits exactly  */</span></td></tr>
<tr><td class="num" id="LN4799">4799</td><td class="line">            accunits=<span class='macro'>D2U(accdigits)<span class='expansion'>((accdigits)&lt;=49?d2utable[accdigits]:((accdigits)+1 -1)/1)</span></span>;    <span class='comment'>/* and recalculate the units for copy  */</span></td></tr>
<tr><td class="num" id="LN4800">4800</td><td class="line">            <span class='comment'>/* [exponent is as for original remainder]  */</span></td></tr>
<tr><td class="num" id="LN4801">4801</td><td class="line">            bits^=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;               <span class='comment'>/* flip the sign  */</span></td></tr>
<tr><td class="num" id="LN4802">4802</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN4803">4803</td><td class="line">          } <span class='comment'>/* REMNEAR  */</span></td></tr>
<tr><td class="num" id="LN4804">4804</td><td class="line">        } <span class='comment'>/* REMAINDER or REMNEAR  */</span></td></tr>
<tr><td class="num" id="LN4805">4805</td><td class="line">      } <span class='comment'>/* not DIVIDE  */</span></td></tr>
<tr><td class="num" id="LN4806">4806</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4807">4807</td><td class="line">    <span class='comment'>/* Set exponent and bits  */</span></td></tr>
<tr><td class="num" id="LN4808">4808</td><td class="line">    res-&gt;exponent=exponent;</td></tr>
<tr><td class="num" id="LN4809">4809</td><td class="line">    res-&gt;bits=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)(bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);          <span class='comment'>/* [cleaned]  */</span></td></tr>
<tr><td class="num" id="LN4810">4810</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4811">4811</td><td class="line">    <span class='comment'>/* Now the coefficient.  */</span></td></tr>
<tr><td class="num" id="LN4812">4812</td><td class="line">    decSetCoeff(res, set, accnext, accdigits, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN4813">4813</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4814">4814</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;   <span class='comment'>/* final cleanup  */</span></td></tr>
<tr><td class="num" id="LN4815">4815</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4816">4816</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4817">4817</td><td class="line">    <span class='comment'>/* If a divide then strip trailing zeros if subset [after round]  */</span></td></tr>
<tr><td class="num" id="LN4818">4818</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended &amp;&amp; (op==<span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>)) decTrim(res, set, 0, 1, &amp;dropped);</td></tr>
<tr><td class="num" id="LN4819">4819</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4820">4820</td><td class="line">    } <span class='keyword'>while</span>(0);                              <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN4821">4821</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4822">4822</td><td class="line">  <span class='keyword'>if</span> (varalloc!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(varalloc)<span class='expansion'>uprv_free_54(varalloc)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN4823">4823</td><td class="line">  <span class='keyword'>if</span> (allocacc!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocacc)<span class='expansion'>uprv_free_54(allocacc)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4824">4824</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4825">4825</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4826">4826</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4827">4827</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4828">4828</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN4829">4829</td><td class="line">  } <span class='comment'>/* decDivideOp  */</span></td></tr>
<tr><td class="num" id="LN4830">4830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4831">4831</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4832">4832</td><td class="line"><span class='comment'>/* decMultiplyOp -- multiplication operation                          */</span></td></tr>
<tr><td class="num" id="LN4833">4833</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4834">4834</td><td class="line"><span class='comment'>/*  This routine performs the multiplication C=A x B.                 */</span></td></tr>
<tr><td class="num" id="LN4835">4835</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4836">4836</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X*X)         */</span></td></tr>
<tr><td class="num" id="LN4837">4837</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN4838">4838</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN4839">4839</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN4840">4840</td><td class="line"><span class='comment'>/*   status is the usual accumulator                                  */</span></td></tr>
<tr><td class="num" id="LN4841">4841</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4842">4842</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN4843">4843</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4844">4844</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4845">4845</td><td class="line"><span class='comment'>/* 'Classic' multiplication is used rather than Karatsuba, as the     */</span></td></tr>
<tr><td class="num" id="LN4846">4846</td><td class="line"><span class='comment'>/* latter would give only a minor improvement for the short numbers   */</span></td></tr>
<tr><td class="num" id="LN4847">4847</td><td class="line"><span class='comment'>/* expected to be handled most (and uses much more memory).           */</span></td></tr>
<tr><td class="num" id="LN4848">4848</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4849">4849</td><td class="line"><span class='comment'>/* There are two major paths here: the general-purpose ('old code')   */</span></td></tr>
<tr><td class="num" id="LN4850">4850</td><td class="line"><span class='comment'>/* path which handles all DECDPUN values, and a fastpath version      */</span></td></tr>
<tr><td class="num" id="LN4851">4851</td><td class="line"><span class='comment'>/* which is used if 64-bit ints are available, DECDPUN&lt;=4, and more   */</span></td></tr>
<tr><td class="num" id="LN4852">4852</td><td class="line"><span class='comment'>/* than two calls to decUnitAddSub would be made.                     */</span></td></tr>
<tr><td class="num" id="LN4853">4853</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4854">4854</td><td class="line"><span class='comment'>/* The fastpath version lumps units together into 8-digit or 9-digit  */</span></td></tr>
<tr><td class="num" id="LN4855">4855</td><td class="line"><span class='comment'>/* chunks, and also uses a lazy carry strategy to minimise expensive  */</span></td></tr>
<tr><td class="num" id="LN4856">4856</td><td class="line"><span class='comment'>/* 64-bit divisions.  The chunks are then broken apart again into     */</span></td></tr>
<tr><td class="num" id="LN4857">4857</td><td class="line"><span class='comment'>/* units for continuing processing.  Despite this overhead, the       */</span></td></tr>
<tr><td class="num" id="LN4858">4858</td><td class="line"><span class='comment'>/* fastpath can speed up some 16-digit operations by 10x (and much    */</span></td></tr>
<tr><td class="num" id="LN4859">4859</td><td class="line"><span class='comment'>/* more for higher-precision calculations).                           */</span></td></tr>
<tr><td class="num" id="LN4860">4860</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN4861">4861</td><td class="line"><span class='comment'>/* A buffer always has to be used for the accumulator; in the         */</span></td></tr>
<tr><td class="num" id="LN4862">4862</td><td class="line"><span class='comment'>/* fastpath, buffers are also always needed for the chunked copies of */</span></td></tr>
<tr><td class="num" id="LN4863">4863</td><td class="line"><span class='comment'>/* of the operand coefficients.                                       */</span></td></tr>
<tr><td class="num" id="LN4864">4864</td><td class="line"><span class='comment'>/* Static buffers are larger than needed just for multiply, to allow  */</span></td></tr>
<tr><td class="num" id="LN4865">4865</td><td class="line"><span class='comment'>/* for calls from other operations (notably exp).                     */</span></td></tr>
<tr><td class="num" id="LN4866">4866</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN4867">4867</td><td class="line"><span class='directive'>#define <span class='macro'>FASTMUL<span class='expansion'>(1 &amp;&amp; 1&lt;5)</span></span> (<span class='macro'>DECUSE64<span class='expansion'>1</span></span> &amp;&amp; <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;5)</span></td></tr>
<tr><td class="num" id="LN4868">4868</td><td class="line"><span class='keyword'>static</span> decNumber * decMultiplyOp(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN4869">4869</td><td class="line">                                 <span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN4870">4870</td><td class="line">                                 <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN4871">4871</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>    accunits;                 <span class='comment'>/* Units of accumulator in use  */</span></td></tr>
<tr><td class="num" id="LN4872">4872</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>    exponent;                 <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4873">4873</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>    residue=0;                <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN4874">4874</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span>  bits;                     <span class='comment'>/* result sign  */</span></td></tr>
<tr><td class="num" id="LN4875">4875</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *acc;                      <span class='comment'>/* -&gt; accumulator Unit array  */</span></td></tr>
<tr><td class="num" id="LN4876">4876</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>    needbytes;                <span class='comment'>/* size calculator  */</span></td></tr>
<tr><td class="num" id="LN4877">4877</td><td class="line">  <span class='keyword'>void</span>  *allocacc=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated accumulator, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4878">4878</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  accbuff[<span class='macro'>SD2U(DECBUFFER*4+1)<span class='expansion'>(((36*4+1)+1 -1)/1)</span></span>]; <span class='comment'>/* buffer (+1 for DECBUFFER==0,  */</span></td></tr>
<tr><td class="num" id="LN4879">4879</td><td class="line">                                   <span class='comment'>/* *4 for calls from other operations)  */</span></td></tr>
<tr><td class="num" id="LN4880">4880</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *mer, *mermsup;       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4881">4881</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   madlength;                 <span class='comment'>/* Units in multiplicand  */</span></td></tr>
<tr><td class="num" id="LN4882">4882</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   shift;                     <span class='comment'>/* Units to shift multiplicand by  */</span></td></tr>
<tr><td class="num" id="LN4883">4883</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4884">4884</td><td class="line">  <span class='directive'>#if <span class='macro'>FASTMUL<span class='expansion'>(1 &amp;&amp; 1&lt;5)</span></span></span></td></tr>
<tr><td class="num" id="LN4885">4885</td><td class="line">    <span class='comment'>/* if DECDPUN is 1 or 3 work in base 10**9, otherwise  */</span></td></tr>
<tr><td class="num" id="LN4886">4886</td><td class="line">    <span class='comment'>/* (DECDPUN is 2 or 4) then work in base 10**8  */</span></td></tr>
<tr><td class="num" id="LN4887">4887</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span> &amp; 1                /* odd  */</span></td></tr>
<tr><td class="num" id="LN4888">4888</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span> 1000000000  /* base  */</span></td></tr>
<tr><td class="num" id="LN4889">4889</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTDIGS<span class='expansion'>9</span></span>          9  /* digits in base  */</span></td></tr>
<tr><td class="num" id="LN4890">4890</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTLAZY<span class='expansion'>18</span></span>         18  /* carry resolution point [1-&gt;18]  */</span></td></tr>
<tr><td class="num" id="LN4891">4891</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN4892">4892</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>  100000000</span></td></tr>
<tr><td class="num" id="LN4893">4893</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTDIGS<span class='expansion'>9</span></span>          8</span></td></tr>
<tr><td class="num" id="LN4894">4894</td><td class="line">      <span class='directive'>#define <span class='macro'>FASTLAZY<span class='expansion'>18</span></span>       1844  /* carry resolution point [1-&gt;1844]  */</span></td></tr>
<tr><td class="num" id="LN4895">4895</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4896">4896</td><td class="line">    <span class='comment'>/* three buffers are used, two for chunked copies of the operands  */</span></td></tr>
<tr><td class="num" id="LN4897">4897</td><td class="line">    <span class='comment'>/* (base 10**8 or base 10**9) and one base 2**64 accumulator with  */</span></td></tr>
<tr><td class="num" id="LN4898">4898</td><td class="line">    <span class='comment'>/* lazy carry evaluation  */</span></td></tr>
<tr><td class="num" id="LN4899">4899</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>   zlhibuff[(<span class='macro'>DECBUFFER<span class='expansion'>36</span></span>*2+1)/8+1]; <span class='comment'>/* buffer (+1 for DECBUFFER==0)  */</span></td></tr>
<tr><td class="num" id="LN4900">4900</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *zlhi=zlhibuff;                 <span class='comment'>/* -&gt; lhs array  */</span></td></tr>
<tr><td class="num" id="LN4901">4901</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *alloclhi=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;                 <span class='comment'>/* -&gt; allocated buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4902">4902</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>   zrhibuff[(<span class='macro'>DECBUFFER<span class='expansion'>36</span></span>*2+1)/8+1]; <span class='comment'>/* buffer (+1 for DECBUFFER==0)  */</span></td></tr>
<tr><td class="num" id="LN4903">4903</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *zrhi=zrhibuff;                 <span class='comment'>/* -&gt; rhs array  */</span></td></tr>
<tr><td class="num" id="LN4904">4904</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *allocrhi=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;                 <span class='comment'>/* -&gt; allocated buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4905">4905</td><td class="line">    <span class='macro'>uLong<span class='expansion'>uint64_t</span></span>  zaccbuff[(<span class='macro'>DECBUFFER<span class='expansion'>36</span></span>*2+1)/4+2]; <span class='comment'>/* buffer (+1 for DECBUFFER==0)  */</span></td></tr>
<tr><td class="num" id="LN4906">4906</td><td class="line">    <span class='comment'>/* [allocacc is shared for both paths, as only one will run]  */</span></td></tr>
<tr><td class="num" id="LN4907">4907</td><td class="line">    <span class='macro'>uLong<span class='expansion'>uint64_t</span></span> *zacc=zaccbuff;          <span class='comment'>/* -&gt; accumulator array for exact result  */</span></td></tr>
<tr><td class="num" id="LN4908">4908</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1</span></td></tr>
<tr><td class="num" id="LN4909">4909</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>    zoff;                   <span class='comment'>/* accumulator offset  */</span></td></tr>
<tr><td class="num" id="LN4910">4910</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4911">4911</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *lip, *rip;              <span class='comment'>/* item pointers  */</span></td></tr>
<tr><td class="num" id="LN4912">4912</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  *lmsi, *rmsi;            <span class='comment'>/* most significant items  */</span></td></tr>
<tr><td class="num" id="LN4913">4913</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>    ilhs, irhs, iacc;       <span class='comment'>/* item counts in the arrays  */</span></td></tr>
<tr><td class="num" id="LN4914">4914</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>    lazy;                   <span class='comment'>/* lazy carry counter  */</span></td></tr>
<tr><td class="num" id="LN4915">4915</td><td class="line">    <span class='macro'>uLong<span class='expansion'>uint64_t</span></span>  lcarry;                 <span class='comment'>/* uLong carry  */</span></td></tr>
<tr><td class="num" id="LN4916">4916</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>   carry;                  <span class='comment'>/* carry (NB not uLong)  */</span></td></tr>
<tr><td class="num" id="LN4917">4917</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>    count;                  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN4918">4918</td><td class="line">    <span class='keyword'>const</span>  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *cup;              <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4919">4919</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *up;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4920">4920</td><td class="line">    <span class='macro'>uLong<span class='expansion'>uint64_t</span></span> *lp;                     <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4921">4921</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span>    p;                      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4922">4922</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4923">4923</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4924">4924</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4925">4925</td><td class="line">    decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;      <span class='comment'>/* -&gt; allocated buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4926">4926</td><td class="line">    decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;      <span class='comment'>/* -&gt; allocated buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN4927">4927</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4928">4928</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4929">4929</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4930">4930</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN4931">4931</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4932">4932</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4933">4933</td><td class="line">  <span class='comment'>/* precalculate result sign  */</span></td></tr>
<tr><td class="num" id="LN4934">4934</td><td class="line">  bits=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span>)((lhs-&gt;bits^rhs-&gt;bits)&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);</td></tr>
<tr><td class="num" id="LN4935">4935</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4936">4936</td><td class="line">  <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN4937">4937</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {               <span class='comment'>/* a special bit set  */</span></td></tr>
<tr><td class="num" id="LN4938">4938</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span> &amp; (<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span> | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>)) { <span class='comment'>/* one or two NaNs  */</span></td></tr>
<tr><td class="num" id="LN4939">4939</td><td class="line">      decNaNs(res, lhs, rhs, set, status);</td></tr>
<tr><td class="num" id="LN4940">4940</td><td class="line">      <span class='keyword'>return</span> res;}</td></tr>
<tr><td class="num" id="LN4941">4941</td><td class="line">    <span class='comment'>/* one or two infinities; Infinity * 0 is invalid  */</span></td></tr>
<tr><td class="num" id="LN4942">4942</td><td class="line">    <span class='keyword'>if</span> (((lhs-&gt;bits &amp; <span class='macro'>DECINF<span class='expansion'>0x40</span></span>)==0 &amp;&amp; <span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>)</td></tr>
<tr><td class="num" id="LN4943">4943</td><td class="line">      ||((rhs-&gt;bits &amp; <span class='macro'>DECINF<span class='expansion'>0x40</span></span>)==0 &amp;&amp; <span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>)) {</td></tr>
<tr><td class="num" id="LN4944">4944</td><td class="line">      *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN4945">4945</td><td class="line">      <span class='keyword'>return</span> res;}</td></tr>
<tr><td class="num" id="LN4946">4946</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN4947">4947</td><td class="line">    res-&gt;bits=bits|<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;         <span class='comment'>/* infinity  */</span></td></tr>
<tr><td class="num" id="LN4948">4948</td><td class="line">    <span class='keyword'>return</span> res;}</td></tr>
<tr><td class="num" id="LN4949">4949</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4950">4950</td><td class="line">  <span class='comment'>/* For best speed, as in DMSRCN [the original Rexx numerics  */</span></td></tr>
<tr><td class="num" id="LN4951">4951</td><td class="line">  <span class='comment'>/* module], use the shorter number as the multiplier (rhs) and  */</span></td></tr>
<tr><td class="num" id="LN4952">4952</td><td class="line">  <span class='comment'>/* the longer as the multiplicand (lhs) to minimise the number of  */</span></td></tr>
<tr><td class="num" id="LN4953">4953</td><td class="line">  <span class='comment'>/* adds (partial products)  */</span></td></tr>
<tr><td class="num" id="LN4954">4954</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;digits&lt;rhs-&gt;digits) {   <span class='comment'>/* swap...  */</span></td></tr>
<tr><td class="num" id="LN4955">4955</td><td class="line">    <span class='keyword'>const</span> decNumber *hold=lhs;</td></tr>
<tr><td class="num" id="LN4956">4956</td><td class="line">    lhs=rhs;</td></tr>
<tr><td class="num" id="LN4957">4957</td><td class="line">    rhs=hold;</td></tr>
<tr><td class="num" id="LN4958">4958</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN4959">4959</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4960">4960</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN4961">4961</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN4962">4962</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN4963">4963</td><td class="line">      <span class='comment'>/* reduce operands and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN4964">4964</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN4965">4965</td><td class="line">        alloclhs=decRoundOperand(lhs, set, status);</td></tr>
<tr><td class="num" id="LN4966">4966</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4967">4967</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN4968">4968</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4969">4969</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN4970">4970</td><td class="line">        allocrhs=decRoundOperand(rhs, set, status);</td></tr>
<tr><td class="num" id="LN4971">4971</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN4972">4972</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN4973">4973</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN4974">4974</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN4975">4975</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN4976">4976</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN4977">4977</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4978">4978</td><td class="line">    <span class='directive'>#if <span class='macro'>FASTMUL<span class='expansion'>(1 &amp;&amp; 1&lt;5)</span></span>                    /* fastpath can be used  */</span></td></tr>
<tr><td class="num" id="LN4979">4979</td><td class="line">    <span class='comment'>/* use the fast path if there are enough digits in the shorter  */</span></td></tr>
<tr><td class="num" id="LN4980">4980</td><td class="line">    <span class='comment'>/* operand to make the setup and takedown worthwhile  */</span></td></tr>
<tr><td class="num" id="LN4981">4981</td><td class="line">    <span class='directive'>#define <span class='macro'>NEEDTWO<span class='expansion'>(1*2)</span></span> (<span class='macro'>DECDPUN<span class='expansion'>1</span></span>*2)    /* within two decUnitAddSub calls  */</span></td></tr>
<tr><td class="num" id="LN4982">4982</td><td class="line">    <span class='keyword'>if</span> (rhs-&gt;digits&gt;<span class='macro'>NEEDTWO<span class='expansion'>(1*2)</span></span>) {     <span class='comment'>/* use fastpath...  */</span></td></tr>
<tr><td class="num" id="LN4983">4983</td><td class="line">      <span class='comment'>/* calculate the number of elements in each array  */</span></td></tr>
<tr><td class="num" id="LN4984">4984</td><td class="line">      ilhs=(lhs-&gt;digits+<span class='macro'>FASTDIGS<span class='expansion'>9</span></span>-1)/<span class='macro'>FASTDIGS<span class='expansion'>9</span></span>; <span class='comment'>/* [ceiling]  */</span></td></tr>
<tr><td class="num" id="LN4985">4985</td><td class="line">      irhs=(rhs-&gt;digits+<span class='macro'>FASTDIGS<span class='expansion'>9</span></span>-1)/<span class='macro'>FASTDIGS<span class='expansion'>9</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN4986">4986</td><td class="line">      iacc=ilhs+irhs;</td></tr>
<tr><td class="num" id="LN4987">4987</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4988">4988</td><td class="line">      <span class='comment'>/* allocate buffers if required, as usual  */</span></td></tr>
<tr><td class="num" id="LN4989">4989</td><td class="line">      needbytes=ilhs*<span class='keyword'>sizeof</span>(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>);</td></tr>
<tr><td class="num" id="LN4990">4990</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(zlhibuff)) {</td></tr>
<tr><td class="num" id="LN4991">4991</td><td class="line">        alloclhi=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN4992">4992</td><td class="line">        zlhi=alloclhi;}</td></tr>
<tr><td class="num" id="LN4993">4993</td><td class="line">      needbytes=irhs*<span class='keyword'>sizeof</span>(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>);</td></tr>
<tr><td class="num" id="LN4994">4994</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(zrhibuff)) {</td></tr>
<tr><td class="num" id="LN4995">4995</td><td class="line">        allocrhi=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN4996">4996</td><td class="line">        zrhi=allocrhi;}</td></tr>
<tr><td class="num" id="LN4997">4997</td><td class="line"> </td></tr>
<tr><td class="num" id="LN4998">4998</td><td class="line">      <span class='comment'>/* Allocating the accumulator space needs a special case when  */</span></td></tr>
<tr><td class="num" id="LN4999">4999</td><td class="line">      <span class='comment'>/* DECDPUN=1 because when converting the accumulator to Units  */</span></td></tr>
<tr><td class="num" id="LN5000">5000</td><td class="line">      <span class='comment'>/* after the multiplication each 8-byte item becomes 9 1-byte  */</span></td></tr>
<tr><td class="num" id="LN5001">5001</td><td class="line">      <span class='comment'>/* units.  Therefore iacc extra bytes are needed at the front  */</span></td></tr>
<tr><td class="num" id="LN5002">5002</td><td class="line">      <span class='comment'>/* (rounded up to a multiple of 8 bytes), and the uLong  */</span></td></tr>
<tr><td class="num" id="LN5003">5003</td><td class="line">      <span class='comment'>/* accumulator starts offset the appropriate number of units  */</span></td></tr>
<tr><td class="num" id="LN5004">5004</td><td class="line">      <span class='comment'>/* to the right to avoid overwrite during the unchunking.  */</span></td></tr>
<tr><td class="num" id="LN5005">5005</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5006">5006</td><td class="line">      <span class='comment'>/* Make sure no signed int overflow below. This is always true */</span></td></tr>
<tr><td class="num" id="LN5007">5007</td><td class="line">      <span class='comment'>/* if the given numbers have less digits than DEC_MAX_DIGITS. */</span></td></tr>
<tr><td class="num" id="LN5008">5008</td><td class="line">      U_ASSERT(iacc &lt;= INT32_MAX/<span class='keyword'>sizeof</span>(uLong));</td></tr>
<tr><td class="num" id="LN5009">5009</td><td class="line">      needbytes=iacc*<span class='keyword'>sizeof</span>(<span class='macro'>uLong<span class='expansion'>uint64_t</span></span>);</td></tr>
<tr><td class="num" id="LN5010">5010</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1</span></td></tr>
<tr><td class="num" id="LN5011">5011</td><td class="line">      zoff=(iacc+7)/8;        <span class='comment'>/* items to offset by  */</span></td></tr>
<tr><td class="num" id="LN5012">5012</td><td class="line">      needbytes+=zoff*8;</td></tr>
<tr><td class="num" id="LN5013">5013</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5014">5014</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(zaccbuff)) {</td></tr>
<tr><td class="num" id="LN5015">5015</td><td class="line">        allocacc=(<span class='macro'>uLong<span class='expansion'>uint64_t</span></span> *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5016">5016</td><td class="line">        zacc=(<span class='macro'>uLong<span class='expansion'>uint64_t</span></span> *)allocacc;}</td></tr>
<tr><td class="num" id="LN5017">5017</td><td class="line">      <span class='keyword'>if</span> (zlhi==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>||zrhi==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>||zacc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN5018">5018</td><td class="line">        *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5019">5019</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5020">5020</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5021">5021</td><td class="line">      acc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)zacc;       <span class='comment'>/* -&gt; target Unit array  */</span></td></tr>
<tr><td class="num" id="LN5022">5022</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1</span></td></tr>
<tr><td class="num" id="LN5023">5023</td><td class="line">      zacc+=zoff;             <span class='comment'>/* start uLong accumulator to right  */</span></td></tr>
<tr><td class="num" id="LN5024">5024</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5025">5025</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5026">5026</td><td class="line">      <span class='comment'>/* assemble the chunked copies of the left and right sides  */</span></td></tr>
<tr><td class="num" id="LN5027">5027</td><td class="line">      <span class='keyword'>for</span> (count=lhs-&gt;digits, cup=lhs-&gt;lsu, lip=zlhi; count&gt;0; lip++)</td></tr>
<tr><td class="num" id="LN5028">5028</td><td class="line">        <span class='keyword'>for</span> (p=0, *lip=0; p&lt;<span class='macro'>FASTDIGS<span class='expansion'>9</span></span> &amp;&amp; count&gt;0;</td></tr>
<tr><td class="num" id="LN5029">5029</td><td class="line">             p+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>, cup++, count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)</td></tr>
<tr><td class="num" id="LN5030">5030</td><td class="line">          *lip+=*cup*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[p];</td></tr>
<tr><td class="num" id="LN5031">5031</td><td class="line">      lmsi=lip-1;     <span class='comment'>/* save -&gt; msi  */</span></td></tr>
<tr><td class="num" id="LN5032">5032</td><td class="line">      <span class='keyword'>for</span> (count=rhs-&gt;digits, cup=rhs-&gt;lsu, rip=zrhi; count&gt;0; rip++)</td></tr>
<tr><td class="num" id="LN5033">5033</td><td class="line">        <span class='keyword'>for</span> (p=0, *rip=0; p&lt;<span class='macro'>FASTDIGS<span class='expansion'>9</span></span> &amp;&amp; count&gt;0;</td></tr>
<tr><td class="num" id="LN5034">5034</td><td class="line">             p+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>, cup++, count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)</td></tr>
<tr><td class="num" id="LN5035">5035</td><td class="line">          *rip+=*cup*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[p];</td></tr>
<tr><td class="num" id="LN5036">5036</td><td class="line">      rmsi=rip-1;     <span class='comment'>/* save -&gt; msi  */</span></td></tr>
<tr><td class="num" id="LN5037">5037</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5038">5038</td><td class="line">      <span class='comment'>/* zero the accumulator  */</span></td></tr>
<tr><td class="num" id="LN5039">5039</td><td class="line">      <span class='keyword'>for</span> (lp=zacc; lp&lt;zacc+iacc; lp++) *lp=0;</td></tr>
<tr><td class="num" id="LN5040">5040</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5041">5041</td><td class="line">      <span class='comment'>/* Start the multiplication */</span></td></tr>
<tr><td class="num" id="LN5042">5042</td><td class="line">      <span class='comment'>/* Resolving carries can dominate the cost of accumulating the  */</span></td></tr>
<tr><td class="num" id="LN5043">5043</td><td class="line">      <span class='comment'>/* partial products, so this is only done when necessary.  */</span></td></tr>
<tr><td class="num" id="LN5044">5044</td><td class="line">      <span class='comment'>/* Each uLong item in the accumulator can hold values up to  */</span></td></tr>
<tr><td class="num" id="LN5045">5045</td><td class="line">      <span class='comment'>/* 2**64-1, and each partial product can be as large as  */</span></td></tr>
<tr><td class="num" id="LN5046">5046</td><td class="line">      <span class='comment'>/* (10**FASTDIGS-1)**2.  When FASTDIGS=9, this can be added to  */</span></td></tr>
<tr><td class="num" id="LN5047">5047</td><td class="line">      <span class='comment'>/* itself 18.4 times in a uLong without overflowing, so during  */</span></td></tr>
<tr><td class="num" id="LN5048">5048</td><td class="line">      <span class='comment'>/* the main calculation resolution is carried out every 18th  */</span></td></tr>
<tr><td class="num" id="LN5049">5049</td><td class="line">      <span class='comment'>/* add -- every 162 digits.  Similarly, when FASTDIGS=8, the  */</span></td></tr>
<tr><td class="num" id="LN5050">5050</td><td class="line">      <span class='comment'>/* partial products can be added to themselves 1844.6 times in  */</span></td></tr>
<tr><td class="num" id="LN5051">5051</td><td class="line">      <span class='comment'>/* a uLong without overflowing, so intermediate carry  */</span></td></tr>
<tr><td class="num" id="LN5052">5052</td><td class="line">      <span class='comment'>/* resolution occurs only every 14752 digits.  Hence for common  */</span></td></tr>
<tr><td class="num" id="LN5053">5053</td><td class="line">      <span class='comment'>/* short numbers usually only the one final carry resolution  */</span></td></tr>
<tr><td class="num" id="LN5054">5054</td><td class="line">      <span class='comment'>/* occurs.  */</span></td></tr>
<tr><td class="num" id="LN5055">5055</td><td class="line">      <span class='comment'>/* (The count is set via FASTLAZY to simplify experiments to  */</span></td></tr>
<tr><td class="num" id="LN5056">5056</td><td class="line">      <span class='comment'>/* measure the value of this approach: a 35% improvement on a  */</span></td></tr>
<tr><td class="num" id="LN5057">5057</td><td class="line">      <span class='comment'>/* [34x34] multiply.)  */</span></td></tr>
<tr><td class="num" id="LN5058">5058</td><td class="line">      lazy=<span class='macro'>FASTLAZY<span class='expansion'>18</span></span>;                         <span class='comment'>/* carry delay count  */</span></td></tr>
<tr><td class="num" id="LN5059">5059</td><td class="line">      <span class='keyword'>for</span> (rip=zrhi; rip&lt;=rmsi; rip++) {     <span class='comment'>/* over each item in rhs  */</span></td></tr>
<tr><td class="num" id="LN5060">5060</td><td class="line">        lp=zacc+(rip-zrhi);                  <span class='comment'>/* where to add the lhs  */</span></td></tr>
<tr><td class="num" id="LN5061">5061</td><td class="line">        <span class='keyword'>for</span> (lip=zlhi; lip&lt;=lmsi; lip++, lp++) { <span class='comment'>/* over each item in lhs  */</span></td></tr>
<tr><td class="num" id="LN5062">5062</td><td class="line">          *lp+=(<span class='macro'>uLong<span class='expansion'>uint64_t</span></span>)(*lip)*(*rip);         <span class='comment'>/* [this should in-line]  */</span></td></tr>
<tr><td class="num" id="LN5063">5063</td><td class="line">          } <span class='comment'>/* lip loop  */</span></td></tr>
<tr><td class="num" id="LN5064">5064</td><td class="line">        lazy--;</td></tr>
<tr><td class="num" id="LN5065">5065</td><td class="line">        <span class='keyword'>if</span> (lazy&gt;0 &amp;&amp; rip!=rmsi) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN5066">5066</td><td class="line">        lazy=<span class='macro'>FASTLAZY<span class='expansion'>18</span></span>;                       <span class='comment'>/* reset delay count  */</span></td></tr>
<tr><td class="num" id="LN5067">5067</td><td class="line">        <span class='comment'>/* spin up the accumulator resolving overflows  */</span></td></tr>
<tr><td class="num" id="LN5068">5068</td><td class="line">        <span class='keyword'>for</span> (lp=zacc; lp&lt;zacc+iacc; lp++) {</td></tr>
<tr><td class="num" id="LN5069">5069</td><td class="line">          <span class='keyword'>if</span> (*lp&lt;<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>) <span class='keyword'>continue</span>;        <span class='comment'>/* it fits  */</span></td></tr>
<tr><td class="num" id="LN5070">5070</td><td class="line">          lcarry=*lp/<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>;               <span class='comment'>/* top part [slow divide]  */</span></td></tr>
<tr><td class="num" id="LN5071">5071</td><td class="line">          <span class='comment'>/* lcarry can exceed 2**32-1, so check again; this check  */</span></td></tr>
<tr><td class="num" id="LN5072">5072</td><td class="line">          <span class='comment'>/* and occasional extra divide (slow) is well worth it, as  */</span></td></tr>
<tr><td class="num" id="LN5073">5073</td><td class="line">          <span class='comment'>/* it allows FASTLAZY to be increased to 18 rather than 4  */</span></td></tr>
<tr><td class="num" id="LN5074">5074</td><td class="line">          <span class='comment'>/* in the FASTDIGS=9 case  */</span></td></tr>
<tr><td class="num" id="LN5075">5075</td><td class="line">          <span class='keyword'>if</span> (lcarry&lt;<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>) carry=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)lcarry;  <span class='comment'>/* [usual]  */</span></td></tr>
<tr><td class="num" id="LN5076">5076</td><td class="line">           <span class='keyword'>else</span> { <span class='comment'>/* two-place carry [fairly rare]  */</span></td></tr>
<tr><td class="num" id="LN5077">5077</td><td class="line">            <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> carry2=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)(lcarry/<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>);    <span class='comment'>/* top top part  */</span></td></tr>
<tr><td class="num" id="LN5078">5078</td><td class="line">            *(lp+2)+=carry2;                        <span class='comment'>/* add to item+2  */</span></td></tr>
<tr><td class="num" id="LN5079">5079</td><td class="line">            *lp-=((<span class='macro'>uLong<span class='expansion'>uint64_t</span></span>)<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>*<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>*carry2); <span class='comment'>/* [slow]  */</span></td></tr>
<tr><td class="num" id="LN5080">5080</td><td class="line">            carry=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)(lcarry-((<span class='macro'>uLong<span class='expansion'>uint64_t</span></span>)<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>*carry2)); <span class='comment'>/* [inline]  */</span></td></tr>
<tr><td class="num" id="LN5081">5081</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN5082">5082</td><td class="line">          *(lp+1)+=carry;                    <span class='comment'>/* add to item above [inline]  */</span></td></tr>
<tr><td class="num" id="LN5083">5083</td><td class="line">          *lp-=((<span class='macro'>uLong<span class='expansion'>uint64_t</span></span>)<span class='macro'>FASTBASE<span class='expansion'>1000000000</span></span>*carry);      <span class='comment'>/* [inline]  */</span></td></tr>
<tr><td class="num" id="LN5084">5084</td><td class="line">          } <span class='comment'>/* carry resolution  */</span></td></tr>
<tr><td class="num" id="LN5085">5085</td><td class="line">        } <span class='comment'>/* rip loop  */</span></td></tr>
<tr><td class="num" id="LN5086">5086</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5087">5087</td><td class="line">      <span class='comment'>/* The multiplication is complete; time to convert back into  */</span></td></tr>
<tr><td class="num" id="LN5088">5088</td><td class="line">      <span class='comment'>/* units.  This can be done in-place in the accumulator and in  */</span></td></tr>
<tr><td class="num" id="LN5089">5089</td><td class="line">      <span class='comment'>/* 32-bit operations, because carries were resolved after the  */</span></td></tr>
<tr><td class="num" id="LN5090">5090</td><td class="line">      <span class='comment'>/* final add.  This needs N-1 divides and multiplies for  */</span></td></tr>
<tr><td class="num" id="LN5091">5091</td><td class="line">      <span class='comment'>/* each item in the accumulator (which will become up to N  */</span></td></tr>
<tr><td class="num" id="LN5092">5092</td><td class="line">      <span class='comment'>/* units, where 2&lt;=N&lt;=9).  */</span></td></tr>
<tr><td class="num" id="LN5093">5093</td><td class="line">      <span class='keyword'>for</span> (lp=zacc, up=acc; lp&lt;zacc+iacc; lp++) {</td></tr>
<tr><td class="num" id="LN5094">5094</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> item=(<span class='macro'>uInt<span class='expansion'>uint32_t</span></span>)*lp;                 <span class='comment'>/* decapitate to uInt  */</span></td></tr>
<tr><td class="num" id="LN5095">5095</td><td class="line">        <span class='keyword'>for</span> (p=0; p&lt;<span class='macro'>FASTDIGS<span class='expansion'>9</span></span>-<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; p+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>, up++) {</td></tr>
<tr><td class="num" id="LN5096">5096</td><td class="line">          <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> part=item/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN5097">5097</td><td class="line">          *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(item-(part*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)));</td></tr>
<tr><td class="num" id="LN5098">5098</td><td class="line">          item=part;</td></tr>
<tr><td class="num" id="LN5099">5099</td><td class="line">          } <span class='comment'>/* p  */</span></td></tr>
<tr><td class="num" id="LN5100">5100</td><td class="line">        *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)item; up++;                <span class='comment'>/* [final needs no division]  */</span></td></tr>
<tr><td class="num" id="LN5101">5101</td><td class="line">        } <span class='comment'>/* lp  */</span></td></tr>
<tr><td class="num" id="LN5102">5102</td><td class="line">      accunits=up-acc;                       <span class='comment'>/* count of units  */</span></td></tr>
<tr><td class="num" id="LN5103">5103</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5104">5104</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* here to use units directly, without chunking ['old code']  */</span></td></tr>
<tr><td class="num" id="LN5105">5105</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5106">5106</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5107">5107</td><td class="line">      <span class='comment'>/* if accumulator will be too long for local storage, then allocate  */</span></td></tr>
<tr><td class="num" id="LN5108">5108</td><td class="line">      acc=accbuff;                 <span class='comment'>/* -&gt; assume buffer for accumulator  */</span></td></tr>
<tr><td class="num" id="LN5109">5109</td><td class="line">      needbytes=(<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5110">5110</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='keyword'>sizeof</span>(accbuff)) {</td></tr>
<tr><td class="num" id="LN5111">5111</td><td class="line">        allocacc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5112">5112</td><td class="line">        <span class='keyword'>if</span> (allocacc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {*status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>; <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5113">5113</td><td class="line">        acc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)allocacc;                <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5114">5114</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5115">5115</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5116">5116</td><td class="line">      <span class='comment'>/* Now the main long multiplication loop */</span></td></tr>
<tr><td class="num" id="LN5117">5117</td><td class="line">      <span class='comment'>/* Unlike the equivalent in the IBM Java implementation, there  */</span></td></tr>
<tr><td class="num" id="LN5118">5118</td><td class="line">      <span class='comment'>/* is no advantage in calculating from msu to lsu.  So, do it  */</span></td></tr>
<tr><td class="num" id="LN5119">5119</td><td class="line">      <span class='comment'>/* by the book, as it were.  */</span></td></tr>
<tr><td class="num" id="LN5120">5120</td><td class="line">      <span class='comment'>/* Each iteration calculates ACC=ACC+MULTAND*MULT  */</span></td></tr>
<tr><td class="num" id="LN5121">5121</td><td class="line">      accunits=1;                  <span class='comment'>/* accumulator starts at '0'  */</span></td></tr>
<tr><td class="num" id="LN5122">5122</td><td class="line">      *acc=0;                      <span class='comment'>/* .. (lsu=0)  */</span></td></tr>
<tr><td class="num" id="LN5123">5123</td><td class="line">      shift=0;                     <span class='comment'>/* no multiplicand shift at first  */</span></td></tr>
<tr><td class="num" id="LN5124">5124</td><td class="line">      madlength=<span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>;  <span class='comment'>/* this won't change  */</span></td></tr>
<tr><td class="num" id="LN5125">5125</td><td class="line">      mermsup=rhs-&gt;lsu+<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>; <span class='comment'>/* -&gt; msu+1 of multiplier  */</span></td></tr>
<tr><td class="num" id="LN5126">5126</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5127">5127</td><td class="line">      <span class='keyword'>for</span> (mer=rhs-&gt;lsu; mer&lt;mermsup; mer++) {</td></tr>
<tr><td class="num" id="LN5128">5128</td><td class="line">        <span class='comment'>/* Here, *mer is the next Unit in the multiplier to use  */</span></td></tr>
<tr><td class="num" id="LN5129">5129</td><td class="line">        <span class='comment'>/* If non-zero [optimization] add it...  */</span></td></tr>
<tr><td class="num" id="LN5130">5130</td><td class="line">        <span class='keyword'>if</span> (*mer!=0) accunits=decUnitAddSub(&amp;acc[shift], accunits-shift,</td></tr>
<tr><td class="num" id="LN5131">5131</td><td class="line">                                            lhs-&gt;lsu, madlength, 0,</td></tr>
<tr><td class="num" id="LN5132">5132</td><td class="line">                                            &amp;acc[shift], *mer)</td></tr>
<tr><td class="num" id="LN5133">5133</td><td class="line">                                            + shift;</td></tr>
<tr><td class="num" id="LN5134">5134</td><td class="line">         <span class='keyword'>else</span> { <span class='comment'>/* extend acc with a 0; it will be used shortly  */</span></td></tr>
<tr><td class="num" id="LN5135">5135</td><td class="line">          *(acc+accunits)=0;       <span class='comment'>/* [this avoids length of &lt;=0 later]  */</span></td></tr>
<tr><td class="num" id="LN5136">5136</td><td class="line">          accunits++;</td></tr>
<tr><td class="num" id="LN5137">5137</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5138">5138</td><td class="line">        <span class='comment'>/* multiply multiplicand by 10**DECDPUN for next Unit to left  */</span></td></tr>
<tr><td class="num" id="LN5139">5139</td><td class="line">        shift++;                   <span class='comment'>/* add this for 'logical length'  */</span></td></tr>
<tr><td class="num" id="LN5140">5140</td><td class="line">        } <span class='comment'>/* n  */</span></td></tr>
<tr><td class="num" id="LN5141">5141</td><td class="line">    <span class='directive'>#if <span class='macro'>FASTMUL<span class='expansion'>(1 &amp;&amp; 1&lt;5)</span></span></span></td></tr>
<tr><td class="num" id="LN5142">5142</td><td class="line">      } <span class='comment'>/* unchunked units  */</span></td></tr>
<tr><td class="num" id="LN5143">5143</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5144">5144</td><td class="line">    <span class='comment'>/* common end-path  */</span></td></tr>
<tr><td class="num" id="LN5145">5145</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5146">5146</td><td class="line">      decDumpAr('*', acc, accunits);         <span class='comment'>/* Show exact result  */</span></td></tr>
<tr><td class="num" id="LN5147">5147</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5148">5148</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5149">5149</td><td class="line">    <span class='comment'>/* acc now contains the exact result of the multiplication,  */</span></td></tr>
<tr><td class="num" id="LN5150">5150</td><td class="line">    <span class='comment'>/* possibly with a leading zero unit; build the decNumber from  */</span></td></tr>
<tr><td class="num" id="LN5151">5151</td><td class="line">    <span class='comment'>/* it, noting if any residue  */</span></td></tr>
<tr><td class="num" id="LN5152">5152</td><td class="line">    res-&gt;bits=bits;                          <span class='comment'>/* set sign  */</span></td></tr>
<tr><td class="num" id="LN5153">5153</td><td class="line">    res-&gt;digits=decGetDigits(acc, accunits); <span class='comment'>/* count digits exactly  */</span></td></tr>
<tr><td class="num" id="LN5154">5154</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5155">5155</td><td class="line">    <span class='comment'>/* There can be a 31-bit wrap in calculating the exponent.  */</span></td></tr>
<tr><td class="num" id="LN5156">5156</td><td class="line">    <span class='comment'>/* This can only happen if both input exponents are negative and  */</span></td></tr>
<tr><td class="num" id="LN5157">5157</td><td class="line">    <span class='comment'>/* both their magnitudes are large.  If there was a wrap, set a  */</span></td></tr>
<tr><td class="num" id="LN5158">5158</td><td class="line">    <span class='comment'>/* safe very negative exponent, from which decFinalize() will  */</span></td></tr>
<tr><td class="num" id="LN5159">5159</td><td class="line">    <span class='comment'>/* raise a hard underflow shortly.  */</span></td></tr>
<tr><td class="num" id="LN5160">5160</td><td class="line">    exponent=lhs-&gt;exponent+rhs-&gt;exponent;    <span class='comment'>/* calculate exponent  */</span></td></tr>
<tr><td class="num" id="LN5161">5161</td><td class="line">    <span class='keyword'>if</span> (lhs-&gt;exponent&lt;0 &amp;&amp; rhs-&gt;exponent&lt;0 &amp;&amp; exponent&gt;0)</td></tr>
<tr><td class="num" id="LN5162">5162</td><td class="line">      exponent=-2*<span class='macro'>DECNUMMAXE<span class='expansion'>999999999</span></span>;                <span class='comment'>/* force underflow  */</span></td></tr>
<tr><td class="num" id="LN5163">5163</td><td class="line">    res-&gt;exponent=exponent;                  <span class='comment'>/* OK to overwrite now  */</span></td></tr>
<tr><td class="num" id="LN5164">5164</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5165">5165</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5166">5166</td><td class="line">    <span class='comment'>/* Set the coefficient.  If any rounding, residue records  */</span></td></tr>
<tr><td class="num" id="LN5167">5167</td><td class="line">    decSetCoeff(res, set, acc, res-&gt;digits, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN5168">5168</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;   <span class='comment'>/* final cleanup  */</span></td></tr>
<tr><td class="num" id="LN5169">5169</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN5170">5170</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5171">5171</td><td class="line">  <span class='keyword'>if</span> (allocacc!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocacc)<span class='expansion'>uprv_free_54(allocacc)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN5172">5172</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5173">5173</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5174">5174</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5175">5175</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5176">5176</td><td class="line">  <span class='directive'>#if <span class='macro'>FASTMUL<span class='expansion'>(1 &amp;&amp; 1&lt;5)</span></span></span></td></tr>
<tr><td class="num" id="LN5177">5177</td><td class="line">  <span class='keyword'>if</span> (allocrhi!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhi)<span class='expansion'>uprv_free_54(allocrhi)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5178">5178</td><td class="line">  <span class='keyword'>if</span> (alloclhi!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhi)<span class='expansion'>uprv_free_54(alloclhi)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5179">5179</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5180">5180</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5181">5181</td><td class="line">  } <span class='comment'>/* decMultiplyOp  */</span></td></tr>
<tr><td class="num" id="LN5182">5182</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5183">5183</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5184">5184</td><td class="line"><span class='comment'>/* decExpOp -- effect exponentiation                                  */</span></td></tr>
<tr><td class="num" id="LN5185">5185</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5186">5186</td><td class="line"><span class='comment'>/*   This computes C = exp(A)                                         */</span></td></tr>
<tr><td class="num" id="LN5187">5187</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5188">5188</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN5189">5189</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN5190">5190</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN5191">5191</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5192">5192</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits. status is updated but    */</span></td></tr>
<tr><td class="num" id="LN5193">5193</td><td class="line"><span class='comment'>/* not set.                                                           */</span></td></tr>
<tr><td class="num" id="LN5194">5194</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5195">5195</td><td class="line"><span class='comment'>/* Restrictions:                                                      */</span></td></tr>
<tr><td class="num" id="LN5196">5196</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5197">5197</td><td class="line"><span class='comment'>/*   digits, emax, and -emin in the context must be less than         */</span></td></tr>
<tr><td class="num" id="LN5198">5198</td><td class="line"><span class='comment'>/*   2*DEC_MAX_MATH (1999998), and the rhs must be within these       */</span></td></tr>
<tr><td class="num" id="LN5199">5199</td><td class="line"><span class='comment'>/*   bounds or a zero.  This is an internal routine, so these         */</span></td></tr>
<tr><td class="num" id="LN5200">5200</td><td class="line"><span class='comment'>/*   restrictions are contractual and not enforced.                   */</span></td></tr>
<tr><td class="num" id="LN5201">5201</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5202">5202</td><td class="line"><span class='comment'>/* A finite result is rounded using DEC_ROUND_HALF_EVEN; it will      */</span></td></tr>
<tr><td class="num" id="LN5203">5203</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN5204">5204</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN5205">5205</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5206">5206</td><td class="line"><span class='comment'>/* Finite results will always be full precision and Inexact, except   */</span></td></tr>
<tr><td class="num" id="LN5207">5207</td><td class="line"><span class='comment'>/* when A is a zero or -Infinity (giving 1 or 0 respectively).        */</span></td></tr>
<tr><td class="num" id="LN5208">5208</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5209">5209</td><td class="line"><span class='comment'>/* This approach used here is similar to the algorithm described in   */</span></td></tr>
<tr><td class="num" id="LN5210">5210</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5211">5211</td><td class="line"><span class='comment'>/*   Variable Precision Exponential Function, T. E. Hull and          */</span></td></tr>
<tr><td class="num" id="LN5212">5212</td><td class="line"><span class='comment'>/*   A. Abrham, ACM Transactions on Mathematical Software, Vol 12 #2, */</span></td></tr>
<tr><td class="num" id="LN5213">5213</td><td class="line"><span class='comment'>/*   pp79-91, ACM, June 1986.                                         */</span></td></tr>
<tr><td class="num" id="LN5214">5214</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5215">5215</td><td class="line"><span class='comment'>/* with the main difference being that the iterations in the series   */</span></td></tr>
<tr><td class="num" id="LN5216">5216</td><td class="line"><span class='comment'>/* evaluation are terminated dynamically (which does not require the  */</span></td></tr>
<tr><td class="num" id="LN5217">5217</td><td class="line"><span class='comment'>/* extra variable-precision variables which are expensive in this     */</span></td></tr>
<tr><td class="num" id="LN5218">5218</td><td class="line"><span class='comment'>/* context).                                                          */</span></td></tr>
<tr><td class="num" id="LN5219">5219</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5220">5220</td><td class="line"><span class='comment'>/* The error analysis in Hull &amp; Abrham's paper applies except for the */</span></td></tr>
<tr><td class="num" id="LN5221">5221</td><td class="line"><span class='comment'>/* round-off error accumulation during the series evaluation.  This   */</span></td></tr>
<tr><td class="num" id="LN5222">5222</td><td class="line"><span class='comment'>/* code does not precalculate the number of iterations and so cannot  */</span></td></tr>
<tr><td class="num" id="LN5223">5223</td><td class="line"><span class='comment'>/* use Horner's scheme.  Instead, the accumulation is done at double- */</span></td></tr>
<tr><td class="num" id="LN5224">5224</td><td class="line"><span class='comment'>/* precision, which ensures that the additions of the terms are exact */</span></td></tr>
<tr><td class="num" id="LN5225">5225</td><td class="line"><span class='comment'>/* and do not accumulate round-off (and any round-off errors in the   */</span></td></tr>
<tr><td class="num" id="LN5226">5226</td><td class="line"><span class='comment'>/* terms themselves move 'to the right' faster than they can          */</span></td></tr>
<tr><td class="num" id="LN5227">5227</td><td class="line"><span class='comment'>/* accumulate).  This code also extends the calculation by allowing,  */</span></td></tr>
<tr><td class="num" id="LN5228">5228</td><td class="line"><span class='comment'>/* in the spirit of other decNumber operators, the input to be more   */</span></td></tr>
<tr><td class="num" id="LN5229">5229</td><td class="line"><span class='comment'>/* precise than the result (the precision used is based on the more   */</span></td></tr>
<tr><td class="num" id="LN5230">5230</td><td class="line"><span class='comment'>/* precise of the input or requested result).                         */</span></td></tr>
<tr><td class="num" id="LN5231">5231</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5232">5232</td><td class="line"><span class='comment'>/* Implementation notes:                                              */</span></td></tr>
<tr><td class="num" id="LN5233">5233</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5234">5234</td><td class="line"><span class='comment'>/* 1. This is separated out as decExpOp so it can be called from      */</span></td></tr>
<tr><td class="num" id="LN5235">5235</td><td class="line"><span class='comment'>/*    other Mathematical functions (notably Ln) with a wider range    */</span></td></tr>
<tr><td class="num" id="LN5236">5236</td><td class="line"><span class='comment'>/*    than normal.  In particular, it can handle the slightly wider   */</span></td></tr>
<tr><td class="num" id="LN5237">5237</td><td class="line"><span class='comment'>/*    (double) range needed by Ln (which has to be able to calculate  */</span></td></tr>
<tr><td class="num" id="LN5238">5238</td><td class="line"><span class='comment'>/*    exp(-x) where x can be the tiniest number (Ntiny).              */</span></td></tr>
<tr><td class="num" id="LN5239">5239</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5240">5240</td><td class="line"><span class='comment'>/* 2. Normalizing x to be &lt;=0.1 (instead of &lt;=1) reduces loop         */</span></td></tr>
<tr><td class="num" id="LN5241">5241</td><td class="line"><span class='comment'>/*    iterations by appoximately a third with additional (although    */</span></td></tr>
<tr><td class="num" id="LN5242">5242</td><td class="line"><span class='comment'>/*    diminishing) returns as the range is reduced to even smaller    */</span></td></tr>
<tr><td class="num" id="LN5243">5243</td><td class="line"><span class='comment'>/*    fractions.  However, h (the power of 10 used to correct the     */</span></td></tr>
<tr><td class="num" id="LN5244">5244</td><td class="line"><span class='comment'>/*    result at the end, see below) must be kept &lt;=8 as otherwise     */</span></td></tr>
<tr><td class="num" id="LN5245">5245</td><td class="line"><span class='comment'>/*    the final result cannot be computed.  Hence the leverage is a   */</span></td></tr>
<tr><td class="num" id="LN5246">5246</td><td class="line"><span class='comment'>/*    sliding value (8-h), where potentially the range is reduced     */</span></td></tr>
<tr><td class="num" id="LN5247">5247</td><td class="line"><span class='comment'>/*    more for smaller values.                                        */</span></td></tr>
<tr><td class="num" id="LN5248">5248</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5249">5249</td><td class="line"><span class='comment'>/*    The leverage that can be applied in this way is severely        */</span></td></tr>
<tr><td class="num" id="LN5250">5250</td><td class="line"><span class='comment'>/*    limited by the cost of the raise-to-the power at the end,       */</span></td></tr>
<tr><td class="num" id="LN5251">5251</td><td class="line"><span class='comment'>/*    which dominates when the number of iterations is small (less    */</span></td></tr>
<tr><td class="num" id="LN5252">5252</td><td class="line"><span class='comment'>/*    than ten) or when rhs is short.  As an example, the adjustment  */</span></td></tr>
<tr><td class="num" id="LN5253">5253</td><td class="line"><span class='comment'>/*    x**10,000,000 needs 31 multiplications, all but one full-width. */</span></td></tr>
<tr><td class="num" id="LN5254">5254</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5255">5255</td><td class="line"><span class='comment'>/* 3. The restrictions (especially precision) could be raised with    */</span></td></tr>
<tr><td class="num" id="LN5256">5256</td><td class="line"><span class='comment'>/*    care, but the full decNumber range seems very hard within the   */</span></td></tr>
<tr><td class="num" id="LN5257">5257</td><td class="line"><span class='comment'>/*    32-bit limits.                                                  */</span></td></tr>
<tr><td class="num" id="LN5258">5258</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5259">5259</td><td class="line"><span class='comment'>/* 4. The working precisions for the static buffers are twice the     */</span></td></tr>
<tr><td class="num" id="LN5260">5260</td><td class="line"><span class='comment'>/*    obvious size to allow for calls from decNumberPower.            */</span></td></tr>
<tr><td class="num" id="LN5261">5261</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5262">5262</td><td class="line">decNumber * decExpOp(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN5263">5263</td><td class="line">                         decContext *set, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN5264">5264</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> ignore=0;                   <span class='comment'>/* working status  */</span></td></tr>
<tr><td class="num" id="LN5265">5265</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> h;                           <span class='comment'>/* adjusted exponent for 0.xxxx  */</span></td></tr>
<tr><td class="num" id="LN5266">5266</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> p;                           <span class='comment'>/* working precision  */</span></td></tr>
<tr><td class="num" id="LN5267">5267</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> residue;                     <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN5268">5268</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> needbytes;                  <span class='comment'>/* for space calculations  */</span></td></tr>
<tr><td class="num" id="LN5269">5269</td><td class="line">  <span class='keyword'>const</span> decNumber *x=rhs;          <span class='comment'>/* (may point to safe copy later)  */</span></td></tr>
<tr><td class="num" id="LN5270">5270</td><td class="line">  decContext aset, tset, dset;     <span class='comment'>/* working contexts  */</span></td></tr>
<tr><td class="num" id="LN5271">5271</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> comp;                        <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN5272">5272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5273">5273</td><td class="line">  <span class='comment'>/* the argument is often copied to normalize it, so (unusually) it  */</span></td></tr>
<tr><td class="num" id="LN5274">5274</td><td class="line">  <span class='comment'>/* is treated like other buffers, using DECBUFFER, +1 in case  */</span></td></tr>
<tr><td class="num" id="LN5275">5275</td><td class="line">  <span class='comment'>/* DECBUFFER is 0  */</span></td></tr>
<tr><td class="num" id="LN5276">5276</td><td class="line">  decNumber bufr[<span class='macro'>D2N(DECBUFFER*2+1)<span class='expansion'>(((((((36*2+1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)<br>*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5277">5277</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rhs buffer allocated  */</span></td></tr>
<tr><td class="num" id="LN5278">5278</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5279">5279</td><td class="line">  <span class='comment'>/* the working precision will be no more than set-&gt;digits+8+1  */</span></td></tr>
<tr><td class="num" id="LN5280">5280</td><td class="line">  <span class='comment'>/* so for on-stack buffers DECBUFFER+9 is used, +1 in case DECBUFFER  */</span></td></tr>
<tr><td class="num" id="LN5281">5281</td><td class="line">  <span class='comment'>/* is 0 (and twice that for the accumulator)  */</span></td></tr>
<tr><td class="num" id="LN5282">5282</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5283">5283</td><td class="line">  <span class='comment'>/* buffer for t, term (working precision plus)  */</span></td></tr>
<tr><td class="num" id="LN5284">5284</td><td class="line">  decNumber buft[<span class='macro'>D2N(DECBUFFER*2+9+1)<span class='expansion'>(((((((36*2+9+1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber<br>)*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5285">5285</td><td class="line">  decNumber *allocbuft=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated buft, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN5286">5286</td><td class="line">  decNumber *t=buft;               <span class='comment'>/* term  */</span></td></tr>
<tr><td class="num" id="LN5287">5287</td><td class="line">  <span class='comment'>/* buffer for a, accumulator (working precision * 2), at least 9  */</span></td></tr>
<tr><td class="num" id="LN5288">5288</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER*4+18+1)<span class='expansion'>(((((((36*4+18+1)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber<br>)*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5289">5289</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN5290">5290</td><td class="line">  decNumber *a=bufa;               <span class='comment'>/* accumulator  */</span></td></tr>
<tr><td class="num" id="LN5291">5291</td><td class="line">  <span class='comment'>/* decNumber for the divisor term; this needs at most 9 digits  */</span></td></tr>
<tr><td class="num" id="LN5292">5292</td><td class="line">  <span class='comment'>/* and so can be fixed size [16 so can use standard context]  */</span></td></tr>
<tr><td class="num" id="LN5293">5293</td><td class="line">  decNumber bufd[<span class='macro'>D2N(16)<span class='expansion'>(((((((16)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)*2-1<br>)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5294">5294</td><td class="line">  decNumber *d=bufd;               <span class='comment'>/* divisor  */</span></td></tr>
<tr><td class="num" id="LN5295">5295</td><td class="line">  decNumber numone;                <span class='comment'>/* constant 1  */</span></td></tr>
<tr><td class="num" id="LN5296">5296</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5297">5297</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5298">5298</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> iterations=0;                <span class='comment'>/* for later sanity check  */</span></td></tr>
<tr><td class="num" id="LN5299">5299</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5300">5300</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5301">5301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5302">5302</td><td class="line">  <span class='keyword'>do</span> {                                  <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN5303">5303</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARG<span class='expansion'>(rhs-&gt;bits &amp; (0x40|0x20|0x10))</span></span>) {                   <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN5304">5304</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) {   <span class='comment'>/* an infinity  */</span></td></tr>
<tr><td class="num" id="LN5305">5305</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>)   <span class='comment'>/* -Infinity -&gt; +0  */</span></td></tr>
<tr><td class="num" id="LN5306">5306</td><td class="line">          <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN5307">5307</td><td class="line">         <span class='keyword'>else</span> <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);  <span class='comment'>/* +Infinity -&gt; self  */</span></td></tr>
<tr><td class="num" id="LN5308">5308</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5309">5309</td><td class="line">       <span class='keyword'>else</span> decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, status); <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN5310">5310</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5311">5311</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5312">5312</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                  <span class='comment'>/* zeros -&gt; exact 1  */</span></td></tr>
<tr><td class="num" id="LN5313">5313</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);               <span class='comment'>/* make clean 1  */</span></td></tr>
<tr><td class="num" id="LN5314">5314</td><td class="line">      *res-&gt;lsu=1;                      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5315">5315</td><td class="line">      <span class='keyword'>break</span>;}                           <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN5316">5316</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5317">5317</td><td class="line">    <span class='comment'>/* e**x when 0 &lt; x &lt; 0.66 is &lt; 1+3x/2, hence can fast-path  */</span></td></tr>
<tr><td class="num" id="LN5318">5318</td><td class="line">    <span class='comment'>/* positive and negative tiny cases which will result in inexact  */</span></td></tr>
<tr><td class="num" id="LN5319">5319</td><td class="line">    <span class='comment'>/* 1.  This also allows the later add-accumulate to always be  */</span></td></tr>
<tr><td class="num" id="LN5320">5320</td><td class="line">    <span class='comment'>/* exact (because its length will never be more than twice the  */</span></td></tr>
<tr><td class="num" id="LN5321">5321</td><td class="line">    <span class='comment'>/* working precision).  */</span></td></tr>
<tr><td class="num" id="LN5322">5322</td><td class="line">    <span class='comment'>/* The comparator (tiny) needs just one digit, so use the  */</span></td></tr>
<tr><td class="num" id="LN5323">5323</td><td class="line">    <span class='comment'>/* decNumber d for it (reused as the divisor, etc., below); its  */</span></td></tr>
<tr><td class="num" id="LN5324">5324</td><td class="line">    <span class='comment'>/* exponent is such that if x is positive it will have  */</span></td></tr>
<tr><td class="num" id="LN5325">5325</td><td class="line">    <span class='comment'>/* set-&gt;digits-1 zeros between the decimal point and the digit,  */</span></td></tr>
<tr><td class="num" id="LN5326">5326</td><td class="line">    <span class='comment'>/* which is 4, and if x is negative one more zero there as the  */</span></td></tr>
<tr><td class="num" id="LN5327">5327</td><td class="line">    <span class='comment'>/* more precise result will be of the form 0.9999999 rather than  */</span></td></tr>
<tr><td class="num" id="LN5328">5328</td><td class="line">    <span class='comment'>/* 1.0000001.  Hence, tiny will be 0.0000004  if digits=7 and x&gt;0  */</span></td></tr>
<tr><td class="num" id="LN5329">5329</td><td class="line">    <span class='comment'>/* or 0.00000004 if digits=7 and x&lt;0.  If RHS not larger than  */</span></td></tr>
<tr><td class="num" id="LN5330">5330</td><td class="line">    <span class='comment'>/* this then the result will be 1.000000  */</span></td></tr>
<tr><td class="num" id="LN5331">5331</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(d);                   <span class='comment'>/* clean  */</span></td></tr>
<tr><td class="num" id="LN5332">5332</td><td class="line">    *d-&gt;lsu=4;                          <span class='comment'>/* set 4 ..  */</span></td></tr>
<tr><td class="num" id="LN5333">5333</td><td class="line">    d-&gt;exponent=-set-&gt;digits;           <span class='comment'>/* * 10**(-d)  */</span></td></tr>
<tr><td class="num" id="LN5334">5334</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) d-&gt;exponent--;  <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN5335">5335</td><td class="line">    comp=decCompare(d, rhs, 1);         <span class='comment'>/* signless compare  */</span></td></tr>
<tr><td class="num" id="LN5336">5336</td><td class="line">    <span class='keyword'>if</span> (comp==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) {</td></tr>
<tr><td class="num" id="LN5337">5337</td><td class="line">      *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5338">5338</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5339">5339</td><td class="line">    <span class='keyword'>if</span> (comp&gt;=0) {                      <span class='comment'>/* rhs &lt; d  */</span></td></tr>
<tr><td class="num" id="LN5340">5340</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift=set-&gt;digits-1;</td></tr>
<tr><td class="num" id="LN5341">5341</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);               <span class='comment'>/* set 1  */</span></td></tr>
<tr><td class="num" id="LN5342">5342</td><td class="line">      *res-&gt;lsu=1;                      <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5343">5343</td><td class="line">      res-&gt;digits=decShiftToMost(res-&gt;lsu, 1, shift);</td></tr>
<tr><td class="num" id="LN5344">5344</td><td class="line">      res-&gt;exponent=-shift;                  <span class='comment'>/* make 1.0000...  */</span></td></tr>
<tr><td class="num" id="LN5345">5345</td><td class="line">      *status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;    <span class='comment'>/* .. inexactly  */</span></td></tr>
<tr><td class="num" id="LN5346">5346</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* tiny  */</span></td></tr>
<tr><td class="num" id="LN5347">5347</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5348">5348</td><td class="line">    <span class='comment'>/* set up the context to be used for calculating a, as this is  */</span></td></tr>
<tr><td class="num" id="LN5349">5349</td><td class="line">    <span class='comment'>/* used on both paths below  */</span></td></tr>
<tr><td class="num" id="LN5350">5350</td><td class="line">    <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;aset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>);</td></tr>
<tr><td class="num" id="LN5351">5351</td><td class="line">    <span class='comment'>/* accumulator bounds are as requested (could underflow)  */</span></td></tr>
<tr><td class="num" id="LN5352">5352</td><td class="line">    aset.emax=set-&gt;emax;                <span class='comment'>/* usual bounds  */</span></td></tr>
<tr><td class="num" id="LN5353">5353</td><td class="line">    aset.emin=set-&gt;emin;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5354">5354</td><td class="line">    aset.clamp=0;                       <span class='comment'>/* and no concrete format  */</span></td></tr>
<tr><td class="num" id="LN5355">5355</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5356">5356</td><td class="line">    <span class='comment'>/* calculate the adjusted (Hull &amp; Abrham) exponent (where the  */</span></td></tr>
<tr><td class="num" id="LN5357">5357</td><td class="line">    <span class='comment'>/* decimal point is just to the left of the coefficient msd)  */</span></td></tr>
<tr><td class="num" id="LN5358">5358</td><td class="line">    h=rhs-&gt;exponent+rhs-&gt;digits;</td></tr>
<tr><td class="num" id="LN5359">5359</td><td class="line">    <span class='comment'>/* if h&gt;8 then 10**h cannot be calculated safely; however, when  */</span></td></tr>
<tr><td class="num" id="LN5360">5360</td><td class="line">    <span class='comment'>/* h=8 then exp(|rhs|) will be at least exp(1E+7) which is at  */</span></td></tr>
<tr><td class="num" id="LN5361">5361</td><td class="line">    <span class='comment'>/* least 6.59E+4342944, so (due to the restriction on Emax/Emin)  */</span></td></tr>
<tr><td class="num" id="LN5362">5362</td><td class="line">    <span class='comment'>/* overflow (or underflow to 0) is guaranteed -- so this case can  */</span></td></tr>
<tr><td class="num" id="LN5363">5363</td><td class="line">    <span class='comment'>/* be handled by simply forcing the appropriate excess  */</span></td></tr>
<tr><td class="num" id="LN5364">5364</td><td class="line">    <span class='keyword'>if</span> (h&gt;8) {                          <span class='comment'>/* overflow/underflow  */</span></td></tr>
<tr><td class="num" id="LN5365">5365</td><td class="line">      <span class='comment'>/* set up here so Power call below will over or underflow to  */</span></td></tr>
<tr><td class="num" id="LN5366">5366</td><td class="line">      <span class='comment'>/* zero; set accumulator to either 2 or 0.02  */</span></td></tr>
<tr><td class="num" id="LN5367">5367</td><td class="line">      <span class='comment'>/* [stack buffer for a is always big enough for this]  */</span></td></tr>
<tr><td class="num" id="LN5368">5368</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(a);</td></tr>
<tr><td class="num" id="LN5369">5369</td><td class="line">      *a-&gt;lsu=2;                        <span class='comment'>/* not 1 but &lt; exp(1)  */</span></td></tr>
<tr><td class="num" id="LN5370">5370</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) a-&gt;exponent=-2; <span class='comment'>/* make 0.02  */</span></td></tr>
<tr><td class="num" id="LN5371">5371</td><td class="line">      h=8;                              <span class='comment'>/* clamp so 10**h computable  */</span></td></tr>
<tr><td class="num" id="LN5372">5372</td><td class="line">      p=9;                              <span class='comment'>/* set a working precision  */</span></td></tr>
<tr><td class="num" id="LN5373">5373</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5374">5374</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* h&lt;=8  */</span></td></tr>
<tr><td class="num" id="LN5375">5375</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> maxlever=(rhs-&gt;digits&gt;8?1:0);</td></tr>
<tr><td class="num" id="LN5376">5376</td><td class="line">      <span class='comment'>/* [could/should increase this for precisions &gt;40 or so, too]  */</span></td></tr>
<tr><td class="num" id="LN5377">5377</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5378">5378</td><td class="line">      <span class='comment'>/* if h is 8, cannot normalize to a lower upper limit because  */</span></td></tr>
<tr><td class="num" id="LN5379">5379</td><td class="line">      <span class='comment'>/* the final result will not be computable (see notes above),  */</span></td></tr>
<tr><td class="num" id="LN5380">5380</td><td class="line">      <span class='comment'>/* but leverage can be applied whenever h is less than 8.  */</span></td></tr>
<tr><td class="num" id="LN5381">5381</td><td class="line">      <span class='comment'>/* Apply as much as possible, up to a MAXLEVER digits, which  */</span></td></tr>
<tr><td class="num" id="LN5382">5382</td><td class="line">      <span class='comment'>/* sets the tradeoff against the cost of the later a**(10**h).  */</span></td></tr>
<tr><td class="num" id="LN5383">5383</td><td class="line">      <span class='comment'>/* As h is increased, the working precision below also  */</span></td></tr>
<tr><td class="num" id="LN5384">5384</td><td class="line">      <span class='comment'>/* increases to compensate for the "constant digits at the  */</span></td></tr>
<tr><td class="num" id="LN5385">5385</td><td class="line">      <span class='comment'>/* front" effect.  */</span></td></tr>
<tr><td class="num" id="LN5386">5386</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> lever=<span class='macro'>MINI(8-h, maxlever)<span class='expansion'>((8-h)&gt;(maxlever)?(maxlever):(8-h))</span></span>;    <span class='comment'>/* leverage attainable  */</span></td></tr>
<tr><td class="num" id="LN5387">5387</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> use=-rhs-&gt;digits-lever;       <span class='comment'>/* exponent to use for RHS  */</span></td></tr>
<tr><td class="num" id="LN5388">5388</td><td class="line">      h+=lever;                         <span class='comment'>/* apply leverage selected  */</span></td></tr>
<tr><td class="num" id="LN5389">5389</td><td class="line">      <span class='keyword'>if</span> (h&lt;0) {                        <span class='comment'>/* clamp  */</span></td></tr>
<tr><td class="num" id="LN5390">5390</td><td class="line">        use+=h;                         <span class='comment'>/* [may end up subnormal]  */</span></td></tr>
<tr><td class="num" id="LN5391">5391</td><td class="line">        h=0;</td></tr>
<tr><td class="num" id="LN5392">5392</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5393">5393</td><td class="line">      <span class='comment'>/* Take a copy of RHS if it needs normalization (true whenever x&gt;=1)  */</span></td></tr>
<tr><td class="num" id="LN5394">5394</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;exponent!=use) {</td></tr>
<tr><td class="num" id="LN5395">5395</td><td class="line">        decNumber *newrhs=bufr;         <span class='comment'>/* assume will fit on stack  */</span></td></tr>
<tr><td class="num" id="LN5396">5396</td><td class="line">        needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5397">5397</td><td class="line">        <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufr)) {   <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN5398">5398</td><td class="line">          allocrhs=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5399">5399</td><td class="line">          <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {         <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN5400">5400</td><td class="line">            *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5401">5401</td><td class="line">            <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5402">5402</td><td class="line">          newrhs=allocrhs;              <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5403">5403</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5404">5404</td><td class="line">        <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(newrhs, rhs);     <span class='comment'>/* copy to safe space  */</span></td></tr>
<tr><td class="num" id="LN5405">5405</td><td class="line">        newrhs-&gt;exponent=use;           <span class='comment'>/* normalize; now &lt;1  */</span></td></tr>
<tr><td class="num" id="LN5406">5406</td><td class="line">        x=newrhs;                       <span class='comment'>/* ready for use  */</span></td></tr>
<tr><td class="num" id="LN5407">5407</td><td class="line">        <span class='comment'>/* decNumberShow(x);  */</span></td></tr>
<tr><td class="num" id="LN5408">5408</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5409">5409</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5410">5410</td><td class="line">      <span class='comment'>/* Now use the usual power series to evaluate exp(x).  The  */</span></td></tr>
<tr><td class="num" id="LN5411">5411</td><td class="line">      <span class='comment'>/* series starts as 1 + x + x^2/2 ... so prime ready for the  */</span></td></tr>
<tr><td class="num" id="LN5412">5412</td><td class="line">      <span class='comment'>/* third term by setting the term variable t=x, the accumulator  */</span></td></tr>
<tr><td class="num" id="LN5413">5413</td><td class="line">      <span class='comment'>/* a=1, and the divisor d=2.  */</span></td></tr>
<tr><td class="num" id="LN5414">5414</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5415">5415</td><td class="line">      <span class='comment'>/* First determine the working precision.  From Hull &amp; Abrham  */</span></td></tr>
<tr><td class="num" id="LN5416">5416</td><td class="line">      <span class='comment'>/* this is set-&gt;digits+h+2.  However, if x is 'over-precise' we  */</span></td></tr>
<tr><td class="num" id="LN5417">5417</td><td class="line">      <span class='comment'>/* need to allow for all its digits to potentially participate  */</span></td></tr>
<tr><td class="num" id="LN5418">5418</td><td class="line">      <span class='comment'>/* (consider an x where all the excess digits are 9s) so in  */</span></td></tr>
<tr><td class="num" id="LN5419">5419</td><td class="line">      <span class='comment'>/* this case use x-&gt;digits+h+2  */</span></td></tr>
<tr><td class="num" id="LN5420">5420</td><td class="line">      p=<span class='macro'>MAXI(x-&gt;digits, set-&gt;digits)<span class='expansion'>((x-&gt;digits)&lt;(set-&gt;digits)?(set-&gt;digits):(x-&gt;digits<br>))</span></span>+h+2;    <span class='comment'>/* [h&lt;=8]  */</span></td></tr>
<tr><td class="num" id="LN5421">5421</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5422">5422</td><td class="line">      <span class='comment'>/* a and t are variable precision, and depend on p, so space  */</span></td></tr>
<tr><td class="num" id="LN5423">5423</td><td class="line">      <span class='comment'>/* must be allocated for them if necessary  */</span></td></tr>
<tr><td class="num" id="LN5424">5424</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5425">5425</td><td class="line">      <span class='comment'>/* the accumulator needs to be able to hold 2p digits so that  */</span></td></tr>
<tr><td class="num" id="LN5426">5426</td><td class="line">      <span class='comment'>/* the additions on the second and subsequent iterations are  */</span></td></tr>
<tr><td class="num" id="LN5427">5427</td><td class="line">      <span class='comment'>/* sufficiently exact.  */</span></td></tr>
<tr><td class="num" id="LN5428">5428</td><td class="line">      needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(p*2)<span class='expansion'>((p*2)&lt;=49?d2utable[p*2]:((p*2)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5429">5429</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufa)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN5430">5430</td><td class="line">        allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5431">5431</td><td class="line">        <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN5432">5432</td><td class="line">          *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5433">5433</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5434">5434</td><td class="line">        a=allocbufa;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5435">5435</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5436">5436</td><td class="line">      <span class='comment'>/* the term needs to be able to hold p digits (which is  */</span></td></tr>
<tr><td class="num" id="LN5437">5437</td><td class="line">      <span class='comment'>/* guaranteed to be larger than x-&gt;digits, so the initial copy  */</span></td></tr>
<tr><td class="num" id="LN5438">5438</td><td class="line">      <span class='comment'>/* is safe); it may also be used for the raise-to-power  */</span></td></tr>
<tr><td class="num" id="LN5439">5439</td><td class="line">      <span class='comment'>/* calculation below, which needs an extra two digits  */</span></td></tr>
<tr><td class="num" id="LN5440">5440</td><td class="line">      needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(p+2)<span class='expansion'>((p+2)&lt;=49?d2utable[p+2]:((p+2)+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5441">5441</td><td class="line">      <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(buft)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN5442">5442</td><td class="line">        allocbuft=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5443">5443</td><td class="line">        <span class='keyword'>if</span> (allocbuft==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN5444">5444</td><td class="line">          *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5445">5445</td><td class="line">          <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5446">5446</td><td class="line">        t=allocbuft;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5447">5447</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5448">5448</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5449">5449</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(t, x);              <span class='comment'>/* term=x  */</span></td></tr>
<tr><td class="num" id="LN5450">5450</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(a); *a-&gt;lsu=1;      <span class='comment'>/* accumulator=1  */</span></td></tr>
<tr><td class="num" id="LN5451">5451</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(d); *d-&gt;lsu=2;      <span class='comment'>/* divisor=2  */</span></td></tr>
<tr><td class="num" id="LN5452">5452</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;numone); *numone.lsu=1; <span class='comment'>/* constant 1 for increment  */</span></td></tr>
<tr><td class="num" id="LN5453">5453</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5454">5454</td><td class="line">      <span class='comment'>/* set up the contexts for calculating a, t, and d  */</span></td></tr>
<tr><td class="num" id="LN5455">5455</td><td class="line">      <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;tset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>);</td></tr>
<tr><td class="num" id="LN5456">5456</td><td class="line">      dset=tset;</td></tr>
<tr><td class="num" id="LN5457">5457</td><td class="line">      <span class='comment'>/* accumulator bounds are set above, set precision now  */</span></td></tr>
<tr><td class="num" id="LN5458">5458</td><td class="line">      aset.digits=p*2;                  <span class='comment'>/* double  */</span></td></tr>
<tr><td class="num" id="LN5459">5459</td><td class="line">      <span class='comment'>/* term bounds avoid any underflow or overflow  */</span></td></tr>
<tr><td class="num" id="LN5460">5460</td><td class="line">      tset.digits=p;</td></tr>
<tr><td class="num" id="LN5461">5461</td><td class="line">      tset.emin=<span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span>;           <span class='comment'>/* [emax is plenty]  */</span></td></tr>
<tr><td class="num" id="LN5462">5462</td><td class="line">      <span class='comment'>/* [dset.digits=16, etc., are sufficient]  */</span></td></tr>
<tr><td class="num" id="LN5463">5463</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5464">5464</td><td class="line">      <span class='comment'>/* finally ready to roll  */</span></td></tr>
<tr><td class="num" id="LN5465">5465</td><td class="line">      <span class='keyword'>for</span> (;;) {</td></tr>
<tr><td class="num" id="LN5466">5466</td><td class="line">        <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5467">5467</td><td class="line">        iterations++;</td></tr>
<tr><td class="num" id="LN5468">5468</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5469">5469</td><td class="line">        <span class='comment'>/* only the status from the accumulation is interesting  */</span></td></tr>
<tr><td class="num" id="LN5470">5470</td><td class="line">        <span class='comment'>/* [but it should remain unchanged after first add]  */</span></td></tr>
<tr><td class="num" id="LN5471">5471</td><td class="line">        decAddOp(a, a, t, &amp;aset, 0, status);           <span class='comment'>/* a=a+t  */</span></td></tr>
<tr><td class="num" id="LN5472">5472</td><td class="line">        decMultiplyOp(t, t, x, &amp;tset, &amp;ignore);        <span class='comment'>/* t=t*x  */</span></td></tr>
<tr><td class="num" id="LN5473">5473</td><td class="line">        decDivideOp(t, t, d, &amp;tset, <span class='macro'>DIVIDE<span class='expansion'>0x80</span></span>, &amp;ignore);  <span class='comment'>/* t=t/d  */</span></td></tr>
<tr><td class="num" id="LN5474">5474</td><td class="line">        <span class='comment'>/* the iteration ends when the term cannot affect the result,  */</span></td></tr>
<tr><td class="num" id="LN5475">5475</td><td class="line">        <span class='comment'>/* if rounded to p digits, which is when its value is smaller  */</span></td></tr>
<tr><td class="num" id="LN5476">5476</td><td class="line">        <span class='comment'>/* than the accumulator by p+1 digits.  There must also be  */</span></td></tr>
<tr><td class="num" id="LN5477">5477</td><td class="line">        <span class='comment'>/* full precision in a.  */</span></td></tr>
<tr><td class="num" id="LN5478">5478</td><td class="line">        <span class='keyword'>if</span> (((a-&gt;digits+a-&gt;exponent)&gt;=(t-&gt;digits+t-&gt;exponent+p+1))</td></tr>
<tr><td class="num" id="LN5479">5479</td><td class="line">            &amp;&amp; (a-&gt;digits&gt;=p)) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5480">5480</td><td class="line">        decAddOp(d, d, &amp;numone, &amp;dset, 0, &amp;ignore);    <span class='comment'>/* d=d+1  */</span></td></tr>
<tr><td class="num" id="LN5481">5481</td><td class="line">        } <span class='comment'>/* iterate  */</span></td></tr>
<tr><td class="num" id="LN5482">5482</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5483">5483</td><td class="line">      <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5484">5484</td><td class="line">      <span class='comment'>/* just a sanity check; comment out test to show always  */</span></td></tr>
<tr><td class="num" id="LN5485">5485</td><td class="line">      <span class='keyword'>if</span> (iterations&gt;p+3)</td></tr>
<tr><td class="num" id="LN5486">5486</td><td class="line">        printf(<span class='string_literal'>"Exp iterations=%ld, status=%08lx, p=%ld, d=%ld\n"</span>,</td></tr>
<tr><td class="num" id="LN5487">5487</td><td class="line">               (LI)iterations, (LI)*status, (LI)p, (LI)x-&gt;digits);</td></tr>
<tr><td class="num" id="LN5488">5488</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5489">5489</td><td class="line">      } <span class='comment'>/* h&lt;=8  */</span></td></tr>
<tr><td class="num" id="LN5490">5490</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5491">5491</td><td class="line">    <span class='comment'>/* apply postconditioning: a=a**(10**h) -- this is calculated  */</span></td></tr>
<tr><td class="num" id="LN5492">5492</td><td class="line">    <span class='comment'>/* at a slightly higher precision than Hull &amp; Abrham suggest  */</span></td></tr>
<tr><td class="num" id="LN5493">5493</td><td class="line">    <span class='keyword'>if</span> (h&gt;0) {</td></tr>
<tr><td class="num" id="LN5494">5494</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> seenbit=0;               <span class='comment'>/* set once a 1-bit is seen  */</span></td></tr>
<tr><td class="num" id="LN5495">5495</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> i;                       <span class='comment'>/* counter  */</span></td></tr>
<tr><td class="num" id="LN5496">5496</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> n=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[h];             <span class='comment'>/* always positive  */</span></td></tr>
<tr><td class="num" id="LN5497">5497</td><td class="line">      aset.digits=p+2;             <span class='comment'>/* sufficient precision  */</span></td></tr>
<tr><td class="num" id="LN5498">5498</td><td class="line">      <span class='comment'>/* avoid the overhead and many extra digits of decNumberPower  */</span></td></tr>
<tr><td class="num" id="LN5499">5499</td><td class="line">      <span class='comment'>/* as all that is needed is the short 'multipliers' loop; here  */</span></td></tr>
<tr><td class="num" id="LN5500">5500</td><td class="line">      <span class='comment'>/* accumulate the answer into t  */</span></td></tr>
<tr><td class="num" id="LN5501">5501</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(t); *t-&gt;lsu=1; <span class='comment'>/* acc=1  */</span></td></tr>
<tr><td class="num" id="LN5502">5502</td><td class="line">      <span class='keyword'>for</span> (i=1;;i++){              <span class='comment'>/* for each bit [top bit ignored]  */</span></td></tr>
<tr><td class="num" id="LN5503">5503</td><td class="line">        <span class='comment'>/* abandon if have had overflow or terminal underflow  */</span></td></tr>
<tr><td class="num" id="LN5504">5504</td><td class="line">        <span class='keyword'>if</span> (*status &amp; (<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span>|<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>)) { <span class='comment'>/* interesting?  */</span></td></tr>
<tr><td class="num" id="LN5505">5505</td><td class="line">          <span class='keyword'>if</span> (*status&amp;<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span> || <span class='macro'>ISZERO(t)<span class='expansion'>(*(t)-&gt;lsu==0 &amp;&amp; (t)-&gt;digits==1 &amp;&amp; (((t<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5506">5506</td><td class="line">        n=n&lt;&lt;1;                    <span class='comment'>/* move next bit to testable position  */</span></td></tr>
<tr><td class="num" id="LN5507">5507</td><td class="line">        <span class='keyword'>if</span> (n&lt;0) {                 <span class='comment'>/* top bit is set  */</span></td></tr>
<tr><td class="num" id="LN5508">5508</td><td class="line">          seenbit=1;               <span class='comment'>/* OK, have a significant bit  */</span></td></tr>
<tr><td class="num" id="LN5509">5509</td><td class="line">          decMultiplyOp(t, t, a, &amp;aset, status); <span class='comment'>/* acc=acc*x  */</span></td></tr>
<tr><td class="num" id="LN5510">5510</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5511">5511</td><td class="line">        <span class='keyword'>if</span> (i==31) <span class='keyword'>break</span>;          <span class='comment'>/* that was the last bit  */</span></td></tr>
<tr><td class="num" id="LN5512">5512</td><td class="line">        <span class='keyword'>if</span> (!seenbit) <span class='keyword'>continue</span>;    <span class='comment'>/* no need to square 1  */</span></td></tr>
<tr><td class="num" id="LN5513">5513</td><td class="line">        decMultiplyOp(t, t, t, &amp;aset, status); <span class='comment'>/* acc=acc*acc [square]  */</span></td></tr>
<tr><td class="num" id="LN5514">5514</td><td class="line">        } <span class='comment'>/*i*/</span> <span class='comment'>/* 32 bits  */</span></td></tr>
<tr><td class="num" id="LN5515">5515</td><td class="line">      <span class='comment'>/* decNumberShow(t);  */</span></td></tr>
<tr><td class="num" id="LN5516">5516</td><td class="line">      a=t;                         <span class='comment'>/* and carry on using t instead of a  */</span></td></tr>
<tr><td class="num" id="LN5517">5517</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5518">5518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5519">5519</td><td class="line">    <span class='comment'>/* Copy and round the result to res  */</span></td></tr>
<tr><td class="num" id="LN5520">5520</td><td class="line">    residue=1;                          <span class='comment'>/* indicate dirt to right ..  */</span></td></tr>
<tr><td class="num" id="LN5521">5521</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(a)<span class='expansion'>(*(a)-&gt;lsu==0 &amp;&amp; (a)-&gt;digits==1 &amp;&amp; (((a<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) residue=0;           <span class='comment'>/* .. unless underflowed to 0  */</span></td></tr>
<tr><td class="num" id="LN5522">5522</td><td class="line">    aset.digits=set-&gt;digits;            <span class='comment'>/* [use default rounding]  */</span></td></tr>
<tr><td class="num" id="LN5523">5523</td><td class="line">    decCopyFit(res, a, &amp;aset, &amp;residue, status); <span class='comment'>/* copy &amp; shorten  */</span></td></tr>
<tr><td class="num" id="LN5524">5524</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;       <span class='comment'>/* cleanup/set flags  */</span></td></tr>
<tr><td class="num" id="LN5525">5525</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN5526">5526</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5527">5527</td><td class="line">  <span class='keyword'>if</span> (allocrhs !=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;  <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN5528">5528</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5529">5529</td><td class="line">  <span class='keyword'>if</span> (allocbuft!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbuft)<span class='expansion'>uprv_free_54(allocbuft)</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5530">5530</td><td class="line">  <span class='comment'>/* [status is handled by caller]  */</span></td></tr>
<tr><td class="num" id="LN5531">5531</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5532">5532</td><td class="line">  } <span class='comment'>/* decExpOp  */</span></td></tr>
<tr><td class="num" id="LN5533">5533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5534">5534</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5535">5535</td><td class="line"><span class='comment'>/* Initial-estimate natural logarithm table                           */</span></td></tr>
<tr><td class="num" id="LN5536">5536</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5537">5537</td><td class="line"><span class='comment'>/*   LNnn -- 90-entry 16-bit table for values from .10 through .99.   */</span></td></tr>
<tr><td class="num" id="LN5538">5538</td><td class="line"><span class='comment'>/*           The result is a 4-digit encode of the coefficient (c=the */</span></td></tr>
<tr><td class="num" id="LN5539">5539</td><td class="line"><span class='comment'>/*           top 14 bits encoding 0-9999) and a 2-digit encode of the */</span></td></tr>
<tr><td class="num" id="LN5540">5540</td><td class="line"><span class='comment'>/*           exponent (e=the bottom 2 bits encoding 0-3)              */</span></td></tr>
<tr><td class="num" id="LN5541">5541</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5542">5542</td><td class="line"><span class='comment'>/*           The resulting value is given by:                         */</span></td></tr>
<tr><td class="num" id="LN5543">5543</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5544">5544</td><td class="line"><span class='comment'>/*             v = -c * 10**(-e-3)                                    */</span></td></tr>
<tr><td class="num" id="LN5545">5545</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5546">5546</td><td class="line"><span class='comment'>/*           where e and c are extracted from entry k = LNnn[x-10]    */</span></td></tr>
<tr><td class="num" id="LN5547">5547</td><td class="line"><span class='comment'>/*           where x is truncated (NB) into the range 10 through 99,  */</span></td></tr>
<tr><td class="num" id="LN5548">5548</td><td class="line"><span class='comment'>/*           and then c = k&gt;&gt;2 and e = k&amp;3.                           */</span></td></tr>
<tr><td class="num" id="LN5549">5549</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5550">5550</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uShort<span class='expansion'>uint16_t</span></span> LNnn[90]={9016,  8652,  8316,  8008,  7724,  7456,  7208,</td></tr>
<tr><td class="num" id="LN5551">5551</td><td class="line">  6972,  6748,  6540,  6340,  6148,  5968,  5792,  5628,  5464,  5312,</td></tr>
<tr><td class="num" id="LN5552">5552</td><td class="line">  5164,  5020,  4884,  4748,  4620,  4496,  4376,  4256,  4144,  4032,</td></tr>
<tr><td class="num" id="LN5553">5553</td><td class="line"> 39233, 38181, 37157, 36157, 35181, 34229, 33297, 32389, 31501, 30629,</td></tr>
<tr><td class="num" id="LN5554">5554</td><td class="line"> 29777, 28945, 28129, 27329, 26545, 25777, 25021, 24281, 23553, 22837,</td></tr>
<tr><td class="num" id="LN5555">5555</td><td class="line"> 22137, 21445, 20769, 20101, 19445, 18801, 18165, 17541, 16925, 16321,</td></tr>
<tr><td class="num" id="LN5556">5556</td><td class="line"> 15721, 15133, 14553, 13985, 13421, 12865, 12317, 11777, 11241, 10717,</td></tr>
<tr><td class="num" id="LN5557">5557</td><td class="line"> 10197,  9685,  9177,  8677,  8185,  7697,  7213,  6737,  6269,  5801,</td></tr>
<tr><td class="num" id="LN5558">5558</td><td class="line">  5341,  4889,  4437, 39930, 35534, 31186, 26886, 22630, 18418, 14254,</td></tr>
<tr><td class="num" id="LN5559">5559</td><td class="line"> 10130,  6046, 20055};</td></tr>
<tr><td class="num" id="LN5560">5560</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5561">5561</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5562">5562</td><td class="line"><span class='comment'>/* decLnOp -- effect natural logarithm                                */</span></td></tr>
<tr><td class="num" id="LN5563">5563</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5564">5564</td><td class="line"><span class='comment'>/*   This computes C = ln(A)                                          */</span></td></tr>
<tr><td class="num" id="LN5565">5565</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5566">5566</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A                                */</span></td></tr>
<tr><td class="num" id="LN5567">5567</td><td class="line"><span class='comment'>/*   rhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN5568">5568</td><td class="line"><span class='comment'>/*   set is the context; note that rounding mode has no effect        */</span></td></tr>
<tr><td class="num" id="LN5569">5569</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5570">5570</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN5571">5571</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5572">5572</td><td class="line"><span class='comment'>/* Notable cases:                                                     */</span></td></tr>
<tr><td class="num" id="LN5573">5573</td><td class="line"><span class='comment'>/*   A&lt;0 -&gt; Invalid                                                   */</span></td></tr>
<tr><td class="num" id="LN5574">5574</td><td class="line"><span class='comment'>/*   A=0 -&gt; -Infinity (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN5575">5575</td><td class="line"><span class='comment'>/*   A=+Infinity -&gt; +Infinity (Exact)                                 */</span></td></tr>
<tr><td class="num" id="LN5576">5576</td><td class="line"><span class='comment'>/*   A=1 exactly -&gt; 0 (Exact)                                         */</span></td></tr>
<tr><td class="num" id="LN5577">5577</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5578">5578</td><td class="line"><span class='comment'>/* Restrictions (as for Exp):                                         */</span></td></tr>
<tr><td class="num" id="LN5579">5579</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5580">5580</td><td class="line"><span class='comment'>/*   digits, emax, and -emin in the context must be less than         */</span></td></tr>
<tr><td class="num" id="LN5581">5581</td><td class="line"><span class='comment'>/*   DEC_MAX_MATH+11 (1000010), and the rhs must be within these      */</span></td></tr>
<tr><td class="num" id="LN5582">5582</td><td class="line"><span class='comment'>/*   bounds or a zero.  This is an internal routine, so these         */</span></td></tr>
<tr><td class="num" id="LN5583">5583</td><td class="line"><span class='comment'>/*   restrictions are contractual and not enforced.                   */</span></td></tr>
<tr><td class="num" id="LN5584">5584</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5585">5585</td><td class="line"><span class='comment'>/* A finite result is rounded using DEC_ROUND_HALF_EVEN; it will      */</span></td></tr>
<tr><td class="num" id="LN5586">5586</td><td class="line"><span class='comment'>/* almost always be correctly rounded, but may be up to 1 ulp in      */</span></td></tr>
<tr><td class="num" id="LN5587">5587</td><td class="line"><span class='comment'>/* error in rare cases.                                               */</span></td></tr>
<tr><td class="num" id="LN5588">5588</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5589">5589</td><td class="line"><span class='comment'>/* The result is calculated using Newton's method, with each          */</span></td></tr>
<tr><td class="num" id="LN5590">5590</td><td class="line"><span class='comment'>/* iteration calculating a' = a + x * exp(-a) - 1.  See, for example, */</span></td></tr>
<tr><td class="num" id="LN5591">5591</td><td class="line"><span class='comment'>/* Epperson 1989.                                                     */</span></td></tr>
<tr><td class="num" id="LN5592">5592</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5593">5593</td><td class="line"><span class='comment'>/* The iteration ends when the adjustment x*exp(-a)-1 is tiny enough. */</span></td></tr>
<tr><td class="num" id="LN5594">5594</td><td class="line"><span class='comment'>/* This has to be calculated at the sum of the precision of x and the */</span></td></tr>
<tr><td class="num" id="LN5595">5595</td><td class="line"><span class='comment'>/* working precision.                                                 */</span></td></tr>
<tr><td class="num" id="LN5596">5596</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5597">5597</td><td class="line"><span class='comment'>/* Implementation notes:                                              */</span></td></tr>
<tr><td class="num" id="LN5598">5598</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5599">5599</td><td class="line"><span class='comment'>/* 1. This is separated out as decLnOp so it can be called from       */</span></td></tr>
<tr><td class="num" id="LN5600">5600</td><td class="line"><span class='comment'>/*    other Mathematical functions (e.g., Log 10) with a wider range  */</span></td></tr>
<tr><td class="num" id="LN5601">5601</td><td class="line"><span class='comment'>/*    than normal.  In particular, it can handle the slightly wider   */</span></td></tr>
<tr><td class="num" id="LN5602">5602</td><td class="line"><span class='comment'>/*    (+9+2) range needed by a power function.                        */</span></td></tr>
<tr><td class="num" id="LN5603">5603</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5604">5604</td><td class="line"><span class='comment'>/* 2. The speed of this function is about 10x slower than exp, as     */</span></td></tr>
<tr><td class="num" id="LN5605">5605</td><td class="line"><span class='comment'>/*    it typically needs 4-6 iterations for short numbers, and the    */</span></td></tr>
<tr><td class="num" id="LN5606">5606</td><td class="line"><span class='comment'>/*    extra precision needed adds a squaring effect, twice.           */</span></td></tr>
<tr><td class="num" id="LN5607">5607</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5608">5608</td><td class="line"><span class='comment'>/* 3. Fastpaths are included for ln(10) and ln(2), up to length 40,   */</span></td></tr>
<tr><td class="num" id="LN5609">5609</td><td class="line"><span class='comment'>/*    as these are common requests.  ln(10) is used by log10(x).      */</span></td></tr>
<tr><td class="num" id="LN5610">5610</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5611">5611</td><td class="line"><span class='comment'>/* 4. An iteration might be saved by widening the LNnn table, and     */</span></td></tr>
<tr><td class="num" id="LN5612">5612</td><td class="line"><span class='comment'>/*    would certainly save at least one if it were made ten times     */</span></td></tr>
<tr><td class="num" id="LN5613">5613</td><td class="line"><span class='comment'>/*    bigger, too (for truncated fractions 0.100 through 0.999).      */</span></td></tr>
<tr><td class="num" id="LN5614">5614</td><td class="line"><span class='comment'>/*    However, for most practical evaluations, at least four or five  */</span></td></tr>
<tr><td class="num" id="LN5615">5615</td><td class="line"><span class='comment'>/*    iterations will be neede -- so this would only speed up by      */</span></td></tr>
<tr><td class="num" id="LN5616">5616</td><td class="line"><span class='comment'>/*    20-25% and that probably does not justify increasing the table  */</span></td></tr>
<tr><td class="num" id="LN5617">5617</td><td class="line"><span class='comment'>/*    size.                                                           */</span></td></tr>
<tr><td class="num" id="LN5618">5618</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5619">5619</td><td class="line"><span class='comment'>/* 5. The static buffers are larger than might be expected to allow   */</span></td></tr>
<tr><td class="num" id="LN5620">5620</td><td class="line"><span class='comment'>/*    for calls from decNumberPower.                                  */</span></td></tr>
<tr><td class="num" id="LN5621">5621</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5622">5622</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN5623">5623</td><td class="line"><span class='directive'>#pragma GCC diagnostic push</span></td></tr>
<tr><td class="num" id="LN5624">5624</td><td class="line"><span class='directive'>#pragma GCC diagnostic ignored "-Warray-bounds"</span></td></tr>
<tr><td class="num" id="LN5625">5625</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5626">5626</td><td class="line">decNumber * decLnOp(decNumber *res, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN5627">5627</td><td class="line">                    decContext *set, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN5628">5628</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> ignore=0;                   <span class='comment'>/* working status accumulator  */</span></td></tr>
<tr><td class="num" id="LN5629">5629</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> needbytes;                  <span class='comment'>/* for space calculations  */</span></td></tr>
<tr><td class="num" id="LN5630">5630</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> residue;                     <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN5631">5631</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> r;                           <span class='comment'>/* rhs=f*10**r [see below]  */</span></td></tr>
<tr><td class="num" id="LN5632">5632</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> p;                           <span class='comment'>/* working precision  */</span></td></tr>
<tr><td class="num" id="LN5633">5633</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> pp;                          <span class='comment'>/* precision for iteration  */</span></td></tr>
<tr><td class="num" id="LN5634">5634</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> t;                           <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN5635">5635</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5636">5636</td><td class="line">  <span class='comment'>/* buffers for a (accumulator, typically precision+2) and b  */</span></td></tr>
<tr><td class="num" id="LN5637">5637</td><td class="line">  <span class='comment'>/* (adjustment calculator, same size)  */</span></td></tr>
<tr><td class="num" id="LN5638">5638</td><td class="line">  decNumber bufa[<span class='macro'>D2N(DECBUFFER+12)<span class='expansion'>(((((((36 +12)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)<br>*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5639">5639</td><td class="line">  decNumber *allocbufa=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN5640">5640</td><td class="line">  decNumber *a=bufa;               <span class='comment'>/* accumulator/work  */</span></td></tr>
<tr><td class="num" id="LN5641">5641</td><td class="line">  decNumber bufb[<span class='macro'>D2N(DECBUFFER*2+2)<span class='expansion'>(((((((36*2+2)+1 -1)/1)-1)*sizeof(uint8_t))+sizeof(decNumber)<br>*2-1)/sizeof(decNumber))</span></span>];</td></tr>
<tr><td class="num" id="LN5642">5642</td><td class="line">  decNumber *allocbufb=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;       <span class='comment'>/* -&gt; allocated bufa, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN5643">5643</td><td class="line">  decNumber *b=bufb;               <span class='comment'>/* adjustment/work  */</span></td></tr>
<tr><td class="num" id="LN5644">5644</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5645">5645</td><td class="line">  decNumber  numone;               <span class='comment'>/* constant 1  */</span></td></tr>
<tr><td class="num" id="LN5646">5646</td><td class="line">  decNumber  cmp;                  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN5647">5647</td><td class="line">  decContext aset, bset;           <span class='comment'>/* working contexts  */</span></td></tr>
<tr><td class="num" id="LN5648">5648</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5649">5649</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5650">5650</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> iterations=0;                <span class='comment'>/* for later sanity check  */</span></td></tr>
<tr><td class="num" id="LN5651">5651</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, DECUNUSED, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5652">5652</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5653">5653</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5654">5654</td><td class="line">  <span class='keyword'>do</span> {                                  <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN5655">5655</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARG<span class='expansion'>(rhs-&gt;bits &amp; (0x40|0x20|0x10))</span></span>) {                   <span class='comment'>/* handle infinities and NaNs  */</span></td></tr>
<tr><td class="num" id="LN5656">5656</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) {   <span class='comment'>/* an infinity  */</span></td></tr>
<tr><td class="num" id="LN5657">5657</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>)   <span class='comment'>/* -Infinity -&gt; error  */</span></td></tr>
<tr><td class="num" id="LN5658">5658</td><td class="line">          *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5659">5659</td><td class="line">         <span class='keyword'>else</span> <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, rhs);  <span class='comment'>/* +Infinity -&gt; self  */</span></td></tr>
<tr><td class="num" id="LN5660">5660</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5661">5661</td><td class="line">       <span class='keyword'>else</span> decNaNs(res, rhs, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, set, status); <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN5662">5662</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5663">5663</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5664">5664</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                  <span class='comment'>/* +/- zeros -&gt; -Infinity  */</span></td></tr>
<tr><td class="num" id="LN5665">5665</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);               <span class='comment'>/* make clean  */</span></td></tr>
<tr><td class="num" id="LN5666">5666</td><td class="line">      res-&gt;bits=<span class='macro'>DECINF<span class='expansion'>0x40</span></span>|<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;          <span class='comment'>/* set - infinity  */</span></td></tr>
<tr><td class="num" id="LN5667">5667</td><td class="line">      <span class='keyword'>break</span>;}                           <span class='comment'>/* [no status to set]  */</span></td></tr>
<tr><td class="num" id="LN5668">5668</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5669">5669</td><td class="line">    <span class='comment'>/* Non-zero negatives are bad...  */</span></td></tr>
<tr><td class="num" id="LN5670">5670</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {     <span class='comment'>/* -x -&gt; error  */</span></td></tr>
<tr><td class="num" id="LN5671">5671</td><td class="line">      *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5672">5672</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5673">5673</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5674">5674</td><td class="line">    <span class='comment'>/* Here, rhs is positive, finite, and in range  */</span></td></tr>
<tr><td class="num" id="LN5675">5675</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5676">5676</td><td class="line">    <span class='comment'>/* lookaside fastpath code for ln(2) and ln(10) at common lengths  */</span></td></tr>
<tr><td class="num" id="LN5677">5677</td><td class="line">    <span class='keyword'>if</span> (rhs-&gt;exponent==0 &amp;&amp; set-&gt;digits&lt;=40) {</td></tr>
<tr><td class="num" id="LN5678">5678</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==1</span></td></tr>
<tr><td class="num" id="LN5679">5679</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;lsu[0]==0 &amp;&amp; rhs-&gt;lsu[1]==1 &amp;&amp; rhs-&gt;digits==2) { <span class='comment'>/* ln(10)  */</span></td></tr>
<tr><td class="num" id="LN5680">5680</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN5681">5681</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;lsu[0]==10 &amp;&amp; rhs-&gt;digits==2) {                  <span class='comment'>/* ln(10)  */</span></td></tr>
<tr><td class="num" id="LN5682">5682</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5683">5683</td><td class="line">        aset=*set; aset.round=DEC_ROUND_HALF_EVEN;</td></tr>
<tr><td class="num" id="LN5684">5684</td><td class="line">        <span class='directive'>#define <span class='macro'>LN10<span class='expansion'>"2.302585092994045684017991454684364207601"</span></span> "2.302585092994045684017991454684364207601"</span></td></tr>
<tr><td class="num" id="LN5685">5685</td><td class="line">        <span class='macro'>uprv_decNumberFromString<span class='expansion'>uprv_decNumberFromString_54</span></span>(res, <span class='macro'>LN10<span class='expansion'>"2.302585092994045684017991454684364207601"</span></span>, &amp;aset);</td></tr>
<tr><td class="num" id="LN5686">5686</td><td class="line">        *status|=(<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>); <span class='comment'>/* is inexact  */</span></td></tr>
<tr><td class="num" id="LN5687">5687</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5688">5688</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;lsu[0]==2 &amp;&amp; rhs-&gt;digits==1) { <span class='comment'>/* ln(2)  */</span></td></tr>
<tr><td class="num" id="LN5689">5689</td><td class="line">        aset=*set; aset.round=DEC_ROUND_HALF_EVEN;</td></tr>
<tr><td class="num" id="LN5690">5690</td><td class="line">        <span class='directive'>#define <span class='macro'>LN2<span class='expansion'>"0.6931471805599453094172321214581765680755"</span></span> "0.6931471805599453094172321214581765680755"</span></td></tr>
<tr><td class="num" id="LN5691">5691</td><td class="line">        <span class='macro'>uprv_decNumberFromString<span class='expansion'>uprv_decNumberFromString_54</span></span>(res, <span class='macro'>LN2<span class='expansion'>"0.6931471805599453094172321214581765680755"</span></span>, &amp;aset);</td></tr>
<tr><td class="num" id="LN5692">5692</td><td class="line">        *status|=(<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>);</td></tr>
<tr><td class="num" id="LN5693">5693</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5694">5694</td><td class="line">      } <span class='comment'>/* integer and short  */</span></td></tr>
<tr><td class="num" id="LN5695">5695</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5696">5696</td><td class="line">    <span class='comment'>/* Determine the working precision.  This is normally the  */</span></td></tr>
<tr><td class="num" id="LN5697">5697</td><td class="line">    <span class='comment'>/* requested precision + 2, with a minimum of 9.  However, if  */</span></td></tr>
<tr><td class="num" id="LN5698">5698</td><td class="line">    <span class='comment'>/* the rhs is 'over-precise' then allow for all its digits to  */</span></td></tr>
<tr><td class="num" id="LN5699">5699</td><td class="line">    <span class='comment'>/* potentially participate (consider an rhs where all the excess  */</span></td></tr>
<tr><td class="num" id="LN5700">5700</td><td class="line">    <span class='comment'>/* digits are 9s) so in this case use rhs-&gt;digits+2.  */</span></td></tr>
<tr><td class="num" id="LN5701">5701</td><td class="line">    p=<span class='macro'>MAXI(rhs-&gt;digits, MAXI(set-&gt;digits, 7))<span class='expansion'>((rhs-&gt;digits)&lt;(((set-&gt;digits)&lt;(7)?(7):(set-&gt;digits<br>)))?(((set-&gt;digits)&lt;(7)?(7):(set-&gt;digits))):(rhs-&gt;<br>digits))</span></span>+2;</td></tr>
<tr><td class="num" id="LN5702">5702</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5703">5703</td><td class="line">    <span class='comment'>/* Allocate space for the accumulator and the high-precision  */</span></td></tr>
<tr><td class="num" id="LN5704">5704</td><td class="line">    <span class='comment'>/* adjustment calculator, if necessary.  The accumulator must  */</span></td></tr>
<tr><td class="num" id="LN5705">5705</td><td class="line">    <span class='comment'>/* be able to hold p digits, and the adjustment up to  */</span></td></tr>
<tr><td class="num" id="LN5706">5706</td><td class="line">    <span class='comment'>/* rhs-&gt;digits+p digits.  They are also made big enough for 16  */</span></td></tr>
<tr><td class="num" id="LN5707">5707</td><td class="line">    <span class='comment'>/* digits so that they can be used for calculating the initial  */</span></td></tr>
<tr><td class="num" id="LN5708">5708</td><td class="line">    <span class='comment'>/* estimate.  */</span></td></tr>
<tr><td class="num" id="LN5709">5709</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(MAXI(p,16))<span class='expansion'>((((p)&lt;(16)?(16):(p)))&lt;=49?d2utable[((p)&lt;(16)?(16):(<br>p))]:((((p)&lt;(16)?(16):(p)))+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5710">5710</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufa)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN5711">5711</td><td class="line">      allocbufa=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5712">5712</td><td class="line">      <span class='keyword'>if</span> (allocbufa==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN5713">5713</td><td class="line">        *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5714">5714</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5715">5715</td><td class="line">      a=allocbufa;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5716">5716</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5717">5717</td><td class="line">    pp=p+rhs-&gt;digits;</td></tr>
<tr><td class="num" id="LN5718">5718</td><td class="line">    needbytes=<span class='keyword'>sizeof</span>(decNumber)+(<span class='macro'>D2U(MAXI(pp,16))<span class='expansion'>((((pp)&lt;(16)?(16):(pp)))&lt;=49?d2utable[((pp)&lt;(16)?(16<br>):(pp))]:((((pp)&lt;(16)?(16):(pp)))+1 -1)/1)</span></span>-1)*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>);</td></tr>
<tr><td class="num" id="LN5719">5719</td><td class="line">    <span class='keyword'>if</span> (needbytes&gt;<span class='keyword'>sizeof</span>(bufb)) {     <span class='comment'>/* need malloc space  */</span></td></tr>
<tr><td class="num" id="LN5720">5720</td><td class="line">      allocbufb=(decNumber *)<span class='macro'>malloc(needbytes)<span class='expansion'>uprv_malloc_54(needbytes)</span></span>;</td></tr>
<tr><td class="num" id="LN5721">5721</td><td class="line">      <span class='keyword'>if</span> (allocbufb==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {          <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN5722">5722</td><td class="line">        *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN5723">5723</td><td class="line">        <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5724">5724</td><td class="line">      b=allocbufb;                    <span class='comment'>/* use the allocated space  */</span></td></tr>
<tr><td class="num" id="LN5725">5725</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5726">5726</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5727">5727</td><td class="line">    <span class='comment'>/* Prepare an initial estimate in acc. Calculate this by  */</span></td></tr>
<tr><td class="num" id="LN5728">5728</td><td class="line">    <span class='comment'>/* considering the coefficient of x to be a normalized fraction,  */</span></td></tr>
<tr><td class="num" id="LN5729">5729</td><td class="line">    <span class='comment'>/* f, with the decimal point at far left and multiplied by  */</span></td></tr>
<tr><td class="num" id="LN5730">5730</td><td class="line">    <span class='comment'>/* 10**r.  Then, rhs=f*10**r and 0.1&lt;=f&lt;1, and  */</span></td></tr>
<tr><td class="num" id="LN5731">5731</td><td class="line">    <span class='comment'>/*   ln(x) = ln(f) + ln(10)*r  */</span></td></tr>
<tr><td class="num" id="LN5732">5732</td><td class="line">    <span class='comment'>/* Get the initial estimate for ln(f) from a small lookup  */</span></td></tr>
<tr><td class="num" id="LN5733">5733</td><td class="line">    <span class='comment'>/* table (see above) indexed by the first two digits of f,  */</span></td></tr>
<tr><td class="num" id="LN5734">5734</td><td class="line">    <span class='comment'>/* truncated.  */</span></td></tr>
<tr><td class="num" id="LN5735">5735</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5736">5736</td><td class="line">    <span class='macro'>uprv_decContextDefault<span class='expansion'>uprv_decContextDefault_54</span></span>(&amp;aset, <span class='macro'>DEC_INIT_DECIMAL64<span class='expansion'>64</span></span>); <span class='comment'>/* 16-digit extended  */</span></td></tr>
<tr><td class="num" id="LN5737">5737</td><td class="line">    r=rhs-&gt;exponent+rhs-&gt;digits;        <span class='comment'>/* 'normalised' exponent  */</span></td></tr>
<tr><td class="num" id="LN5738">5738</td><td class="line">    <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(a, r);           <span class='comment'>/* a=r  */</span></td></tr>
<tr><td class="num" id="LN5739">5739</td><td class="line">    <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(b, 2302585);     <span class='comment'>/* b=ln(10) (2.302585)  */</span></td></tr>
<tr><td class="num" id="LN5740">5740</td><td class="line">    b-&gt;exponent=-6;                     <span class='comment'>/*  ..  */</span></td></tr>
<tr><td class="num" id="LN5741">5741</td><td class="line">    decMultiplyOp(a, a, b, &amp;aset, &amp;ignore);  <span class='comment'>/* a=a*b  */</span></td></tr>
<tr><td class="num" id="LN5742">5742</td><td class="line">    <span class='comment'>/* now get top two digits of rhs into b by simple truncate and  */</span></td></tr>
<tr><td class="num" id="LN5743">5743</td><td class="line">    <span class='comment'>/* force to integer  */</span></td></tr>
<tr><td class="num" id="LN5744">5744</td><td class="line">    residue=0;                          <span class='comment'>/* (no residue)  */</span></td></tr>
<tr><td class="num" id="LN5745">5745</td><td class="line">    aset.digits=2; aset.round=DEC_ROUND_DOWN;</td></tr>
<tr><td class="num" id="LN5746">5746</td><td class="line">    decCopyFit(b, rhs, &amp;aset, &amp;residue, &amp;ignore); <span class='comment'>/* copy &amp; shorten  */</span></td></tr>
<tr><td class="num" id="LN5747">5747</td><td class="line">    b-&gt;exponent=0;                      <span class='comment'>/* make integer  */</span></td></tr>
<tr><td class="num" id="LN5748">5748</td><td class="line">    t=decGetInt(b);                     <span class='comment'>/* [cannot fail]  */</span></td></tr>
<tr><td class="num" id="LN5749">5749</td><td class="line">    <span class='keyword'>if</span> (t&lt;10) t=<span class='macro'>X10(t)<span class='expansion'>(((t)&lt;&lt;1)+((t)&lt;&lt;3))</span></span>;                 <span class='comment'>/* adjust single-digit b  */</span></td></tr>
<tr><td class="num" id="LN5750">5750</td><td class="line">    t=LNnn[t-10];                       <span class='comment'>/* look up ln(b)  */</span></td></tr>
<tr><td class="num" id="LN5751">5751</td><td class="line">    <span class='macro'>uprv_decNumberFromInt32<span class='expansion'>uprv_decNumberFromInt32_54</span></span>(b, t&gt;&gt;2);        <span class='comment'>/* b=ln(b) coefficient  */</span></td></tr>
<tr><td class="num" id="LN5752">5752</td><td class="line">    b-&gt;exponent=-(t&amp;3)-3;               <span class='comment'>/* set exponent  */</span></td></tr>
<tr><td class="num" id="LN5753">5753</td><td class="line">    b-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                     <span class='comment'>/* ln(0.10)-&gt;ln(0.99) always -ve  */</span></td></tr>
<tr><td class="num" id="LN5754">5754</td><td class="line">    aset.digits=16; aset.round=DEC_ROUND_HALF_EVEN; <span class='comment'>/* restore  */</span></td></tr>
<tr><td class="num" id="LN5755">5755</td><td class="line">    decAddOp(a, a, b, &amp;aset, 0, &amp;ignore); <span class='comment'>/* acc=a+b  */</span></td></tr>
<tr><td class="num" id="LN5756">5756</td><td class="line">    <span class='comment'>/* the initial estimate is now in a, with up to 4 digits correct.  */</span></td></tr>
<tr><td class="num" id="LN5757">5757</td><td class="line">    <span class='comment'>/* When rhs is at or near Nmax the estimate will be low, so we  */</span></td></tr>
<tr><td class="num" id="LN5758">5758</td><td class="line">    <span class='comment'>/* will approach it from below, avoiding overflow when calling exp.  */</span></td></tr>
<tr><td class="num" id="LN5759">5759</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5760">5760</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;numone); *numone.lsu=1;   <span class='comment'>/* constant 1 for adjustment  */</span></td></tr>
<tr><td class="num" id="LN5761">5761</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5762">5762</td><td class="line">    <span class='comment'>/* accumulator bounds are as requested (could underflow, but  */</span></td></tr>
<tr><td class="num" id="LN5763">5763</td><td class="line">    <span class='comment'>/* cannot overflow)  */</span></td></tr>
<tr><td class="num" id="LN5764">5764</td><td class="line">    aset.emax=set-&gt;emax;</td></tr>
<tr><td class="num" id="LN5765">5765</td><td class="line">    aset.emin=set-&gt;emin;</td></tr>
<tr><td class="num" id="LN5766">5766</td><td class="line">    aset.clamp=0;                       <span class='comment'>/* no concrete format  */</span></td></tr>
<tr><td class="num" id="LN5767">5767</td><td class="line">    <span class='comment'>/* set up a context to be used for the multiply and subtract  */</span></td></tr>
<tr><td class="num" id="LN5768">5768</td><td class="line">    bset=aset;</td></tr>
<tr><td class="num" id="LN5769">5769</td><td class="line">    bset.emax=<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>*2;           <span class='comment'>/* use double bounds for the  */</span></td></tr>
<tr><td class="num" id="LN5770">5770</td><td class="line">    bset.emin=-<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>*2;          <span class='comment'>/* adjustment calculation  */</span></td></tr>
<tr><td class="num" id="LN5771">5771</td><td class="line">                                        <span class='comment'>/* [see decExpOp call below]  */</span></td></tr>
<tr><td class="num" id="LN5772">5772</td><td class="line">    <span class='comment'>/* for each iteration double the number of digits to calculate,  */</span></td></tr>
<tr><td class="num" id="LN5773">5773</td><td class="line">    <span class='comment'>/* up to a maximum of p  */</span></td></tr>
<tr><td class="num" id="LN5774">5774</td><td class="line">    pp=9;                               <span class='comment'>/* initial precision  */</span></td></tr>
<tr><td class="num" id="LN5775">5775</td><td class="line">    <span class='comment'>/* [initially 9 as then the sequence starts 7+2, 16+2, and  */</span></td></tr>
<tr><td class="num" id="LN5776">5776</td><td class="line">    <span class='comment'>/* 34+2, which is ideal for standard-sized numbers]  */</span></td></tr>
<tr><td class="num" id="LN5777">5777</td><td class="line">    aset.digits=pp;                     <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN5778">5778</td><td class="line">    bset.digits=pp+rhs-&gt;digits;         <span class='comment'>/* wider context  */</span></td></tr>
<tr><td class="num" id="LN5779">5779</td><td class="line">    <span class='keyword'>for</span> (;;) {                          <span class='comment'>/* iterate  */</span></td></tr>
<tr><td class="num" id="LN5780">5780</td><td class="line">      <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5781">5781</td><td class="line">      iterations++;</td></tr>
<tr><td class="num" id="LN5782">5782</td><td class="line">      <span class='keyword'>if</span> (iterations&gt;24) <span class='keyword'>break</span>;         <span class='comment'>/* consider 9 * 2**24  */</span></td></tr>
<tr><td class="num" id="LN5783">5783</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5784">5784</td><td class="line">      <span class='comment'>/* calculate the adjustment (exp(-a)*x-1) into b.  This is a  */</span></td></tr>
<tr><td class="num" id="LN5785">5785</td><td class="line">      <span class='comment'>/* catastrophic subtraction but it really is the difference  */</span></td></tr>
<tr><td class="num" id="LN5786">5786</td><td class="line">      <span class='comment'>/* from 1 that is of interest.  */</span></td></tr>
<tr><td class="num" id="LN5787">5787</td><td class="line">      <span class='comment'>/* Use the internal entry point to Exp as it allows the double  */</span></td></tr>
<tr><td class="num" id="LN5788">5788</td><td class="line">      <span class='comment'>/* range for calculating exp(-a) when a is the tiniest subnormal.  */</span></td></tr>
<tr><td class="num" id="LN5789">5789</td><td class="line">      a-&gt;bits^=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                  <span class='comment'>/* make -a  */</span></td></tr>
<tr><td class="num" id="LN5790">5790</td><td class="line">      decExpOp(b, a, &amp;bset, &amp;ignore);   <span class='comment'>/* b=exp(-a)  */</span></td></tr>
<tr><td class="num" id="LN5791">5791</td><td class="line">      a-&gt;bits^=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;                  <span class='comment'>/* restore sign of a  */</span></td></tr>
<tr><td class="num" id="LN5792">5792</td><td class="line">      <span class='comment'>/* now multiply by rhs and subtract 1, at the wider precision  */</span></td></tr>
<tr><td class="num" id="LN5793">5793</td><td class="line">      decMultiplyOp(b, b, rhs, &amp;bset, &amp;ignore);        <span class='comment'>/* b=b*rhs  */</span></td></tr>
<tr><td class="num" id="LN5794">5794</td><td class="line">      decAddOp(b, b, &amp;numone, &amp;bset, <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>, &amp;ignore); <span class='comment'>/* b=b-1  */</span></td></tr>
<tr><td class="num" id="LN5795">5795</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5796">5796</td><td class="line">      <span class='comment'>/* the iteration ends when the adjustment cannot affect the  */</span></td></tr>
<tr><td class="num" id="LN5797">5797</td><td class="line">      <span class='comment'>/* result by &gt;=0.5 ulp (at the requested digits), which  */</span></td></tr>
<tr><td class="num" id="LN5798">5798</td><td class="line">      <span class='comment'>/* is when its value is smaller than the accumulator by  */</span></td></tr>
<tr><td class="num" id="LN5799">5799</td><td class="line">      <span class='comment'>/* set-&gt;digits+1 digits (or it is zero) -- this is a looser  */</span></td></tr>
<tr><td class="num" id="LN5800">5800</td><td class="line">      <span class='comment'>/* requirement than for Exp because all that happens to the  */</span></td></tr>
<tr><td class="num" id="LN5801">5801</td><td class="line">      <span class='comment'>/* accumulator after this is the final rounding (but note that  */</span></td></tr>
<tr><td class="num" id="LN5802">5802</td><td class="line">      <span class='comment'>/* there must also be full precision in a, or a=0).  */</span></td></tr>
<tr><td class="num" id="LN5803">5803</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5804">5804</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(b)<span class='expansion'>(*(b)-&gt;lsu==0 &amp;&amp; (b)-&gt;digits==1 &amp;&amp; (((b<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span> ||</td></tr>
<tr><td class="num" id="LN5805">5805</td><td class="line">          (a-&gt;digits+a-&gt;exponent)&gt;=(b-&gt;digits+b-&gt;exponent+set-&gt;digits+1)) {</td></tr>
<tr><td class="num" id="LN5806">5806</td><td class="line">        <span class='keyword'>if</span> (a-&gt;digits==p) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5807">5807</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(a)<span class='expansion'>(*(a)-&gt;lsu==0 &amp;&amp; (a)-&gt;digits==1 &amp;&amp; (((a<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN5808">5808</td><td class="line">          decCompareOp(&amp;cmp, rhs, &amp;numone, &amp;aset, <span class='macro'>COMPARE<span class='expansion'>0x01</span></span>, &amp;ignore); <span class='comment'>/* rhs=1 ?  */</span></td></tr>
<tr><td class="num" id="LN5809">5809</td><td class="line">          <span class='keyword'>if</span> (cmp.lsu[0]==0) a-&gt;exponent=0;            <span class='comment'>/* yes, exact 0  */</span></td></tr>
<tr><td class="num" id="LN5810">5810</td><td class="line">           <span class='keyword'>else</span> *status|=(<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>);  <span class='comment'>/* no, inexact  */</span></td></tr>
<tr><td class="num" id="LN5811">5811</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5812">5812</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5813">5813</td><td class="line">        <span class='comment'>/* force padding if adjustment has gone to 0 before full length  */</span></td></tr>
<tr><td class="num" id="LN5814">5814</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsZero(b)<span class='expansion'>(*(b)-&gt;lsu==0 &amp;&amp; (b)-&gt;digits==1 &amp;&amp; (((b<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) b-&gt;exponent=a-&gt;exponent-p;</td></tr>
<tr><td class="num" id="LN5815">5815</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5816">5816</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5817">5817</td><td class="line">      <span class='comment'>/* not done yet ...  */</span></td></tr>
<tr><td class="num" id="LN5818">5818</td><td class="line">      decAddOp(a, a, b, &amp;aset, 0, &amp;ignore);  <span class='comment'>/* a=a+b for next estimate  */</span></td></tr>
<tr><td class="num" id="LN5819">5819</td><td class="line">      <span class='keyword'>if</span> (pp==p) <span class='keyword'>continue</span>;                   <span class='comment'>/* precision is at maximum  */</span></td></tr>
<tr><td class="num" id="LN5820">5820</td><td class="line">      <span class='comment'>/* lengthen the next calculation  */</span></td></tr>
<tr><td class="num" id="LN5821">5821</td><td class="line">      pp=pp*2;                               <span class='comment'>/* double precision  */</span></td></tr>
<tr><td class="num" id="LN5822">5822</td><td class="line">      <span class='keyword'>if</span> (pp&gt;p) pp=p;                        <span class='comment'>/* clamp to maximum  */</span></td></tr>
<tr><td class="num" id="LN5823">5823</td><td class="line">      aset.digits=pp;                        <span class='comment'>/* working context  */</span></td></tr>
<tr><td class="num" id="LN5824">5824</td><td class="line">      bset.digits=pp+rhs-&gt;digits;            <span class='comment'>/* wider context  */</span></td></tr>
<tr><td class="num" id="LN5825">5825</td><td class="line">      } <span class='comment'>/* Newton's iteration  */</span></td></tr>
<tr><td class="num" id="LN5826">5826</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5827">5827</td><td class="line">    <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5828">5828</td><td class="line">    <span class='comment'>/* just a sanity check; remove the test to show always  */</span></td></tr>
<tr><td class="num" id="LN5829">5829</td><td class="line">    <span class='keyword'>if</span> (iterations&gt;24)</td></tr>
<tr><td class="num" id="LN5830">5830</td><td class="line">      printf(<span class='string_literal'>"Ln iterations=%ld, status=%08lx, p=%ld, d=%ld\n"</span>,</td></tr>
<tr><td class="num" id="LN5831">5831</td><td class="line">            (LI)iterations, (LI)*status, (LI)p, (LI)rhs-&gt;digits);</td></tr>
<tr><td class="num" id="LN5832">5832</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5833">5833</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5834">5834</td><td class="line">    <span class='comment'>/* Copy and round the result to res  */</span></td></tr>
<tr><td class="num" id="LN5835">5835</td><td class="line">    residue=1;                          <span class='comment'>/* indicate dirt to right  */</span></td></tr>
<tr><td class="num" id="LN5836">5836</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(a)<span class='expansion'>(*(a)-&gt;lsu==0 &amp;&amp; (a)-&gt;digits==1 &amp;&amp; (((a<br>)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) residue=0;           <span class='comment'>/* .. unless underflowed to 0  */</span></td></tr>
<tr><td class="num" id="LN5837">5837</td><td class="line">    aset.digits=set-&gt;digits;            <span class='comment'>/* [use default rounding]  */</span></td></tr>
<tr><td class="num" id="LN5838">5838</td><td class="line">    decCopyFit(res, a, &amp;aset, &amp;residue, status); <span class='comment'>/* copy &amp; shorten  */</span></td></tr>
<tr><td class="num" id="LN5839">5839</td><td class="line">    <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;       <span class='comment'>/* cleanup/set flags  */</span></td></tr>
<tr><td class="num" id="LN5840">5840</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN5841">5841</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5842">5842</td><td class="line">  <span class='keyword'>if</span> (allocbufa!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufa)<span class='expansion'>uprv_free_54(allocbufa)</span></span>; <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN5843">5843</td><td class="line">  <span class='keyword'>if</span> (allocbufb!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocbufb)<span class='expansion'>uprv_free_54(allocbufb)</span></span>; <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN5844">5844</td><td class="line">  <span class='comment'>/* [status is handled by caller]  */</span></td></tr>
<tr><td class="num" id="LN5845">5845</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5846">5846</td><td class="line">  } <span class='comment'>/* decLnOp  */</span></td></tr>
<tr><td class="num" id="LN5847">5847</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='expansion'>1</span></span>) || <span class='macro'>U_GCC_MAJOR_MINOR<span class='expansion'>(4 * 100 + 2)</span></span> &gt;= 406</span></td></tr>
<tr><td class="num" id="LN5848">5848</td><td class="line"><span class='directive'>#pragma GCC diagnostic pop</span></td></tr>
<tr><td class="num" id="LN5849">5849</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5850">5850</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5851">5851</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5852">5852</td><td class="line"><span class='comment'>/* decQuantizeOp  -- force exponent to requested value                */</span></td></tr>
<tr><td class="num" id="LN5853">5853</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5854">5854</td><td class="line"><span class='comment'>/*   This computes C = op(A, B), where op adjusts the coefficient     */</span></td></tr>
<tr><td class="num" id="LN5855">5855</td><td class="line"><span class='comment'>/*   of C (by rounding or shifting) such that the exponent (-scale)   */</span></td></tr>
<tr><td class="num" id="LN5856">5856</td><td class="line"><span class='comment'>/*   of C has the value B or matches the exponent of B.               */</span></td></tr>
<tr><td class="num" id="LN5857">5857</td><td class="line"><span class='comment'>/*   The numerical value of C will equal A, except for the effects of */</span></td></tr>
<tr><td class="num" id="LN5858">5858</td><td class="line"><span class='comment'>/*   any rounding that occurred.                                      */</span></td></tr>
<tr><td class="num" id="LN5859">5859</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5860">5860</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A or B                           */</span></td></tr>
<tr><td class="num" id="LN5861">5861</td><td class="line"><span class='comment'>/*   lhs is A, the number to adjust                                   */</span></td></tr>
<tr><td class="num" id="LN5862">5862</td><td class="line"><span class='comment'>/*   rhs is B, the requested exponent                                 */</span></td></tr>
<tr><td class="num" id="LN5863">5863</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN5864">5864</td><td class="line"><span class='comment'>/*   quant is 1 for quantize or 0 for rescale                         */</span></td></tr>
<tr><td class="num" id="LN5865">5865</td><td class="line"><span class='comment'>/*   status is the status accumulator (this can be called without     */</span></td></tr>
<tr><td class="num" id="LN5866">5866</td><td class="line"><span class='comment'>/*          risk of control loss)                                     */</span></td></tr>
<tr><td class="num" id="LN5867">5867</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5868">5868</td><td class="line"><span class='comment'>/* C must have space for set-&gt;digits digits.                          */</span></td></tr>
<tr><td class="num" id="LN5869">5869</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN5870">5870</td><td class="line"><span class='comment'>/* Unless there is an error or the result is infinite, the exponent   */</span></td></tr>
<tr><td class="num" id="LN5871">5871</td><td class="line"><span class='comment'>/* after the operation is guaranteed to be that requested.            */</span></td></tr>
<tr><td class="num" id="LN5872">5872</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN5873">5873</td><td class="line"><span class='keyword'>static</span> decNumber * decQuantizeOp(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN5874">5874</td><td class="line">                                 <span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN5875">5875</td><td class="line">                                 <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> quant, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN5876">5876</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5877">5877</td><td class="line">  decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded lhs allocated  */</span></td></tr>
<tr><td class="num" id="LN5878">5878</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* .., rhs  */</span></td></tr>
<tr><td class="num" id="LN5879">5879</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5880">5880</td><td class="line">  <span class='keyword'>const</span> decNumber *inrhs=rhs;      <span class='comment'>/* save original rhs  */</span></td></tr>
<tr><td class="num" id="LN5881">5881</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   reqdigits=set-&gt;digits;     <span class='comment'>/* requested DIGITS  */</span></td></tr>
<tr><td class="num" id="LN5882">5882</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   reqexp;                    <span class='comment'>/* requested exponent [-scale]  */</span></td></tr>
<tr><td class="num" id="LN5883">5883</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   residue=0;                 <span class='comment'>/* rounding residue  */</span></td></tr>
<tr><td class="num" id="LN5884">5884</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   etiny=set-&gt;emin-(reqdigits-1);</td></tr>
<tr><td class="num" id="LN5885">5885</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5886">5886</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5887">5887</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN5888">5888</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5889">5889</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5890">5890</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN5891">5891</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5892">5892</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN5893">5893</td><td class="line">      <span class='comment'>/* reduce operands and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN5894">5894</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN5895">5895</td><td class="line">        alloclhs=decRoundOperand(lhs, set, status);</td></tr>
<tr><td class="num" id="LN5896">5896</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5897">5897</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN5898">5898</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5899">5899</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;reqdigits) { <span class='comment'>/* [this only checks lostDigits]  */</span></td></tr>
<tr><td class="num" id="LN5900">5900</td><td class="line">        allocrhs=decRoundOperand(rhs, set, status);</td></tr>
<tr><td class="num" id="LN5901">5901</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5902">5902</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN5903">5903</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5904">5904</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5905">5905</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5906">5906</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN5907">5907</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5908">5908</td><td class="line">    <span class='comment'>/* Handle special values  */</span></td></tr>
<tr><td class="num" id="LN5909">5909</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span>) {</td></tr>
<tr><td class="num" id="LN5910">5910</td><td class="line">      <span class='comment'>/* NaNs get usual processing  */</span></td></tr>
<tr><td class="num" id="LN5911">5911</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>SPECIALARGS<span class='expansion'>((lhs-&gt;bits | rhs-&gt;bits) &amp; (0x40|0x20|0x10))</span></span> &amp; (<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span> | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>))</td></tr>
<tr><td class="num" id="LN5912">5912</td><td class="line">        decNaNs(res, lhs, rhs, set, status);</td></tr>
<tr><td class="num" id="LN5913">5913</td><td class="line">      <span class='comment'>/* one infinity but not both is bad  */</span></td></tr>
<tr><td class="num" id="LN5914">5914</td><td class="line">      <span class='keyword'>else</span> <span class='keyword'>if</span> ((lhs-&gt;bits ^ rhs-&gt;bits) &amp; <span class='macro'>DECINF<span class='expansion'>0x40</span></span>)</td></tr>
<tr><td class="num" id="LN5915">5915</td><td class="line">        *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5916">5916</td><td class="line">      <span class='comment'>/* both infinity: return lhs  */</span></td></tr>
<tr><td class="num" id="LN5917">5917</td><td class="line">      <span class='keyword'>else</span> <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);          <span class='comment'>/* [nop if in place]  */</span></td></tr>
<tr><td class="num" id="LN5918">5918</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5919">5919</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5920">5920</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5921">5921</td><td class="line">    <span class='comment'>/* set requested exponent  */</span></td></tr>
<tr><td class="num" id="LN5922">5922</td><td class="line">    <span class='keyword'>if</span> (quant) reqexp=inrhs-&gt;exponent;  <span class='comment'>/* quantize -- match exponents  */</span></td></tr>
<tr><td class="num" id="LN5923">5923</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* rescale -- use value of rhs  */</span></td></tr>
<tr><td class="num" id="LN5924">5924</td><td class="line">      <span class='comment'>/* Original rhs must be an integer that fits and is in range,  */</span></td></tr>
<tr><td class="num" id="LN5925">5925</td><td class="line">      <span class='comment'>/* which could be from -1999999997 to +999999999, thanks to  */</span></td></tr>
<tr><td class="num" id="LN5926">5926</td><td class="line">      <span class='comment'>/* subnormals  */</span></td></tr>
<tr><td class="num" id="LN5927">5927</td><td class="line">      reqexp=decGetInt(inrhs);               <span class='comment'>/* [cannot fail]  */</span></td></tr>
<tr><td class="num" id="LN5928">5928</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5929">5929</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5930">5930</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5931">5931</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) etiny=set-&gt;emin;     <span class='comment'>/* no subnormals  */</span></td></tr>
<tr><td class="num" id="LN5932">5932</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5933">5933</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5934">5934</td><td class="line">    <span class='keyword'>if</span> (reqexp==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>                       <span class='comment'>/* bad (rescale only) or ..  */</span></td></tr>
<tr><td class="num" id="LN5935">5935</td><td class="line">     || reqexp==<span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span> || reqexp==<span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span>    <span class='comment'>/* very big (ditto) or ..  */</span></td></tr>
<tr><td class="num" id="LN5936">5936</td><td class="line">     || (reqexp&lt;etiny)                       <span class='comment'>/* &lt; lowest  */</span></td></tr>
<tr><td class="num" id="LN5937">5937</td><td class="line">     || (reqexp&gt;set-&gt;emax)) {                <span class='comment'>/* &gt; emax  */</span></td></tr>
<tr><td class="num" id="LN5938">5938</td><td class="line">      *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5939">5939</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN5940">5940</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5941">5941</td><td class="line">    <span class='comment'>/* the RHS has been processed, so it can be overwritten now if necessary  */</span></td></tr>
<tr><td class="num" id="LN5942">5942</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                       <span class='comment'>/* zero coefficient unchanged  */</span></td></tr>
<tr><td class="num" id="LN5943">5943</td><td class="line">      <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);               <span class='comment'>/* [nop if in place]  */</span></td></tr>
<tr><td class="num" id="LN5944">5944</td><td class="line">      res-&gt;exponent=reqexp;                  <span class='comment'>/* .. just set exponent  */</span></td></tr>
<tr><td class="num" id="LN5945">5945</td><td class="line">      <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5946">5946</td><td class="line">      <span class='keyword'>if</span> (!set-&gt;extended) res-&gt;bits=0;       <span class='comment'>/* subset specification; no -0  */</span></td></tr>
<tr><td class="num" id="LN5947">5947</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5948">5948</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN5949">5949</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* non-zero lhs  */</span></td></tr>
<tr><td class="num" id="LN5950">5950</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> adjust=reqexp-lhs-&gt;exponent;       <span class='comment'>/* digit adjustment needed  */</span></td></tr>
<tr><td class="num" id="LN5951">5951</td><td class="line">      <span class='comment'>/* if adjusted coefficient will definitely not fit, give up now  */</span></td></tr>
<tr><td class="num" id="LN5952">5952</td><td class="line">      <span class='keyword'>if</span> ((lhs-&gt;digits-adjust)&gt;reqdigits) {</td></tr>
<tr><td class="num" id="LN5953">5953</td><td class="line">        *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5954">5954</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5955">5955</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN5956">5956</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5957">5957</td><td class="line">      <span class='keyword'>if</span> (adjust&gt;0) {                        <span class='comment'>/* increasing exponent  */</span></td></tr>
<tr><td class="num" id="LN5958">5958</td><td class="line">        <span class='comment'>/* this will decrease the length of the coefficient by adjust  */</span></td></tr>
<tr><td class="num" id="LN5959">5959</td><td class="line">        <span class='comment'>/* digits, and must round as it does so  */</span></td></tr>
<tr><td class="num" id="LN5960">5960</td><td class="line">        decContext workset;                  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN5961">5961</td><td class="line">        workset=*set;                        <span class='comment'>/* clone rounding, etc.  */</span></td></tr>
<tr><td class="num" id="LN5962">5962</td><td class="line">        workset.digits=lhs-&gt;digits-adjust;   <span class='comment'>/* set requested length  */</span></td></tr>
<tr><td class="num" id="LN5963">5963</td><td class="line">        <span class='comment'>/* [note that the latter can be &lt;1, here]  */</span></td></tr>
<tr><td class="num" id="LN5964">5964</td><td class="line">        decCopyFit(res, lhs, &amp;workset, &amp;residue, status); <span class='comment'>/* fit to result  */</span></td></tr>
<tr><td class="num" id="LN5965">5965</td><td class="line">        decApplyRound(res, &amp;workset, residue, status);    <span class='comment'>/* .. and round  */</span></td></tr>
<tr><td class="num" id="LN5966">5966</td><td class="line">        residue=0;                                        <span class='comment'>/* [used]  */</span></td></tr>
<tr><td class="num" id="LN5967">5967</td><td class="line">        <span class='comment'>/* If just rounded a 999s case, exponent will be off by one;  */</span></td></tr>
<tr><td class="num" id="LN5968">5968</td><td class="line">        <span class='comment'>/* adjust back (after checking space), if so.  */</span></td></tr>
<tr><td class="num" id="LN5969">5969</td><td class="line">        <span class='keyword'>if</span> (res-&gt;exponent&gt;reqexp) {</td></tr>
<tr><td class="num" id="LN5970">5970</td><td class="line">          <span class='comment'>/* re-check needed, e.g., for quantize(0.9999, 0.001) under  */</span></td></tr>
<tr><td class="num" id="LN5971">5971</td><td class="line">          <span class='comment'>/* set-&gt;digits==3  */</span></td></tr>
<tr><td class="num" id="LN5972">5972</td><td class="line">          <span class='keyword'>if</span> (res-&gt;digits==reqdigits) {      <span class='comment'>/* cannot shift by 1  */</span></td></tr>
<tr><td class="num" id="LN5973">5973</td><td class="line">            *status&amp;=~(<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>); <span class='comment'>/* [clean these]  */</span></td></tr>
<tr><td class="num" id="LN5974">5974</td><td class="line">            *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN5975">5975</td><td class="line">            <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN5976">5976</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN5977">5977</td><td class="line">          res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, 1); <span class='comment'>/* shift  */</span></td></tr>
<tr><td class="num" id="LN5978">5978</td><td class="line">          res-&gt;exponent--;                   <span class='comment'>/* (re)adjust the exponent.  */</span></td></tr>
<tr><td class="num" id="LN5979">5979</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5980">5980</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN5981">5981</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>ISZERO(res)<span class='expansion'>(*(res)-&gt;lsu==0 &amp;&amp; (res)-&gt;digits==1 &amp;&amp; (<br>((res)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span> &amp;&amp; !set-&gt;extended) res-&gt;bits=0; <span class='comment'>/* subset; no -0  */</span></td></tr>
<tr><td class="num" id="LN5982">5982</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN5983">5983</td><td class="line">        } <span class='comment'>/* increase  */</span></td></tr>
<tr><td class="num" id="LN5984">5984</td><td class="line">       <span class='keyword'>else</span> <span class='comment'>/* adjust&lt;=0 */</span> {                <span class='comment'>/* decreasing or = exponent  */</span></td></tr>
<tr><td class="num" id="LN5985">5985</td><td class="line">        <span class='comment'>/* this will increase the length of the coefficient by -adjust  */</span></td></tr>
<tr><td class="num" id="LN5986">5986</td><td class="line">        <span class='comment'>/* digits, by adding zero or more trailing zeros; this is  */</span></td></tr>
<tr><td class="num" id="LN5987">5987</td><td class="line">        <span class='comment'>/* already checked for fit, above  */</span></td></tr>
<tr><td class="num" id="LN5988">5988</td><td class="line">        <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs);             <span class='comment'>/* [it will fit]  */</span></td></tr>
<tr><td class="num" id="LN5989">5989</td><td class="line">        <span class='comment'>/* if padding needed (adjust&lt;0), add it now...  */</span></td></tr>
<tr><td class="num" id="LN5990">5990</td><td class="line">        <span class='keyword'>if</span> (adjust&lt;0) {</td></tr>
<tr><td class="num" id="LN5991">5991</td><td class="line">          res-&gt;digits=decShiftToMost(res-&gt;lsu, res-&gt;digits, -adjust);</td></tr>
<tr><td class="num" id="LN5992">5992</td><td class="line">          res-&gt;exponent+=adjust;             <span class='comment'>/* adjust the exponent  */</span></td></tr>
<tr><td class="num" id="LN5993">5993</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN5994">5994</td><td class="line">        } <span class='comment'>/* decrease  */</span></td></tr>
<tr><td class="num" id="LN5995">5995</td><td class="line">      } <span class='comment'>/* non-zero  */</span></td></tr>
<tr><td class="num" id="LN5996">5996</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5997">5997</td><td class="line">    <span class='comment'>/* Check for overflow [do not use Finalize in this case, as an  */</span></td></tr>
<tr><td class="num" id="LN5998">5998</td><td class="line">    <span class='comment'>/* overflow here is a "don't fit" situation]  */</span></td></tr>
<tr><td class="num" id="LN5999">5999</td><td class="line">    <span class='keyword'>if</span> (res-&gt;exponent&gt;set-&gt;emax-res-&gt;digits+1) {  <span class='comment'>/* too big  */</span></td></tr>
<tr><td class="num" id="LN6000">6000</td><td class="line">      *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN6001">6001</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6002">6002</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6003">6003</td><td class="line">     <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN6004">6004</td><td class="line">      decFinalize(res, set, &amp;residue, status);    <span class='comment'>/* set subnormal flags  */</span></td></tr>
<tr><td class="num" id="LN6005">6005</td><td class="line">      *status&amp;=~<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>;          <span class='comment'>/* suppress Underflow [as per 754]  */</span></td></tr>
<tr><td class="num" id="LN6006">6006</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6007">6007</td><td class="line">    } <span class='keyword'>while</span>(0);                         <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN6008">6008</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6009">6009</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6010">6010</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN6011">6011</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6012">6012</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6013">6013</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN6014">6014</td><td class="line">  } <span class='comment'>/* decQuantizeOp  */</span></td></tr>
<tr><td class="num" id="LN6015">6015</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6016">6016</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6017">6017</td><td class="line"><span class='comment'>/* decCompareOp -- compare, min, or max two Numbers                   */</span></td></tr>
<tr><td class="num" id="LN6018">6018</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6019">6019</td><td class="line"><span class='comment'>/*   This computes C = A ? B and carries out one of four operations:  */</span></td></tr>
<tr><td class="num" id="LN6020">6020</td><td class="line"><span class='comment'>/*     COMPARE    -- returns the signum (as a number) giving the      */</span></td></tr>
<tr><td class="num" id="LN6021">6021</td><td class="line"><span class='comment'>/*                   result of a comparison unless one or both        */</span></td></tr>
<tr><td class="num" id="LN6022">6022</td><td class="line"><span class='comment'>/*                   operands is a NaN (in which case a NaN results)  */</span></td></tr>
<tr><td class="num" id="LN6023">6023</td><td class="line"><span class='comment'>/*     COMPSIG    -- as COMPARE except that a quiet NaN raises        */</span></td></tr>
<tr><td class="num" id="LN6024">6024</td><td class="line"><span class='comment'>/*                   Invalid operation.                               */</span></td></tr>
<tr><td class="num" id="LN6025">6025</td><td class="line"><span class='comment'>/*     COMPMAX    -- returns the larger of the operands, using the    */</span></td></tr>
<tr><td class="num" id="LN6026">6026</td><td class="line"><span class='comment'>/*                   754 maxnum operation                             */</span></td></tr>
<tr><td class="num" id="LN6027">6027</td><td class="line"><span class='comment'>/*     COMPMAXMAG -- ditto, comparing absolute values                 */</span></td></tr>
<tr><td class="num" id="LN6028">6028</td><td class="line"><span class='comment'>/*     COMPMIN    -- the 754 minnum operation                         */</span></td></tr>
<tr><td class="num" id="LN6029">6029</td><td class="line"><span class='comment'>/*     COMPMINMAG -- ditto, comparing absolute values                 */</span></td></tr>
<tr><td class="num" id="LN6030">6030</td><td class="line"><span class='comment'>/*     COMTOTAL   -- returns the signum (as a number) giving the      */</span></td></tr>
<tr><td class="num" id="LN6031">6031</td><td class="line"><span class='comment'>/*                   result of a comparison using 754 total ordering  */</span></td></tr>
<tr><td class="num" id="LN6032">6032</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6033">6033</td><td class="line"><span class='comment'>/*   res is C, the result.  C may be A and/or B (e.g., X=X?X)         */</span></td></tr>
<tr><td class="num" id="LN6034">6034</td><td class="line"><span class='comment'>/*   lhs is A                                                         */</span></td></tr>
<tr><td class="num" id="LN6035">6035</td><td class="line"><span class='comment'>/*   rhs is B                                                         */</span></td></tr>
<tr><td class="num" id="LN6036">6036</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN6037">6037</td><td class="line"><span class='comment'>/*   op  is the operation flag                                        */</span></td></tr>
<tr><td class="num" id="LN6038">6038</td><td class="line"><span class='comment'>/*   status is the usual accumulator                                  */</span></td></tr>
<tr><td class="num" id="LN6039">6039</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6040">6040</td><td class="line"><span class='comment'>/* C must have space for one digit for COMPARE or set-&gt;digits for     */</span></td></tr>
<tr><td class="num" id="LN6041">6041</td><td class="line"><span class='comment'>/* COMPMAX, COMPMIN, COMPMAXMAG, or COMPMINMAG.                       */</span></td></tr>
<tr><td class="num" id="LN6042">6042</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6043">6043</td><td class="line"><span class='comment'>/* The emphasis here is on speed for common cases, and avoiding       */</span></td></tr>
<tr><td class="num" id="LN6044">6044</td><td class="line"><span class='comment'>/* coefficient comparison if possible.                                */</span></td></tr>
<tr><td class="num" id="LN6045">6045</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6046">6046</td><td class="line"><span class='keyword'>static</span> decNumber * decCompareOp(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN6047">6047</td><td class="line">                         <span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN6048">6048</td><td class="line">                         <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> op, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN6049">6049</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6050">6050</td><td class="line">  decNumber *alloclhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* non-NULL if rounded lhs allocated  */</span></td></tr>
<tr><td class="num" id="LN6051">6051</td><td class="line">  decNumber *allocrhs=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;        <span class='comment'>/* .., rhs  */</span></td></tr>
<tr><td class="num" id="LN6052">6052</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6053">6053</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   result=0;                  <span class='comment'>/* default result value  */</span></td></tr>
<tr><td class="num" id="LN6054">6054</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> merged;                    <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6055">6055</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6056">6056</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6057">6057</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(res, lhs, rhs, set)) <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN6058">6058</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6059">6059</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6060">6060</td><td class="line">  <span class='keyword'>do</span> {                             <span class='comment'>/* protect allocated storage  */</span></td></tr>
<tr><td class="num" id="LN6061">6061</td><td class="line">    <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6062">6062</td><td class="line">    <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN6063">6063</td><td class="line">      <span class='comment'>/* reduce operands and set lostDigits status, as needed  */</span></td></tr>
<tr><td class="num" id="LN6064">6064</td><td class="line">      <span class='keyword'>if</span> (lhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN6065">6065</td><td class="line">        alloclhs=decRoundOperand(lhs, set, status);</td></tr>
<tr><td class="num" id="LN6066">6066</td><td class="line">        <span class='keyword'>if</span> (alloclhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {result=<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>; <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN6067">6067</td><td class="line">        lhs=alloclhs;</td></tr>
<tr><td class="num" id="LN6068">6068</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6069">6069</td><td class="line">      <span class='keyword'>if</span> (rhs-&gt;digits&gt;set-&gt;digits) {</td></tr>
<tr><td class="num" id="LN6070">6070</td><td class="line">        allocrhs=decRoundOperand(rhs, set, status);</td></tr>
<tr><td class="num" id="LN6071">6071</td><td class="line">        <span class='keyword'>if</span> (allocrhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {result=<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>; <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN6072">6072</td><td class="line">        rhs=allocrhs;</td></tr>
<tr><td class="num" id="LN6073">6073</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6074">6074</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6075">6075</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6076">6076</td><td class="line">    <span class='comment'>/* [following code does not require input rounding]  */</span></td></tr>
<tr><td class="num" id="LN6077">6077</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6078">6078</td><td class="line">    <span class='comment'>/* If total ordering then handle differing signs 'up front'  */</span></td></tr>
<tr><td class="num" id="LN6079">6079</td><td class="line">    <span class='keyword'>if</span> (op==<span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>) {                <span class='comment'>/* total ordering  */</span></td></tr>
<tr><td class="num" id="LN6080">6080</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span> &amp;&amp; !<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN6081">6081</td><td class="line">        result=-1;</td></tr>
<tr><td class="num" id="LN6082">6082</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6083">6083</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6084">6084</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span> &amp;&amp; <span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN6085">6085</td><td class="line">        result=+1;</td></tr>
<tr><td class="num" id="LN6086">6086</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6087">6087</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6088">6088</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6089">6089</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6090">6090</td><td class="line">    <span class='comment'>/* handle NaNs specially; let infinities drop through  */</span></td></tr>
<tr><td class="num" id="LN6091">6091</td><td class="line">    <span class='comment'>/* This assumes sNaN (even just one) leads to NaN.  */</span></td></tr>
<tr><td class="num" id="LN6092">6092</td><td class="line">    merged=(lhs-&gt;bits | rhs-&gt;bits) &amp; (<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span> | <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>);</td></tr>
<tr><td class="num" id="LN6093">6093</td><td class="line">    <span class='keyword'>if</span> (merged) {                       <span class='comment'>/* a NaN bit set  */</span></td></tr>
<tr><td class="num" id="LN6094">6094</td><td class="line">      <span class='keyword'>if</span> (op==<span class='macro'>COMPARE<span class='expansion'>0x01</span></span>);                 <span class='comment'>/* result will be NaN  */</span></td></tr>
<tr><td class="num" id="LN6095">6095</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (op==<span class='macro'>COMPSIG<span class='expansion'>0x06</span></span>)            <span class='comment'>/* treat qNaN as sNaN  */</span></td></tr>
<tr><td class="num" id="LN6096">6096</td><td class="line">        *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span> | <span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;</td></tr>
<tr><td class="num" id="LN6097">6097</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (op==<span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>) {        <span class='comment'>/* total ordering, always finite  */</span></td></tr>
<tr><td class="num" id="LN6098">6098</td><td class="line">        <span class='comment'>/* signs are known to be the same; compute the ordering here  */</span></td></tr>
<tr><td class="num" id="LN6099">6099</td><td class="line">        <span class='comment'>/* as if the signs are both positive, then invert for negatives  */</span></td></tr>
<tr><td class="num" id="LN6100">6100</td><td class="line">        <span class='keyword'>if</span> (!<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) result=-1;</td></tr>
<tr><td class="num" id="LN6101">6101</td><td class="line">         <span class='keyword'>else</span> <span class='keyword'>if</span> (!<span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) result=+1;</td></tr>
<tr><td class="num" id="LN6102">6102</td><td class="line">         <span class='comment'>/* here if both NaNs  */</span></td></tr>
<tr><td class="num" id="LN6103">6103</td><td class="line">         <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsSNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x10))!=0)</span></span> &amp;&amp; <span class='macro'>decNumberIsQNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20))!=0)</span></span>) result=-1;</td></tr>
<tr><td class="num" id="LN6104">6104</td><td class="line">         <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsQNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20))!=0)</span></span> &amp;&amp; <span class='macro'>decNumberIsSNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x10))!=0)</span></span>) result=+1;</td></tr>
<tr><td class="num" id="LN6105">6105</td><td class="line">         <span class='keyword'>else</span> { <span class='comment'>/* both NaN or both sNaN  */</span></td></tr>
<tr><td class="num" id="LN6106">6106</td><td class="line">          <span class='comment'>/* now it just depends on the payload  */</span></td></tr>
<tr><td class="num" id="LN6107">6107</td><td class="line">          result=decUnitCompare(lhs-&gt;lsu, <span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN6108">6108</td><td class="line">                                rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>, 0);</td></tr>
<tr><td class="num" id="LN6109">6109</td><td class="line">          <span class='comment'>/* [Error not possible, as these are 'aligned']  */</span></td></tr>
<tr><td class="num" id="LN6110">6110</td><td class="line">          } <span class='comment'>/* both same NaNs  */</span></td></tr>
<tr><td class="num" id="LN6111">6111</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) result=-result;</td></tr>
<tr><td class="num" id="LN6112">6112</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6113">6113</td><td class="line">        } <span class='comment'>/* total order  */</span></td></tr>
<tr><td class="num" id="LN6114">6114</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6115">6115</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (merged &amp; <span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>);           <span class='comment'>/* sNaN -&gt; qNaN  */</span></td></tr>
<tr><td class="num" id="LN6116">6116</td><td class="line">       <span class='keyword'>else</span> { <span class='comment'>/* here if MIN or MAX and one or two quiet NaNs  */</span></td></tr>
<tr><td class="num" id="LN6117">6117</td><td class="line">        <span class='comment'>/* min or max -- 754 rules ignore single NaN  */</span></td></tr>
<tr><td class="num" id="LN6118">6118</td><td class="line">        <span class='keyword'>if</span> (!<span class='macro'>decNumberIsNaN(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span> || !<span class='macro'>decNumberIsNaN(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;(0x20|0x10))!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN6119">6119</td><td class="line">          <span class='comment'>/* just one NaN; force choice to be the non-NaN operand  */</span></td></tr>
<tr><td class="num" id="LN6120">6120</td><td class="line">          op=<span class='macro'>COMPMAX<span class='expansion'>0x02</span></span>;</td></tr>
<tr><td class="num" id="LN6121">6121</td><td class="line">          <span class='keyword'>if</span> (lhs-&gt;bits &amp; <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>) result=-1; <span class='comment'>/* pick rhs  */</span></td></tr>
<tr><td class="num" id="LN6122">6122</td><td class="line">                             <span class='keyword'>else</span> result=+1; <span class='comment'>/* pick lhs  */</span></td></tr>
<tr><td class="num" id="LN6123">6123</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6124">6124</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN6125">6125</td><td class="line">        } <span class='comment'>/* max or min  */</span></td></tr>
<tr><td class="num" id="LN6126">6126</td><td class="line">      op=<span class='macro'>COMPNAN<span class='expansion'>0x05</span></span>;                            <span class='comment'>/* use special path  */</span></td></tr>
<tr><td class="num" id="LN6127">6127</td><td class="line">      decNaNs(res, lhs, rhs, set, status);   <span class='comment'>/* propagate NaN  */</span></td></tr>
<tr><td class="num" id="LN6128">6128</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6129">6129</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6130">6130</td><td class="line">    <span class='comment'>/* have numbers  */</span></td></tr>
<tr><td class="num" id="LN6131">6131</td><td class="line">    <span class='keyword'>if</span> (op==<span class='macro'>COMPMAXMAG<span class='expansion'>0x07</span></span> || op==<span class='macro'>COMPMINMAG<span class='expansion'>0x08</span></span>) result=decCompare(lhs, rhs, 1);</td></tr>
<tr><td class="num" id="LN6132">6132</td><td class="line">     <span class='keyword'>else</span> result=decCompare(lhs, rhs, 0);    <span class='comment'>/* sign matters  */</span></td></tr>
<tr><td class="num" id="LN6133">6133</td><td class="line">    } <span class='keyword'>while</span>(0);                              <span class='comment'>/* end protected  */</span></td></tr>
<tr><td class="num" id="LN6134">6134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6135">6135</td><td class="line">  <span class='keyword'>if</span> (result==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>; <span class='comment'>/* rare  */</span></td></tr>
<tr><td class="num" id="LN6136">6136</td><td class="line">   <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN6137">6137</td><td class="line">    <span class='keyword'>if</span> (op==<span class='macro'>COMPARE<span class='expansion'>0x01</span></span> || op==<span class='macro'>COMPSIG<span class='expansion'>0x06</span></span> ||op==<span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span>) { <span class='comment'>/* returning signum  */</span></td></tr>
<tr><td class="num" id="LN6138">6138</td><td class="line">      <span class='keyword'>if</span> (op==<span class='macro'>COMPTOTAL<span class='expansion'>0x04</span></span> &amp;&amp; result==0) {</td></tr>
<tr><td class="num" id="LN6139">6139</td><td class="line">        <span class='comment'>/* operands are numerically equal or same NaN (and same sign,  */</span></td></tr>
<tr><td class="num" id="LN6140">6140</td><td class="line">        <span class='comment'>/* tested first); if identical, leave result 0  */</span></td></tr>
<tr><td class="num" id="LN6141">6141</td><td class="line">        <span class='keyword'>if</span> (lhs-&gt;exponent!=rhs-&gt;exponent) {</td></tr>
<tr><td class="num" id="LN6142">6142</td><td class="line">          <span class='keyword'>if</span> (lhs-&gt;exponent&lt;rhs-&gt;exponent) result=-1;</td></tr>
<tr><td class="num" id="LN6143">6143</td><td class="line">           <span class='keyword'>else</span> result=+1;</td></tr>
<tr><td class="num" id="LN6144">6144</td><td class="line">          <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) result=-result;</td></tr>
<tr><td class="num" id="LN6145">6145</td><td class="line">          } <span class='comment'>/* lexp!=rexp  */</span></td></tr>
<tr><td class="num" id="LN6146">6146</td><td class="line">        } <span class='comment'>/* total-order by exponent  */</span></td></tr>
<tr><td class="num" id="LN6147">6147</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);               <span class='comment'>/* [always a valid result]  */</span></td></tr>
<tr><td class="num" id="LN6148">6148</td><td class="line">      <span class='keyword'>if</span> (result!=0) {                  <span class='comment'>/* must be -1 or +1  */</span></td></tr>
<tr><td class="num" id="LN6149">6149</td><td class="line">        *res-&gt;lsu=1;</td></tr>
<tr><td class="num" id="LN6150">6150</td><td class="line">        <span class='keyword'>if</span> (result&lt;0) res-&gt;bits=<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;</td></tr>
<tr><td class="num" id="LN6151">6151</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6152">6152</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6153">6153</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>if</span> (op==<span class='macro'>COMPNAN<span class='expansion'>0x05</span></span>);             <span class='comment'>/* special, drop through  */</span></td></tr>
<tr><td class="num" id="LN6154">6154</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* MAX or MIN, non-NaN result  */</span></td></tr>
<tr><td class="num" id="LN6155">6155</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> residue=0;                    <span class='comment'>/* rounding accumulator  */</span></td></tr>
<tr><td class="num" id="LN6156">6156</td><td class="line">      <span class='comment'>/* choose the operand for the result  */</span></td></tr>
<tr><td class="num" id="LN6157">6157</td><td class="line">      <span class='keyword'>const</span> decNumber *choice;</td></tr>
<tr><td class="num" id="LN6158">6158</td><td class="line">      <span class='keyword'>if</span> (result==0) { <span class='comment'>/* operands are numerically equal  */</span></td></tr>
<tr><td class="num" id="LN6159">6159</td><td class="line">        <span class='comment'>/* choose according to sign then exponent (see 754)  */</span></td></tr>
<tr><td class="num" id="LN6160">6160</td><td class="line">        <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> slhs=(lhs-&gt;bits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);</td></tr>
<tr><td class="num" id="LN6161">6161</td><td class="line">        <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> srhs=(rhs-&gt;bits &amp; <span class='macro'>DECNEG<span class='expansion'>0x80</span></span>);</td></tr>
<tr><td class="num" id="LN6162">6162</td><td class="line">        <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6163">6163</td><td class="line">        <span class='keyword'>if</span> (!set-&gt;extended) {           <span class='comment'>/* subset: force left-hand  */</span></td></tr>
<tr><td class="num" id="LN6164">6164</td><td class="line">          op=<span class='macro'>COMPMAX<span class='expansion'>0x02</span></span>;</td></tr>
<tr><td class="num" id="LN6165">6165</td><td class="line">          result=+1;</td></tr>
<tr><td class="num" id="LN6166">6166</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN6167">6167</td><td class="line">        <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN6168">6168</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6169">6169</td><td class="line">        <span class='keyword'>if</span> (slhs!=srhs) {          <span class='comment'>/* signs differ  */</span></td></tr>
<tr><td class="num" id="LN6170">6170</td><td class="line">          <span class='keyword'>if</span> (slhs) result=-1;     <span class='comment'>/* rhs is max  */</span></td></tr>
<tr><td class="num" id="LN6171">6171</td><td class="line">               <span class='keyword'>else</span> result=+1;     <span class='comment'>/* lhs is max  */</span></td></tr>
<tr><td class="num" id="LN6172">6172</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN6173">6173</td><td class="line">         <span class='keyword'>else</span> <span class='keyword'>if</span> (slhs &amp;&amp; srhs) {  <span class='comment'>/* both negative  */</span></td></tr>
<tr><td class="num" id="LN6174">6174</td><td class="line">          <span class='keyword'>if</span> (lhs-&gt;exponent&lt;rhs-&gt;exponent) result=+1;</td></tr>
<tr><td class="num" id="LN6175">6175</td><td class="line">                                      <span class='keyword'>else</span> result=-1;</td></tr>
<tr><td class="num" id="LN6176">6176</td><td class="line">          <span class='comment'>/* [if equal, use lhs, technically identical]  */</span></td></tr>
<tr><td class="num" id="LN6177">6177</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN6178">6178</td><td class="line">         <span class='keyword'>else</span> {                    <span class='comment'>/* both positive  */</span></td></tr>
<tr><td class="num" id="LN6179">6179</td><td class="line">          <span class='keyword'>if</span> (lhs-&gt;exponent&gt;rhs-&gt;exponent) result=+1;</td></tr>
<tr><td class="num" id="LN6180">6180</td><td class="line">                                      <span class='keyword'>else</span> result=-1;</td></tr>
<tr><td class="num" id="LN6181">6181</td><td class="line">          <span class='comment'>/* [ditto]  */</span></td></tr>
<tr><td class="num" id="LN6182">6182</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN6183">6183</td><td class="line">        } <span class='comment'>/* numerically equal  */</span></td></tr>
<tr><td class="num" id="LN6184">6184</td><td class="line">      <span class='comment'>/* here result will be non-0; reverse if looking for MIN  */</span></td></tr>
<tr><td class="num" id="LN6185">6185</td><td class="line">      <span class='keyword'>if</span> (op==<span class='macro'>COMPMIN<span class='expansion'>0x03</span></span> || op==<span class='macro'>COMPMINMAG<span class='expansion'>0x08</span></span>) result=-result;</td></tr>
<tr><td class="num" id="LN6186">6186</td><td class="line">      choice=(result&gt;0 ? lhs : rhs);    <span class='comment'>/* choose  */</span></td></tr>
<tr><td class="num" id="LN6187">6187</td><td class="line">      <span class='comment'>/* copy chosen to result, rounding if need be  */</span></td></tr>
<tr><td class="num" id="LN6188">6188</td><td class="line">      decCopyFit(res, choice, set, &amp;residue, status);</td></tr>
<tr><td class="num" id="LN6189">6189</td><td class="line">      <span class='macro'>decFinish(res, set, &amp;residue, status)<span class='expansion'>decFinalize(res,set,&amp;residue,status)</span></span>;</td></tr>
<tr><td class="num" id="LN6190">6190</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6191">6191</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6192">6192</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6193">6193</td><td class="line">  <span class='keyword'>if</span> (allocrhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocrhs)<span class='expansion'>uprv_free_54(allocrhs)</span></span>;   <span class='comment'>/* free any storage used  */</span></td></tr>
<tr><td class="num" id="LN6194">6194</td><td class="line">  <span class='keyword'>if</span> (alloclhs!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(alloclhs)<span class='expansion'>uprv_free_54(alloclhs)</span></span>;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6195">6195</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6196">6196</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN6197">6197</td><td class="line">  } <span class='comment'>/* decCompareOp  */</span></td></tr>
<tr><td class="num" id="LN6198">6198</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6199">6199</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6200">6200</td><td class="line"><span class='comment'>/* decCompare -- compare two decNumbers by numerical value            */</span></td></tr>
<tr><td class="num" id="LN6201">6201</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6202">6202</td><td class="line"><span class='comment'>/*  This routine compares A ? B without altering them.                */</span></td></tr>
<tr><td class="num" id="LN6203">6203</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6204">6204</td><td class="line"><span class='comment'>/*  Arg1 is A, a decNumber which is not a NaN                         */</span></td></tr>
<tr><td class="num" id="LN6205">6205</td><td class="line"><span class='comment'>/*  Arg2 is B, a decNumber which is not a NaN                         */</span></td></tr>
<tr><td class="num" id="LN6206">6206</td><td class="line"><span class='comment'>/*  Arg3 is 1 for a sign-independent compare, 0 otherwise             */</span></td></tr>
<tr><td class="num" id="LN6207">6207</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6208">6208</td><td class="line"><span class='comment'>/*  returns -1, 0, or 1 for A&lt;B, A==B, or A&gt;B, or BADINT if failure   */</span></td></tr>
<tr><td class="num" id="LN6209">6209</td><td class="line"><span class='comment'>/*  (the only possible failure is an allocation error)                */</span></td></tr>
<tr><td class="num" id="LN6210">6210</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6211">6211</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decCompare(<span class='keyword'>const</span> decNumber *lhs, <span class='keyword'>const</span> decNumber *rhs,</td></tr>
<tr><td class="num" id="LN6212">6212</td><td class="line">                      <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> abs_c) {</td></tr>
<tr><td class="num" id="LN6213">6213</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   result;                    <span class='comment'>/* result value  */</span></td></tr>
<tr><td class="num" id="LN6214">6214</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   sigr;                      <span class='comment'>/* rhs signum  */</span></td></tr>
<tr><td class="num" id="LN6215">6215</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   compare;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6216">6216</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6217">6217</td><td class="line">  result=1;                                  <span class='comment'>/* assume signum(lhs)  */</span></td></tr>
<tr><td class="num" id="LN6218">6218</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ISZERO(lhs)<span class='expansion'>(*(lhs)-&gt;lsu==0 &amp;&amp; (lhs)-&gt;digits==1 &amp;&amp; (<br>((lhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) result=0;</td></tr>
<tr><td class="num" id="LN6219">6219</td><td class="line">  <span class='keyword'>if</span> (abs_c) {</td></tr>
<tr><td class="num" id="LN6220">6220</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>return</span> result;          <span class='comment'>/* LHS wins or both 0  */</span></td></tr>
<tr><td class="num" id="LN6221">6221</td><td class="line">    <span class='comment'>/* RHS is non-zero  */</span></td></tr>
<tr><td class="num" id="LN6222">6222</td><td class="line">    <span class='keyword'>if</span> (result==0) <span class='keyword'>return</span> -1;                <span class='comment'>/* LHS is 0; RHS wins  */</span></td></tr>
<tr><td class="num" id="LN6223">6223</td><td class="line">    <span class='comment'>/* [here, both non-zero, result=1]  */</span></td></tr>
<tr><td class="num" id="LN6224">6224</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6225">6225</td><td class="line">   <span class='keyword'>else</span> {                                    <span class='comment'>/* signs matter  */</span></td></tr>
<tr><td class="num" id="LN6226">6226</td><td class="line">    <span class='keyword'>if</span> (result &amp;&amp; <span class='macro'>decNumberIsNegative(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x80)!=0)</span></span>) result=-1;</td></tr>
<tr><td class="num" id="LN6227">6227</td><td class="line">    sigr=1;                                  <span class='comment'>/* compute signum(rhs)  */</span></td></tr>
<tr><td class="num" id="LN6228">6228</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) sigr=0;</td></tr>
<tr><td class="num" id="LN6229">6229</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x80)!=0)</span></span>) sigr=-1;</td></tr>
<tr><td class="num" id="LN6230">6230</td><td class="line">    <span class='keyword'>if</span> (result &gt; sigr) <span class='keyword'>return</span> +1;            <span class='comment'>/* L &gt; R, return 1  */</span></td></tr>
<tr><td class="num" id="LN6231">6231</td><td class="line">    <span class='keyword'>if</span> (result &lt; sigr) <span class='keyword'>return</span> -1;            <span class='comment'>/* L &lt; R, return -1  */</span></td></tr>
<tr><td class="num" id="LN6232">6232</td><td class="line">    <span class='keyword'>if</span> (result==0) <span class='keyword'>return</span> 0;                   <span class='comment'>/* both 0  */</span></td></tr>
<tr><td class="num" id="LN6233">6233</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6234">6234</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6235">6235</td><td class="line">  <span class='comment'>/* signums are the same; both are non-zero  */</span></td></tr>
<tr><td class="num" id="LN6236">6236</td><td class="line">  <span class='keyword'>if</span> ((lhs-&gt;bits | rhs-&gt;bits) &amp; <span class='macro'>DECINF<span class='expansion'>0x40</span></span>) {    <span class='comment'>/* one or more infinities  */</span></td></tr>
<tr><td class="num" id="LN6237">6237</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(rhs)<span class='expansion'>(((rhs)-&gt;bits&amp;0x40)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN6238">6238</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(lhs)<span class='expansion'>(((lhs)-&gt;bits&amp;0x40)!=0)</span></span>) result=0;<span class='comment'>/* both infinite  */</span></td></tr>
<tr><td class="num" id="LN6239">6239</td><td class="line">       <span class='keyword'>else</span> result=-result;                  <span class='comment'>/* only rhs infinite  */</span></td></tr>
<tr><td class="num" id="LN6240">6240</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6241">6241</td><td class="line">    <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN6242">6242</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6243">6243</td><td class="line">  <span class='comment'>/* must compare the coefficients, allowing for exponents  */</span></td></tr>
<tr><td class="num" id="LN6244">6244</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;exponent&gt;rhs-&gt;exponent) {         <span class='comment'>/* LHS exponent larger  */</span></td></tr>
<tr><td class="num" id="LN6245">6245</td><td class="line">    <span class='comment'>/* swap sides, and sign  */</span></td></tr>
<tr><td class="num" id="LN6246">6246</td><td class="line">    <span class='keyword'>const</span> decNumber *temp=lhs;</td></tr>
<tr><td class="num" id="LN6247">6247</td><td class="line">    lhs=rhs;</td></tr>
<tr><td class="num" id="LN6248">6248</td><td class="line">    rhs=temp;</td></tr>
<tr><td class="num" id="LN6249">6249</td><td class="line">    result=-result;</td></tr>
<tr><td class="num" id="LN6250">6250</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6251">6251</td><td class="line">  compare=decUnitCompare(lhs-&gt;lsu, <span class='macro'>D2U(lhs-&gt;digits)<span class='expansion'>((lhs-&gt;digits)&lt;=49?d2utable[lhs-&gt;digits]:((lhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN6252">6252</td><td class="line">                         rhs-&gt;lsu, <span class='macro'>D2U(rhs-&gt;digits)<span class='expansion'>((rhs-&gt;digits)&lt;=49?d2utable[rhs-&gt;digits]:((rhs-&gt;digits<br>)+1 -1)/1)</span></span>,</td></tr>
<tr><td class="num" id="LN6253">6253</td><td class="line">                         rhs-&gt;exponent-lhs-&gt;exponent);</td></tr>
<tr><td class="num" id="LN6254">6254</td><td class="line">  <span class='keyword'>if</span> (compare!=<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) compare*=result;      <span class='comment'>/* comparison succeeded  */</span></td></tr>
<tr><td class="num" id="LN6255">6255</td><td class="line">  <span class='keyword'>return</span> compare;</td></tr>
<tr><td class="num" id="LN6256">6256</td><td class="line">  } <span class='comment'>/* decCompare  */</span></td></tr>
<tr><td class="num" id="LN6257">6257</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6258">6258</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6259">6259</td><td class="line"><span class='comment'>/* decUnitCompare -- compare two &gt;=0 integers in Unit arrays          */</span></td></tr>
<tr><td class="num" id="LN6260">6260</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6261">6261</td><td class="line"><span class='comment'>/*  This routine compares A ? B*10**E where A and B are unit arrays   */</span></td></tr>
<tr><td class="num" id="LN6262">6262</td><td class="line"><span class='comment'>/*  A is a plain integer                                              */</span></td></tr>
<tr><td class="num" id="LN6263">6263</td><td class="line"><span class='comment'>/*  B has an exponent of E (which must be non-negative)               */</span></td></tr>
<tr><td class="num" id="LN6264">6264</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6265">6265</td><td class="line"><span class='comment'>/*  Arg1 is A first Unit (lsu)                                        */</span></td></tr>
<tr><td class="num" id="LN6266">6266</td><td class="line"><span class='comment'>/*  Arg2 is A length in Units                                         */</span></td></tr>
<tr><td class="num" id="LN6267">6267</td><td class="line"><span class='comment'>/*  Arg3 is B first Unit (lsu)                                        */</span></td></tr>
<tr><td class="num" id="LN6268">6268</td><td class="line"><span class='comment'>/*  Arg4 is B length in Units                                         */</span></td></tr>
<tr><td class="num" id="LN6269">6269</td><td class="line"><span class='comment'>/*  Arg5 is E (0 if the units are aligned)                            */</span></td></tr>
<tr><td class="num" id="LN6270">6270</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6271">6271</td><td class="line"><span class='comment'>/*  returns -1, 0, or 1 for A&lt;B, A==B, or A&gt;B, or BADINT if failure   */</span></td></tr>
<tr><td class="num" id="LN6272">6272</td><td class="line"><span class='comment'>/*  (the only possible failure is an allocation error, which can      */</span></td></tr>
<tr><td class="num" id="LN6273">6273</td><td class="line"><span class='comment'>/*  only occur if E!=0)                                               */</span></td></tr>
<tr><td class="num" id="LN6274">6274</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6275">6275</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decUnitCompare(<span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *a, <span class='macro'>Int<span class='expansion'>int32_t</span></span> alength,</td></tr>
<tr><td class="num" id="LN6276">6276</td><td class="line">                          <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *b, <span class='macro'>Int<span class='expansion'>int32_t</span></span> blength, <span class='macro'>Int<span class='expansion'>int32_t</span></span> exp) {</td></tr>
<tr><td class="num" id="LN6277">6277</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *acc;                      <span class='comment'>/* accumulator for result  */</span></td></tr>
<tr><td class="num" id="LN6278">6278</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  accbuff[<span class='macro'>SD2U(DECBUFFER*2+1)<span class='expansion'>(((36*2+1)+1 -1)/1)</span></span>]; <span class='comment'>/* local buffer  */</span></td></tr>
<tr><td class="num" id="LN6279">6279</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *allocacc=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;            <span class='comment'>/* -&gt; allocated acc buffer, iff allocated  */</span></td></tr>
<tr><td class="num" id="LN6280">6280</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   accunits, need;            <span class='comment'>/* units in use or needed for acc  */</span></td></tr>
<tr><td class="num" id="LN6281">6281</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *l, *r, *u;           <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6282">6282</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   expunits, exprem, result;  <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6283">6283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6284">6284</td><td class="line">  <span class='keyword'>if</span> (exp==0) {                    <span class='comment'>/* aligned; fastpath  */</span></td></tr>
<tr><td class="num" id="LN6285">6285</td><td class="line">    <span class='keyword'>if</span> (alength&gt;blength) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN6286">6286</td><td class="line">    <span class='keyword'>if</span> (alength&lt;blength) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN6287">6287</td><td class="line">    <span class='comment'>/* same number of units in both -- need unit-by-unit compare  */</span></td></tr>
<tr><td class="num" id="LN6288">6288</td><td class="line">    l=a+alength-1;</td></tr>
<tr><td class="num" id="LN6289">6289</td><td class="line">    r=b+alength-1;</td></tr>
<tr><td class="num" id="LN6290">6290</td><td class="line">    <span class='keyword'>for</span> (;l&gt;=a; l--, r--) {</td></tr>
<tr><td class="num" id="LN6291">6291</td><td class="line">      <span class='keyword'>if</span> (*l&gt;*r) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN6292">6292</td><td class="line">      <span class='keyword'>if</span> (*l&lt;*r) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN6293">6293</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6294">6294</td><td class="line">    <span class='keyword'>return</span> 0;                      <span class='comment'>/* all units match  */</span></td></tr>
<tr><td class="num" id="LN6295">6295</td><td class="line">    } <span class='comment'>/* aligned  */</span></td></tr>
<tr><td class="num" id="LN6296">6296</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6297">6297</td><td class="line">  <span class='comment'>/* Unaligned.  If one is &gt;1 unit longer than the other, padded  */</span></td></tr>
<tr><td class="num" id="LN6298">6298</td><td class="line">  <span class='comment'>/* approximately, then can return easily  */</span></td></tr>
<tr><td class="num" id="LN6299">6299</td><td class="line">  <span class='keyword'>if</span> (alength&gt;blength+(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>D2U(exp)<span class='expansion'>((exp)&lt;=49?d2utable[exp]:((exp)+1 -1)/1)</span></span>) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN6300">6300</td><td class="line">  <span class='keyword'>if</span> (alength+1&lt;blength+(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>D2U(exp)<span class='expansion'>((exp)&lt;=49?d2utable[exp]:((exp)+1 -1)/1)</span></span>) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN6301">6301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6302">6302</td><td class="line">  <span class='comment'>/* Need to do a real subtract.  For this, a result buffer is needed  */</span></td></tr>
<tr><td class="num" id="LN6303">6303</td><td class="line">  <span class='comment'>/* even though only the sign is of interest.  Its length needs  */</span></td></tr>
<tr><td class="num" id="LN6304">6304</td><td class="line">  <span class='comment'>/* to be the larger of alength and padded blength, +2  */</span></td></tr>
<tr><td class="num" id="LN6305">6305</td><td class="line">  need=blength+<span class='macro'>D2U(exp)<span class='expansion'>((exp)&lt;=49?d2utable[exp]:((exp)+1 -1)/1)</span></span>;                <span class='comment'>/* maximum real length of B  */</span></td></tr>
<tr><td class="num" id="LN6306">6306</td><td class="line">  <span class='keyword'>if</span> (need&lt;alength) need=alength;</td></tr>
<tr><td class="num" id="LN6307">6307</td><td class="line">  need+=2;</td></tr>
<tr><td class="num" id="LN6308">6308</td><td class="line">  acc=accbuff;                          <span class='comment'>/* assume use local buffer  */</span></td></tr>
<tr><td class="num" id="LN6309">6309</td><td class="line">  <span class='keyword'>if</span> (need*<span class='keyword'>sizeof</span>(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)&gt;<span class='keyword'>sizeof</span>(accbuff)) {</td></tr>
<tr><td class="num" id="LN6310">6310</td><td class="line">    allocacc=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *)<span class='macro'>malloc(need*<span class='keyword'>sizeof</span>(Unit))<span class='expansion'>uprv_malloc_54(need*sizeof(uint8_t))</span></span>;</td></tr>
<tr><td class="num" id="LN6311">6311</td><td class="line">    <span class='keyword'>if</span> (allocacc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>return</span> <span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>;  <span class='comment'>/* hopeless -- abandon  */</span></td></tr>
<tr><td class="num" id="LN6312">6312</td><td class="line">    acc=allocacc;</td></tr>
<tr><td class="num" id="LN6313">6313</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6314">6314</td><td class="line">  <span class='comment'>/* Calculate units and remainder from exponent.  */</span></td></tr>
<tr><td class="num" id="LN6315">6315</td><td class="line">  expunits=exp/<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN6316">6316</td><td class="line">  exprem=exp%<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN6317">6317</td><td class="line">  <span class='comment'>/* subtract [A+B*(-m)]  */</span></td></tr>
<tr><td class="num" id="LN6318">6318</td><td class="line">  accunits=decUnitAddSub(a, alength, b, blength, expunits, acc,</td></tr>
<tr><td class="num" id="LN6319">6319</td><td class="line">                         -(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[exprem]);</td></tr>
<tr><td class="num" id="LN6320">6320</td><td class="line">  <span class='comment'>/* [UnitAddSub result may have leading zeros, even on zero]  */</span></td></tr>
<tr><td class="num" id="LN6321">6321</td><td class="line">  <span class='keyword'>if</span> (accunits&lt;0) result=-1;            <span class='comment'>/* negative result  */</span></td></tr>
<tr><td class="num" id="LN6322">6322</td><td class="line">   <span class='keyword'>else</span> {                               <span class='comment'>/* non-negative result  */</span></td></tr>
<tr><td class="num" id="LN6323">6323</td><td class="line">    <span class='comment'>/* check units of the result before freeing any storage  */</span></td></tr>
<tr><td class="num" id="LN6324">6324</td><td class="line">    <span class='keyword'>for</span> (u=acc; u&lt;acc+accunits-1 &amp;&amp; *u==0;) u++;</td></tr>
<tr><td class="num" id="LN6325">6325</td><td class="line">    result=(*u==0 ? 0 : +1);</td></tr>
<tr><td class="num" id="LN6326">6326</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6327">6327</td><td class="line">  <span class='comment'>/* clean up and return the result  */</span></td></tr>
<tr><td class="num" id="LN6328">6328</td><td class="line">  <span class='keyword'>if</span> (allocacc!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='macro'>free(allocacc)<span class='expansion'>uprv_free_54(allocacc)</span></span>;   <span class='comment'>/* drop any storage used  */</span></td></tr>
<tr><td class="num" id="LN6329">6329</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN6330">6330</td><td class="line">  } <span class='comment'>/* decUnitCompare  */</span></td></tr>
<tr><td class="num" id="LN6331">6331</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6332">6332</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6333">6333</td><td class="line"><span class='comment'>/* decUnitAddSub -- add or subtract two &gt;=0 integers in Unit arrays   */</span></td></tr>
<tr><td class="num" id="LN6334">6334</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6335">6335</td><td class="line"><span class='comment'>/*  This routine performs the calculation:                            */</span></td></tr>
<tr><td class="num" id="LN6336">6336</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6337">6337</td><td class="line"><span class='comment'>/*  C=A+(B*M)                                                         */</span></td></tr>
<tr><td class="num" id="LN6338">6338</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6339">6339</td><td class="line"><span class='comment'>/*  Where M is in the range -DECDPUNMAX through +DECDPUNMAX.          */</span></td></tr>
<tr><td class="num" id="LN6340">6340</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6341">6341</td><td class="line"><span class='comment'>/*  A may be shorter or longer than B.                                */</span></td></tr>
<tr><td class="num" id="LN6342">6342</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6343">6343</td><td class="line"><span class='comment'>/*  Leading zeros are not removed after a calculation.  The result is */</span></td></tr>
<tr><td class="num" id="LN6344">6344</td><td class="line"><span class='comment'>/*  either the same length as the longer of A and B (adding any       */</span></td></tr>
<tr><td class="num" id="LN6345">6345</td><td class="line"><span class='comment'>/*  shift), or one Unit longer than that (if a Unit carry occurred).  */</span></td></tr>
<tr><td class="num" id="LN6346">6346</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6347">6347</td><td class="line"><span class='comment'>/*  A and B content are not altered unless C is also A or B.          */</span></td></tr>
<tr><td class="num" id="LN6348">6348</td><td class="line"><span class='comment'>/*  C may be the same array as A or B, but only if no zero padding is */</span></td></tr>
<tr><td class="num" id="LN6349">6349</td><td class="line"><span class='comment'>/*  requested (that is, C may be B only if bshift==0).                */</span></td></tr>
<tr><td class="num" id="LN6350">6350</td><td class="line"><span class='comment'>/*  C is filled from the lsu; only those units necessary to complete  */</span></td></tr>
<tr><td class="num" id="LN6351">6351</td><td class="line"><span class='comment'>/*  the calculation are referenced.                                   */</span></td></tr>
<tr><td class="num" id="LN6352">6352</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6353">6353</td><td class="line"><span class='comment'>/*  Arg1 is A first Unit (lsu)                                        */</span></td></tr>
<tr><td class="num" id="LN6354">6354</td><td class="line"><span class='comment'>/*  Arg2 is A length in Units                                         */</span></td></tr>
<tr><td class="num" id="LN6355">6355</td><td class="line"><span class='comment'>/*  Arg3 is B first Unit (lsu)                                        */</span></td></tr>
<tr><td class="num" id="LN6356">6356</td><td class="line"><span class='comment'>/*  Arg4 is B length in Units                                         */</span></td></tr>
<tr><td class="num" id="LN6357">6357</td><td class="line"><span class='comment'>/*  Arg5 is B shift in Units  (&gt;=0; pads with 0 units if positive)    */</span></td></tr>
<tr><td class="num" id="LN6358">6358</td><td class="line"><span class='comment'>/*  Arg6 is C first Unit (lsu)                                        */</span></td></tr>
<tr><td class="num" id="LN6359">6359</td><td class="line"><span class='comment'>/*  Arg7 is M, the multiplier                                         */</span></td></tr>
<tr><td class="num" id="LN6360">6360</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6361">6361</td><td class="line"><span class='comment'>/*  returns the count of Units written to C, which will be non-zero   */</span></td></tr>
<tr><td class="num" id="LN6362">6362</td><td class="line"><span class='comment'>/*  and negated if the result is negative.  That is, the sign of the  */</span></td></tr>
<tr><td class="num" id="LN6363">6363</td><td class="line"><span class='comment'>/*  returned Int is the sign of the result (positive for zero) and    */</span></td></tr>
<tr><td class="num" id="LN6364">6364</td><td class="line"><span class='comment'>/*  the absolute value of the Int is the count of Units.              */</span></td></tr>
<tr><td class="num" id="LN6365">6365</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6366">6366</td><td class="line"><span class='comment'>/*  It is the caller's responsibility to make sure that C size is     */</span></td></tr>
<tr><td class="num" id="LN6367">6367</td><td class="line"><span class='comment'>/*  safe, allowing space if necessary for a one-Unit carry.           */</span></td></tr>
<tr><td class="num" id="LN6368">6368</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6369">6369</td><td class="line"><span class='comment'>/*  This routine is severely performance-critical; *any* change here  */</span></td></tr>
<tr><td class="num" id="LN6370">6370</td><td class="line"><span class='comment'>/*  must be measured (timed) to assure no performance degradation.    */</span></td></tr>
<tr><td class="num" id="LN6371">6371</td><td class="line"><span class='comment'>/*  In particular, trickery here tends to be counter-productive, as   */</span></td></tr>
<tr><td class="num" id="LN6372">6372</td><td class="line"><span class='comment'>/*  increased complexity of code hurts register optimizations on      */</span></td></tr>
<tr><td class="num" id="LN6373">6373</td><td class="line"><span class='comment'>/*  register-poor architectures.  Avoiding divisions is nearly        */</span></td></tr>
<tr><td class="num" id="LN6374">6374</td><td class="line"><span class='comment'>/*  always a Good Idea, however.                                      */</span></td></tr>
<tr><td class="num" id="LN6375">6375</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6376">6376</td><td class="line"><span class='comment'>/* Special thanks to Rick McGuire (IBM Cambridge, MA) and Dave Clark  */</span></td></tr>
<tr><td class="num" id="LN6377">6377</td><td class="line"><span class='comment'>/* (IBM Warwick, UK) for some of the ideas used in this routine.      */</span></td></tr>
<tr><td class="num" id="LN6378">6378</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6379">6379</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decUnitAddSub(<span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *a, <span class='macro'>Int<span class='expansion'>int32_t</span></span> alength,</td></tr>
<tr><td class="num" id="LN6380">6380</td><td class="line">                         <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *b, <span class='macro'>Int<span class='expansion'>int32_t</span></span> blength, <span class='macro'>Int<span class='expansion'>int32_t</span></span> bshift,</td></tr>
<tr><td class="num" id="LN6381">6381</td><td class="line">                         <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *c, <span class='macro'>Int<span class='expansion'>int32_t</span></span> m) {</td></tr>
<tr><td class="num" id="LN6382">6382</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *alsu=a;              <span class='comment'>/* A lsu [need to remember it]  */</span></td></tr>
<tr><td class="num" id="LN6383">6383</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *clsu=c;                    <span class='comment'>/* C ditto  */</span></td></tr>
<tr><td class="num" id="LN6384">6384</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *minC;                      <span class='comment'>/* low water mark for C  */</span></td></tr>
<tr><td class="num" id="LN6385">6385</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *maxC;                      <span class='comment'>/* high water mark for C  */</span></td></tr>
<tr><td class="num" id="LN6386">6386</td><td class="line">  <span class='macro'>eInt<span class='expansion'>int32_t</span></span> carry=0;                    <span class='comment'>/* carry integer (could be Long)  */</span></td></tr>
<tr><td class="num" id="LN6387">6387</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  add;                        <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6388">6388</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4                   /* myriadal, millenary, etc.  */</span></td></tr>
<tr><td class="num" id="LN6389">6389</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  est;                        <span class='comment'>/* estimated quotient  */</span></td></tr>
<tr><td class="num" id="LN6390">6390</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6391">6391</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6392">6392</td><td class="line">  <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6393">6393</td><td class="line">  <span class='keyword'>if</span> (alength&lt;1 || blength&lt;1)</td></tr>
<tr><td class="num" id="LN6394">6394</td><td class="line">    printf(<span class='string_literal'>"decUnitAddSub: alen blen m %ld %ld [%ld]\n"</span>, alength, blength, m);</td></tr>
<tr><td class="num" id="LN6395">6395</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6396">6396</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6397">6397</td><td class="line">  maxC=c+alength;                  <span class='comment'>/* A is usually the longer  */</span></td></tr>
<tr><td class="num" id="LN6398">6398</td><td class="line">  minC=c+blength;                  <span class='comment'>/* .. and B the shorter  */</span></td></tr>
<tr><td class="num" id="LN6399">6399</td><td class="line">  <span class='keyword'>if</span> (bshift!=0) {                 <span class='comment'>/* B is shifted; low As copy across  */</span></td></tr>
<tr><td class="num" id="LN6400">6400</td><td class="line">    minC+=bshift;</td></tr>
<tr><td class="num" id="LN6401">6401</td><td class="line">    <span class='comment'>/* if in place [common], skip copy unless there's a gap [rare]  */</span></td></tr>
<tr><td class="num" id="LN6402">6402</td><td class="line">    <span class='keyword'>if</span> (a==c &amp;&amp; bshift&lt;=alength) {</td></tr>
<tr><td class="num" id="LN6403">6403</td><td class="line">      c+=bshift;</td></tr>
<tr><td class="num" id="LN6404">6404</td><td class="line">      a+=bshift;</td></tr>
<tr><td class="num" id="LN6405">6405</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6406">6406</td><td class="line">     <span class='keyword'>else</span> <span class='keyword'>for</span> (; c&lt;clsu+bshift; a++, c++) {  <span class='comment'>/* copy needed  */</span></td></tr>
<tr><td class="num" id="LN6407">6407</td><td class="line">      <span class='keyword'>if</span> (a&lt;alsu+alength) *c=*a;</td></tr>
<tr><td class="num" id="LN6408">6408</td><td class="line">       <span class='keyword'>else</span> *c=0;</td></tr>
<tr><td class="num" id="LN6409">6409</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6410">6410</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6411">6411</td><td class="line">  <span class='keyword'>if</span> (minC&gt;maxC) { <span class='comment'>/* swap  */</span></td></tr>
<tr><td class="num" id="LN6412">6412</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *hold=minC;</td></tr>
<tr><td class="num" id="LN6413">6413</td><td class="line">    minC=maxC;</td></tr>
<tr><td class="num" id="LN6414">6414</td><td class="line">    maxC=hold;</td></tr>
<tr><td class="num" id="LN6415">6415</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6416">6416</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6417">6417</td><td class="line">  <span class='comment'>/* For speed, do the addition as two loops; the first where both A  */</span></td></tr>
<tr><td class="num" id="LN6418">6418</td><td class="line">  <span class='comment'>/* and B contribute, and the second (if necessary) where only one or  */</span></td></tr>
<tr><td class="num" id="LN6419">6419</td><td class="line">  <span class='comment'>/* other of the numbers contribute.  */</span></td></tr>
<tr><td class="num" id="LN6420">6420</td><td class="line">  <span class='comment'>/* Carry handling is the same (i.e., duplicated) in each case.  */</span></td></tr>
<tr><td class="num" id="LN6421">6421</td><td class="line">  <span class='keyword'>for</span> (; c&lt;minC; c++) {</td></tr>
<tr><td class="num" id="LN6422">6422</td><td class="line">    carry+=*a;</td></tr>
<tr><td class="num" id="LN6423">6423</td><td class="line">    a++;</td></tr>
<tr><td class="num" id="LN6424">6424</td><td class="line">    carry+=((<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)*b)*m;                <span class='comment'>/* [special-casing m=1/-1  */</span></td></tr>
<tr><td class="num" id="LN6425">6425</td><td class="line">    b++;                                <span class='comment'>/* here is not a win]  */</span></td></tr>
<tr><td class="num" id="LN6426">6426</td><td class="line">    <span class='comment'>/* here carry is new Unit of digits; it could be +ve or -ve  */</span></td></tr>
<tr><td class="num" id="LN6427">6427</td><td class="line">    <span class='keyword'>if</span> ((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&lt;=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>) {     <span class='comment'>/* fastpath 0-DECDPUNMAX  */</span></td></tr>
<tr><td class="num" id="LN6428">6428</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)carry;</td></tr>
<tr><td class="num" id="LN6429">6429</td><td class="line">      carry=0;</td></tr>
<tr><td class="num" id="LN6430">6430</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6431">6431</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6432">6432</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==4                           /* use divide-by-multiply  */</span></td></tr>
<tr><td class="num" id="LN6433">6433</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6434">6434</td><td class="line">        est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;11)*53687)&gt;&gt;18;</td></tr>
<tr><td class="num" id="LN6435">6435</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6436">6436</td><td class="line">        carry=est;                           <span class='comment'>/* likely quotient [89%]  */</span></td></tr>
<tr><td class="num" id="LN6437">6437</td><td class="line">        <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;       <span class='comment'>/* estimate was correct  */</span></td></tr>
<tr><td class="num" id="LN6438">6438</td><td class="line">        carry++;</td></tr>
<tr><td class="num" id="LN6439">6439</td><td class="line">        *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6440">6440</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6441">6441</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6442">6442</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6443">6443</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6444">6444</td><td class="line">      est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;11)*53687)&gt;&gt;18;</td></tr>
<tr><td class="num" id="LN6445">6445</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6446">6446</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6447">6447</td><td class="line">      <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;         <span class='comment'>/* was OK  */</span></td></tr>
<tr><td class="num" id="LN6448">6448</td><td class="line">      carry++;</td></tr>
<tr><td class="num" id="LN6449">6449</td><td class="line">      *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6450">6450</td><td class="line">    <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==3</span></td></tr>
<tr><td class="num" id="LN6451">6451</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6452">6452</td><td class="line">        est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;3)*16777)&gt;&gt;21;</td></tr>
<tr><td class="num" id="LN6453">6453</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6454">6454</td><td class="line">        carry=est;                           <span class='comment'>/* likely quotient [99%]  */</span></td></tr>
<tr><td class="num" id="LN6455">6455</td><td class="line">        <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;       <span class='comment'>/* estimate was correct  */</span></td></tr>
<tr><td class="num" id="LN6456">6456</td><td class="line">        carry++;</td></tr>
<tr><td class="num" id="LN6457">6457</td><td class="line">        *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6458">6458</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6459">6459</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6460">6460</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6461">6461</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6462">6462</td><td class="line">      est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;3)*16777)&gt;&gt;21;</td></tr>
<tr><td class="num" id="LN6463">6463</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6464">6464</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6465">6465</td><td class="line">      <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;         <span class='comment'>/* was OK  */</span></td></tr>
<tr><td class="num" id="LN6466">6466</td><td class="line">      carry++;</td></tr>
<tr><td class="num" id="LN6467">6467</td><td class="line">      *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6468">6468</td><td class="line">    <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=2</span></td></tr>
<tr><td class="num" id="LN6469">6469</td><td class="line">      <span class='comment'>/* Can use QUOT10 as carry &lt;= 4 digits  */</span></td></tr>
<tr><td class="num" id="LN6470">6470</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6471">6471</td><td class="line">        est=<span class='macro'>QUOT10(carry, DECDPUN)<span class='expansion'>((((uint32_t)(carry)&gt;&gt;(1))*multies[1])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6472">6472</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6473">6473</td><td class="line">        carry=est;                           <span class='comment'>/* quotient  */</span></td></tr>
<tr><td class="num" id="LN6474">6474</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6475">6475</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6476">6476</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6477">6477</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6478">6478</td><td class="line">      est=<span class='macro'>QUOT10(carry, DECDPUN)<span class='expansion'>((((uint32_t)(carry)&gt;&gt;(1))*multies[1])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6479">6479</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6480">6480</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6481">6481</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6482">6482</td><td class="line">      <span class='comment'>/* remainder operator is undefined if negative, so must test  */</span></td></tr>
<tr><td class="num" id="LN6483">6483</td><td class="line">      <span class='keyword'>if</span> ((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&lt;(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*2) {   <span class='comment'>/* fastpath carry +1  */</span></td></tr>
<tr><td class="num" id="LN6484">6484</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));     <span class='comment'>/* [helps additions]  */</span></td></tr>
<tr><td class="num" id="LN6485">6485</td><td class="line">        carry=1;</td></tr>
<tr><td class="num" id="LN6486">6486</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6487">6487</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6488">6488</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6489">6489</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry%(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6490">6490</td><td class="line">        carry=carry/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN6491">6491</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6492">6492</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6493">6493</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6494">6494</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6495">6495</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry%(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6496">6496</td><td class="line">      carry=carry/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN6497">6497</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6498">6498</td><td class="line">    } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN6499">6499</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6500">6500</td><td class="line">  <span class='comment'>/* now may have one or other to complete  */</span></td></tr>
<tr><td class="num" id="LN6501">6501</td><td class="line">  <span class='comment'>/* [pretest to avoid loop setup/shutdown]  */</span></td></tr>
<tr><td class="num" id="LN6502">6502</td><td class="line">  <span class='keyword'>if</span> (c&lt;maxC) <span class='keyword'>for</span> (; c&lt;maxC; c++) {</td></tr>
<tr><td class="num" id="LN6503">6503</td><td class="line">    <span class='keyword'>if</span> (a&lt;alsu+alength) {               <span class='comment'>/* still in A  */</span></td></tr>
<tr><td class="num" id="LN6504">6504</td><td class="line">      carry+=*a;</td></tr>
<tr><td class="num" id="LN6505">6505</td><td class="line">      a++;</td></tr>
<tr><td class="num" id="LN6506">6506</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6507">6507</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* inside B  */</span></td></tr>
<tr><td class="num" id="LN6508">6508</td><td class="line">      carry+=((<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)*b)*m;</td></tr>
<tr><td class="num" id="LN6509">6509</td><td class="line">      b++;</td></tr>
<tr><td class="num" id="LN6510">6510</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6511">6511</td><td class="line">    <span class='comment'>/* here carry is new Unit of digits; it could be +ve or -ve and  */</span></td></tr>
<tr><td class="num" id="LN6512">6512</td><td class="line">    <span class='comment'>/* magnitude up to DECDPUNMAX squared  */</span></td></tr>
<tr><td class="num" id="LN6513">6513</td><td class="line">    <span class='keyword'>if</span> ((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&lt;=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>) {     <span class='comment'>/* fastpath 0-DECDPUNMAX  */</span></td></tr>
<tr><td class="num" id="LN6514">6514</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)carry;</td></tr>
<tr><td class="num" id="LN6515">6515</td><td class="line">      carry=0;</td></tr>
<tr><td class="num" id="LN6516">6516</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6517">6517</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6518">6518</td><td class="line">    <span class='comment'>/* result for this unit is negative or &gt;DECDPUNMAX  */</span></td></tr>
<tr><td class="num" id="LN6519">6519</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==4                           /* use divide-by-multiply  */</span></td></tr>
<tr><td class="num" id="LN6520">6520</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6521">6521</td><td class="line">        est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;11)*53687)&gt;&gt;18;</td></tr>
<tr><td class="num" id="LN6522">6522</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6523">6523</td><td class="line">        carry=est;                           <span class='comment'>/* likely quotient [79.7%]  */</span></td></tr>
<tr><td class="num" id="LN6524">6524</td><td class="line">        <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;       <span class='comment'>/* estimate was correct  */</span></td></tr>
<tr><td class="num" id="LN6525">6525</td><td class="line">        carry++;</td></tr>
<tr><td class="num" id="LN6526">6526</td><td class="line">        *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6527">6527</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6528">6528</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6529">6529</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6530">6530</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6531">6531</td><td class="line">      est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;11)*53687)&gt;&gt;18;</td></tr>
<tr><td class="num" id="LN6532">6532</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6533">6533</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6534">6534</td><td class="line">      <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;         <span class='comment'>/* was OK  */</span></td></tr>
<tr><td class="num" id="LN6535">6535</td><td class="line">      carry++;</td></tr>
<tr><td class="num" id="LN6536">6536</td><td class="line">      *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6537">6537</td><td class="line">    <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==3</span></td></tr>
<tr><td class="num" id="LN6538">6538</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6539">6539</td><td class="line">        est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;3)*16777)&gt;&gt;21;</td></tr>
<tr><td class="num" id="LN6540">6540</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6541">6541</td><td class="line">        carry=est;                           <span class='comment'>/* likely quotient [99%]  */</span></td></tr>
<tr><td class="num" id="LN6542">6542</td><td class="line">        <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;       <span class='comment'>/* estimate was correct  */</span></td></tr>
<tr><td class="num" id="LN6543">6543</td><td class="line">        carry++;</td></tr>
<tr><td class="num" id="LN6544">6544</td><td class="line">        *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6545">6545</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6546">6546</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6547">6547</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6548">6548</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6549">6549</td><td class="line">      est=(((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&gt;&gt;3)*16777)&gt;&gt;21;</td></tr>
<tr><td class="num" id="LN6550">6550</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6551">6551</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6552">6552</td><td class="line">      <span class='keyword'>if</span> (*c&lt;<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1) <span class='keyword'>continue</span>;         <span class='comment'>/* was OK  */</span></td></tr>
<tr><td class="num" id="LN6553">6553</td><td class="line">      carry++;</td></tr>
<tr><td class="num" id="LN6554">6554</td><td class="line">      *c-=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1;</td></tr>
<tr><td class="num" id="LN6555">6555</td><td class="line">    <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=2</span></td></tr>
<tr><td class="num" id="LN6556">6556</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6557">6557</td><td class="line">        est=<span class='macro'>QUOT10(carry, DECDPUN)<span class='expansion'>((((uint32_t)(carry)&gt;&gt;(1))*multies[1])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6558">6558</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)); <span class='comment'>/* remainder  */</span></td></tr>
<tr><td class="num" id="LN6559">6559</td><td class="line">        carry=est;                           <span class='comment'>/* quotient  */</span></td></tr>
<tr><td class="num" id="LN6560">6560</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6561">6561</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6562">6562</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6563">6563</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6564">6564</td><td class="line">      est=<span class='macro'>QUOT10(carry, DECDPUN)<span class='expansion'>((((uint32_t)(carry)&gt;&gt;(1))*multies[1])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6565">6565</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-est*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6566">6566</td><td class="line">      carry=est-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);              <span class='comment'>/* correctly negative  */</span></td></tr>
<tr><td class="num" id="LN6567">6567</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6568">6568</td><td class="line">      <span class='keyword'>if</span> ((<span class='macro'>ueInt<span class='expansion'>uint32_t</span></span>)carry&lt;(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*2){    <span class='comment'>/* fastpath carry 1  */</span></td></tr>
<tr><td class="num" id="LN6569">6569</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6570">6570</td><td class="line">        carry=1;</td></tr>
<tr><td class="num" id="LN6571">6571</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6572">6572</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6573">6573</td><td class="line">      <span class='comment'>/* remainder operator is undefined if negative, so must test  */</span></td></tr>
<tr><td class="num" id="LN6574">6574</td><td class="line">      <span class='keyword'>if</span> (carry&gt;=0) {</td></tr>
<tr><td class="num" id="LN6575">6575</td><td class="line">        *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry%(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6576">6576</td><td class="line">        carry=carry/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN6577">6577</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN6578">6578</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6579">6579</td><td class="line">      <span class='comment'>/* negative case  */</span></td></tr>
<tr><td class="num" id="LN6580">6580</td><td class="line">      carry=carry+(<span class='macro'>eInt<span class='expansion'>int32_t</span></span>)(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)*(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1); <span class='comment'>/* make positive  */</span></td></tr>
<tr><td class="num" id="LN6581">6581</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(carry%(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1));</td></tr>
<tr><td class="num" id="LN6582">6582</td><td class="line">      carry=carry/(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1)-(<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+1);</td></tr>
<tr><td class="num" id="LN6583">6583</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6584">6584</td><td class="line">    } <span class='comment'>/* c  */</span></td></tr>
<tr><td class="num" id="LN6585">6585</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6586">6586</td><td class="line">  <span class='comment'>/* OK, all A and B processed; might still have carry or borrow  */</span></td></tr>
<tr><td class="num" id="LN6587">6587</td><td class="line">  <span class='comment'>/* return number of Units in the result, negated if a borrow  */</span></td></tr>
<tr><td class="num" id="LN6588">6588</td><td class="line">  <span class='keyword'>if</span> (carry==0) <span class='keyword'>return</span> c-clsu;     <span class='comment'>/* no carry, so no more to do  */</span></td></tr>
<tr><td class="num" id="LN6589">6589</td><td class="line">  <span class='keyword'>if</span> (carry&gt;0) {                   <span class='comment'>/* positive carry  */</span></td></tr>
<tr><td class="num" id="LN6590">6590</td><td class="line">    *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)carry;                <span class='comment'>/* place as new unit  */</span></td></tr>
<tr><td class="num" id="LN6591">6591</td><td class="line">    c++;                           <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6592">6592</td><td class="line">    <span class='keyword'>return</span> c-clsu;</td></tr>
<tr><td class="num" id="LN6593">6593</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6594">6594</td><td class="line">  <span class='comment'>/* -ve carry: it's a borrow; complement needed  */</span></td></tr>
<tr><td class="num" id="LN6595">6595</td><td class="line">  add=1;                           <span class='comment'>/* temporary carry...  */</span></td></tr>
<tr><td class="num" id="LN6596">6596</td><td class="line">  <span class='keyword'>for</span> (c=clsu; c&lt;maxC; c++) {</td></tr>
<tr><td class="num" id="LN6597">6597</td><td class="line">    add=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>+add-*c;</td></tr>
<tr><td class="num" id="LN6598">6598</td><td class="line">    <span class='keyword'>if</span> (add&lt;=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>) {</td></tr>
<tr><td class="num" id="LN6599">6599</td><td class="line">      *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)add;</td></tr>
<tr><td class="num" id="LN6600">6600</td><td class="line">      add=0;</td></tr>
<tr><td class="num" id="LN6601">6601</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6602">6602</td><td class="line">     <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN6603">6603</td><td class="line">      *c=0;</td></tr>
<tr><td class="num" id="LN6604">6604</td><td class="line">      add=1;</td></tr>
<tr><td class="num" id="LN6605">6605</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6606">6606</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6607">6607</td><td class="line">  <span class='comment'>/* add an extra unit iff it would be non-zero  */</span></td></tr>
<tr><td class="num" id="LN6608">6608</td><td class="line">  <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6609">6609</td><td class="line">    printf(<span class='string_literal'>"UAS borrow: add %ld, carry %ld\n"</span>, add, carry);</td></tr>
<tr><td class="num" id="LN6610">6610</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6611">6611</td><td class="line">  <span class='keyword'>if</span> ((add-carry-1)!=0) {</td></tr>
<tr><td class="num" id="LN6612">6612</td><td class="line">    *c=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(add-carry-1);</td></tr>
<tr><td class="num" id="LN6613">6613</td><td class="line">    c++;                      <span class='comment'>/* interesting, include it  */</span></td></tr>
<tr><td class="num" id="LN6614">6614</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6615">6615</td><td class="line">  <span class='keyword'>return</span> clsu-c;              <span class='comment'>/* -ve result indicates borrowed  */</span></td></tr>
<tr><td class="num" id="LN6616">6616</td><td class="line">  } <span class='comment'>/* decUnitAddSub  */</span></td></tr>
<tr><td class="num" id="LN6617">6617</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6618">6618</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6619">6619</td><td class="line"><span class='comment'>/* decTrim -- trim trailing zeros or normalize                        */</span></td></tr>
<tr><td class="num" id="LN6620">6620</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6621">6621</td><td class="line"><span class='comment'>/*   dn is the number to trim or normalize                            */</span></td></tr>
<tr><td class="num" id="LN6622">6622</td><td class="line"><span class='comment'>/*   set is the context to use to check for clamp                     */</span></td></tr>
<tr><td class="num" id="LN6623">6623</td><td class="line"><span class='comment'>/*   all is 1 to remove all trailing zeros, 0 for just fraction ones  */</span></td></tr>
<tr><td class="num" id="LN6624">6624</td><td class="line"><span class='comment'>/*   noclamp is 1 to unconditional (unclamped) trim                   */</span></td></tr>
<tr><td class="num" id="LN6625">6625</td><td class="line"><span class='comment'>/*   dropped returns the number of discarded trailing zeros           */</span></td></tr>
<tr><td class="num" id="LN6626">6626</td><td class="line"><span class='comment'>/*   returns dn                                                       */</span></td></tr>
<tr><td class="num" id="LN6627">6627</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6628">6628</td><td class="line"><span class='comment'>/* If clamp is set in the context then the number of zeros trimmed    */</span></td></tr>
<tr><td class="num" id="LN6629">6629</td><td class="line"><span class='comment'>/* may be limited if the exponent is high.                            */</span></td></tr>
<tr><td class="num" id="LN6630">6630</td><td class="line"><span class='comment'>/* All fields are updated as required.  This is a utility operation,  */</span></td></tr>
<tr><td class="num" id="LN6631">6631</td><td class="line"><span class='comment'>/* so special values are unchanged and no error is possible.          */</span></td></tr>
<tr><td class="num" id="LN6632">6632</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6633">6633</td><td class="line"><span class='keyword'>static</span> decNumber * decTrim(decNumber *dn, decContext *set, <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> all,</td></tr>
<tr><td class="num" id="LN6634">6634</td><td class="line">                           <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> noclamp, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *dropped) {</td></tr>
<tr><td class="num" id="LN6635">6635</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   d, exp;                    <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6636">6636</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  cut;                       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6637">6637</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *up;                       <span class='comment'>/* -&gt; current Unit  */</span></td></tr>
<tr><td class="num" id="LN6638">6638</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6639">6639</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6640">6640</td><td class="line">  <span class='keyword'>if</span> (decCheckOperands(dn, DECUNUSED, DECUNUSED, DECUNCONT)) <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN6641">6641</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6642">6642</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6643">6643</td><td class="line">  *dropped=0;                           <span class='comment'>/* assume no zeros dropped  */</span></td></tr>
<tr><td class="num" id="LN6644">6644</td><td class="line">  <span class='keyword'>if</span> ((dn-&gt;bits &amp; <span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>)           <span class='comment'>/* fast exit if special ..  */</span></td></tr>
<tr><td class="num" id="LN6645">6645</td><td class="line">    || (*dn-&gt;lsu &amp; 0x01)) <span class='keyword'>return</span> dn;    <span class='comment'>/* .. or odd  */</span></td></tr>
<tr><td class="num" id="LN6646">6646</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                     <span class='comment'>/* .. or 0  */</span></td></tr>
<tr><td class="num" id="LN6647">6647</td><td class="line">    dn-&gt;exponent=0;                     <span class='comment'>/* (sign is preserved)  */</span></td></tr>
<tr><td class="num" id="LN6648">6648</td><td class="line">    <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN6649">6649</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6650">6650</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6651">6651</td><td class="line">  <span class='comment'>/* have a finite number which is even  */</span></td></tr>
<tr><td class="num" id="LN6652">6652</td><td class="line">  exp=dn-&gt;exponent;</td></tr>
<tr><td class="num" id="LN6653">6653</td><td class="line">  cut=1;                           <span class='comment'>/* digit (1-DECDPUN) in Unit  */</span></td></tr>
<tr><td class="num" id="LN6654">6654</td><td class="line">  up=dn-&gt;lsu;                      <span class='comment'>/* -&gt; current Unit  */</span></td></tr>
<tr><td class="num" id="LN6655">6655</td><td class="line">  <span class='keyword'>for</span> (d=0; d&lt;dn-&gt;digits-1; d++) { <span class='comment'>/* [don't strip the final digit]  */</span></td></tr>
<tr><td class="num" id="LN6656">6656</td><td class="line">    <span class='comment'>/* slice by powers  */</span></td></tr>
<tr><td class="num" id="LN6657">6657</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN6658">6658</td><td class="line">      <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> quot=<span class='macro'>QUOT10(*up, cut)<span class='expansion'>((((uint32_t)(*up)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6659">6659</td><td class="line">      <span class='keyword'>if</span> ((*up-quot*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut])!=0) <span class='keyword'>break</span>;  <span class='comment'>/* found non-0 digit  */</span></td></tr>
<tr><td class="num" id="LN6660">6660</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6661">6661</td><td class="line">      <span class='keyword'>if</span> (*up%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut]!=0) <span class='keyword'>break</span>;         <span class='comment'>/* found non-0 digit  */</span></td></tr>
<tr><td class="num" id="LN6662">6662</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6663">6663</td><td class="line">    <span class='comment'>/* have a trailing 0  */</span></td></tr>
<tr><td class="num" id="LN6664">6664</td><td class="line">    <span class='keyword'>if</span> (!all) {                    <span class='comment'>/* trimming  */</span></td></tr>
<tr><td class="num" id="LN6665">6665</td><td class="line">      <span class='comment'>/* [if exp&gt;0 then all trailing 0s are significant for trim]  */</span></td></tr>
<tr><td class="num" id="LN6666">6666</td><td class="line">      <span class='keyword'>if</span> (exp&lt;=0) {                <span class='comment'>/* if digit might be significant  */</span></td></tr>
<tr><td class="num" id="LN6667">6667</td><td class="line">        <span class='keyword'>if</span> (exp==0) <span class='keyword'>break</span>;         <span class='comment'>/* then quit  */</span></td></tr>
<tr><td class="num" id="LN6668">6668</td><td class="line">        exp++;                     <span class='comment'>/* next digit might be significant  */</span></td></tr>
<tr><td class="num" id="LN6669">6669</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6670">6670</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6671">6671</td><td class="line">    cut++;                         <span class='comment'>/* next power  */</span></td></tr>
<tr><td class="num" id="LN6672">6672</td><td class="line">    <span class='keyword'>if</span> (cut&gt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {             <span class='comment'>/* need new Unit  */</span></td></tr>
<tr><td class="num" id="LN6673">6673</td><td class="line">      up++;</td></tr>
<tr><td class="num" id="LN6674">6674</td><td class="line">      cut=1;</td></tr>
<tr><td class="num" id="LN6675">6675</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6676">6676</td><td class="line">    } <span class='comment'>/* d  */</span></td></tr>
<tr><td class="num" id="LN6677">6677</td><td class="line">  <span class='keyword'>if</span> (d==0) <span class='keyword'>return</span> dn;             <span class='comment'>/* none to drop  */</span></td></tr>
<tr><td class="num" id="LN6678">6678</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6679">6679</td><td class="line">  <span class='comment'>/* may need to limit drop if clamping  */</span></td></tr>
<tr><td class="num" id="LN6680">6680</td><td class="line">  <span class='keyword'>if</span> (set-&gt;clamp &amp;&amp; !noclamp) {</td></tr>
<tr><td class="num" id="LN6681">6681</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> maxd=set-&gt;emax-set-&gt;digits+1-dn-&gt;exponent;</td></tr>
<tr><td class="num" id="LN6682">6682</td><td class="line">    <span class='keyword'>if</span> (maxd&lt;=0) <span class='keyword'>return</span> dn;        <span class='comment'>/* nothing possible  */</span></td></tr>
<tr><td class="num" id="LN6683">6683</td><td class="line">    <span class='keyword'>if</span> (d&gt;maxd) d=maxd;</td></tr>
<tr><td class="num" id="LN6684">6684</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6685">6685</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6686">6686</td><td class="line">  <span class='comment'>/* effect the drop  */</span></td></tr>
<tr><td class="num" id="LN6687">6687</td><td class="line">  decShiftToLeast(dn-&gt;lsu, <span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>, d);</td></tr>
<tr><td class="num" id="LN6688">6688</td><td class="line">  dn-&gt;exponent+=d;                 <span class='comment'>/* maintain numerical value  */</span></td></tr>
<tr><td class="num" id="LN6689">6689</td><td class="line">  dn-&gt;digits-=d;                   <span class='comment'>/* new length  */</span></td></tr>
<tr><td class="num" id="LN6690">6690</td><td class="line">  *dropped=d;                      <span class='comment'>/* report the count  */</span></td></tr>
<tr><td class="num" id="LN6691">6691</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN6692">6692</td><td class="line">  } <span class='comment'>/* decTrim  */</span></td></tr>
<tr><td class="num" id="LN6693">6693</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6694">6694</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6695">6695</td><td class="line"><span class='comment'>/* decReverse -- reverse a Unit array in place                        */</span></td></tr>
<tr><td class="num" id="LN6696">6696</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6697">6697</td><td class="line"><span class='comment'>/*   ulo    is the start of the array                                 */</span></td></tr>
<tr><td class="num" id="LN6698">6698</td><td class="line"><span class='comment'>/*   uhi    is the end of the array (highest Unit to include)         */</span></td></tr>
<tr><td class="num" id="LN6699">6699</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6700">6700</td><td class="line"><span class='comment'>/* The units ulo through uhi are reversed in place (if the number     */</span></td></tr>
<tr><td class="num" id="LN6701">6701</td><td class="line"><span class='comment'>/* of units is odd, the middle one is untouched).  Note that the      */</span></td></tr>
<tr><td class="num" id="LN6702">6702</td><td class="line"><span class='comment'>/* digit(s) in each unit are unaffected.                              */</span></td></tr>
<tr><td class="num" id="LN6703">6703</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6704">6704</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decReverse(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ulo, <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *uhi) {</td></tr>
<tr><td class="num" id="LN6705">6705</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> temp;</td></tr>
<tr><td class="num" id="LN6706">6706</td><td class="line">  <span class='keyword'>for</span> (; ulo&lt;uhi; ulo++, uhi--) {</td></tr>
<tr><td class="num" id="LN6707">6707</td><td class="line">    temp=*ulo;</td></tr>
<tr><td class="num" id="LN6708">6708</td><td class="line">    *ulo=*uhi;</td></tr>
<tr><td class="num" id="LN6709">6709</td><td class="line">    *uhi=temp;</td></tr>
<tr><td class="num" id="LN6710">6710</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6711">6711</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN6712">6712</td><td class="line">  } <span class='comment'>/* decReverse  */</span></td></tr>
<tr><td class="num" id="LN6713">6713</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6714">6714</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6715">6715</td><td class="line"><span class='comment'>/* decShiftToMost -- shift digits in array towards most significant   */</span></td></tr>
<tr><td class="num" id="LN6716">6716</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6717">6717</td><td class="line"><span class='comment'>/*   uar    is the array                                              */</span></td></tr>
<tr><td class="num" id="LN6718">6718</td><td class="line"><span class='comment'>/*   digits is the count of digits in use in the array                */</span></td></tr>
<tr><td class="num" id="LN6719">6719</td><td class="line"><span class='comment'>/*   shift  is the number of zeros to pad with (least significant);   */</span></td></tr>
<tr><td class="num" id="LN6720">6720</td><td class="line"><span class='comment'>/*     it must be zero or positive                                    */</span></td></tr>
<tr><td class="num" id="LN6721">6721</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6722">6722</td><td class="line"><span class='comment'>/*   returns the new length of the integer in the array, in digits    */</span></td></tr>
<tr><td class="num" id="LN6723">6723</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6724">6724</td><td class="line"><span class='comment'>/* No overflow is permitted (that is, the uar array must be known to  */</span></td></tr>
<tr><td class="num" id="LN6725">6725</td><td class="line"><span class='comment'>/* be large enough to hold the result, after shifting).               */</span></td></tr>
<tr><td class="num" id="LN6726">6726</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6727">6727</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decShiftToMost(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *uar, <span class='macro'>Int<span class='expansion'>int32_t</span></span> digits, <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift) {</td></tr>
<tr><td class="num" id="LN6728">6728</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *target, *source, *first;  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6729">6729</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   cut;                       <span class='comment'>/* odd 0's to add  */</span></td></tr>
<tr><td class="num" id="LN6730">6730</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  next;                      <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6731">6731</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6732">6732</td><td class="line">  <span class='keyword'>if</span> (shift==0) <span class='keyword'>return</span> digits;     <span class='comment'>/* [fastpath] nothing to do  */</span></td></tr>
<tr><td class="num" id="LN6733">6733</td><td class="line">  <span class='keyword'>if</span> ((digits+shift)&lt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {   <span class='comment'>/* [fastpath] single-unit case  */</span></td></tr>
<tr><td class="num" id="LN6734">6734</td><td class="line">    *uar=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(*uar*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[shift]);</td></tr>
<tr><td class="num" id="LN6735">6735</td><td class="line">    <span class='keyword'>return</span> digits+shift;</td></tr>
<tr><td class="num" id="LN6736">6736</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6737">6737</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6738">6738</td><td class="line">  next=0;                          <span class='comment'>/* all paths  */</span></td></tr>
<tr><td class="num" id="LN6739">6739</td><td class="line">  source=uar+<span class='macro'>D2U(digits)<span class='expansion'>((digits)&lt;=49?d2utable[digits]:((digits)+1 -1)/1)</span></span>-1;        <span class='comment'>/* where msu comes from  */</span></td></tr>
<tr><td class="num" id="LN6740">6740</td><td class="line">  target=source+<span class='macro'>D2U(shift)<span class='expansion'>((shift)&lt;=49?d2utable[shift]:((shift)+1 -1)/1)</span></span>;        <span class='comment'>/* where upper part of first cut goes  */</span></td></tr>
<tr><td class="num" id="LN6741">6741</td><td class="line">  cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-<span class='macro'>MSUDIGITS(shift)<span class='expansion'>((shift)-(((shift)&lt;=49?d2utable[shift]:((shift)+1 -1)/1)-1<br>)*1)</span></span>;    <span class='comment'>/* where to slice  */</span></td></tr>
<tr><td class="num" id="LN6742">6742</td><td class="line">  <span class='keyword'>if</span> (cut==0) {                    <span class='comment'>/* unit-boundary case  */</span></td></tr>
<tr><td class="num" id="LN6743">6743</td><td class="line">    <span class='keyword'>for</span> (; source&gt;=uar; source--, target--) *target=*source;</td></tr>
<tr><td class="num" id="LN6744">6744</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6745">6745</td><td class="line">   <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN6746">6746</td><td class="line">    first=uar+<span class='macro'>D2U(digits+shift)<span class='expansion'>((digits+shift)&lt;=49?d2utable[digits+shift]:((digits+shift)<br>+1 -1)/1)</span></span>-1; <span class='comment'>/* where msu of source will end up  */</span></td></tr>
<tr><td class="num" id="LN6747">6747</td><td class="line">    <span class='keyword'>for</span> (; source&gt;=uar; source--, target--) {</td></tr>
<tr><td class="num" id="LN6748">6748</td><td class="line">      <span class='comment'>/* split the source Unit and accumulate remainder for next  */</span></td></tr>
<tr><td class="num" id="LN6749">6749</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN6750">6750</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> quot=<span class='macro'>QUOT10(*source, cut)<span class='expansion'>((((uint32_t)(*source)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6751">6751</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> rem=*source-quot*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6752">6752</td><td class="line">        next+=quot;</td></tr>
<tr><td class="num" id="LN6753">6753</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6754">6754</td><td class="line">        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> rem=*source%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6755">6755</td><td class="line">        next+=*source/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6756">6756</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6757">6757</td><td class="line">      <span class='keyword'>if</span> (target&lt;=first) *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)next;   <span class='comment'>/* write to target iff valid  */</span></td></tr>
<tr><td class="num" id="LN6758">6758</td><td class="line">      next=rem*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-cut];            <span class='comment'>/* save remainder for next Unit  */</span></td></tr>
<tr><td class="num" id="LN6759">6759</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6760">6760</td><td class="line">    } <span class='comment'>/* shift-move  */</span></td></tr>
<tr><td class="num" id="LN6761">6761</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6762">6762</td><td class="line">  <span class='comment'>/* propagate any partial unit to one below and clear the rest  */</span></td></tr>
<tr><td class="num" id="LN6763">6763</td><td class="line">  <span class='keyword'>for</span> (; target&gt;=uar; target--) {</td></tr>
<tr><td class="num" id="LN6764">6764</td><td class="line">    *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)next;</td></tr>
<tr><td class="num" id="LN6765">6765</td><td class="line">    next=0;</td></tr>
<tr><td class="num" id="LN6766">6766</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6767">6767</td><td class="line">  <span class='keyword'>return</span> digits+shift;</td></tr>
<tr><td class="num" id="LN6768">6768</td><td class="line">  } <span class='comment'>/* decShiftToMost  */</span></td></tr>
<tr><td class="num" id="LN6769">6769</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6770">6770</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6771">6771</td><td class="line"><span class='comment'>/* decShiftToLeast -- shift digits in array towards least significant */</span></td></tr>
<tr><td class="num" id="LN6772">6772</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6773">6773</td><td class="line"><span class='comment'>/*   uar   is the array                                               */</span></td></tr>
<tr><td class="num" id="LN6774">6774</td><td class="line"><span class='comment'>/*   units is length of the array, in units                           */</span></td></tr>
<tr><td class="num" id="LN6775">6775</td><td class="line"><span class='comment'>/*   shift is the number of digits to remove from the lsu end; it     */</span></td></tr>
<tr><td class="num" id="LN6776">6776</td><td class="line"><span class='comment'>/*     must be zero or positive and &lt;= than units*DECDPUN.            */</span></td></tr>
<tr><td class="num" id="LN6777">6777</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6778">6778</td><td class="line"><span class='comment'>/*   returns the new length of the integer in the array, in units     */</span></td></tr>
<tr><td class="num" id="LN6779">6779</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6780">6780</td><td class="line"><span class='comment'>/* Removed digits are discarded (lost).  Units not required to hold   */</span></td></tr>
<tr><td class="num" id="LN6781">6781</td><td class="line"><span class='comment'>/* the final result are unchanged.                                    */</span></td></tr>
<tr><td class="num" id="LN6782">6782</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6783">6783</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decShiftToLeast(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *uar, <span class='macro'>Int<span class='expansion'>int32_t</span></span> units, <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift) {</td></tr>
<tr><td class="num" id="LN6784">6784</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *target, *up;              <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6785">6785</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   cut, count;                <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6786">6786</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   quot, rem;                 <span class='comment'>/* for division  */</span></td></tr>
<tr><td class="num" id="LN6787">6787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6788">6788</td><td class="line">  <span class='keyword'>if</span> (shift==0) <span class='keyword'>return</span> units;      <span class='comment'>/* [fastpath] nothing to do  */</span></td></tr>
<tr><td class="num" id="LN6789">6789</td><td class="line">  <span class='keyword'>if</span> (shift==units*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {      <span class='comment'>/* [fastpath] little to do  */</span></td></tr>
<tr><td class="num" id="LN6790">6790</td><td class="line">    *uar=0;                        <span class='comment'>/* all digits cleared gives zero  */</span></td></tr>
<tr><td class="num" id="LN6791">6791</td><td class="line">    <span class='keyword'>return</span> 1;                      <span class='comment'>/* leaves just the one  */</span></td></tr>
<tr><td class="num" id="LN6792">6792</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6793">6793</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6794">6794</td><td class="line">  target=uar;                      <span class='comment'>/* both paths  */</span></td></tr>
<tr><td class="num" id="LN6795">6795</td><td class="line">  cut=<span class='macro'>MSUDIGITS(shift)<span class='expansion'>((shift)-(((shift)&lt;=49?d2utable[shift]:((shift)+1 -1)/1)-1<br>)*1)</span></span>;</td></tr>
<tr><td class="num" id="LN6796">6796</td><td class="line">  <span class='keyword'>if</span> (cut==<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {              <span class='comment'>/* unit-boundary case; easy  */</span></td></tr>
<tr><td class="num" id="LN6797">6797</td><td class="line">    up=uar+<span class='macro'>D2U(shift)<span class='expansion'>((shift)&lt;=49?d2utable[shift]:((shift)+1 -1)/1)</span></span>;</td></tr>
<tr><td class="num" id="LN6798">6798</td><td class="line">    <span class='keyword'>for</span> (; up&lt;uar+units; target++, up++) *target=*up;</td></tr>
<tr><td class="num" id="LN6799">6799</td><td class="line">    <span class='keyword'>return</span> target-uar;</td></tr>
<tr><td class="num" id="LN6800">6800</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6801">6801</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6802">6802</td><td class="line">  <span class='comment'>/* messier  */</span></td></tr>
<tr><td class="num" id="LN6803">6803</td><td class="line">  up=uar+<span class='macro'>D2U(shift-cut)<span class='expansion'>((shift-cut)&lt;=49?d2utable[shift-cut]:((shift-cut)+1 -1)/1)</span></span>;           <span class='comment'>/* source; correct to whole Units  */</span></td></tr>
<tr><td class="num" id="LN6804">6804</td><td class="line">  count=units*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-shift;       <span class='comment'>/* the maximum new length  */</span></td></tr>
<tr><td class="num" id="LN6805">6805</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN6806">6806</td><td class="line">    quot=<span class='macro'>QUOT10(*up, cut)<span class='expansion'>((((uint32_t)(*up)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6807">6807</td><td class="line">  <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6808">6808</td><td class="line">    quot=*up/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6809">6809</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6810">6810</td><td class="line">  <span class='keyword'>for</span> (; ; target++) {</td></tr>
<tr><td class="num" id="LN6811">6811</td><td class="line">    *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)quot;</td></tr>
<tr><td class="num" id="LN6812">6812</td><td class="line">    count-=(<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-cut);</td></tr>
<tr><td class="num" id="LN6813">6813</td><td class="line">    <span class='keyword'>if</span> (count&lt;=0) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6814">6814</td><td class="line">    up++;</td></tr>
<tr><td class="num" id="LN6815">6815</td><td class="line">    quot=*up;</td></tr>
<tr><td class="num" id="LN6816">6816</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN6817">6817</td><td class="line">      quot=<span class='macro'>QUOT10(quot, cut)<span class='expansion'>((((uint32_t)(quot)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN6818">6818</td><td class="line">      rem=*up-quot*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6819">6819</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN6820">6820</td><td class="line">      rem=quot%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6821">6821</td><td class="line">      quot=quot/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN6822">6822</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6823">6823</td><td class="line">    *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(*target+rem*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-cut]);</td></tr>
<tr><td class="num" id="LN6824">6824</td><td class="line">    count-=cut;</td></tr>
<tr><td class="num" id="LN6825">6825</td><td class="line">    <span class='keyword'>if</span> (count&lt;=0) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN6826">6826</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6827">6827</td><td class="line">  <span class='keyword'>return</span> target-uar+1;</td></tr>
<tr><td class="num" id="LN6828">6828</td><td class="line">  } <span class='comment'>/* decShiftToLeast  */</span></td></tr>
<tr><td class="num" id="LN6829">6829</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6830">6830</td><td class="line"><span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN6831">6831</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6832">6832</td><td class="line"><span class='comment'>/* decRoundOperand -- round an operand  [used for subset only]        */</span></td></tr>
<tr><td class="num" id="LN6833">6833</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6834">6834</td><td class="line"><span class='comment'>/*   dn is the number to round (dn-&gt;digits is &gt; set-&gt;digits)          */</span></td></tr>
<tr><td class="num" id="LN6835">6835</td><td class="line"><span class='comment'>/*   set is the relevant context                                      */</span></td></tr>
<tr><td class="num" id="LN6836">6836</td><td class="line"><span class='comment'>/*   status is the status accumulator                                 */</span></td></tr>
<tr><td class="num" id="LN6837">6837</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6838">6838</td><td class="line"><span class='comment'>/*   returns an allocated decNumber with the rounded result.          */</span></td></tr>
<tr><td class="num" id="LN6839">6839</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6840">6840</td><td class="line"><span class='comment'>/* lostDigits and other status may be set by this.                    */</span></td></tr>
<tr><td class="num" id="LN6841">6841</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6842">6842</td><td class="line"><span class='comment'>/* Since the input is an operand, it must not be modified.            */</span></td></tr>
<tr><td class="num" id="LN6843">6843</td><td class="line"><span class='comment'>/* Instead, return an allocated decNumber, rounded as required.       */</span></td></tr>
<tr><td class="num" id="LN6844">6844</td><td class="line"><span class='comment'>/* It is the caller's responsibility to free the allocated storage.   */</span></td></tr>
<tr><td class="num" id="LN6845">6845</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6846">6846</td><td class="line"><span class='comment'>/* If no storage is available then the result cannot be used, so NULL */</span></td></tr>
<tr><td class="num" id="LN6847">6847</td><td class="line"><span class='comment'>/* is returned.                                                       */</span></td></tr>
<tr><td class="num" id="LN6848">6848</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6849">6849</td><td class="line"><span class='keyword'>static</span> decNumber *decRoundOperand(<span class='keyword'>const</span> decNumber *dn, decContext *set,</td></tr>
<tr><td class="num" id="LN6850">6850</td><td class="line">                                  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN6851">6851</td><td class="line">  decNumber *res;                       <span class='comment'>/* result structure  */</span></td></tr>
<tr><td class="num" id="LN6852">6852</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> newstatus=0;                     <span class='comment'>/* status from round  */</span></td></tr>
<tr><td class="num" id="LN6853">6853</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  residue=0;                       <span class='comment'>/* rounding accumulator  */</span></td></tr>
<tr><td class="num" id="LN6854">6854</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6855">6855</td><td class="line">  <span class='comment'>/* Allocate storage for the returned decNumber, big enough for the  */</span></td></tr>
<tr><td class="num" id="LN6856">6856</td><td class="line">  <span class='comment'>/* length specified by the context  */</span></td></tr>
<tr><td class="num" id="LN6857">6857</td><td class="line">  res=(decNumber *)<span class='macro'>malloc(<span class='keyword'>sizeof</span>(decNumber)<span class='expansion'>uprv_malloc_54(sizeof(decNumber) +(((set-&gt;digits)&lt;=49?d2utable<br>[set-&gt;digits]:((set-&gt;digits)+1 -1)/1)-1)*sizeof(uint8_t<br>))</span></span></td></tr>
<tr><td class="num" id="LN6858">6858</td><td class="line">                          <span class='macro'>+(D2U(set-&gt;digits)-1)*<span class='keyword'>sizeof</span>(Unit))<span class='expansion'>uprv_malloc_54(sizeof(decNumber) +(((set-&gt;digits)&lt;=49?d2utable<br>[set-&gt;digits]:((set-&gt;digits)+1 -1)/1)-1)*sizeof(uint8_t<br>))</span></span>;</td></tr>
<tr><td class="num" id="LN6859">6859</td><td class="line">  <span class='keyword'>if</span> (res==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN6860">6860</td><td class="line">    *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;</td></tr>
<tr><td class="num" id="LN6861">6861</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN6862">6862</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6863">6863</td><td class="line">  decCopyFit(res, dn, set, &amp;residue, &amp;newstatus);</td></tr>
<tr><td class="num" id="LN6864">6864</td><td class="line">  decApplyRound(res, set, residue, &amp;newstatus);</td></tr>
<tr><td class="num" id="LN6865">6865</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6866">6866</td><td class="line">  <span class='comment'>/* If that set Inexact then "lost digits" is raised...  */</span></td></tr>
<tr><td class="num" id="LN6867">6867</td><td class="line">  <span class='keyword'>if</span> (newstatus &amp; <span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>) newstatus|=DEC_Lost_digits;</td></tr>
<tr><td class="num" id="LN6868">6868</td><td class="line">  *status|=newstatus;</td></tr>
<tr><td class="num" id="LN6869">6869</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN6870">6870</td><td class="line">  } <span class='comment'>/* decRoundOperand  */</span></td></tr>
<tr><td class="num" id="LN6871">6871</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6872">6872</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6873">6873</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6874">6874</td><td class="line"><span class='comment'>/* decCopyFit -- copy a number, truncating the coefficient if needed  */</span></td></tr>
<tr><td class="num" id="LN6875">6875</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6876">6876</td><td class="line"><span class='comment'>/*   dest is the target decNumber                                     */</span></td></tr>
<tr><td class="num" id="LN6877">6877</td><td class="line"><span class='comment'>/*   src  is the source decNumber                                     */</span></td></tr>
<tr><td class="num" id="LN6878">6878</td><td class="line"><span class='comment'>/*   set is the context [used for length (digits) and rounding mode]  */</span></td></tr>
<tr><td class="num" id="LN6879">6879</td><td class="line"><span class='comment'>/*   residue is the residue accumulator                               */</span></td></tr>
<tr><td class="num" id="LN6880">6880</td><td class="line"><span class='comment'>/*   status contains the current status to be updated                 */</span></td></tr>
<tr><td class="num" id="LN6881">6881</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6882">6882</td><td class="line"><span class='comment'>/* (dest==src is allowed and will be a no-op if fits)                 */</span></td></tr>
<tr><td class="num" id="LN6883">6883</td><td class="line"><span class='comment'>/* All fields are updated as required.                                */</span></td></tr>
<tr><td class="num" id="LN6884">6884</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6885">6885</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decCopyFit(decNumber *dest, <span class='keyword'>const</span> decNumber *src,</td></tr>
<tr><td class="num" id="LN6886">6886</td><td class="line">                       decContext *set, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *residue, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN6887">6887</td><td class="line">  dest-&gt;bits=src-&gt;bits;</td></tr>
<tr><td class="num" id="LN6888">6888</td><td class="line">  dest-&gt;exponent=src-&gt;exponent;</td></tr>
<tr><td class="num" id="LN6889">6889</td><td class="line">  decSetCoeff(dest, set, src-&gt;lsu, src-&gt;digits, residue, status);</td></tr>
<tr><td class="num" id="LN6890">6890</td><td class="line">  } <span class='comment'>/* decCopyFit  */</span></td></tr>
<tr><td class="num" id="LN6891">6891</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6892">6892</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6893">6893</td><td class="line"><span class='comment'>/* decSetCoeff -- set the coefficient of a number                     */</span></td></tr>
<tr><td class="num" id="LN6894">6894</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6895">6895</td><td class="line"><span class='comment'>/*   dn    is the number whose coefficient array is to be set.        */</span></td></tr>
<tr><td class="num" id="LN6896">6896</td><td class="line"><span class='comment'>/*         It must have space for set-&gt;digits digits                  */</span></td></tr>
<tr><td class="num" id="LN6897">6897</td><td class="line"><span class='comment'>/*   set   is the context [for size]                                  */</span></td></tr>
<tr><td class="num" id="LN6898">6898</td><td class="line"><span class='comment'>/*   lsu   -&gt; lsu of the source coefficient [may be dn-&gt;lsu]          */</span></td></tr>
<tr><td class="num" id="LN6899">6899</td><td class="line"><span class='comment'>/*   len   is digits in the source coefficient [may be dn-&gt;digits]    */</span></td></tr>
<tr><td class="num" id="LN6900">6900</td><td class="line"><span class='comment'>/*   residue is the residue accumulator.  This has values as in       */</span></td></tr>
<tr><td class="num" id="LN6901">6901</td><td class="line"><span class='comment'>/*         decApplyRound, and will be unchanged unless the            */</span></td></tr>
<tr><td class="num" id="LN6902">6902</td><td class="line"><span class='comment'>/*         target size is less than len.  In this case, the           */</span></td></tr>
<tr><td class="num" id="LN6903">6903</td><td class="line"><span class='comment'>/*         coefficient is truncated and the residue is updated to     */</span></td></tr>
<tr><td class="num" id="LN6904">6904</td><td class="line"><span class='comment'>/*         reflect the previous residue and the dropped digits.       */</span></td></tr>
<tr><td class="num" id="LN6905">6905</td><td class="line"><span class='comment'>/*   status is the status accumulator, as usual                       */</span></td></tr>
<tr><td class="num" id="LN6906">6906</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6907">6907</td><td class="line"><span class='comment'>/* The coefficient may already be in the number, or it can be an      */</span></td></tr>
<tr><td class="num" id="LN6908">6908</td><td class="line"><span class='comment'>/* external intermediate array.  If it is in the number, lsu must ==  */</span></td></tr>
<tr><td class="num" id="LN6909">6909</td><td class="line"><span class='comment'>/* dn-&gt;lsu and len must == dn-&gt;digits.                                */</span></td></tr>
<tr><td class="num" id="LN6910">6910</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6911">6911</td><td class="line"><span class='comment'>/* Note that the coefficient length (len) may be &lt; set-&gt;digits, and   */</span></td></tr>
<tr><td class="num" id="LN6912">6912</td><td class="line"><span class='comment'>/* in this case this merely copies the coefficient (or is a no-op     */</span></td></tr>
<tr><td class="num" id="LN6913">6913</td><td class="line"><span class='comment'>/* if dn-&gt;lsu==lsu).                                                  */</span></td></tr>
<tr><td class="num" id="LN6914">6914</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6915">6915</td><td class="line"><span class='comment'>/* Note also that (only internally, from decQuantizeOp and            */</span></td></tr>
<tr><td class="num" id="LN6916">6916</td><td class="line"><span class='comment'>/* decSetSubnormal) the value of set-&gt;digits may be less than one,    */</span></td></tr>
<tr><td class="num" id="LN6917">6917</td><td class="line"><span class='comment'>/* indicating a round to left.  This routine handles that case        */</span></td></tr>
<tr><td class="num" id="LN6918">6918</td><td class="line"><span class='comment'>/* correctly; caller ensures space.                                   */</span></td></tr>
<tr><td class="num" id="LN6919">6919</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6920">6920</td><td class="line"><span class='comment'>/* dn-&gt;digits, dn-&gt;lsu (and as required), and dn-&gt;exponent are        */</span></td></tr>
<tr><td class="num" id="LN6921">6921</td><td class="line"><span class='comment'>/* updated as necessary.   dn-&gt;bits (sign) is unchanged.              */</span></td></tr>
<tr><td class="num" id="LN6922">6922</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN6923">6923</td><td class="line"><span class='comment'>/* DEC_Rounded status is set if any digits are discarded.             */</span></td></tr>
<tr><td class="num" id="LN6924">6924</td><td class="line"><span class='comment'>/* DEC_Inexact status is set if any non-zero digits are discarded, or */</span></td></tr>
<tr><td class="num" id="LN6925">6925</td><td class="line"><span class='comment'>/*                       incoming residue was non-0 (implies rounded) */</span></td></tr>
<tr><td class="num" id="LN6926">6926</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN6927">6927</td><td class="line"><span class='comment'>/* mapping array: maps 0-9 to canonical residues, so that a residue  */</span></td></tr>
<tr><td class="num" id="LN6928">6928</td><td class="line"><span class='comment'>/* can be adjusted in the range [-1, +1] and achieve correct rounding  */</span></td></tr>
<tr><td class="num" id="LN6929">6929</td><td class="line"><span class='comment'>/*                             0  1  2  3  4  5  6  7  8  9  */</span></td></tr>
<tr><td class="num" id="LN6930">6930</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> resmap[10]={0, 3, 3, 3, 3, 5, 7, 7, 7, 7};</td></tr>
<tr><td class="num" id="LN6931">6931</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decSetCoeff(decNumber *dn, decContext *set, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *lsu,</td></tr>
<tr><td class="num" id="LN6932">6932</td><td class="line">                        <span class='macro'>Int<span class='expansion'>int32_t</span></span> len, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *residue, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN6933">6933</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   discard;              <span class='comment'>/* number of digits to discard  */</span></td></tr>
<tr><td class="num" id="LN6934">6934</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  cut;                  <span class='comment'>/* cut point in Unit  */</span></td></tr>
<tr><td class="num" id="LN6935">6935</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;             <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN6936">6936</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span>  *target;              <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6937">6937</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>   count;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6938">6938</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN6939">6939</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  temp;                 <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6940">6940</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN6941">6941</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6942">6942</td><td class="line">  discard=len-set-&gt;digits;    <span class='comment'>/* digits to discard  */</span></td></tr>
<tr><td class="num" id="LN6943">6943</td><td class="line">  <span class='keyword'>if</span> (discard&lt;=0) {           <span class='comment'>/* no digits are being discarded  */</span></td></tr>
<tr><td class="num" id="LN6944">6944</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;lsu!=lsu) {       <span class='comment'>/* copy needed  */</span></td></tr>
<tr><td class="num" id="LN6945">6945</td><td class="line">      <span class='comment'>/* copy the coefficient array to the result number; no shift needed  */</span></td></tr>
<tr><td class="num" id="LN6946">6946</td><td class="line">      count=len;              <span class='comment'>/* avoids D2U  */</span></td></tr>
<tr><td class="num" id="LN6947">6947</td><td class="line">      up=lsu;</td></tr>
<tr><td class="num" id="LN6948">6948</td><td class="line">      <span class='keyword'>for</span> (target=dn-&gt;lsu; count&gt;0; target++, up++, count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)</td></tr>
<tr><td class="num" id="LN6949">6949</td><td class="line">        *target=*up;</td></tr>
<tr><td class="num" id="LN6950">6950</td><td class="line">      dn-&gt;digits=len;         <span class='comment'>/* set the new length  */</span></td></tr>
<tr><td class="num" id="LN6951">6951</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6952">6952</td><td class="line">    <span class='comment'>/* dn-&gt;exponent and residue are unchanged, record any inexactitude  */</span></td></tr>
<tr><td class="num" id="LN6953">6953</td><td class="line">    <span class='keyword'>if</span> (*residue!=0) *status|=(<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>);</td></tr>
<tr><td class="num" id="LN6954">6954</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN6955">6955</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN6956">6956</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6957">6957</td><td class="line">  <span class='comment'>/* some digits must be discarded ...  */</span></td></tr>
<tr><td class="num" id="LN6958">6958</td><td class="line">  dn-&gt;exponent+=discard;      <span class='comment'>/* maintain numerical value  */</span></td></tr>
<tr><td class="num" id="LN6959">6959</td><td class="line">  *status|=<span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;       <span class='comment'>/* accumulate Rounded status  */</span></td></tr>
<tr><td class="num" id="LN6960">6960</td><td class="line">  <span class='keyword'>if</span> (*residue&gt;1) *residue=1; <span class='comment'>/* previous residue now to right, so reduce  */</span></td></tr>
<tr><td class="num" id="LN6961">6961</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6962">6962</td><td class="line">  <span class='keyword'>if</span> (discard&gt;len) {          <span class='comment'>/* everything, +1, is being discarded  */</span></td></tr>
<tr><td class="num" id="LN6963">6963</td><td class="line">    <span class='comment'>/* guard digit is 0  */</span></td></tr>
<tr><td class="num" id="LN6964">6964</td><td class="line">    <span class='comment'>/* residue is all the number [NB could be all 0s]  */</span></td></tr>
<tr><td class="num" id="LN6965">6965</td><td class="line">    <span class='keyword'>if</span> (*residue&lt;=0) {        <span class='comment'>/* not already positive  */</span></td></tr>
<tr><td class="num" id="LN6966">6966</td><td class="line">      count=len;              <span class='comment'>/* avoids D2U  */</span></td></tr>
<tr><td class="num" id="LN6967">6967</td><td class="line">      <span class='keyword'>for</span> (up=lsu; count&gt;0; up++, count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) <span class='keyword'>if</span> (*up!=0) { <span class='comment'>/* found non-0  */</span></td></tr>
<tr><td class="num" id="LN6968">6968</td><td class="line">        *residue=1;</td></tr>
<tr><td class="num" id="LN6969">6969</td><td class="line">        <span class='keyword'>break</span>;                <span class='comment'>/* no need to check any others  */</span></td></tr>
<tr><td class="num" id="LN6970">6970</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN6971">6971</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN6972">6972</td><td class="line">    <span class='keyword'>if</span> (*residue!=0) *status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>; <span class='comment'>/* record inexactitude  */</span></td></tr>
<tr><td class="num" id="LN6973">6973</td><td class="line">    *dn-&gt;lsu=0;               <span class='comment'>/* coefficient will now be 0  */</span></td></tr>
<tr><td class="num" id="LN6974">6974</td><td class="line">    dn-&gt;digits=1;             <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN6975">6975</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN6976">6976</td><td class="line">    } <span class='comment'>/* total discard  */</span></td></tr>
<tr><td class="num" id="LN6977">6977</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6978">6978</td><td class="line">  <span class='comment'>/* partial discard [most common case]  */</span></td></tr>
<tr><td class="num" id="LN6979">6979</td><td class="line">  <span class='comment'>/* here, at least the first (most significant) discarded digit exists  */</span></td></tr>
<tr><td class="num" id="LN6980">6980</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6981">6981</td><td class="line">  <span class='comment'>/* spin up the number, noting residue during the spin, until get to  */</span></td></tr>
<tr><td class="num" id="LN6982">6982</td><td class="line">  <span class='comment'>/* the Unit with the first discarded digit.  When reach it, extract  */</span></td></tr>
<tr><td class="num" id="LN6983">6983</td><td class="line">  <span class='comment'>/* it and remember its position  */</span></td></tr>
<tr><td class="num" id="LN6984">6984</td><td class="line">  count=0;</td></tr>
<tr><td class="num" id="LN6985">6985</td><td class="line">  <span class='keyword'>for</span> (up=lsu;; up++) {</td></tr>
<tr><td class="num" id="LN6986">6986</td><td class="line">    count+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN6987">6987</td><td class="line">    <span class='keyword'>if</span> (count&gt;=discard) <span class='keyword'>break</span>; <span class='comment'>/* full ones all checked  */</span></td></tr>
<tr><td class="num" id="LN6988">6988</td><td class="line">    <span class='keyword'>if</span> (*up!=0) *residue=1;</td></tr>
<tr><td class="num" id="LN6989">6989</td><td class="line">    } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN6990">6990</td><td class="line"> </td></tr>
<tr><td class="num" id="LN6991">6991</td><td class="line">  <span class='comment'>/* here up -&gt; Unit with first discarded digit  */</span></td></tr>
<tr><td class="num" id="LN6992">6992</td><td class="line">  cut=discard-(count-<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)-1;</td></tr>
<tr><td class="num" id="LN6993">6993</td><td class="line">  <span class='keyword'>if</span> (cut==<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1) {       <span class='comment'>/* unit-boundary case (fast)  */</span></td></tr>
<tr><td class="num" id="LN6994">6994</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> half=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>]&gt;&gt;1;</td></tr>
<tr><td class="num" id="LN6995">6995</td><td class="line">    <span class='comment'>/* set residue directly  */</span></td></tr>
<tr><td class="num" id="LN6996">6996</td><td class="line">    <span class='keyword'>if</span> (*up&gt;=half) {</td></tr>
<tr><td class="num" id="LN6997">6997</td><td class="line">      <span class='keyword'>if</span> (*up&gt;half) *residue=7;</td></tr>
<tr><td class="num" id="LN6998">6998</td><td class="line">      <span class='keyword'>else</span> *residue+=5;       <span class='comment'>/* add sticky bit  */</span></td></tr>
<tr><td class="num" id="LN6999">6999</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7000">7000</td><td class="line">     <span class='keyword'>else</span> { <span class='comment'>/* &lt;half  */</span></td></tr>
<tr><td class="num" id="LN7001">7001</td><td class="line">      <span class='keyword'>if</span> (*up!=0) *residue=3; <span class='comment'>/* [else is 0, leave as sticky bit]  */</span></td></tr>
<tr><td class="num" id="LN7002">7002</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7003">7003</td><td class="line">    <span class='keyword'>if</span> (set-&gt;digits&lt;=0) {     <span class='comment'>/* special for Quantize/Subnormal :-(  */</span></td></tr>
<tr><td class="num" id="LN7004">7004</td><td class="line">      *dn-&gt;lsu=0;             <span class='comment'>/* .. result is 0  */</span></td></tr>
<tr><td class="num" id="LN7005">7005</td><td class="line">      dn-&gt;digits=1;           <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN7006">7006</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7007">7007</td><td class="line">     <span class='keyword'>else</span> {                   <span class='comment'>/* shift to least  */</span></td></tr>
<tr><td class="num" id="LN7008">7008</td><td class="line">      count=set-&gt;digits;      <span class='comment'>/* now digits to end up with  */</span></td></tr>
<tr><td class="num" id="LN7009">7009</td><td class="line">      dn-&gt;digits=count;       <span class='comment'>/* set the new length  */</span></td></tr>
<tr><td class="num" id="LN7010">7010</td><td class="line">      up++;                   <span class='comment'>/* move to next  */</span></td></tr>
<tr><td class="num" id="LN7011">7011</td><td class="line">      <span class='comment'>/* on unit boundary, so shift-down copy loop is simple  */</span></td></tr>
<tr><td class="num" id="LN7012">7012</td><td class="line">      <span class='keyword'>for</span> (target=dn-&gt;lsu; count&gt;0; target++, up++, count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>)</td></tr>
<tr><td class="num" id="LN7013">7013</td><td class="line">        *target=*up;</td></tr>
<tr><td class="num" id="LN7014">7014</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7015">7015</td><td class="line">    } <span class='comment'>/* unit-boundary case  */</span></td></tr>
<tr><td class="num" id="LN7016">7016</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7017">7017</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* discard digit is in low digit(s), and not top digit  */</span></td></tr>
<tr><td class="num" id="LN7018">7018</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  discard1;                <span class='comment'>/* first discarded digit  */</span></td></tr>
<tr><td class="num" id="LN7019">7019</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  quot, rem;               <span class='comment'>/* for divisions  */</span></td></tr>
<tr><td class="num" id="LN7020">7020</td><td class="line">    <span class='keyword'>if</span> (cut==0) quot=*up;          <span class='comment'>/* is at bottom of unit  */</span></td></tr>
<tr><td class="num" id="LN7021">7021</td><td class="line">     <span class='keyword'>else</span> <span class='comment'>/* cut&gt;0 */</span> {            <span class='comment'>/* it's not at bottom of unit  */</span></td></tr>
<tr><td class="num" id="LN7022">7022</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN7023">7023</td><td class="line">        U_ASSERT(<span class='comment'>/* cut &gt;= 0 &amp;&amp;*/</span> cut &lt;= 4);</td></tr>
<tr><td class="num" id="LN7024">7024</td><td class="line">        quot=<span class='macro'>QUOT10(*up, cut)<span class='expansion'>((((uint32_t)(*up)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN7025">7025</td><td class="line">        rem=*up-quot*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7026">7026</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN7027">7027</td><td class="line">        rem=*up%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7028">7028</td><td class="line">        quot=*up/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7029">7029</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7030">7030</td><td class="line">      <span class='keyword'>if</span> (rem!=0) *residue=1;</td></tr>
<tr><td class="num" id="LN7031">7031</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7032">7032</td><td class="line">    <span class='comment'>/* discard digit is now at bottom of quot  */</span></td></tr>
<tr><td class="num" id="LN7033">7033</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN7034">7034</td><td class="line">      temp=(quot*6554)&gt;&gt;16;        <span class='comment'>/* fast /10  */</span></td></tr>
<tr><td class="num" id="LN7035">7035</td><td class="line">      <span class='comment'>/* Vowels algorithm here not a win (9 instructions)  */</span></td></tr>
<tr><td class="num" id="LN7036">7036</td><td class="line">      discard1=quot-<span class='macro'>X10(temp)<span class='expansion'>(((temp)&lt;&lt;1)+((temp)&lt;&lt;3))</span></span>;</td></tr>
<tr><td class="num" id="LN7037">7037</td><td class="line">      quot=temp;</td></tr>
<tr><td class="num" id="LN7038">7038</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN7039">7039</td><td class="line">      discard1=quot%10;</td></tr>
<tr><td class="num" id="LN7040">7040</td><td class="line">      quot=quot/10;</td></tr>
<tr><td class="num" id="LN7041">7041</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7042">7042</td><td class="line">    <span class='comment'>/* here, discard1 is the guard digit, and residue is everything  */</span></td></tr>
<tr><td class="num" id="LN7043">7043</td><td class="line">    <span class='comment'>/* else [use mapping array to accumulate residue safely]  */</span></td></tr>
<tr><td class="num" id="LN7044">7044</td><td class="line">    *residue+=resmap[discard1];</td></tr>
<tr><td class="num" id="LN7045">7045</td><td class="line">    cut++;                         <span class='comment'>/* update cut  */</span></td></tr>
<tr><td class="num" id="LN7046">7046</td><td class="line">    <span class='comment'>/* here: up -&gt; Unit of the array with bottom digit  */</span></td></tr>
<tr><td class="num" id="LN7047">7047</td><td class="line">    <span class='comment'>/*       cut is the division point for each Unit  */</span></td></tr>
<tr><td class="num" id="LN7048">7048</td><td class="line">    <span class='comment'>/*       quot holds the uncut high-order digits for the current unit  */</span></td></tr>
<tr><td class="num" id="LN7049">7049</td><td class="line">    <span class='keyword'>if</span> (set-&gt;digits&lt;=0) {          <span class='comment'>/* special for Quantize/Subnormal :-(  */</span></td></tr>
<tr><td class="num" id="LN7050">7050</td><td class="line">      *dn-&gt;lsu=0;                  <span class='comment'>/* .. result is 0  */</span></td></tr>
<tr><td class="num" id="LN7051">7051</td><td class="line">      dn-&gt;digits=1;                <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN7052">7052</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7053">7053</td><td class="line">     <span class='keyword'>else</span> {                        <span class='comment'>/* shift to least needed  */</span></td></tr>
<tr><td class="num" id="LN7054">7054</td><td class="line">      count=set-&gt;digits;           <span class='comment'>/* now digits to end up with  */</span></td></tr>
<tr><td class="num" id="LN7055">7055</td><td class="line">      dn-&gt;digits=count;            <span class='comment'>/* set the new length  */</span></td></tr>
<tr><td class="num" id="LN7056">7056</td><td class="line">      <span class='comment'>/* shift-copy the coefficient array to the result number  */</span></td></tr>
<tr><td class="num" id="LN7057">7057</td><td class="line">      <span class='keyword'>for</span> (target=dn-&gt;lsu; ; target++) {</td></tr>
<tr><td class="num" id="LN7058">7058</td><td class="line">        *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)quot;</td></tr>
<tr><td class="num" id="LN7059">7059</td><td class="line">        count-=(<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-cut);</td></tr>
<tr><td class="num" id="LN7060">7060</td><td class="line">        <span class='keyword'>if</span> (count&lt;=0) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN7061">7061</td><td class="line">        up++;</td></tr>
<tr><td class="num" id="LN7062">7062</td><td class="line">        quot=*up;</td></tr>
<tr><td class="num" id="LN7063">7063</td><td class="line">        <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN7064">7064</td><td class="line">          quot=<span class='macro'>QUOT10(quot, cut)<span class='expansion'>((((uint32_t)(quot)&gt;&gt;(cut))*multies[cut])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN7065">7065</td><td class="line">          rem=*up-quot*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7066">7066</td><td class="line">        <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN7067">7067</td><td class="line">          rem=quot%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7068">7068</td><td class="line">          quot=quot/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7069">7069</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7070">7070</td><td class="line">        *target=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(*target+rem*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-cut]);</td></tr>
<tr><td class="num" id="LN7071">7071</td><td class="line">        count-=cut;</td></tr>
<tr><td class="num" id="LN7072">7072</td><td class="line">        <span class='keyword'>if</span> (count&lt;=0) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN7073">7073</td><td class="line">        } <span class='comment'>/* shift-copy loop  */</span></td></tr>
<tr><td class="num" id="LN7074">7074</td><td class="line">      } <span class='comment'>/* shift to least  */</span></td></tr>
<tr><td class="num" id="LN7075">7075</td><td class="line">    } <span class='comment'>/* not unit boundary  */</span></td></tr>
<tr><td class="num" id="LN7076">7076</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7077">7077</td><td class="line">  <span class='keyword'>if</span> (*residue!=0) *status|=<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>; <span class='comment'>/* record inexactitude  */</span></td></tr>
<tr><td class="num" id="LN7078">7078</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7079">7079</td><td class="line">  } <span class='comment'>/* decSetCoeff  */</span></td></tr>
<tr><td class="num" id="LN7080">7080</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7081">7081</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7082">7082</td><td class="line"><span class='comment'>/* decApplyRound -- apply pending rounding to a number                */</span></td></tr>
<tr><td class="num" id="LN7083">7083</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7084">7084</td><td class="line"><span class='comment'>/*   dn    is the number, with space for set-&gt;digits digits           */</span></td></tr>
<tr><td class="num" id="LN7085">7085</td><td class="line"><span class='comment'>/*   set   is the context [for size and rounding mode]                */</span></td></tr>
<tr><td class="num" id="LN7086">7086</td><td class="line"><span class='comment'>/*   residue indicates pending rounding, being any accumulated        */</span></td></tr>
<tr><td class="num" id="LN7087">7087</td><td class="line"><span class='comment'>/*         guard and sticky information.  It may be:                  */</span></td></tr>
<tr><td class="num" id="LN7088">7088</td><td class="line"><span class='comment'>/*         6-9: rounding digit is &gt;5                                  */</span></td></tr>
<tr><td class="num" id="LN7089">7089</td><td class="line"><span class='comment'>/*         5:   rounding digit is exactly half-way                    */</span></td></tr>
<tr><td class="num" id="LN7090">7090</td><td class="line"><span class='comment'>/*         1-4: rounding digit is &lt;5 and &gt;0                           */</span></td></tr>
<tr><td class="num" id="LN7091">7091</td><td class="line"><span class='comment'>/*         0:   the coefficient is exact                              */</span></td></tr>
<tr><td class="num" id="LN7092">7092</td><td class="line"><span class='comment'>/*        -1:   as 1, but the hidden digits are subtractive, that     */</span></td></tr>
<tr><td class="num" id="LN7093">7093</td><td class="line"><span class='comment'>/*              is, of the opposite sign to dn.  In this case the     */</span></td></tr>
<tr><td class="num" id="LN7094">7094</td><td class="line"><span class='comment'>/*              coefficient must be non-0.  This case occurs when     */</span></td></tr>
<tr><td class="num" id="LN7095">7095</td><td class="line"><span class='comment'>/*              subtracting a small number (which can be reduced to   */</span></td></tr>
<tr><td class="num" id="LN7096">7096</td><td class="line"><span class='comment'>/*              a sticky bit); see decAddOp.                          */</span></td></tr>
<tr><td class="num" id="LN7097">7097</td><td class="line"><span class='comment'>/*   status is the status accumulator, as usual                       */</span></td></tr>
<tr><td class="num" id="LN7098">7098</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7099">7099</td><td class="line"><span class='comment'>/* This routine applies rounding while keeping the length of the      */</span></td></tr>
<tr><td class="num" id="LN7100">7100</td><td class="line"><span class='comment'>/* coefficient constant.  The exponent and status are unchanged       */</span></td></tr>
<tr><td class="num" id="LN7101">7101</td><td class="line"><span class='comment'>/* except if:                                                         */</span></td></tr>
<tr><td class="num" id="LN7102">7102</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7103">7103</td><td class="line"><span class='comment'>/*   -- the coefficient was increased and is all nines (in which      */</span></td></tr>
<tr><td class="num" id="LN7104">7104</td><td class="line"><span class='comment'>/*      case Overflow could occur, and is handled directly here so    */</span></td></tr>
<tr><td class="num" id="LN7105">7105</td><td class="line"><span class='comment'>/*      the caller does not need to re-test for overflow)             */</span></td></tr>
<tr><td class="num" id="LN7106">7106</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7107">7107</td><td class="line"><span class='comment'>/*   -- the coefficient was decreased and becomes all nines (in which */</span></td></tr>
<tr><td class="num" id="LN7108">7108</td><td class="line"><span class='comment'>/*      case Underflow could occur, and is also handled directly).    */</span></td></tr>
<tr><td class="num" id="LN7109">7109</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7110">7110</td><td class="line"><span class='comment'>/* All fields in dn are updated as required.                          */</span></td></tr>
<tr><td class="num" id="LN7111">7111</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7112">7112</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7113">7113</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decApplyRound(decNumber *dn, decContext *set, <span class='macro'>Int<span class='expansion'>int32_t</span></span> residue,</td></tr>
<tr><td class="num" id="LN7114">7114</td><td class="line">                          <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7115">7115</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  bump;                  <span class='comment'>/* 1 if coefficient needs to be incremented  */</span></td></tr>
<tr><td class="num" id="LN7116">7116</td><td class="line">                              <span class='comment'>/* -1 if coefficient needs to be decremented  */</span></td></tr>
<tr><td class="num" id="LN7117">7117</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7118">7118</td><td class="line">  <span class='keyword'>if</span> (residue==0) <span class='keyword'>return</span>;     <span class='comment'>/* nothing to apply  */</span></td></tr>
<tr><td class="num" id="LN7119">7119</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7120">7120</td><td class="line">  bump=0;                     <span class='comment'>/* assume a smooth ride  */</span></td></tr>
<tr><td class="num" id="LN7121">7121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7122">7122</td><td class="line">  <span class='comment'>/* now decide whether, and how, to round, depending on mode  */</span></td></tr>
<tr><td class="num" id="LN7123">7123</td><td class="line">  <span class='keyword'>switch</span> (set-&gt;round) {</td></tr>
<tr><td class="num" id="LN7124">7124</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_05UP: {    <span class='comment'>/* round zero or five up (for reround)  */</span></td></tr>
<tr><td class="num" id="LN7125">7125</td><td class="line">      <span class='comment'>/* This is the same as DEC_ROUND_DOWN unless there is a  */</span></td></tr>
<tr><td class="num" id="LN7126">7126</td><td class="line">      <span class='comment'>/* positive residue and the lsd of dn is 0 or 5, in which case  */</span></td></tr>
<tr><td class="num" id="LN7127">7127</td><td class="line">      <span class='comment'>/* it is bumped; when residue is &lt;0, the number is therefore  */</span></td></tr>
<tr><td class="num" id="LN7128">7128</td><td class="line">      <span class='comment'>/* bumped down unless the final digit was 1 or 6 (in which  */</span></td></tr>
<tr><td class="num" id="LN7129">7129</td><td class="line">      <span class='comment'>/* case it is bumped down and then up -- a no-op)  */</span></td></tr>
<tr><td class="num" id="LN7130">7130</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> lsd5=*dn-&gt;lsu%5;     <span class='comment'>/* get lsd and quintate  */</span></td></tr>
<tr><td class="num" id="LN7131">7131</td><td class="line">      <span class='keyword'>if</span> (residue&lt;0 &amp;&amp; lsd5!=1) bump=-1;</td></tr>
<tr><td class="num" id="LN7132">7132</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (residue&gt;0 &amp;&amp; lsd5==0) bump=1;</td></tr>
<tr><td class="num" id="LN7133">7133</td><td class="line">      <span class='comment'>/* [bump==1 could be applied directly; use common path for clarity]  */</span></td></tr>
<tr><td class="num" id="LN7134">7134</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-05  */</span></td></tr>
<tr><td class="num" id="LN7135">7135</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7136">7136</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_DOWN: {</td></tr>
<tr><td class="num" id="LN7137">7137</td><td class="line">      <span class='comment'>/* no change, except if negative residue  */</span></td></tr>
<tr><td class="num" id="LN7138">7138</td><td class="line">      <span class='keyword'>if</span> (residue&lt;0) bump=-1;</td></tr>
<tr><td class="num" id="LN7139">7139</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-d  */</span></td></tr>
<tr><td class="num" id="LN7140">7140</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7141">7141</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_HALF_DOWN: {</td></tr>
<tr><td class="num" id="LN7142">7142</td><td class="line">      <span class='keyword'>if</span> (residue&gt;5) bump=1;</td></tr>
<tr><td class="num" id="LN7143">7143</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-h-d  */</span></td></tr>
<tr><td class="num" id="LN7144">7144</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7145">7145</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_HALF_EVEN: {</td></tr>
<tr><td class="num" id="LN7146">7146</td><td class="line">      <span class='keyword'>if</span> (residue&gt;5) bump=1;            <span class='comment'>/* &gt;0.5 goes up  */</span></td></tr>
<tr><td class="num" id="LN7147">7147</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (residue==5) {           <span class='comment'>/* exactly 0.5000...  */</span></td></tr>
<tr><td class="num" id="LN7148">7148</td><td class="line">        <span class='comment'>/* 0.5 goes up iff [new] lsd is odd  */</span></td></tr>
<tr><td class="num" id="LN7149">7149</td><td class="line">        <span class='keyword'>if</span> (*dn-&gt;lsu &amp; 0x01) bump=1;</td></tr>
<tr><td class="num" id="LN7150">7150</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7151">7151</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-h-e  */</span></td></tr>
<tr><td class="num" id="LN7152">7152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7153">7153</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_HALF_UP: {</td></tr>
<tr><td class="num" id="LN7154">7154</td><td class="line">      <span class='keyword'>if</span> (residue&gt;=5) bump=1;</td></tr>
<tr><td class="num" id="LN7155">7155</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-h-u  */</span></td></tr>
<tr><td class="num" id="LN7156">7156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7157">7157</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_UP: {</td></tr>
<tr><td class="num" id="LN7158">7158</td><td class="line">      <span class='keyword'>if</span> (residue&gt;0) bump=1;</td></tr>
<tr><td class="num" id="LN7159">7159</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-u  */</span></td></tr>
<tr><td class="num" id="LN7160">7160</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7161">7161</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_CEILING: {</td></tr>
<tr><td class="num" id="LN7162">7162</td><td class="line">      <span class='comment'>/* same as _UP for positive numbers, and as _DOWN for negatives  */</span></td></tr>
<tr><td class="num" id="LN7163">7163</td><td class="line">      <span class='comment'>/* [negative residue cannot occur on 0]  */</span></td></tr>
<tr><td class="num" id="LN7164">7164</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN7165">7165</td><td class="line">        <span class='keyword'>if</span> (residue&lt;0) bump=-1;</td></tr>
<tr><td class="num" id="LN7166">7166</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7167">7167</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN7168">7168</td><td class="line">        <span class='keyword'>if</span> (residue&gt;0) bump=1;</td></tr>
<tr><td class="num" id="LN7169">7169</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7170">7170</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-c  */</span></td></tr>
<tr><td class="num" id="LN7171">7171</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7172">7172</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_FLOOR: {</td></tr>
<tr><td class="num" id="LN7173">7173</td><td class="line">      <span class='comment'>/* same as _UP for negative numbers, and as _DOWN for positive  */</span></td></tr>
<tr><td class="num" id="LN7174">7174</td><td class="line">      <span class='comment'>/* [negative residue cannot occur on 0]  */</span></td></tr>
<tr><td class="num" id="LN7175">7175</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN7176">7176</td><td class="line">        <span class='keyword'>if</span> (residue&lt;0) bump=-1;</td></tr>
<tr><td class="num" id="LN7177">7177</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7178">7178</td><td class="line">       <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN7179">7179</td><td class="line">        <span class='keyword'>if</span> (residue&gt;0) bump=1;</td></tr>
<tr><td class="num" id="LN7180">7180</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7181">7181</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-f  */</span></td></tr>
<tr><td class="num" id="LN7182">7182</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7183">7183</td><td class="line">    <span class='keyword'>default</span>: {      <span class='comment'>/* e.g., DEC_ROUND_MAX  */</span></td></tr>
<tr><td class="num" id="LN7184">7184</td><td class="line">      *status|=<span class='macro'>DEC_Invalid_context<span class='expansion'>0x00000040</span></span>;</td></tr>
<tr><td class="num" id="LN7185">7185</td><td class="line">      <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || (<span class='macro'>DECCHECK<span class='expansion'>0</span></span> &amp;&amp; <span class='macro'>DECVERB<span class='expansion'>1</span></span>)</span></td></tr>
<tr><td class="num" id="LN7186">7186</td><td class="line">      printf(<span class='string_literal'>"Unknown rounding mode: %d\n"</span>, set-&gt;round);</td></tr>
<tr><td class="num" id="LN7187">7187</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7188">7188</td><td class="line">      <span class='keyword'>break</span>;}</td></tr>
<tr><td class="num" id="LN7189">7189</td><td class="line">    } <span class='comment'>/* switch  */</span></td></tr>
<tr><td class="num" id="LN7190">7190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7191">7191</td><td class="line">  <span class='comment'>/* now bump the number, up or down, if need be  */</span></td></tr>
<tr><td class="num" id="LN7192">7192</td><td class="line">  <span class='keyword'>if</span> (bump==0) <span class='keyword'>return</span>;                       <span class='comment'>/* no action required  */</span></td></tr>
<tr><td class="num" id="LN7193">7193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7194">7194</td><td class="line">  <span class='comment'>/* Simply use decUnitAddSub unless bumping up and the number is  */</span></td></tr>
<tr><td class="num" id="LN7195">7195</td><td class="line">  <span class='comment'>/* all nines.  In this special case set to 100... explicitly  */</span></td></tr>
<tr><td class="num" id="LN7196">7196</td><td class="line">  <span class='comment'>/* and adjust the exponent by one (as otherwise could overflow  */</span></td></tr>
<tr><td class="num" id="LN7197">7197</td><td class="line">  <span class='comment'>/* the array)  */</span></td></tr>
<tr><td class="num" id="LN7198">7198</td><td class="line">  <span class='comment'>/* Similarly handle all-nines result if bumping down.  */</span></td></tr>
<tr><td class="num" id="LN7199">7199</td><td class="line">  <span class='keyword'>if</span> (bump&gt;0) {</td></tr>
<tr><td class="num" id="LN7200">7200</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                                <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7201">7201</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> count=dn-&gt;digits;                   <span class='comment'>/* digits to be checked  */</span></td></tr>
<tr><td class="num" id="LN7202">7202</td><td class="line">    <span class='keyword'>for</span> (up=dn-&gt;lsu; ; up++) {</td></tr>
<tr><td class="num" id="LN7203">7203</td><td class="line">      <span class='keyword'>if</span> (count&lt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {</td></tr>
<tr><td class="num" id="LN7204">7204</td><td class="line">        <span class='comment'>/* this is the last Unit (the msu)  */</span></td></tr>
<tr><td class="num" id="LN7205">7205</td><td class="line">        <span class='keyword'>if</span> (*up!=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count]-1) <span class='keyword'>break</span>;     <span class='comment'>/* not still 9s  */</span></td></tr>
<tr><td class="num" id="LN7206">7206</td><td class="line">        <span class='comment'>/* here if it, too, is all nines  */</span></td></tr>
<tr><td class="num" id="LN7207">7207</td><td class="line">        *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count-1];           <span class='comment'>/* here 999 -&gt; 100 etc.  */</span></td></tr>
<tr><td class="num" id="LN7208">7208</td><td class="line">        <span class='keyword'>for</span> (up=up-1; up&gt;=dn-&gt;lsu; up--) *up=0; <span class='comment'>/* others all to 0  */</span></td></tr>
<tr><td class="num" id="LN7209">7209</td><td class="line">        dn-&gt;exponent++;                      <span class='comment'>/* and bump exponent  */</span></td></tr>
<tr><td class="num" id="LN7210">7210</td><td class="line">        <span class='comment'>/* [which, very rarely, could cause Overflow...]  */</span></td></tr>
<tr><td class="num" id="LN7211">7211</td><td class="line">        <span class='keyword'>if</span> ((dn-&gt;exponent+dn-&gt;digits)&gt;set-&gt;emax+1) {</td></tr>
<tr><td class="num" id="LN7212">7212</td><td class="line">          decSetOverflow(dn, set, status);</td></tr>
<tr><td class="num" id="LN7213">7213</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN7214">7214</td><td class="line">        <span class='keyword'>return</span>;                              <span class='comment'>/* done  */</span></td></tr>
<tr><td class="num" id="LN7215">7215</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7216">7216</td><td class="line">      <span class='comment'>/* a full unit to check, with more to come  */</span></td></tr>
<tr><td class="num" id="LN7217">7217</td><td class="line">      <span class='keyword'>if</span> (*up!=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>) <span class='keyword'>break</span>;            <span class='comment'>/* not still 9s  */</span></td></tr>
<tr><td class="num" id="LN7218">7218</td><td class="line">      count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN7219">7219</td><td class="line">      } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN7220">7220</td><td class="line">    } <span class='comment'>/* bump&gt;0  */</span></td></tr>
<tr><td class="num" id="LN7221">7221</td><td class="line">   <span class='keyword'>else</span> {                                    <span class='comment'>/* -1  */</span></td></tr>
<tr><td class="num" id="LN7222">7222</td><td class="line">    <span class='comment'>/* here checking for a pre-bump of 1000... (leading 1, all  */</span></td></tr>
<tr><td class="num" id="LN7223">7223</td><td class="line">    <span class='comment'>/* other digits zero)  */</span></td></tr>
<tr><td class="num" id="LN7224">7224</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up, *sup;                          <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7225">7225</td><td class="line">    <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> count=dn-&gt;digits;                   <span class='comment'>/* digits to be checked  */</span></td></tr>
<tr><td class="num" id="LN7226">7226</td><td class="line">    <span class='keyword'>for</span> (up=dn-&gt;lsu; ; up++) {</td></tr>
<tr><td class="num" id="LN7227">7227</td><td class="line">      <span class='keyword'>if</span> (count&lt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) {</td></tr>
<tr><td class="num" id="LN7228">7228</td><td class="line">        <span class='comment'>/* this is the last Unit (the msu)  */</span></td></tr>
<tr><td class="num" id="LN7229">7229</td><td class="line">        <span class='keyword'>if</span> (*up!=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count-1]) <span class='keyword'>break</span>;     <span class='comment'>/* not 100..  */</span></td></tr>
<tr><td class="num" id="LN7230">7230</td><td class="line">        <span class='comment'>/* here if have the 1000... case  */</span></td></tr>
<tr><td class="num" id="LN7231">7231</td><td class="line">        sup=up;                              <span class='comment'>/* save msu pointer  */</span></td></tr>
<tr><td class="num" id="LN7232">7232</td><td class="line">        *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count]-1;           <span class='comment'>/* here 100 in msu -&gt; 999  */</span></td></tr>
<tr><td class="num" id="LN7233">7233</td><td class="line">        <span class='comment'>/* others all to all-nines, too  */</span></td></tr>
<tr><td class="num" id="LN7234">7234</td><td class="line">        <span class='keyword'>for</span> (up=up-1; up&gt;=dn-&gt;lsu; up--) *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[<span class='macro'>DECDPUN<span class='expansion'>1</span></span>]-1;</td></tr>
<tr><td class="num" id="LN7235">7235</td><td class="line">        dn-&gt;exponent--;                      <span class='comment'>/* and bump exponent  */</span></td></tr>
<tr><td class="num" id="LN7236">7236</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7237">7237</td><td class="line">        <span class='comment'>/* iff the number was at the subnormal boundary (exponent=etiny)  */</span></td></tr>
<tr><td class="num" id="LN7238">7238</td><td class="line">        <span class='comment'>/* then the exponent is now out of range, so it will in fact get  */</span></td></tr>
<tr><td class="num" id="LN7239">7239</td><td class="line">        <span class='comment'>/* clamped to etiny and the final 9 dropped.  */</span></td></tr>
<tr><td class="num" id="LN7240">7240</td><td class="line">        <span class='comment'>/* printf("&gt;&gt; emin=%d exp=%d sdig=%d\n", set-&gt;emin,  */</span></td></tr>
<tr><td class="num" id="LN7241">7241</td><td class="line">        <span class='comment'>/*        dn-&gt;exponent, set-&gt;digits);  */</span></td></tr>
<tr><td class="num" id="LN7242">7242</td><td class="line">        <span class='keyword'>if</span> (dn-&gt;exponent+1==set-&gt;emin-set-&gt;digits+1) {</td></tr>
<tr><td class="num" id="LN7243">7243</td><td class="line">          <span class='keyword'>if</span> (count==1 &amp;&amp; dn-&gt;digits==1) *sup=0;  <span class='comment'>/* here 9 -&gt; 0[.9]  */</span></td></tr>
<tr><td class="num" id="LN7244">7244</td><td class="line">           <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN7245">7245</td><td class="line">            *sup=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count-1]-1;    <span class='comment'>/* here 999.. in msu -&gt; 99..  */</span></td></tr>
<tr><td class="num" id="LN7246">7246</td><td class="line">            dn-&gt;digits--;</td></tr>
<tr><td class="num" id="LN7247">7247</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN7248">7248</td><td class="line">          dn-&gt;exponent++;</td></tr>
<tr><td class="num" id="LN7249">7249</td><td class="line">          *status|=<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span> | <span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span> | <span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;</td></tr>
<tr><td class="num" id="LN7250">7250</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN7251">7251</td><td class="line">        <span class='keyword'>return</span>;                              <span class='comment'>/* done  */</span></td></tr>
<tr><td class="num" id="LN7252">7252</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7253">7253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7254">7254</td><td class="line">      <span class='comment'>/* a full unit to check, with more to come  */</span></td></tr>
<tr><td class="num" id="LN7255">7255</td><td class="line">      <span class='keyword'>if</span> (*up!=0) <span class='keyword'>break</span>;                     <span class='comment'>/* not still 0s  */</span></td></tr>
<tr><td class="num" id="LN7256">7256</td><td class="line">      count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN7257">7257</td><td class="line">      } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN7258">7258</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7259">7259</td><td class="line">    } <span class='comment'>/* bump&lt;0  */</span></td></tr>
<tr><td class="num" id="LN7260">7260</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7261">7261</td><td class="line">  <span class='comment'>/* Actual bump needed.  Do it.  */</span></td></tr>
<tr><td class="num" id="LN7262">7262</td><td class="line">  decUnitAddSub(dn-&gt;lsu, <span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>, uarrone, 1, 0, dn-&gt;lsu, bump);</td></tr>
<tr><td class="num" id="LN7263">7263</td><td class="line">  } <span class='comment'>/* decApplyRound  */</span></td></tr>
<tr><td class="num" id="LN7264">7264</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7265">7265</td><td class="line"><span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7266">7266</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7267">7267</td><td class="line"><span class='comment'>/* decFinish -- finish processing a number                            */</span></td></tr>
<tr><td class="num" id="LN7268">7268</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7269">7269</td><td class="line"><span class='comment'>/*   dn is the number                                                 */</span></td></tr>
<tr><td class="num" id="LN7270">7270</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN7271">7271</td><td class="line"><span class='comment'>/*   residue is the rounding accumulator (as in decApplyRound)        */</span></td></tr>
<tr><td class="num" id="LN7272">7272</td><td class="line"><span class='comment'>/*   status is the accumulator                                        */</span></td></tr>
<tr><td class="num" id="LN7273">7273</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7274">7274</td><td class="line"><span class='comment'>/* This finishes off the current number by:                           */</span></td></tr>
<tr><td class="num" id="LN7275">7275</td><td class="line"><span class='comment'>/*    1. If not extended:                                             */</span></td></tr>
<tr><td class="num" id="LN7276">7276</td><td class="line"><span class='comment'>/*       a. Converting a zero result to clean '0'                     */</span></td></tr>
<tr><td class="num" id="LN7277">7277</td><td class="line"><span class='comment'>/*       b. Reducing positive exponents to 0, if would fit in digits  */</span></td></tr>
<tr><td class="num" id="LN7278">7278</td><td class="line"><span class='comment'>/*    2. Checking for overflow and subnormals (always)                */</span></td></tr>
<tr><td class="num" id="LN7279">7279</td><td class="line"><span class='comment'>/* Note this is just Finalize when no subset arithmetic.              */</span></td></tr>
<tr><td class="num" id="LN7280">7280</td><td class="line"><span class='comment'>/* All fields are updated as required.                                */</span></td></tr>
<tr><td class="num" id="LN7281">7281</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7282">7282</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> <span class='macro'>decFinish(decNumber *dn, decContext *set, Int *residue,<span class='expansion'>decFinalize(decNumber *dn,decContext *set,int32_t *residue,uint32_t<br> *status)</span></span></td></tr>
<tr><td class="num" id="LN7283">7283</td><td class="line">                      <span class='macro'>uInt *status)<span class='expansion'>decFinalize(decNumber *dn,decContext *set,int32_t *residue,uint32_t<br> *status)</span></span> {</td></tr>
<tr><td class="num" id="LN7284">7284</td><td class="line">  <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN7285">7285</td><td class="line">    <span class='keyword'>if</span> <span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span> {                <span class='comment'>/* value is zero  */</span></td></tr>
<tr><td class="num" id="LN7286">7286</td><td class="line">      dn-&gt;exponent=0;              <span class='comment'>/* clean exponent ..  */</span></td></tr>
<tr><td class="num" id="LN7287">7287</td><td class="line">      dn-&gt;bits=0;                  <span class='comment'>/* .. and sign  */</span></td></tr>
<tr><td class="num" id="LN7288">7288</td><td class="line">      <span class='keyword'>return</span>;                      <span class='comment'>/* no error possible  */</span></td></tr>
<tr><td class="num" id="LN7289">7289</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7290">7290</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent&gt;=0) {         <span class='comment'>/* non-negative exponent  */</span></td></tr>
<tr><td class="num" id="LN7291">7291</td><td class="line">      <span class='comment'>/* &gt;0; reduce to integer if possible  */</span></td></tr>
<tr><td class="num" id="LN7292">7292</td><td class="line">      <span class='keyword'>if</span> (set-&gt;digits &gt;= (dn-&gt;exponent+dn-&gt;digits)) {</td></tr>
<tr><td class="num" id="LN7293">7293</td><td class="line">        dn-&gt;digits=decShiftToMost(dn-&gt;lsu, dn-&gt;digits, dn-&gt;exponent);</td></tr>
<tr><td class="num" id="LN7294">7294</td><td class="line">        dn-&gt;exponent=0;</td></tr>
<tr><td class="num" id="LN7295">7295</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7296">7296</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7297">7297</td><td class="line">    } <span class='comment'>/* !extended  */</span></td></tr>
<tr><td class="num" id="LN7298">7298</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7299">7299</td><td class="line">  decFinalize(dn, set, residue, status);</td></tr>
<tr><td class="num" id="LN7300">7300</td><td class="line">  } <span class='comment'>/* decFinish  */</span></td></tr>
<tr><td class="num" id="LN7301">7301</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7302">7302</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7303">7303</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7304">7304</td><td class="line"><span class='comment'>/* decFinalize -- final check, clamp, and round of a number           */</span></td></tr>
<tr><td class="num" id="LN7305">7305</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7306">7306</td><td class="line"><span class='comment'>/*   dn is the number                                                 */</span></td></tr>
<tr><td class="num" id="LN7307">7307</td><td class="line"><span class='comment'>/*   set is the context                                               */</span></td></tr>
<tr><td class="num" id="LN7308">7308</td><td class="line"><span class='comment'>/*   residue is the rounding accumulator (as in decApplyRound)        */</span></td></tr>
<tr><td class="num" id="LN7309">7309</td><td class="line"><span class='comment'>/*   status is the status accumulator                                 */</span></td></tr>
<tr><td class="num" id="LN7310">7310</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7311">7311</td><td class="line"><span class='comment'>/* This finishes off the current number by checking for subnormal     */</span></td></tr>
<tr><td class="num" id="LN7312">7312</td><td class="line"><span class='comment'>/* results, applying any pending rounding, checking for overflow,     */</span></td></tr>
<tr><td class="num" id="LN7313">7313</td><td class="line"><span class='comment'>/* and applying any clamping.                                         */</span></td></tr>
<tr><td class="num" id="LN7314">7314</td><td class="line"><span class='comment'>/* Underflow and overflow conditions are raised as appropriate.       */</span></td></tr>
<tr><td class="num" id="LN7315">7315</td><td class="line"><span class='comment'>/* All fields are updated as required.                                */</span></td></tr>
<tr><td class="num" id="LN7316">7316</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7317">7317</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decFinalize(decNumber *dn, decContext *set, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *residue,</td></tr>
<tr><td class="num" id="LN7318">7318</td><td class="line">                        <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7319">7319</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> shift;                            <span class='comment'>/* shift needed if clamping  */</span></td></tr>
<tr><td class="num" id="LN7320">7320</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> tinyexp=set-&gt;emin-dn-&gt;digits+1;   <span class='comment'>/* precalculate subnormal boundary  */</span></td></tr>
<tr><td class="num" id="LN7321">7321</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7322">7322</td><td class="line">  <span class='comment'>/* Must be careful, here, when checking the exponent as the  */</span></td></tr>
<tr><td class="num" id="LN7323">7323</td><td class="line">  <span class='comment'>/* adjusted exponent could overflow 31 bits [because it may already  */</span></td></tr>
<tr><td class="num" id="LN7324">7324</td><td class="line">  <span class='comment'>/* be up to twice the expected].  */</span></td></tr>
<tr><td class="num" id="LN7325">7325</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7326">7326</td><td class="line">  <span class='comment'>/* First test for subnormal.  This must be done before any final  */</span></td></tr>
<tr><td class="num" id="LN7327">7327</td><td class="line">  <span class='comment'>/* round as the result could be rounded to Nmin or 0.  */</span></td></tr>
<tr><td class="num" id="LN7328">7328</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent&lt;=tinyexp) {          <span class='comment'>/* prefilter  */</span></td></tr>
<tr><td class="num" id="LN7329">7329</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> comp;</td></tr>
<tr><td class="num" id="LN7330">7330</td><td class="line">    decNumber nmin;</td></tr>
<tr><td class="num" id="LN7331">7331</td><td class="line">    <span class='comment'>/* A very nasty case here is dn == Nmin and residue&lt;0  */</span></td></tr>
<tr><td class="num" id="LN7332">7332</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent&lt;tinyexp) {</td></tr>
<tr><td class="num" id="LN7333">7333</td><td class="line">      <span class='comment'>/* Go handle subnormals; this will apply round if needed.  */</span></td></tr>
<tr><td class="num" id="LN7334">7334</td><td class="line">      decSetSubnormal(dn, set, residue, status);</td></tr>
<tr><td class="num" id="LN7335">7335</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7336">7336</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7337">7337</td><td class="line">    <span class='comment'>/* Equals case: only subnormal if dn=Nmin and negative residue  */</span></td></tr>
<tr><td class="num" id="LN7338">7338</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(&amp;nmin);</td></tr>
<tr><td class="num" id="LN7339">7339</td><td class="line">    nmin.lsu[0]=1;</td></tr>
<tr><td class="num" id="LN7340">7340</td><td class="line">    nmin.exponent=set-&gt;emin;</td></tr>
<tr><td class="num" id="LN7341">7341</td><td class="line">    comp=decCompare(dn, &amp;nmin, 1);                <span class='comment'>/* (signless compare)  */</span></td></tr>
<tr><td class="num" id="LN7342">7342</td><td class="line">    <span class='keyword'>if</span> (comp==<span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>) {                           <span class='comment'>/* oops  */</span></td></tr>
<tr><td class="num" id="LN7343">7343</td><td class="line">      *status|=<span class='macro'>DEC_Insufficient_storage<span class='expansion'>0x00000010</span></span>;          <span class='comment'>/* abandon...  */</span></td></tr>
<tr><td class="num" id="LN7344">7344</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7345">7345</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7346">7346</td><td class="line">    <span class='keyword'>if</span> (*residue&lt;0 &amp;&amp; comp==0) {                  <span class='comment'>/* neg residue and dn==Nmin  */</span></td></tr>
<tr><td class="num" id="LN7347">7347</td><td class="line">      decApplyRound(dn, set, *residue, status);   <span class='comment'>/* might force down  */</span></td></tr>
<tr><td class="num" id="LN7348">7348</td><td class="line">      decSetSubnormal(dn, set, residue, status);</td></tr>
<tr><td class="num" id="LN7349">7349</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7350">7350</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7351">7351</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7352">7352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7353">7353</td><td class="line">  <span class='comment'>/* now apply any pending round (this could raise overflow).  */</span></td></tr>
<tr><td class="num" id="LN7354">7354</td><td class="line">  <span class='keyword'>if</span> (*residue!=0) decApplyRound(dn, set, *residue, status);</td></tr>
<tr><td class="num" id="LN7355">7355</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7356">7356</td><td class="line">  <span class='comment'>/* Check for overflow [redundant in the 'rare' case] or clamp  */</span></td></tr>
<tr><td class="num" id="LN7357">7357</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent&lt;=set-&gt;emax-set-&gt;digits+1) <span class='keyword'>return</span>;   <span class='comment'>/* neither needed  */</span></td></tr>
<tr><td class="num" id="LN7358">7358</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7359">7359</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7360">7360</td><td class="line">  <span class='comment'>/* here when might have an overflow or clamp to do  */</span></td></tr>
<tr><td class="num" id="LN7361">7361</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent&gt;set-&gt;emax-dn-&gt;digits+1) {           <span class='comment'>/* too big  */</span></td></tr>
<tr><td class="num" id="LN7362">7362</td><td class="line">    decSetOverflow(dn, set, status);</td></tr>
<tr><td class="num" id="LN7363">7363</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7364">7364</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7365">7365</td><td class="line">  <span class='comment'>/* here when the result is normal but in clamp range  */</span></td></tr>
<tr><td class="num" id="LN7366">7366</td><td class="line">  <span class='keyword'>if</span> (!set-&gt;clamp) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7367">7367</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7368">7368</td><td class="line">  <span class='comment'>/* here when need to apply the IEEE exponent clamp (fold-down)  */</span></td></tr>
<tr><td class="num" id="LN7369">7369</td><td class="line">  shift=dn-&gt;exponent-(set-&gt;emax-set-&gt;digits+1);</td></tr>
<tr><td class="num" id="LN7370">7370</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7371">7371</td><td class="line">  <span class='comment'>/* shift coefficient (if non-zero)  */</span></td></tr>
<tr><td class="num" id="LN7372">7372</td><td class="line">  <span class='keyword'>if</span> (!<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {</td></tr>
<tr><td class="num" id="LN7373">7373</td><td class="line">    dn-&gt;digits=decShiftToMost(dn-&gt;lsu, dn-&gt;digits, shift);</td></tr>
<tr><td class="num" id="LN7374">7374</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7375">7375</td><td class="line">  dn-&gt;exponent-=shift;   <span class='comment'>/* adjust the exponent to match  */</span></td></tr>
<tr><td class="num" id="LN7376">7376</td><td class="line">  *status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;  <span class='comment'>/* and record the dirty deed  */</span></td></tr>
<tr><td class="num" id="LN7377">7377</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7378">7378</td><td class="line">  } <span class='comment'>/* decFinalize  */</span></td></tr>
<tr><td class="num" id="LN7379">7379</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7380">7380</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7381">7381</td><td class="line"><span class='comment'>/* decSetOverflow -- set number to proper overflow value              */</span></td></tr>
<tr><td class="num" id="LN7382">7382</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7383">7383</td><td class="line"><span class='comment'>/*   dn is the number (used for sign [only] and result)               */</span></td></tr>
<tr><td class="num" id="LN7384">7384</td><td class="line"><span class='comment'>/*   set is the context [used for the rounding mode, etc.]            */</span></td></tr>
<tr><td class="num" id="LN7385">7385</td><td class="line"><span class='comment'>/*   status contains the current status to be updated                 */</span></td></tr>
<tr><td class="num" id="LN7386">7386</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7387">7387</td><td class="line"><span class='comment'>/* This sets the sign of a number and sets its value to either        */</span></td></tr>
<tr><td class="num" id="LN7388">7388</td><td class="line"><span class='comment'>/* Infinity or the maximum finite value, depending on the sign of     */</span></td></tr>
<tr><td class="num" id="LN7389">7389</td><td class="line"><span class='comment'>/* dn and the rounding mode, following IEEE 754 rules.                */</span></td></tr>
<tr><td class="num" id="LN7390">7390</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7391">7391</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decSetOverflow(decNumber *dn, decContext *set, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7392">7392</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> needmax=0;                  <span class='comment'>/* result is maximum finite value  */</span></td></tr>
<tr><td class="num" id="LN7393">7393</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> sign=dn-&gt;bits&amp;<span class='macro'>DECNEG<span class='expansion'>0x80</span></span>;      <span class='comment'>/* clean and save sign bit  */</span></td></tr>
<tr><td class="num" id="LN7394">7394</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7395">7395</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) {                <span class='comment'>/* zero does not overflow magnitude  */</span></td></tr>
<tr><td class="num" id="LN7396">7396</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> emax=set-&gt;emax;                      <span class='comment'>/* limit value  */</span></td></tr>
<tr><td class="num" id="LN7397">7397</td><td class="line">    <span class='keyword'>if</span> (set-&gt;clamp) emax-=set-&gt;digits-1;     <span class='comment'>/* lower if clamping  */</span></td></tr>
<tr><td class="num" id="LN7398">7398</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent&gt;emax) {                 <span class='comment'>/* clamp required  */</span></td></tr>
<tr><td class="num" id="LN7399">7399</td><td class="line">      dn-&gt;exponent=emax;</td></tr>
<tr><td class="num" id="LN7400">7400</td><td class="line">      *status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN7401">7401</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7402">7402</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7403">7403</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7404">7404</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7405">7405</td><td class="line">  <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);</td></tr>
<tr><td class="num" id="LN7406">7406</td><td class="line">  <span class='keyword'>switch</span> (set-&gt;round) {</td></tr>
<tr><td class="num" id="LN7407">7407</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_DOWN: {</td></tr>
<tr><td class="num" id="LN7408">7408</td><td class="line">      needmax=1;                   <span class='comment'>/* never Infinity  */</span></td></tr>
<tr><td class="num" id="LN7409">7409</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-d  */</span></td></tr>
<tr><td class="num" id="LN7410">7410</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_05UP: {</td></tr>
<tr><td class="num" id="LN7411">7411</td><td class="line">      needmax=1;                   <span class='comment'>/* never Infinity  */</span></td></tr>
<tr><td class="num" id="LN7412">7412</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-05  */</span></td></tr>
<tr><td class="num" id="LN7413">7413</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_CEILING: {</td></tr>
<tr><td class="num" id="LN7414">7414</td><td class="line">      <span class='keyword'>if</span> (sign) needmax=1;         <span class='comment'>/* Infinity if non-negative  */</span></td></tr>
<tr><td class="num" id="LN7415">7415</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-c  */</span></td></tr>
<tr><td class="num" id="LN7416">7416</td><td class="line">    <span class='keyword'>case</span> DEC_ROUND_FLOOR: {</td></tr>
<tr><td class="num" id="LN7417">7417</td><td class="line">      <span class='keyword'>if</span> (!sign) needmax=1;        <span class='comment'>/* Infinity if negative  */</span></td></tr>
<tr><td class="num" id="LN7418">7418</td><td class="line">      <span class='keyword'>break</span>;} <span class='comment'>/* r-f  */</span></td></tr>
<tr><td class="num" id="LN7419">7419</td><td class="line">    <span class='keyword'>default</span>: <span class='keyword'>break</span>;                <span class='comment'>/* Infinity in all other cases  */</span></td></tr>
<tr><td class="num" id="LN7420">7420</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7421">7421</td><td class="line">  <span class='keyword'>if</span> (needmax) {</td></tr>
<tr><td class="num" id="LN7422">7422</td><td class="line">    decSetMaxValue(dn, set);</td></tr>
<tr><td class="num" id="LN7423">7423</td><td class="line">    dn-&gt;bits=sign;                 <span class='comment'>/* set sign  */</span></td></tr>
<tr><td class="num" id="LN7424">7424</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7425">7425</td><td class="line">   <span class='keyword'>else</span> dn-&gt;bits=sign|<span class='macro'>DECINF<span class='expansion'>0x40</span></span>;      <span class='comment'>/* Value is +/-Infinity  */</span></td></tr>
<tr><td class="num" id="LN7426">7426</td><td class="line">  *status|=<span class='macro'>DEC_Overflow<span class='expansion'>0x00000200</span></span> | <span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;</td></tr>
<tr><td class="num" id="LN7427">7427</td><td class="line">  } <span class='comment'>/* decSetOverflow  */</span></td></tr>
<tr><td class="num" id="LN7428">7428</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7429">7429</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7430">7430</td><td class="line"><span class='comment'>/* decSetMaxValue -- set number to +Nmax (maximum normal value)       */</span></td></tr>
<tr><td class="num" id="LN7431">7431</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7432">7432</td><td class="line"><span class='comment'>/*   dn is the number to set                                          */</span></td></tr>
<tr><td class="num" id="LN7433">7433</td><td class="line"><span class='comment'>/*   set is the context [used for digits and emax]                    */</span></td></tr>
<tr><td class="num" id="LN7434">7434</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7435">7435</td><td class="line"><span class='comment'>/* This sets the number to the maximum positive value.                */</span></td></tr>
<tr><td class="num" id="LN7436">7436</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7437">7437</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decSetMaxValue(decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN7438">7438</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                        <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7439">7439</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> count=set-&gt;digits;           <span class='comment'>/* nines to add  */</span></td></tr>
<tr><td class="num" id="LN7440">7440</td><td class="line">  dn-&gt;digits=count;</td></tr>
<tr><td class="num" id="LN7441">7441</td><td class="line">  <span class='comment'>/* fill in all nines to set maximum value  */</span></td></tr>
<tr><td class="num" id="LN7442">7442</td><td class="line">  <span class='keyword'>for</span> (up=dn-&gt;lsu; ; up++) {</td></tr>
<tr><td class="num" id="LN7443">7443</td><td class="line">    <span class='keyword'>if</span> (count&gt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) *up=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>;  <span class='comment'>/* unit full o'nines  */</span></td></tr>
<tr><td class="num" id="LN7444">7444</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* this is the msu  */</span></td></tr>
<tr><td class="num" id="LN7445">7445</td><td class="line">      *up=(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span>)(<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count]-1);</td></tr>
<tr><td class="num" id="LN7446">7446</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN7447">7447</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7448">7448</td><td class="line">    count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;                <span class='comment'>/* filled those digits  */</span></td></tr>
<tr><td class="num" id="LN7449">7449</td><td class="line">    } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN7450">7450</td><td class="line">  dn-&gt;bits=0;                      <span class='comment'>/* + sign  */</span></td></tr>
<tr><td class="num" id="LN7451">7451</td><td class="line">  dn-&gt;exponent=set-&gt;emax-set-&gt;digits+1;</td></tr>
<tr><td class="num" id="LN7452">7452</td><td class="line">  } <span class='comment'>/* decSetMaxValue  */</span></td></tr>
<tr><td class="num" id="LN7453">7453</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7454">7454</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7455">7455</td><td class="line"><span class='comment'>/* decSetSubnormal -- process value whose exponent is &lt;Emin           */</span></td></tr>
<tr><td class="num" id="LN7456">7456</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7457">7457</td><td class="line"><span class='comment'>/*   dn is the number (used as input as well as output; it may have   */</span></td></tr>
<tr><td class="num" id="LN7458">7458</td><td class="line"><span class='comment'>/*         an allowed subnormal value, which may need to be rounded)  */</span></td></tr>
<tr><td class="num" id="LN7459">7459</td><td class="line"><span class='comment'>/*   set is the context [used for the rounding mode]                  */</span></td></tr>
<tr><td class="num" id="LN7460">7460</td><td class="line"><span class='comment'>/*   residue is any pending residue                                   */</span></td></tr>
<tr><td class="num" id="LN7461">7461</td><td class="line"><span class='comment'>/*   status contains the current status to be updated                 */</span></td></tr>
<tr><td class="num" id="LN7462">7462</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7463">7463</td><td class="line"><span class='comment'>/* If subset mode, set result to zero and set Underflow flags.        */</span></td></tr>
<tr><td class="num" id="LN7464">7464</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7465">7465</td><td class="line"><span class='comment'>/* Value may be zero with a low exponent; this does not set Subnormal */</span></td></tr>
<tr><td class="num" id="LN7466">7466</td><td class="line"><span class='comment'>/* but the exponent will be clamped to Etiny.                         */</span></td></tr>
<tr><td class="num" id="LN7467">7467</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7468">7468</td><td class="line"><span class='comment'>/* Otherwise ensure exponent is not out of range, and round as        */</span></td></tr>
<tr><td class="num" id="LN7469">7469</td><td class="line"><span class='comment'>/* necessary.  Underflow is set if the result is Inexact.             */</span></td></tr>
<tr><td class="num" id="LN7470">7470</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7471">7471</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decSetSubnormal(decNumber *dn, decContext *set, <span class='macro'>Int<span class='expansion'>int32_t</span></span> *residue,</td></tr>
<tr><td class="num" id="LN7472">7472</td><td class="line">                            <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7473">7473</td><td class="line">  decContext workset;         <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7474">7474</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>        etiny, adjust;   <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN7475">7475</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7476">7476</td><td class="line">  <span class='directive'>#if <span class='macro'>DECSUBSET<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7477">7477</td><td class="line">  <span class='comment'>/* simple set to zero and 'hard underflow' for subset  */</span></td></tr>
<tr><td class="num" id="LN7478">7478</td><td class="line">  <span class='keyword'>if</span> (!set-&gt;extended) {</td></tr>
<tr><td class="num" id="LN7479">7479</td><td class="line">    <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);</td></tr>
<tr><td class="num" id="LN7480">7480</td><td class="line">    <span class='comment'>/* always full overflow  */</span></td></tr>
<tr><td class="num" id="LN7481">7481</td><td class="line">    *status|=<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span> | <span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span> | <span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span> | <span class='macro'>DEC_Rounded<span class='expansion'>0x00000800</span></span>;</td></tr>
<tr><td class="num" id="LN7482">7482</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7483">7483</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7484">7484</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7485">7485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7486">7486</td><td class="line">  <span class='comment'>/* Full arithmetic -- allow subnormals, rounded to minimum exponent  */</span></td></tr>
<tr><td class="num" id="LN7487">7487</td><td class="line">  <span class='comment'>/* (Etiny) if needed  */</span></td></tr>
<tr><td class="num" id="LN7488">7488</td><td class="line">  etiny=set-&gt;emin-(set-&gt;digits-1);      <span class='comment'>/* smallest allowed exponent  */</span></td></tr>
<tr><td class="num" id="LN7489">7489</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7490">7490</td><td class="line">  <span class='keyword'>if</span> <span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span> {                       <span class='comment'>/* value is zero  */</span></td></tr>
<tr><td class="num" id="LN7491">7491</td><td class="line">    <span class='comment'>/* residue can never be non-zero here  */</span></td></tr>
<tr><td class="num" id="LN7492">7492</td><td class="line">    <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7493">7493</td><td class="line">      <span class='keyword'>if</span> (*residue!=0) {</td></tr>
<tr><td class="num" id="LN7494">7494</td><td class="line">        printf(<span class='string_literal'>"++ Subnormal 0 residue %ld\n"</span>, (LI)*residue);</td></tr>
<tr><td class="num" id="LN7495">7495</td><td class="line">        *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN7496">7496</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN7497">7497</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7498">7498</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent&lt;etiny) {           <span class='comment'>/* clamp required  */</span></td></tr>
<tr><td class="num" id="LN7499">7499</td><td class="line">      dn-&gt;exponent=etiny;</td></tr>
<tr><td class="num" id="LN7500">7500</td><td class="line">      *status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN7501">7501</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7502">7502</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7503">7503</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7504">7504</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7505">7505</td><td class="line">  *status|=<span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span>;               <span class='comment'>/* have a non-zero subnormal  */</span></td></tr>
<tr><td class="num" id="LN7506">7506</td><td class="line">  adjust=etiny-dn-&gt;exponent;            <span class='comment'>/* calculate digits to remove  */</span></td></tr>
<tr><td class="num" id="LN7507">7507</td><td class="line">  <span class='keyword'>if</span> (adjust&lt;=0) {                      <span class='comment'>/* not out of range; unrounded  */</span></td></tr>
<tr><td class="num" id="LN7508">7508</td><td class="line">    <span class='comment'>/* residue can never be non-zero here, except in the Nmin-residue  */</span></td></tr>
<tr><td class="num" id="LN7509">7509</td><td class="line">    <span class='comment'>/* case (which is a subnormal result), so can take fast-path here  */</span></td></tr>
<tr><td class="num" id="LN7510">7510</td><td class="line">    <span class='comment'>/* it may already be inexact (from setting the coefficient)  */</span></td></tr>
<tr><td class="num" id="LN7511">7511</td><td class="line">    <span class='keyword'>if</span> (*status&amp;<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>) *status|=<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>;</td></tr>
<tr><td class="num" id="LN7512">7512</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7513">7513</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7514">7514</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7515">7515</td><td class="line">  <span class='comment'>/* adjust&gt;0, so need to rescale the result so exponent becomes Etiny  */</span></td></tr>
<tr><td class="num" id="LN7516">7516</td><td class="line">  <span class='comment'>/* [this code is similar to that in rescale]  */</span></td></tr>
<tr><td class="num" id="LN7517">7517</td><td class="line">  workset=*set;                         <span class='comment'>/* clone rounding, etc.  */</span></td></tr>
<tr><td class="num" id="LN7518">7518</td><td class="line">  workset.digits=dn-&gt;digits-adjust;     <span class='comment'>/* set requested length  */</span></td></tr>
<tr><td class="num" id="LN7519">7519</td><td class="line">  workset.emin-=adjust;                 <span class='comment'>/* and adjust emin to match  */</span></td></tr>
<tr><td class="num" id="LN7520">7520</td><td class="line">  <span class='comment'>/* [note that the latter can be &lt;1, here, similar to Rescale case]  */</span></td></tr>
<tr><td class="num" id="LN7521">7521</td><td class="line">  decSetCoeff(dn, &amp;workset, dn-&gt;lsu, dn-&gt;digits, residue, status);</td></tr>
<tr><td class="num" id="LN7522">7522</td><td class="line">  decApplyRound(dn, &amp;workset, *residue, status);</td></tr>
<tr><td class="num" id="LN7523">7523</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7524">7524</td><td class="line">  <span class='comment'>/* Use 754 default rule: Underflow is set iff Inexact  */</span></td></tr>
<tr><td class="num" id="LN7525">7525</td><td class="line">  <span class='comment'>/* [independent of whether trapped]  */</span></td></tr>
<tr><td class="num" id="LN7526">7526</td><td class="line">  <span class='keyword'>if</span> (*status&amp;<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>) *status|=<span class='macro'>DEC_Underflow<span class='expansion'>0x00002000</span></span>;</td></tr>
<tr><td class="num" id="LN7527">7527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7528">7528</td><td class="line">  <span class='comment'>/* if rounded up a 999s case, exponent will be off by one; adjust  */</span></td></tr>
<tr><td class="num" id="LN7529">7529</td><td class="line">  <span class='comment'>/* back if so [it will fit, because it was shortened earlier]  */</span></td></tr>
<tr><td class="num" id="LN7530">7530</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent&gt;etiny) {</td></tr>
<tr><td class="num" id="LN7531">7531</td><td class="line">    dn-&gt;digits=decShiftToMost(dn-&gt;lsu, dn-&gt;digits, 1);</td></tr>
<tr><td class="num" id="LN7532">7532</td><td class="line">    dn-&gt;exponent--;                     <span class='comment'>/* (re)adjust the exponent.  */</span></td></tr>
<tr><td class="num" id="LN7533">7533</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7534">7534</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7535">7535</td><td class="line">  <span class='comment'>/* if rounded to zero, it is by definition clamped...  */</span></td></tr>
<tr><td class="num" id="LN7536">7536</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) *status|=<span class='macro'>DEC_Clamped<span class='expansion'>0x00000400</span></span>;</td></tr>
<tr><td class="num" id="LN7537">7537</td><td class="line">  } <span class='comment'>/* decSetSubnormal  */</span></td></tr>
<tr><td class="num" id="LN7538">7538</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7539">7539</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7540">7540</td><td class="line"><span class='comment'>/* decCheckMath - check entry conditions for a math function          */</span></td></tr>
<tr><td class="num" id="LN7541">7541</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7542">7542</td><td class="line"><span class='comment'>/*   This checks the context and the operand                          */</span></td></tr>
<tr><td class="num" id="LN7543">7543</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7544">7544</td><td class="line"><span class='comment'>/*   rhs is the operand to check                                      */</span></td></tr>
<tr><td class="num" id="LN7545">7545</td><td class="line"><span class='comment'>/*   set is the context to check                                      */</span></td></tr>
<tr><td class="num" id="LN7546">7546</td><td class="line"><span class='comment'>/*   status is unchanged if both are good                             */</span></td></tr>
<tr><td class="num" id="LN7547">7547</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7548">7548</td><td class="line"><span class='comment'>/* returns non-zero if status is changed, 0 otherwise                 */</span></td></tr>
<tr><td class="num" id="LN7549">7549</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7550">7550</td><td class="line"><span class='comment'>/* Restrictions enforced:                                             */</span></td></tr>
<tr><td class="num" id="LN7551">7551</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7552">7552</td><td class="line"><span class='comment'>/*   digits, emax, and -emin in the context must be less than         */</span></td></tr>
<tr><td class="num" id="LN7553">7553</td><td class="line"><span class='comment'>/*   DEC_MAX_MATH (999999), and A must be within these bounds if      */</span></td></tr>
<tr><td class="num" id="LN7554">7554</td><td class="line"><span class='comment'>/*   non-zero.  Invalid_operation is set in the status if a           */</span></td></tr>
<tr><td class="num" id="LN7555">7555</td><td class="line"><span class='comment'>/*   restriction is violated.                                         */</span></td></tr>
<tr><td class="num" id="LN7556">7556</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7557">7557</td><td class="line"><span class='keyword'>static</span> <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> decCheckMath(<span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN7558">7558</td><td class="line">                         <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7559">7559</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> save=*status;                         <span class='comment'>/* record  */</span></td></tr>
<tr><td class="num" id="LN7560">7560</td><td class="line">  <span class='keyword'>if</span> (set-&gt;digits&gt;<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span></td></tr>
<tr><td class="num" id="LN7561">7561</td><td class="line">   || set-&gt;emax&gt;<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span></td></tr>
<tr><td class="num" id="LN7562">7562</td><td class="line">   || -set-&gt;emin&gt;<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>) *status|=<span class='macro'>DEC_Invalid_context<span class='expansion'>0x00000040</span></span>;</td></tr>
<tr><td class="num" id="LN7563">7563</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> ((rhs-&gt;digits&gt;<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span></td></tr>
<tr><td class="num" id="LN7564">7564</td><td class="line">     || rhs-&gt;exponent+rhs-&gt;digits&gt;<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>+1</td></tr>
<tr><td class="num" id="LN7565">7565</td><td class="line">     || rhs-&gt;exponent+rhs-&gt;digits&lt;2*(1-<span class='macro'>DEC_MAX_MATH<span class='expansion'>999999</span></span>))</td></tr>
<tr><td class="num" id="LN7566">7566</td><td class="line">     &amp;&amp; !<span class='macro'>ISZERO(rhs)<span class='expansion'>(*(rhs)-&gt;lsu==0 &amp;&amp; (rhs)-&gt;digits==1 &amp;&amp; (<br>((rhs)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN7567">7567</td><td class="line">  <span class='keyword'>return</span> (*status!=save);</td></tr>
<tr><td class="num" id="LN7568">7568</td><td class="line">  } <span class='comment'>/* decCheckMath  */</span></td></tr>
<tr><td class="num" id="LN7569">7569</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7570">7570</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7571">7571</td><td class="line"><span class='comment'>/* decGetInt -- get integer from a number                             */</span></td></tr>
<tr><td class="num" id="LN7572">7572</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7573">7573</td><td class="line"><span class='comment'>/*   dn is the number [which will not be altered]                     */</span></td></tr>
<tr><td class="num" id="LN7574">7574</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7575">7575</td><td class="line"><span class='comment'>/*   returns one of:                                                  */</span></td></tr>
<tr><td class="num" id="LN7576">7576</td><td class="line"><span class='comment'>/*     BADINT if there is a non-zero fraction                         */</span></td></tr>
<tr><td class="num" id="LN7577">7577</td><td class="line"><span class='comment'>/*     the converted integer                                          */</span></td></tr>
<tr><td class="num" id="LN7578">7578</td><td class="line"><span class='comment'>/*     BIGEVEN if the integer is even and magnitude &gt; 2*10**9         */</span></td></tr>
<tr><td class="num" id="LN7579">7579</td><td class="line"><span class='comment'>/*     BIGODD  if the integer is odd  and magnitude &gt; 2*10**9         */</span></td></tr>
<tr><td class="num" id="LN7580">7580</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7581">7581</td><td class="line"><span class='comment'>/* This checks and gets a whole number from the input decNumber.      */</span></td></tr>
<tr><td class="num" id="LN7582">7582</td><td class="line"><span class='comment'>/* The sign can be determined from dn by the caller when BIGEVEN or   */</span></td></tr>
<tr><td class="num" id="LN7583">7583</td><td class="line"><span class='comment'>/* BIGODD is returned.                                                */</span></td></tr>
<tr><td class="num" id="LN7584">7584</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7585">7585</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decGetInt(<span class='keyword'>const</span> decNumber *dn) {</td></tr>
<tr><td class="num" id="LN7586">7586</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  theInt;                          <span class='comment'>/* result accumulator  */</span></td></tr>
<tr><td class="num" id="LN7587">7587</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                       <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7588">7588</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  got;                             <span class='comment'>/* digits (real or not) processed  */</span></td></tr>
<tr><td class="num" id="LN7589">7589</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  ilength=dn-&gt;digits+dn-&gt;exponent; <span class='comment'>/* integral length  */</span></td></tr>
<tr><td class="num" id="LN7590">7590</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> neg=<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>;     <span class='comment'>/* 1 if -ve  */</span></td></tr>
<tr><td class="num" id="LN7591">7591</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7592">7592</td><td class="line">  <span class='comment'>/* The number must be an integer that fits in 10 digits  */</span></td></tr>
<tr><td class="num" id="LN7593">7593</td><td class="line">  <span class='comment'>/* Assert, here, that 10 is enough for any rescale Etiny  */</span></td></tr>
<tr><td class="num" id="LN7594">7594</td><td class="line">  <span class='directive'>#if <span class='macro'>DEC_MAX_EMAX<span class='expansion'>999999999</span></span> &gt; 999999999</span></td></tr>
<tr><td class="num" id="LN7595">7595</td><td class="line">    <span class='directive'>#error GetInt may need updating [for Emax]</span></td></tr>
<tr><td class="num" id="LN7596">7596</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7597">7597</td><td class="line">  <span class='directive'>#if <span class='macro'>DEC_MIN_EMIN<span class='expansion'>-999999999</span></span> &lt; -999999999</span></td></tr>
<tr><td class="num" id="LN7598">7598</td><td class="line">    <span class='directive'>#error GetInt may need updating [for Emin]</span></td></tr>
<tr><td class="num" id="LN7599">7599</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7600">7600</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ISZERO(dn)<span class='expansion'>(*(dn)-&gt;lsu==0 &amp;&amp; (dn)-&gt;digits==1 &amp;&amp; ((<br>(dn)-&gt;bits&amp;(0x40|0x20|0x10))==0))</span></span>) <span class='keyword'>return</span> 0;             <span class='comment'>/* zeros are OK, with any exponent  */</span></td></tr>
<tr><td class="num" id="LN7601">7601</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7602">7602</td><td class="line">  up=dn-&gt;lsu;                           <span class='comment'>/* ready for lsu  */</span></td></tr>
<tr><td class="num" id="LN7603">7603</td><td class="line">  theInt=0;                             <span class='comment'>/* ready to accumulate  */</span></td></tr>
<tr><td class="num" id="LN7604">7604</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent&gt;=0) {                <span class='comment'>/* relatively easy  */</span></td></tr>
<tr><td class="num" id="LN7605">7605</td><td class="line">    <span class='comment'>/* no fractional part [usual]; allow for positive exponent  */</span></td></tr>
<tr><td class="num" id="LN7606">7606</td><td class="line">    got=dn-&gt;exponent;</td></tr>
<tr><td class="num" id="LN7607">7607</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7608">7608</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* -ve exponent; some fractional part to check and discard  */</span></td></tr>
<tr><td class="num" id="LN7609">7609</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> count=-dn-&gt;exponent;            <span class='comment'>/* digits to discard  */</span></td></tr>
<tr><td class="num" id="LN7610">7610</td><td class="line">    <span class='comment'>/* spin up whole units until reach the Unit with the unit digit  */</span></td></tr>
<tr><td class="num" id="LN7611">7611</td><td class="line">    <span class='keyword'>for</span> (; count&gt;=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; up++) {</td></tr>
<tr><td class="num" id="LN7612">7612</td><td class="line">      <span class='keyword'>if</span> (*up!=0) <span class='keyword'>return</span> <span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>;        <span class='comment'>/* non-zero Unit to discard  */</span></td></tr>
<tr><td class="num" id="LN7613">7613</td><td class="line">      count-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN7614">7614</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7615">7615</td><td class="line">    <span class='keyword'>if</span> (count==0) got=0;                <span class='comment'>/* [a multiple of DECDPUN]  */</span></td></tr>
<tr><td class="num" id="LN7616">7616</td><td class="line">     <span class='keyword'>else</span> {                             <span class='comment'>/* [not multiple of DECDPUN]  */</span></td></tr>
<tr><td class="num" id="LN7617">7617</td><td class="line">      <span class='macro'>Int<span class='expansion'>int32_t</span></span> rem;                          <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7618">7618</td><td class="line">      <span class='comment'>/* slice off fraction digits and check for non-zero  */</span></td></tr>
<tr><td class="num" id="LN7619">7619</td><td class="line">      <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&lt;=4</span></td></tr>
<tr><td class="num" id="LN7620">7620</td><td class="line">        theInt=<span class='macro'>QUOT10(*up, count)<span class='expansion'>((((uint32_t)(*up)&gt;&gt;(count))*multies[count])&gt;&gt;17)</span></span>;</td></tr>
<tr><td class="num" id="LN7621">7621</td><td class="line">        rem=*up-theInt*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count];</td></tr>
<tr><td class="num" id="LN7622">7622</td><td class="line">      <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN7623">7623</td><td class="line">        rem=*up%<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count];          <span class='comment'>/* slice off discards  */</span></td></tr>
<tr><td class="num" id="LN7624">7624</td><td class="line">        theInt=*up/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[count];</td></tr>
<tr><td class="num" id="LN7625">7625</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7626">7626</td><td class="line">      <span class='keyword'>if</span> (rem!=0) <span class='keyword'>return</span> <span class='macro'>BADINT<span class='expansion'>(int32_t)0x80000000</span></span>;        <span class='comment'>/* non-zero fraction  */</span></td></tr>
<tr><td class="num" id="LN7627">7627</td><td class="line">      <span class='comment'>/* it looks good  */</span></td></tr>
<tr><td class="num" id="LN7628">7628</td><td class="line">      got=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-count;                <span class='comment'>/* number of digits so far  */</span></td></tr>
<tr><td class="num" id="LN7629">7629</td><td class="line">      up++;                             <span class='comment'>/* ready for next  */</span></td></tr>
<tr><td class="num" id="LN7630">7630</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7631">7631</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7632">7632</td><td class="line">  <span class='comment'>/* now it's known there's no fractional part  */</span></td></tr>
<tr><td class="num" id="LN7633">7633</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7634">7634</td><td class="line">  <span class='comment'>/* tricky code now, to accumulate up to 9.3 digits  */</span></td></tr>
<tr><td class="num" id="LN7635">7635</td><td class="line">  <span class='keyword'>if</span> (got==0) {theInt=*up; got+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>; up++;} <span class='comment'>/* ensure lsu is there  */</span></td></tr>
<tr><td class="num" id="LN7636">7636</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7637">7637</td><td class="line">  <span class='keyword'>if</span> (ilength&lt;11) {</td></tr>
<tr><td class="num" id="LN7638">7638</td><td class="line">    <span class='macro'>Int<span class='expansion'>int32_t</span></span> save=theInt;</td></tr>
<tr><td class="num" id="LN7639">7639</td><td class="line">    <span class='comment'>/* collect any remaining unit(s)  */</span></td></tr>
<tr><td class="num" id="LN7640">7640</td><td class="line">    <span class='keyword'>for</span> (; got&lt;ilength; up++) {</td></tr>
<tr><td class="num" id="LN7641">7641</td><td class="line">      theInt+=*up*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[got];</td></tr>
<tr><td class="num" id="LN7642">7642</td><td class="line">      got+=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN7643">7643</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7644">7644</td><td class="line">    <span class='keyword'>if</span> (ilength==10) {                  <span class='comment'>/* need to check for wrap  */</span></td></tr>
<tr><td class="num" id="LN7645">7645</td><td class="line">      <span class='keyword'>if</span> (theInt/(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[got-<span class='macro'>DECDPUN<span class='expansion'>1</span></span>]!=(<span class='macro'>Int<span class='expansion'>int32_t</span></span>)*(up-1)) ilength=11;</td></tr>
<tr><td class="num" id="LN7646">7646</td><td class="line">         <span class='comment'>/* [that test also disallows the BADINT result case]  */</span></td></tr>
<tr><td class="num" id="LN7647">7647</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (neg &amp;&amp; theInt&gt;1999999997) ilength=11;</td></tr>
<tr><td class="num" id="LN7648">7648</td><td class="line">       <span class='keyword'>else</span> <span class='keyword'>if</span> (!neg &amp;&amp; theInt&gt;999999999) ilength=11;</td></tr>
<tr><td class="num" id="LN7649">7649</td><td class="line">      <span class='keyword'>if</span> (ilength==11) theInt=save;     <span class='comment'>/* restore correct low bit  */</span></td></tr>
<tr><td class="num" id="LN7650">7650</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7651">7651</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7652">7652</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7653">7653</td><td class="line">  <span class='keyword'>if</span> (ilength&gt;10) {                     <span class='comment'>/* too big  */</span></td></tr>
<tr><td class="num" id="LN7654">7654</td><td class="line">    <span class='keyword'>if</span> (theInt&amp;1) <span class='keyword'>return</span> <span class='macro'>BIGODD<span class='expansion'>(int32_t)0x80000003</span></span>;        <span class='comment'>/* bottom bit 1  */</span></td></tr>
<tr><td class="num" id="LN7655">7655</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>BIGEVEN<span class='expansion'>(int32_t)0x80000002</span></span>;                     <span class='comment'>/* bottom bit 0  */</span></td></tr>
<tr><td class="num" id="LN7656">7656</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7657">7657</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7658">7658</td><td class="line">  <span class='keyword'>if</span> (neg) theInt=-theInt;              <span class='comment'>/* apply sign  */</span></td></tr>
<tr><td class="num" id="LN7659">7659</td><td class="line">  <span class='keyword'>return</span> theInt;</td></tr>
<tr><td class="num" id="LN7660">7660</td><td class="line">  } <span class='comment'>/* decGetInt  */</span></td></tr>
<tr><td class="num" id="LN7661">7661</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7662">7662</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7663">7663</td><td class="line"><span class='comment'>/* decDecap -- decapitate the coefficient of a number                 */</span></td></tr>
<tr><td class="num" id="LN7664">7664</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7665">7665</td><td class="line"><span class='comment'>/*   dn   is the number to be decapitated                             */</span></td></tr>
<tr><td class="num" id="LN7666">7666</td><td class="line"><span class='comment'>/*   drop is the number of digits to be removed from the left of dn;  */</span></td></tr>
<tr><td class="num" id="LN7667">7667</td><td class="line"><span class='comment'>/*     this must be &lt;= dn-&gt;digits (if equal, the coefficient is       */</span></td></tr>
<tr><td class="num" id="LN7668">7668</td><td class="line"><span class='comment'>/*     set to 0)                                                      */</span></td></tr>
<tr><td class="num" id="LN7669">7669</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7670">7670</td><td class="line"><span class='comment'>/* Returns dn; dn-&gt;digits will be &lt;= the initial digits less drop     */</span></td></tr>
<tr><td class="num" id="LN7671">7671</td><td class="line"><span class='comment'>/* (after removing drop digits there may be leading zero digits       */</span></td></tr>
<tr><td class="num" id="LN7672">7672</td><td class="line"><span class='comment'>/* which will also be removed).  Only dn-&gt;lsu and dn-&gt;digits change.  */</span></td></tr>
<tr><td class="num" id="LN7673">7673</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7674">7674</td><td class="line"><span class='keyword'>static</span> decNumber *decDecap(decNumber *dn, <span class='macro'>Int<span class='expansion'>int32_t</span></span> drop) {</td></tr>
<tr><td class="num" id="LN7675">7675</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *msu;                            <span class='comment'>/* -&gt; target cut point  */</span></td></tr>
<tr><td class="num" id="LN7676">7676</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> cut;                              <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7677">7677</td><td class="line">  <span class='keyword'>if</span> (drop&gt;=dn-&gt;digits) {               <span class='comment'>/* losing the whole thing  */</span></td></tr>
<tr><td class="num" id="LN7678">7678</td><td class="line">    <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7679">7679</td><td class="line">    <span class='keyword'>if</span> (drop&gt;dn-&gt;digits)</td></tr>
<tr><td class="num" id="LN7680">7680</td><td class="line">      printf(<span class='string_literal'>"decDecap called with drop&gt;digits [%ld&gt;%ld]\n"</span>,</td></tr>
<tr><td class="num" id="LN7681">7681</td><td class="line">             (LI)drop, (LI)dn-&gt;digits);</td></tr>
<tr><td class="num" id="LN7682">7682</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7683">7683</td><td class="line">    dn-&gt;lsu[0]=0;</td></tr>
<tr><td class="num" id="LN7684">7684</td><td class="line">    dn-&gt;digits=1;</td></tr>
<tr><td class="num" id="LN7685">7685</td><td class="line">    <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN7686">7686</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7687">7687</td><td class="line">  msu=dn-&gt;lsu+<span class='macro'>D2U(dn-&gt;digits-drop)<span class='expansion'>((dn-&gt;digits-drop)&lt;=49?d2utable[dn-&gt;digits-drop]:((dn<br>-&gt;digits-drop)+1 -1)/1)</span></span>-1;   <span class='comment'>/* -&gt; likely msu  */</span></td></tr>
<tr><td class="num" id="LN7688">7688</td><td class="line">  cut=<span class='macro'>MSUDIGITS(dn-&gt;digits-drop)<span class='expansion'>((dn-&gt;digits-drop)-(((dn-&gt;digits-drop)&lt;=49?d2utable[<br>dn-&gt;digits-drop]:((dn-&gt;digits-drop)+1 -1)/1)-1)*1)</span></span>;       <span class='comment'>/* digits to be in use in msu  */</span></td></tr>
<tr><td class="num" id="LN7689">7689</td><td class="line">  <span class='keyword'>if</span> (cut!=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) *msu%=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];  <span class='comment'>/* clear left digits  */</span></td></tr>
<tr><td class="num" id="LN7690">7690</td><td class="line">  <span class='comment'>/* that may have left leading zero digits, so do a proper count...  */</span></td></tr>
<tr><td class="num" id="LN7691">7691</td><td class="line">  dn-&gt;digits=decGetDigits(dn-&gt;lsu, msu-dn-&gt;lsu+1);</td></tr>
<tr><td class="num" id="LN7692">7692</td><td class="line">  <span class='keyword'>return</span> dn;</td></tr>
<tr><td class="num" id="LN7693">7693</td><td class="line">  } <span class='comment'>/* decDecap  */</span></td></tr>
<tr><td class="num" id="LN7694">7694</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7695">7695</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7696">7696</td><td class="line"><span class='comment'>/* decBiStr -- compare string with pairwise options                   */</span></td></tr>
<tr><td class="num" id="LN7697">7697</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7698">7698</td><td class="line"><span class='comment'>/*   targ is the string to compare                                    */</span></td></tr>
<tr><td class="num" id="LN7699">7699</td><td class="line"><span class='comment'>/*   str1 is one of the strings to compare against (length may be 0)  */</span></td></tr>
<tr><td class="num" id="LN7700">7700</td><td class="line"><span class='comment'>/*   str2 is the other; it must be the same length as str1            */</span></td></tr>
<tr><td class="num" id="LN7701">7701</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7702">7702</td><td class="line"><span class='comment'>/*   returns 1 if strings compare equal, (that is, it is the same     */</span></td></tr>
<tr><td class="num" id="LN7703">7703</td><td class="line"><span class='comment'>/*   length as str1 and str2, and each character of targ is in either */</span></td></tr>
<tr><td class="num" id="LN7704">7704</td><td class="line"><span class='comment'>/*   str1 or str2 in the corresponding position), or 0 otherwise      */</span></td></tr>
<tr><td class="num" id="LN7705">7705</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7706">7706</td><td class="line"><span class='comment'>/* This is used for generic caseless compare, including the awkward   */</span></td></tr>
<tr><td class="num" id="LN7707">7707</td><td class="line"><span class='comment'>/* case of the Turkish dotted and dotless Is.  Use as (for example):  */</span></td></tr>
<tr><td class="num" id="LN7708">7708</td><td class="line"><span class='comment'>/*   if (decBiStr(test, "mike", "MIKE")) ...                          */</span></td></tr>
<tr><td class="num" id="LN7709">7709</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7710">7710</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> decBiStr(<span class='keyword'>const</span> <span class='keyword'>char</span> *targ, <span class='keyword'>const</span> <span class='keyword'>char</span> *str1, <span class='keyword'>const</span> <span class='keyword'>char</span> *str2) {</td></tr>
<tr><td class="num" id="LN7711">7711</td><td class="line">  <span class='keyword'>for</span> (;;targ++, str1++, str2++) {</td></tr>
<tr><td class="num" id="LN7712">7712</td><td class="line">    <span class='keyword'>if</span> (*targ!=*str1 &amp;&amp; *targ!=*str2) <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN7713">7713</td><td class="line">    <span class='comment'>/* *targ has a match in one (or both, if terminator)  */</span></td></tr>
<tr><td class="num" id="LN7714">7714</td><td class="line">    <span class='keyword'>if</span> (*targ=='\0') <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN7715">7715</td><td class="line">    } <span class='comment'>/* forever  */</span></td></tr>
<tr><td class="num" id="LN7716">7716</td><td class="line">  <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN7717">7717</td><td class="line">  } <span class='comment'>/* decBiStr  */</span></td></tr>
<tr><td class="num" id="LN7718">7718</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7719">7719</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7720">7720</td><td class="line"><span class='comment'>/* decNaNs -- handle NaN operand or operands                          */</span></td></tr>
<tr><td class="num" id="LN7721">7721</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7722">7722</td><td class="line"><span class='comment'>/*   res     is the result number                                     */</span></td></tr>
<tr><td class="num" id="LN7723">7723</td><td class="line"><span class='comment'>/*   lhs     is the first operand                                     */</span></td></tr>
<tr><td class="num" id="LN7724">7724</td><td class="line"><span class='comment'>/*   rhs     is the second operand, or NULL if none                   */</span></td></tr>
<tr><td class="num" id="LN7725">7725</td><td class="line"><span class='comment'>/*   context is used to limit payload length                          */</span></td></tr>
<tr><td class="num" id="LN7726">7726</td><td class="line"><span class='comment'>/*   status  contains the current status                              */</span></td></tr>
<tr><td class="num" id="LN7727">7727</td><td class="line"><span class='comment'>/*   returns res in case convenient                                   */</span></td></tr>
<tr><td class="num" id="LN7728">7728</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7729">7729</td><td class="line"><span class='comment'>/* Called when one or both operands is a NaN, and propagates the      */</span></td></tr>
<tr><td class="num" id="LN7730">7730</td><td class="line"><span class='comment'>/* appropriate result to res.  When an sNaN is found, it is changed   */</span></td></tr>
<tr><td class="num" id="LN7731">7731</td><td class="line"><span class='comment'>/* to a qNaN and Invalid operation is set.                            */</span></td></tr>
<tr><td class="num" id="LN7732">7732</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7733">7733</td><td class="line"><span class='keyword'>static</span> decNumber * decNaNs(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN7734">7734</td><td class="line">                           <span class='keyword'>const</span> decNumber *rhs, decContext *set,</td></tr>
<tr><td class="num" id="LN7735">7735</td><td class="line">                           <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> *status) {</td></tr>
<tr><td class="num" id="LN7736">7736</td><td class="line">  <span class='comment'>/* This decision tree ends up with LHS being the source pointer,  */</span></td></tr>
<tr><td class="num" id="LN7737">7737</td><td class="line">  <span class='comment'>/* and status updated if need be  */</span></td></tr>
<tr><td class="num" id="LN7738">7738</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;bits &amp; <span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>)</td></tr>
<tr><td class="num" id="LN7739">7739</td><td class="line">    *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span> | <span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;</td></tr>
<tr><td class="num" id="LN7740">7740</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (rhs==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</td></tr>
<tr><td class="num" id="LN7741">7741</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (rhs-&gt;bits &amp; <span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>) {</td></tr>
<tr><td class="num" id="LN7742">7742</td><td class="line">    lhs=rhs;</td></tr>
<tr><td class="num" id="LN7743">7743</td><td class="line">    *status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span> | <span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;</td></tr>
<tr><td class="num" id="LN7744">7744</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7745">7745</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (lhs-&gt;bits &amp; <span class='macro'>DECNAN<span class='expansion'>0x20</span></span>);</td></tr>
<tr><td class="num" id="LN7746">7746</td><td class="line">   <span class='keyword'>else</span> lhs=rhs;</td></tr>
<tr><td class="num" id="LN7747">7747</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7748">7748</td><td class="line">  <span class='comment'>/* propagate the payload  */</span></td></tr>
<tr><td class="num" id="LN7749">7749</td><td class="line">  <span class='keyword'>if</span> (lhs-&gt;digits&lt;=set-&gt;digits) <span class='macro'>uprv_decNumberCopy<span class='expansion'>uprv_decNumberCopy_54</span></span>(res, lhs); <span class='comment'>/* easy  */</span></td></tr>
<tr><td class="num" id="LN7750">7750</td><td class="line">   <span class='keyword'>else</span> { <span class='comment'>/* too long  */</span></td></tr>
<tr><td class="num" id="LN7751">7751</td><td class="line">    <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ul;</td></tr>
<tr><td class="num" id="LN7752">7752</td><td class="line">    <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ur, *uresp1;</td></tr>
<tr><td class="num" id="LN7753">7753</td><td class="line">    <span class='comment'>/* copy safe number of units, then decapitate  */</span></td></tr>
<tr><td class="num" id="LN7754">7754</td><td class="line">    res-&gt;bits=lhs-&gt;bits;                <span class='comment'>/* need sign etc.  */</span></td></tr>
<tr><td class="num" id="LN7755">7755</td><td class="line">    uresp1=res-&gt;lsu+<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>;</td></tr>
<tr><td class="num" id="LN7756">7756</td><td class="line">    <span class='keyword'>for</span> (ur=res-&gt;lsu, ul=lhs-&gt;lsu; ur&lt;uresp1; ur++, ul++) *ur=*ul;</td></tr>
<tr><td class="num" id="LN7757">7757</td><td class="line">    res-&gt;digits=<span class='macro'>D2U(set-&gt;digits)<span class='expansion'>((set-&gt;digits)&lt;=49?d2utable[set-&gt;digits]:((set-&gt;digits<br>)+1 -1)/1)</span></span>*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN7758">7758</td><td class="line">    <span class='comment'>/* maybe still too long  */</span></td></tr>
<tr><td class="num" id="LN7759">7759</td><td class="line">    <span class='keyword'>if</span> (res-&gt;digits&gt;set-&gt;digits) decDecap(res, res-&gt;digits-set-&gt;digits);</td></tr>
<tr><td class="num" id="LN7760">7760</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7761">7761</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7762">7762</td><td class="line">  res-&gt;bits&amp;=~<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>;        <span class='comment'>/* convert any sNaN to NaN, while  */</span></td></tr>
<tr><td class="num" id="LN7763">7763</td><td class="line">  res-&gt;bits|=<span class='macro'>DECNAN<span class='expansion'>0x20</span></span>;          <span class='comment'>/* .. preserving sign  */</span></td></tr>
<tr><td class="num" id="LN7764">7764</td><td class="line">  res-&gt;exponent=0;            <span class='comment'>/* clean exponent  */</span></td></tr>
<tr><td class="num" id="LN7765">7765</td><td class="line">                              <span class='comment'>/* [coefficient was copied/decapitated]  */</span></td></tr>
<tr><td class="num" id="LN7766">7766</td><td class="line">  <span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN7767">7767</td><td class="line">  } <span class='comment'>/* decNaNs  */</span></td></tr>
<tr><td class="num" id="LN7768">7768</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7769">7769</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7770">7770</td><td class="line"><span class='comment'>/* decStatus -- apply non-zero status                                 */</span></td></tr>
<tr><td class="num" id="LN7771">7771</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7772">7772</td><td class="line"><span class='comment'>/*   dn     is the number to set if error                             */</span></td></tr>
<tr><td class="num" id="LN7773">7773</td><td class="line"><span class='comment'>/*   status contains the current status (not yet in context)          */</span></td></tr>
<tr><td class="num" id="LN7774">7774</td><td class="line"><span class='comment'>/*   set    is the context                                            */</span></td></tr>
<tr><td class="num" id="LN7775">7775</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7776">7776</td><td class="line"><span class='comment'>/* If the status is an error status, the number is set to a NaN,      */</span></td></tr>
<tr><td class="num" id="LN7777">7777</td><td class="line"><span class='comment'>/* unless the error was an overflow, divide-by-zero, or underflow,    */</span></td></tr>
<tr><td class="num" id="LN7778">7778</td><td class="line"><span class='comment'>/* in which case the number will have already been set.               */</span></td></tr>
<tr><td class="num" id="LN7779">7779</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7780">7780</td><td class="line"><span class='comment'>/* The context status is then updated with the new status.  Note that */</span></td></tr>
<tr><td class="num" id="LN7781">7781</td><td class="line"><span class='comment'>/* this may raise a signal, so control may never return from this     */</span></td></tr>
<tr><td class="num" id="LN7782">7782</td><td class="line"><span class='comment'>/* routine (hence resources must be recovered before it is called).   */</span></td></tr>
<tr><td class="num" id="LN7783">7783</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7784">7784</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decStatus(decNumber *dn, <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> status, decContext *set) {</td></tr>
<tr><td class="num" id="LN7785">7785</td><td class="line">  <span class='keyword'>if</span> (status &amp; <span class='macro'>DEC_NaNs<span class='expansion'>(0x00000001 | 0x00000004 | 0x00000008 | 0x00000010 | 0x00000040<br> | 0x00000080)</span></span>) {              <span class='comment'>/* error status -&gt; NaN  */</span></td></tr>
<tr><td class="num" id="LN7786">7786</td><td class="line">    <span class='comment'>/* if cause was an sNaN, clear and propagate [NaN is already set up]  */</span></td></tr>
<tr><td class="num" id="LN7787">7787</td><td class="line">    <span class='keyword'>if</span> (status &amp; <span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>) status&amp;=~<span class='macro'>DEC_sNaN<span class='expansion'>0x40000000</span></span>;</td></tr>
<tr><td class="num" id="LN7788">7788</td><td class="line">     <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN7789">7789</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(dn);                <span class='comment'>/* other error: clean throughout  */</span></td></tr>
<tr><td class="num" id="LN7790">7790</td><td class="line">      dn-&gt;bits=<span class='macro'>DECNAN<span class='expansion'>0x20</span></span>;                  <span class='comment'>/* and make a quiet NaN  */</span></td></tr>
<tr><td class="num" id="LN7791">7791</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7792">7792</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7793">7793</td><td class="line">  <span class='macro'>uprv_decContextSetStatus<span class='expansion'>uprv_decContextSetStatus_54</span></span>(set, status);     <span class='comment'>/* [may not return]  */</span></td></tr>
<tr><td class="num" id="LN7794">7794</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN7795">7795</td><td class="line">  } <span class='comment'>/* decStatus  */</span></td></tr>
<tr><td class="num" id="LN7796">7796</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7797">7797</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7798">7798</td><td class="line"><span class='comment'>/* decGetDigits -- count digits in a Units array                      */</span></td></tr>
<tr><td class="num" id="LN7799">7799</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7800">7800</td><td class="line"><span class='comment'>/*   uar is the Unit array holding the number (this is often an       */</span></td></tr>
<tr><td class="num" id="LN7801">7801</td><td class="line"><span class='comment'>/*          accumulator of some sort)                                 */</span></td></tr>
<tr><td class="num" id="LN7802">7802</td><td class="line"><span class='comment'>/*   len is the length of the array in units [&gt;=1]                    */</span></td></tr>
<tr><td class="num" id="LN7803">7803</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7804">7804</td><td class="line"><span class='comment'>/*   returns the number of (significant) digits in the array          */</span></td></tr>
<tr><td class="num" id="LN7805">7805</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7806">7806</td><td class="line"><span class='comment'>/* All leading zeros are excluded, except the last if the array has   */</span></td></tr>
<tr><td class="num" id="LN7807">7807</td><td class="line"><span class='comment'>/* only zero Units.                                                   */</span></td></tr>
<tr><td class="num" id="LN7808">7808</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7809">7809</td><td class="line"><span class='comment'>/* This may be called twice during some operations.  */</span></td></tr>
<tr><td class="num" id="LN7810">7810</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Int<span class='expansion'>int32_t</span></span> decGetDigits(<span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *uar, <span class='macro'>Int<span class='expansion'>int32_t</span></span> len) {</td></tr>
<tr><td class="num" id="LN7811">7811</td><td class="line">  <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up=uar+(len-1);            <span class='comment'>/* -&gt; msu  */</span></td></tr>
<tr><td class="num" id="LN7812">7812</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span>  digits=(len-1)*<span class='macro'>DECDPUN<span class='expansion'>1</span></span>+1;   <span class='comment'>/* possible digits excluding msu  */</span></td></tr>
<tr><td class="num" id="LN7813">7813</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;4</span></td></tr>
<tr><td class="num" id="LN7814">7814</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> <span class='keyword'>const</span> *pow;                 <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7815">7815</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7816">7816</td><td class="line">                                   <span class='comment'>/* (at least 1 in final msu)  */</span></td></tr>
<tr><td class="num" id="LN7817">7817</td><td class="line">  <span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7818">7818</td><td class="line">  <span class='keyword'>if</span> (len&lt;1) printf(<span class='string_literal'>"decGetDigits called with len&lt;1 [%ld]\n"</span>, (LI)len);</td></tr>
<tr><td class="num" id="LN7819">7819</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7820">7820</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7821">7821</td><td class="line">  <span class='keyword'>for</span> (; up&gt;=uar; up--) {</td></tr>
<tr><td class="num" id="LN7822">7822</td><td class="line">    <span class='keyword'>if</span> (*up==0) {                  <span class='comment'>/* unit is all 0s  */</span></td></tr>
<tr><td class="num" id="LN7823">7823</td><td class="line">      <span class='keyword'>if</span> (digits==1) <span class='keyword'>break</span>;        <span class='comment'>/* a zero has one digit  */</span></td></tr>
<tr><td class="num" id="LN7824">7824</td><td class="line">      digits-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;             <span class='comment'>/* adjust for 0 unit  */</span></td></tr>
<tr><td class="num" id="LN7825">7825</td><td class="line">      <span class='keyword'>continue</span>;}</td></tr>
<tr><td class="num" id="LN7826">7826</td><td class="line">    <span class='comment'>/* found the first (most significant) non-zero Unit  */</span></td></tr>
<tr><td class="num" id="LN7827">7827</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;1                  /* not done yet  */</span></td></tr>
<tr><td class="num" id="LN7828">7828</td><td class="line">    <span class='keyword'>if</span> (*up&lt;10) <span class='keyword'>break</span>;             <span class='comment'>/* is 1-9  */</span></td></tr>
<tr><td class="num" id="LN7829">7829</td><td class="line">    digits++;</td></tr>
<tr><td class="num" id="LN7830">7830</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;2                  /* not done yet  */</span></td></tr>
<tr><td class="num" id="LN7831">7831</td><td class="line">    <span class='keyword'>if</span> (*up&lt;100) <span class='keyword'>break</span>;            <span class='comment'>/* is 10-99  */</span></td></tr>
<tr><td class="num" id="LN7832">7832</td><td class="line">    digits++;</td></tr>
<tr><td class="num" id="LN7833">7833</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;3                  /* not done yet  */</span></td></tr>
<tr><td class="num" id="LN7834">7834</td><td class="line">    <span class='keyword'>if</span> (*up&lt;1000) <span class='keyword'>break</span>;           <span class='comment'>/* is 100-999  */</span></td></tr>
<tr><td class="num" id="LN7835">7835</td><td class="line">    digits++;</td></tr>
<tr><td class="num" id="LN7836">7836</td><td class="line">    <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>&gt;4                  /* count the rest ...  */</span></td></tr>
<tr><td class="num" id="LN7837">7837</td><td class="line">    <span class='keyword'>for</span> (pow=&amp;<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[4]; *up&gt;=*pow; pow++) digits++;</td></tr>
<tr><td class="num" id="LN7838">7838</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7839">7839</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7840">7840</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7841">7841</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7842">7842</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN7843">7843</td><td class="line">    } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN7844">7844</td><td class="line">  <span class='keyword'>return</span> digits;</td></tr>
<tr><td class="num" id="LN7845">7845</td><td class="line">  } <span class='comment'>/* decGetDigits  */</span></td></tr>
<tr><td class="num" id="LN7846">7846</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7847">7847</td><td class="line"><span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> | <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7848">7848</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7849">7849</td><td class="line"><span class='comment'>/* decNumberShow -- display a number [debug aid]                      */</span></td></tr>
<tr><td class="num" id="LN7850">7850</td><td class="line"><span class='comment'>/*   dn is the number to show                                         */</span></td></tr>
<tr><td class="num" id="LN7851">7851</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7852">7852</td><td class="line"><span class='comment'>/* Shows: sign, exponent, coefficient (msu first), digits             */</span></td></tr>
<tr><td class="num" id="LN7853">7853</td><td class="line"><span class='comment'>/*    or: sign, special-value                                         */</span></td></tr>
<tr><td class="num" id="LN7854">7854</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7855">7855</td><td class="line"><span class='comment'>/* this is public so other modules can use it  */</span></td></tr>
<tr><td class="num" id="LN7856">7856</td><td class="line"><span class='keyword'>void</span> uprv_decNumberShow(<span class='keyword'>const</span> decNumber *dn) {</td></tr>
<tr><td class="num" id="LN7857">7857</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;                  <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN7858">7858</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> u, d;                       <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN7859">7859</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> cut;                         <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN7860">7860</td><td class="line">  <span class='keyword'>char</span> isign='+';                  <span class='comment'>/* main sign  */</span></td></tr>
<tr><td class="num" id="LN7861">7861</td><td class="line">  <span class='keyword'>if</span> (dn==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN7862">7862</td><td class="line">    printf(<span class='string_literal'>"NULL\n"</span>);</td></tr>
<tr><td class="num" id="LN7863">7863</td><td class="line">    <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN7864">7864</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>decNumberIsNegative(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x80)!=0)</span></span>) isign='-';</td></tr>
<tr><td class="num" id="LN7865">7865</td><td class="line">  printf(<span class='string_literal'>" &gt;&gt; %c "</span>, isign);</td></tr>
<tr><td class="num" id="LN7866">7866</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>) {       <span class='comment'>/* Is a special value  */</span></td></tr>
<tr><td class="num" id="LN7867">7867</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x40)!=0)</span></span>) printf(<span class='string_literal'>"Infinity"</span>);</td></tr>
<tr><td class="num" id="LN7868">7868</td><td class="line">     <span class='keyword'>else</span> {                                  <span class='comment'>/* a NaN  */</span></td></tr>
<tr><td class="num" id="LN7869">7869</td><td class="line">      <span class='keyword'>if</span> (dn-&gt;bits&amp;<span class='macro'>DECSNAN<span class='expansion'>0x10</span></span>) printf(<span class='string_literal'>"sNaN"</span>);  <span class='comment'>/* signalling NaN  */</span></td></tr>
<tr><td class="num" id="LN7870">7870</td><td class="line">       <span class='keyword'>else</span> printf(<span class='string_literal'>"NaN"</span>);</td></tr>
<tr><td class="num" id="LN7871">7871</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7872">7872</td><td class="line">    <span class='comment'>/* if coefficient and exponent are 0, no more to do  */</span></td></tr>
<tr><td class="num" id="LN7873">7873</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent==0 &amp;&amp; dn-&gt;digits==1 &amp;&amp; *dn-&gt;lsu==0) {</td></tr>
<tr><td class="num" id="LN7874">7874</td><td class="line">      printf(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN7875">7875</td><td class="line">      <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN7876">7876</td><td class="line">    <span class='comment'>/* drop through to report other information  */</span></td></tr>
<tr><td class="num" id="LN7877">7877</td><td class="line">    printf(<span class='string_literal'>" "</span>);</td></tr>
<tr><td class="num" id="LN7878">7878</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7879">7879</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7880">7880</td><td class="line">  <span class='comment'>/* now carefully display the coefficient  */</span></td></tr>
<tr><td class="num" id="LN7881">7881</td><td class="line">  up=dn-&gt;lsu+<span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>-1;         <span class='comment'>/* msu  */</span></td></tr>
<tr><td class="num" id="LN7882">7882</td><td class="line">  printf(<span class='string_literal'>"%ld"</span>, (LI)*up);</td></tr>
<tr><td class="num" id="LN7883">7883</td><td class="line">  <span class='keyword'>for</span> (up=up-1; up&gt;=dn-&gt;lsu; up--) {</td></tr>
<tr><td class="num" id="LN7884">7884</td><td class="line">    u=*up;</td></tr>
<tr><td class="num" id="LN7885">7885</td><td class="line">    printf(<span class='string_literal'>":"</span>);</td></tr>
<tr><td class="num" id="LN7886">7886</td><td class="line">    <span class='keyword'>for</span> (cut=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>-1; cut&gt;=0; cut--) {</td></tr>
<tr><td class="num" id="LN7887">7887</td><td class="line">      d=u/<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7888">7888</td><td class="line">      u-=d*<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[cut];</td></tr>
<tr><td class="num" id="LN7889">7889</td><td class="line">      printf(<span class='string_literal'>"%ld"</span>, (LI)d);</td></tr>
<tr><td class="num" id="LN7890">7890</td><td class="line">      } <span class='comment'>/* cut  */</span></td></tr>
<tr><td class="num" id="LN7891">7891</td><td class="line">    } <span class='comment'>/* up  */</span></td></tr>
<tr><td class="num" id="LN7892">7892</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;exponent!=0) {</td></tr>
<tr><td class="num" id="LN7893">7893</td><td class="line">    <span class='keyword'>char</span> esign='+';</td></tr>
<tr><td class="num" id="LN7894">7894</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent&lt;0) esign='-';</td></tr>
<tr><td class="num" id="LN7895">7895</td><td class="line">    printf(<span class='string_literal'>" E%c%ld"</span>, esign, (LI)abs(dn-&gt;exponent));</td></tr>
<tr><td class="num" id="LN7896">7896</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7897">7897</td><td class="line">  printf(<span class='string_literal'>" [%ld]\n"</span>, (LI)dn-&gt;digits);</td></tr>
<tr><td class="num" id="LN7898">7898</td><td class="line">  } <span class='comment'>/* decNumberShow  */</span></td></tr>
<tr><td class="num" id="LN7899">7899</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7900">7900</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7901">7901</td><td class="line"><span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7902">7902</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7903">7903</td><td class="line"><span class='comment'>/* decDumpAr -- display a unit array [debug/check aid]                */</span></td></tr>
<tr><td class="num" id="LN7904">7904</td><td class="line"><span class='comment'>/*   name is a single-character tag name                              */</span></td></tr>
<tr><td class="num" id="LN7905">7905</td><td class="line"><span class='comment'>/*   ar   is the array to display                                     */</span></td></tr>
<tr><td class="num" id="LN7906">7906</td><td class="line"><span class='comment'>/*   len  is the length of the array in Units                         */</span></td></tr>
<tr><td class="num" id="LN7907">7907</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7908">7908</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decDumpAr(<span class='keyword'>char</span> name, <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *ar, <span class='macro'>Int<span class='expansion'>int32_t</span></span> len) {</td></tr>
<tr><td class="num" id="LN7909">7909</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> i;</td></tr>
<tr><td class="num" id="LN7910">7910</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *spec;</td></tr>
<tr><td class="num" id="LN7911">7911</td><td class="line">  <span class='directive'>#if <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==9</span></td></tr>
<tr><td class="num" id="LN7912">7912</td><td class="line">    spec=<span class='string_literal'>"%09d "</span>;</td></tr>
<tr><td class="num" id="LN7913">7913</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==8</span></td></tr>
<tr><td class="num" id="LN7914">7914</td><td class="line">    spec=<span class='string_literal'>"%08d "</span>;</td></tr>
<tr><td class="num" id="LN7915">7915</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==7</span></td></tr>
<tr><td class="num" id="LN7916">7916</td><td class="line">    spec=<span class='string_literal'>"%07d "</span>;</td></tr>
<tr><td class="num" id="LN7917">7917</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==6</span></td></tr>
<tr><td class="num" id="LN7918">7918</td><td class="line">    spec=<span class='string_literal'>"%06d "</span>;</td></tr>
<tr><td class="num" id="LN7919">7919</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==5</span></td></tr>
<tr><td class="num" id="LN7920">7920</td><td class="line">    spec=<span class='string_literal'>"%05d "</span>;</td></tr>
<tr><td class="num" id="LN7921">7921</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==4</span></td></tr>
<tr><td class="num" id="LN7922">7922</td><td class="line">    spec=<span class='string_literal'>"%04d "</span>;</td></tr>
<tr><td class="num" id="LN7923">7923</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==3</span></td></tr>
<tr><td class="num" id="LN7924">7924</td><td class="line">    spec=<span class='string_literal'>"%03d "</span>;</td></tr>
<tr><td class="num" id="LN7925">7925</td><td class="line">  <span class='directive'>#elif <span class='macro'>DECDPUN<span class='expansion'>1</span></span>==2</span></td></tr>
<tr><td class="num" id="LN7926">7926</td><td class="line">    spec=<span class='string_literal'>"%02d "</span>;</td></tr>
<tr><td class="num" id="LN7927">7927</td><td class="line">  <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN7928">7928</td><td class="line">    spec=<span class='string_literal'>"%d "</span>;</td></tr>
<tr><td class="num" id="LN7929">7929</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7930">7930</td><td class="line">  printf(<span class='string_literal'>"  :%c: "</span>, name);</td></tr>
<tr><td class="num" id="LN7931">7931</td><td class="line">  <span class='keyword'>for</span> (i=len-1; i&gt;=0; i--) {</td></tr>
<tr><td class="num" id="LN7932">7932</td><td class="line">    <span class='keyword'>if</span> (i==len-1) printf(<span class='string_literal'>"%ld "</span>, (LI)ar[i]);</td></tr>
<tr><td class="num" id="LN7933">7933</td><td class="line">     <span class='keyword'>else</span> printf(spec, ar[i]);</td></tr>
<tr><td class="num" id="LN7934">7934</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7935">7935</td><td class="line">  printf(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN7936">7936</td><td class="line">  <span class='keyword'>return</span>;}</td></tr>
<tr><td class="num" id="LN7937">7937</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7938">7938</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7939">7939</td><td class="line"><span class='directive'>#if <span class='macro'>DECCHECK<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7940">7940</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7941">7941</td><td class="line"><span class='comment'>/* decCheckOperands -- check operand(s) to a routine                  */</span></td></tr>
<tr><td class="num" id="LN7942">7942</td><td class="line"><span class='comment'>/*   res is the result structure (not checked; it will be set to      */</span></td></tr>
<tr><td class="num" id="LN7943">7943</td><td class="line"><span class='comment'>/*          quiet NaN if error found (and it is not NULL))            */</span></td></tr>
<tr><td class="num" id="LN7944">7944</td><td class="line"><span class='comment'>/*   lhs is the first operand (may be DECUNRESU)                      */</span></td></tr>
<tr><td class="num" id="LN7945">7945</td><td class="line"><span class='comment'>/*   rhs is the second (may be DECUNUSED)                             */</span></td></tr>
<tr><td class="num" id="LN7946">7946</td><td class="line"><span class='comment'>/*   set is the context (may be DECUNCONT)                            */</span></td></tr>
<tr><td class="num" id="LN7947">7947</td><td class="line"><span class='comment'>/*   returns 0 if both operands, and the context are clean, or 1      */</span></td></tr>
<tr><td class="num" id="LN7948">7948</td><td class="line"><span class='comment'>/*     otherwise (in which case the context will show an error,       */</span></td></tr>
<tr><td class="num" id="LN7949">7949</td><td class="line"><span class='comment'>/*     unless NULL).  Note that res is not cleaned; caller should     */</span></td></tr>
<tr><td class="num" id="LN7950">7950</td><td class="line"><span class='comment'>/*     handle this so res=NULL case is safe.                          */</span></td></tr>
<tr><td class="num" id="LN7951">7951</td><td class="line"><span class='comment'>/* The caller is expected to abandon immediately if 1 is returned.    */</span></td></tr>
<tr><td class="num" id="LN7952">7952</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7953">7953</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> decCheckOperands(decNumber *res, <span class='keyword'>const</span> decNumber *lhs,</td></tr>
<tr><td class="num" id="LN7954">7954</td><td class="line">                             <span class='keyword'>const</span> decNumber *rhs, decContext *set) {</td></tr>
<tr><td class="num" id="LN7955">7955</td><td class="line">  <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> bad=0;</td></tr>
<tr><td class="num" id="LN7956">7956</td><td class="line">  <span class='keyword'>if</span> (set==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {                 <span class='comment'>/* oops; hopeless  */</span></td></tr>
<tr><td class="num" id="LN7957">7957</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN7958">7958</td><td class="line">    printf(<span class='string_literal'>"Reference to context is NULL.\n"</span>);</td></tr>
<tr><td class="num" id="LN7959">7959</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7960">7960</td><td class="line">    bad=1;</td></tr>
<tr><td class="num" id="LN7961">7961</td><td class="line">    <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN7962">7962</td><td class="line">   <span class='keyword'>else</span> <span class='keyword'>if</span> (set!=DECUNCONT</td></tr>
<tr><td class="num" id="LN7963">7963</td><td class="line">     &amp;&amp; (set-&gt;digits&lt;1 || set-&gt;round&gt;=DEC_ROUND_MAX)) {</td></tr>
<tr><td class="num" id="LN7964">7964</td><td class="line">    bad=1;</td></tr>
<tr><td class="num" id="LN7965">7965</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN7966">7966</td><td class="line">    printf(<span class='string_literal'>"Bad context [digits=%ld round=%ld].\n"</span>,</td></tr>
<tr><td class="num" id="LN7967">7967</td><td class="line">           (LI)set-&gt;digits, (LI)set-&gt;round);</td></tr>
<tr><td class="num" id="LN7968">7968</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7969">7969</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7970">7970</td><td class="line">   <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN7971">7971</td><td class="line">    <span class='keyword'>if</span> (res==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN7972">7972</td><td class="line">      bad=1;</td></tr>
<tr><td class="num" id="LN7973">7973</td><td class="line">      <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN7974">7974</td><td class="line">      <span class='comment'>/* this one not DECVERB as standard tests include NULL  */</span></td></tr>
<tr><td class="num" id="LN7975">7975</td><td class="line">      printf(<span class='string_literal'>"Reference to result is NULL.\n"</span>);</td></tr>
<tr><td class="num" id="LN7976">7976</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN7977">7977</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7978">7978</td><td class="line">    <span class='keyword'>if</span> (!bad &amp;&amp; lhs!=DECUNUSED) bad=(decCheckNumber(lhs));</td></tr>
<tr><td class="num" id="LN7979">7979</td><td class="line">    <span class='keyword'>if</span> (!bad &amp;&amp; rhs!=DECUNUSED) bad=(decCheckNumber(rhs));</td></tr>
<tr><td class="num" id="LN7980">7980</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7981">7981</td><td class="line">  <span class='keyword'>if</span> (bad) {</td></tr>
<tr><td class="num" id="LN7982">7982</td><td class="line">    <span class='keyword'>if</span> (set!=DECUNCONT) <span class='macro'>uprv_decContextSetStatus<span class='expansion'>uprv_decContextSetStatus_54</span></span>(set, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>);</td></tr>
<tr><td class="num" id="LN7983">7983</td><td class="line">    <span class='keyword'>if</span> (res!=DECUNRESU &amp;&amp; res!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN7984">7984</td><td class="line">      <span class='macro'>uprv_decNumberZero<span class='expansion'>uprv_decNumberZero_54</span></span>(res);</td></tr>
<tr><td class="num" id="LN7985">7985</td><td class="line">      res-&gt;bits=<span class='macro'>DECNAN<span class='expansion'>0x20</span></span>;       <span class='comment'>/* qNaN  */</span></td></tr>
<tr><td class="num" id="LN7986">7986</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN7987">7987</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN7988">7988</td><td class="line">  <span class='keyword'>return</span> bad;</td></tr>
<tr><td class="num" id="LN7989">7989</td><td class="line">  } <span class='comment'>/* decCheckOperands  */</span></td></tr>
<tr><td class="num" id="LN7990">7990</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7991">7991</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7992">7992</td><td class="line"><span class='comment'>/* decCheckNumber -- check a number                                   */</span></td></tr>
<tr><td class="num" id="LN7993">7993</td><td class="line"><span class='comment'>/*   dn is the number to check                                        */</span></td></tr>
<tr><td class="num" id="LN7994">7994</td><td class="line"><span class='comment'>/*   returns 0 if the number is clean, or 1 otherwise                 */</span></td></tr>
<tr><td class="num" id="LN7995">7995</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN7996">7996</td><td class="line"><span class='comment'>/* The number is considered valid if it could be a result from some   */</span></td></tr>
<tr><td class="num" id="LN7997">7997</td><td class="line"><span class='comment'>/* operation in some valid context.                                   */</span></td></tr>
<tr><td class="num" id="LN7998">7998</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN7999">7999</td><td class="line"><span class='keyword'>static</span> <span class='macro'>Flag<span class='expansion'>uint8_t</span></span> decCheckNumber(<span class='keyword'>const</span> decNumber *dn) {</td></tr>
<tr><td class="num" id="LN8000">8000</td><td class="line">  <span class='keyword'>const</span> <span class='macro'>Unit<span class='expansion'>uint8_t</span></span> *up;             <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN8001">8001</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span> maxuint;               <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN8002">8002</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> ae, d, digits;          <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN8003">8003</td><td class="line">  <span class='macro'>Int<span class='expansion'>int32_t</span></span> emin, emax;             <span class='comment'>/* ..  */</span></td></tr>
<tr><td class="num" id="LN8004">8004</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8005">8005</td><td class="line">  <span class='keyword'>if</span> (dn==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {             <span class='comment'>/* hopeless  */</span></td></tr>
<tr><td class="num" id="LN8006">8006</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN8007">8007</td><td class="line">    <span class='comment'>/* this one not DECVERB as standard tests include NULL  */</span></td></tr>
<tr><td class="num" id="LN8008">8008</td><td class="line">    printf(<span class='string_literal'>"Reference to decNumber is NULL.\n"</span>);</td></tr>
<tr><td class="num" id="LN8009">8009</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8010">8010</td><td class="line">    <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8011">8011</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8012">8012</td><td class="line">  <span class='comment'>/* check special values  */</span></td></tr>
<tr><td class="num" id="LN8013">8013</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;bits &amp; <span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>) {</td></tr>
<tr><td class="num" id="LN8014">8014</td><td class="line">    <span class='keyword'>if</span> (dn-&gt;exponent!=0) {</td></tr>
<tr><td class="num" id="LN8015">8015</td><td class="line">      <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8016">8016</td><td class="line">      printf(<span class='string_literal'>"Exponent %ld (not 0) for a special value [%02x].\n"</span>,</td></tr>
<tr><td class="num" id="LN8017">8017</td><td class="line">             (LI)dn-&gt;exponent, dn-&gt;bits);</td></tr>
<tr><td class="num" id="LN8018">8018</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8019">8019</td><td class="line">      <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8020">8020</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8021">8021</td><td class="line">    <span class='comment'>/* 2003.09.08: NaNs may now have coefficients, so next tests Inf only  */</span></td></tr>
<tr><td class="num" id="LN8022">8022</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>decNumberIsInfinite(dn)<span class='expansion'>(((dn)-&gt;bits&amp;0x40)!=0)</span></span>) {</td></tr>
<tr><td class="num" id="LN8023">8023</td><td class="line">      <span class='keyword'>if</span> (dn-&gt;digits!=1) {</td></tr>
<tr><td class="num" id="LN8024">8024</td><td class="line">        <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8025">8025</td><td class="line">        printf(<span class='string_literal'>"Digits %ld (not 1) for an infinity.\n"</span>, (LI)dn-&gt;digits);</td></tr>
<tr><td class="num" id="LN8026">8026</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8027">8027</td><td class="line">        <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8028">8028</td><td class="line">      <span class='keyword'>if</span> (*dn-&gt;lsu!=0) {</td></tr>
<tr><td class="num" id="LN8029">8029</td><td class="line">        <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8030">8030</td><td class="line">        printf(<span class='string_literal'>"LSU %ld (not 0) for an infinity.\n"</span>, (LI)*dn-&gt;lsu);</td></tr>
<tr><td class="num" id="LN8031">8031</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8032">8032</td><td class="line">        decDumpAr('I', dn-&gt;lsu, <span class='macro'>D2U(dn-&gt;digits)<span class='expansion'>((dn-&gt;digits)&lt;=49?d2utable[dn-&gt;digits]:((dn-&gt;digits<br>)+1 -1)/1)</span></span>);</td></tr>
<tr><td class="num" id="LN8033">8033</td><td class="line">        <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8034">8034</td><td class="line">      } <span class='comment'>/* Inf  */</span></td></tr>
<tr><td class="num" id="LN8035">8035</td><td class="line">    <span class='comment'>/* 2002.12.26: negative NaNs can now appear through proposed IEEE  */</span></td></tr>
<tr><td class="num" id="LN8036">8036</td><td class="line">    <span class='comment'>/*             concrete formats (decimal64, etc.).  */</span></td></tr>
<tr><td class="num" id="LN8037">8037</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN8038">8038</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN8039">8039</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8040">8040</td><td class="line">  <span class='comment'>/* check the coefficient  */</span></td></tr>
<tr><td class="num" id="LN8041">8041</td><td class="line">  <span class='keyword'>if</span> (dn-&gt;digits&lt;1 || dn-&gt;digits&gt;<span class='macro'>DECNUMMAXP<span class='expansion'>999999999</span></span>) {</td></tr>
<tr><td class="num" id="LN8042">8042</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8043">8043</td><td class="line">    printf(<span class='string_literal'>"Digits %ld in number.\n"</span>, (LI)dn-&gt;digits);</td></tr>
<tr><td class="num" id="LN8044">8044</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8045">8045</td><td class="line">    <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8046">8046</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8047">8047</td><td class="line">  d=dn-&gt;digits;</td></tr>
<tr><td class="num" id="LN8048">8048</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8049">8049</td><td class="line">  <span class='keyword'>for</span> (up=dn-&gt;lsu; d&gt;0; up++) {</td></tr>
<tr><td class="num" id="LN8050">8050</td><td class="line">    <span class='keyword'>if</span> (d&gt;<span class='macro'>DECDPUN<span class='expansion'>1</span></span>) maxuint=<span class='macro'>DECDPUNMAX<span class='expansion'>9</span></span>;</td></tr>
<tr><td class="num" id="LN8051">8051</td><td class="line">     <span class='keyword'>else</span> {                   <span class='comment'>/* reached the msu  */</span></td></tr>
<tr><td class="num" id="LN8052">8052</td><td class="line">      maxuint=<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[d]-1;</td></tr>
<tr><td class="num" id="LN8053">8053</td><td class="line">      <span class='keyword'>if</span> (dn-&gt;digits&gt;1 &amp;&amp; *up&lt;<span class='macro'>powers<span class='expansion'>DECPOWERS</span></span>[d-1]) {</td></tr>
<tr><td class="num" id="LN8054">8054</td><td class="line">        <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8055">8055</td><td class="line">        printf(<span class='string_literal'>"Leading 0 in number.\n"</span>);</td></tr>
<tr><td class="num" id="LN8056">8056</td><td class="line">        uprv_decNumberShow(dn);</td></tr>
<tr><td class="num" id="LN8057">8057</td><td class="line">        <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8058">8058</td><td class="line">        <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8059">8059</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN8060">8060</td><td class="line">    <span class='keyword'>if</span> (*up&gt;maxuint) {</td></tr>
<tr><td class="num" id="LN8061">8061</td><td class="line">      <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8062">8062</td><td class="line">      printf(<span class='string_literal'>"Bad Unit [%08lx] in %ld-digit number at offset %ld [maxuint %ld].\n"</span>,</td></tr>
<tr><td class="num" id="LN8063">8063</td><td class="line">              (LI)*up, (LI)dn-&gt;digits, (LI)(up-dn-&gt;lsu), (LI)maxuint);</td></tr>
<tr><td class="num" id="LN8064">8064</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8065">8065</td><td class="line">      <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8066">8066</td><td class="line">    d-=<span class='macro'>DECDPUN<span class='expansion'>1</span></span>;</td></tr>
<tr><td class="num" id="LN8067">8067</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN8068">8068</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8069">8069</td><td class="line">  <span class='comment'>/* check the exponent.  Note that input operands can have exponents  */</span></td></tr>
<tr><td class="num" id="LN8070">8070</td><td class="line">  <span class='comment'>/* which are out of the set-&gt;emin/set-&gt;emax and set-&gt;digits range  */</span></td></tr>
<tr><td class="num" id="LN8071">8071</td><td class="line">  <span class='comment'>/* (just as they can have more digits than set-&gt;digits).  */</span></td></tr>
<tr><td class="num" id="LN8072">8072</td><td class="line">  ae=dn-&gt;exponent+dn-&gt;digits-1;    <span class='comment'>/* adjusted exponent  */</span></td></tr>
<tr><td class="num" id="LN8073">8073</td><td class="line">  emax=<span class='macro'>DECNUMMAXE<span class='expansion'>999999999</span></span>;</td></tr>
<tr><td class="num" id="LN8074">8074</td><td class="line">  emin=<span class='macro'>DECNUMMINE<span class='expansion'>-999999999</span></span>;</td></tr>
<tr><td class="num" id="LN8075">8075</td><td class="line">  digits=<span class='macro'>DECNUMMAXP<span class='expansion'>999999999</span></span>;</td></tr>
<tr><td class="num" id="LN8076">8076</td><td class="line">  <span class='keyword'>if</span> (ae&lt;emin-(digits-1)) {</td></tr>
<tr><td class="num" id="LN8077">8077</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8078">8078</td><td class="line">    printf(<span class='string_literal'>"Adjusted exponent underflow [%ld].\n"</span>, (LI)ae);</td></tr>
<tr><td class="num" id="LN8079">8079</td><td class="line">    uprv_decNumberShow(dn);</td></tr>
<tr><td class="num" id="LN8080">8080</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8081">8081</td><td class="line">    <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8082">8082</td><td class="line">  <span class='keyword'>if</span> (ae&gt;+emax) {</td></tr>
<tr><td class="num" id="LN8083">8083</td><td class="line">    <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8084">8084</td><td class="line">    printf(<span class='string_literal'>"Adjusted exponent overflow [%ld].\n"</span>, (LI)ae);</td></tr>
<tr><td class="num" id="LN8085">8085</td><td class="line">    uprv_decNumberShow(dn);</td></tr>
<tr><td class="num" id="LN8086">8086</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8087">8087</td><td class="line">    <span class='keyword'>return</span> 1;}</td></tr>
<tr><td class="num" id="LN8088">8088</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8089">8089</td><td class="line">  <span class='keyword'>return</span> 0;              <span class='comment'>/* it's OK  */</span></td></tr>
<tr><td class="num" id="LN8090">8090</td><td class="line">  } <span class='comment'>/* decCheckNumber  */</span></td></tr>
<tr><td class="num" id="LN8091">8091</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8092">8092</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8093">8093</td><td class="line"><span class='comment'>/* decCheckInexact -- check a normal finite inexact result has digits */</span></td></tr>
<tr><td class="num" id="LN8094">8094</td><td class="line"><span class='comment'>/*   dn is the number to check                                        */</span></td></tr>
<tr><td class="num" id="LN8095">8095</td><td class="line"><span class='comment'>/*   set is the context (for status and precision)                    */</span></td></tr>
<tr><td class="num" id="LN8096">8096</td><td class="line"><span class='comment'>/*   sets Invalid operation, etc., if some digits are missing         */</span></td></tr>
<tr><td class="num" id="LN8097">8097</td><td class="line"><span class='comment'>/* [this check is not made for DECSUBSET compilation or when          */</span></td></tr>
<tr><td class="num" id="LN8098">8098</td><td class="line"><span class='comment'>/* subnormal is not set]                                              */</span></td></tr>
<tr><td class="num" id="LN8099">8099</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8100">8100</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decCheckInexact(<span class='keyword'>const</span> decNumber *dn, decContext *set) {</td></tr>
<tr><td class="num" id="LN8101">8101</td><td class="line">  <span class='directive'>#if !<span class='macro'>DECSUBSET<span class='expansion'>0</span></span> &amp;&amp; <span class='macro'>DECEXTFLAG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8102">8102</td><td class="line">    <span class='keyword'>if</span> ((set-&gt;status &amp; (<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span>|<span class='macro'>DEC_Subnormal<span class='expansion'>0x00001000</span></span>))==<span class='macro'>DEC_Inexact<span class='expansion'>0x00000020</span></span></td></tr>
<tr><td class="num" id="LN8103">8103</td><td class="line">     &amp;&amp; (set-&gt;digits!=dn-&gt;digits) &amp;&amp; !(dn-&gt;bits &amp; <span class='macro'>DECSPECIAL<span class='expansion'>(0x40|0x20|0x10)</span></span>)) {</td></tr>
<tr><td class="num" id="LN8104">8104</td><td class="line">      <span class='directive'>#if <span class='macro'>DECTRACE<span class='expansion'>0</span></span> || <span class='macro'>DECVERB<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN8105">8105</td><td class="line">      printf(<span class='string_literal'>"Insufficient digits [%ld] on normal Inexact result.\n"</span>,</td></tr>
<tr><td class="num" id="LN8106">8106</td><td class="line">             (LI)dn-&gt;digits);</td></tr>
<tr><td class="num" id="LN8107">8107</td><td class="line">      uprv_decNumberShow(dn);</td></tr>
<tr><td class="num" id="LN8108">8108</td><td class="line">      <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8109">8109</td><td class="line">      <span class='macro'>uprv_decContextSetStatus<span class='expansion'>uprv_decContextSetStatus_54</span></span>(set, <span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>);</td></tr>
<tr><td class="num" id="LN8110">8110</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN8111">8111</td><td class="line">  <span class='directive'>#else</span></td></tr>
<tr><td class="num" id="LN8112">8112</td><td class="line">    <span class='comment'>/* next is a noop for quiet compiler  */</span></td></tr>
<tr><td class="num" id="LN8113">8113</td><td class="line">    <span class='keyword'>if</span> (dn!=<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> &amp;&amp; dn-&gt;digits==0) set-&gt;status|=<span class='macro'>DEC_Invalid_operation<span class='expansion'>0x00000080</span></span>;</td></tr>
<tr><td class="num" id="LN8114">8114</td><td class="line">  <span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8115">8115</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN8116">8116</td><td class="line">  } <span class='comment'>/* decCheckInexact  */</span></td></tr>
<tr><td class="num" id="LN8117">8117</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN8118">8118</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8119">8119</td><td class="line"><span class='directive'>#if <span class='macro'>DECALLOC<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN8120">8120</td><td class="line"><span class='directive'>#undef malloc</span></td></tr>
<tr><td class="num" id="LN8121">8121</td><td class="line"><span class='directive'>#undef free</span></td></tr>
<tr><td class="num" id="LN8122">8122</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8123">8123</td><td class="line"><span class='comment'>/* decMalloc -- accountable allocation routine                        */</span></td></tr>
<tr><td class="num" id="LN8124">8124</td><td class="line"><span class='comment'>/*   n is the number of bytes to allocate                             */</span></td></tr>
<tr><td class="num" id="LN8125">8125</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN8126">8126</td><td class="line"><span class='comment'>/* Semantics is the same as the stdlib malloc routine, but bytes      */</span></td></tr>
<tr><td class="num" id="LN8127">8127</td><td class="line"><span class='comment'>/* allocated are accounted for globally, and corruption fences are    */</span></td></tr>
<tr><td class="num" id="LN8128">8128</td><td class="line"><span class='comment'>/* added before and after the 'actual' storage.                       */</span></td></tr>
<tr><td class="num" id="LN8129">8129</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8130">8130</td><td class="line"><span class='comment'>/* This routine allocates storage with an extra twelve bytes; 8 are   */</span></td></tr>
<tr><td class="num" id="LN8131">8131</td><td class="line"><span class='comment'>/* at the start and hold:                                             */</span></td></tr>
<tr><td class="num" id="LN8132">8132</td><td class="line"><span class='comment'>/*   0-3 the original length requested                                */</span></td></tr>
<tr><td class="num" id="LN8133">8133</td><td class="line"><span class='comment'>/*   4-7 buffer corruption detection fence (DECFENCE, x4)             */</span></td></tr>
<tr><td class="num" id="LN8134">8134</td><td class="line"><span class='comment'>/* The 4 bytes at the end also hold a corruption fence (DECFENCE, x4) */</span></td></tr>
<tr><td class="num" id="LN8135">8135</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8136">8136</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> *decMalloc(size_t n) {</td></tr>
<tr><td class="num" id="LN8137">8137</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  size=n+12;                 <span class='comment'>/* true size  */</span></td></tr>
<tr><td class="num" id="LN8138">8138</td><td class="line">  <span class='keyword'>void</span>  *alloc;                    <span class='comment'>/* -&gt; allocated storage  */</span></td></tr>
<tr><td class="num" id="LN8139">8139</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *b, *b0;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN8140">8140</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  uiwork;                    <span class='comment'>/* for macros  */</span></td></tr>
<tr><td class="num" id="LN8141">8141</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8142">8142</td><td class="line">  alloc=<span class='macro'>malloc(size)<span class='expansion'>uprv_malloc_54(size)</span></span>;              <span class='comment'>/* -&gt; allocated storage  */</span></td></tr>
<tr><td class="num" id="LN8143">8143</td><td class="line">  <span class='keyword'>if</span> (alloc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;    <span class='comment'>/* out of strorage  */</span></td></tr>
<tr><td class="num" id="LN8144">8144</td><td class="line">  b0=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *)alloc;               <span class='comment'>/* as bytes  */</span></td></tr>
<tr><td class="num" id="LN8145">8145</td><td class="line">  decAllocBytes+=n;                <span class='comment'>/* account for storage  */</span></td></tr>
<tr><td class="num" id="LN8146">8146</td><td class="line">  <span class='macro'>UBFROMUI(alloc, n)<span class='expansion'>(uiwork=(n), memcpy(alloc, (void *)&amp;uiwork, 4), uiwork)</span></span>;              <span class='comment'>/* save n  */</span></td></tr>
<tr><td class="num" id="LN8147">8147</td><td class="line">  <span class='comment'>/* printf(" alloc ++ dAB: %ld (%ld)\n", (LI)decAllocBytes, (LI)n);  */</span></td></tr>
<tr><td class="num" id="LN8148">8148</td><td class="line">  <span class='keyword'>for</span> (b=b0+4; b&lt;b0+8; b++) *b=DECFENCE;</td></tr>
<tr><td class="num" id="LN8149">8149</td><td class="line">  <span class='keyword'>for</span> (b=b0+n+8; b&lt;b0+n+12; b++) *b=DECFENCE;</td></tr>
<tr><td class="num" id="LN8150">8150</td><td class="line">  <span class='keyword'>return</span> b0+8;                     <span class='comment'>/* -&gt; play area  */</span></td></tr>
<tr><td class="num" id="LN8151">8151</td><td class="line">  } <span class='comment'>/* decMalloc  */</span></td></tr>
<tr><td class="num" id="LN8152">8152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8153">8153</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8154">8154</td><td class="line"><span class='comment'>/* decFree -- accountable free routine                                */</span></td></tr>
<tr><td class="num" id="LN8155">8155</td><td class="line"><span class='comment'>/*   alloc is the storage to free                                     */</span></td></tr>
<tr><td class="num" id="LN8156">8156</td><td class="line"><span class='comment'>/*                                                                    */</span></td></tr>
<tr><td class="num" id="LN8157">8157</td><td class="line"><span class='comment'>/* Semantics is the same as the stdlib malloc routine, except that    */</span></td></tr>
<tr><td class="num" id="LN8158">8158</td><td class="line"><span class='comment'>/* the global storage accounting is updated and the fences are        */</span></td></tr>
<tr><td class="num" id="LN8159">8159</td><td class="line"><span class='comment'>/* checked to ensure that no routine has written 'out of bounds'.     */</span></td></tr>
<tr><td class="num" id="LN8160">8160</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8161">8161</td><td class="line"><span class='comment'>/* This routine first checks that the fences have not been corrupted. */</span></td></tr>
<tr><td class="num" id="LN8162">8162</td><td class="line"><span class='comment'>/* It then frees the storage using the 'truw' storage address (that   */</span></td></tr>
<tr><td class="num" id="LN8163">8163</td><td class="line"><span class='comment'>/* is, offset by 8).                                                  */</span></td></tr>
<tr><td class="num" id="LN8164">8164</td><td class="line"><span class='comment'>/* ------------------------------------------------------------------ */</span></td></tr>
<tr><td class="num" id="LN8165">8165</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> decFree(<span class='keyword'>void</span> *alloc) {</td></tr>
<tr><td class="num" id="LN8166">8166</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  n;                         <span class='comment'>/* original length  */</span></td></tr>
<tr><td class="num" id="LN8167">8167</td><td class="line">  <span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *b, *b0;                   <span class='comment'>/* work  */</span></td></tr>
<tr><td class="num" id="LN8168">8168</td><td class="line">  <span class='macro'>uInt<span class='expansion'>uint32_t</span></span>  uiwork;                    <span class='comment'>/* for macros  */</span></td></tr>
<tr><td class="num" id="LN8169">8169</td><td class="line"> </td></tr>
<tr><td class="num" id="LN8170">8170</td><td class="line">  <span class='keyword'>if</span> (alloc==<span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) <span class='keyword'>return</span>;         <span class='comment'>/* allowed; it's a nop  */</span></td></tr>
<tr><td class="num" id="LN8171">8171</td><td class="line">  b0=(<span class='macro'>uByte<span class='expansion'>uint8_t</span></span> *)alloc;               <span class='comment'>/* as bytes  */</span></td></tr>
<tr><td class="num" id="LN8172">8172</td><td class="line">  b0-=8;                           <span class='comment'>/* -&gt; true start of storage  */</span></td></tr>
<tr><td class="num" id="LN8173">8173</td><td class="line">  n=<span class='macro'>UBTOUI(b0)<span class='expansion'>(memcpy((void *)&amp;uiwork, b0, 4), uiwork)</span></span>;                    <span class='comment'>/* lift length  */</span></td></tr>
<tr><td class="num" id="LN8174">8174</td><td class="line">  <span class='keyword'>for</span> (b=b0+4; b&lt;b0+8; b++) <span class='keyword'>if</span> (*b!=DECFENCE)</td></tr>
<tr><td class="num" id="LN8175">8175</td><td class="line">    printf(<span class='string_literal'>"=== Corrupt byte [%02x] at offset %d from %ld ===\n"</span>, *b,</td></tr>
<tr><td class="num" id="LN8176">8176</td><td class="line">           b-b0-8, (LI)b0);</td></tr>
<tr><td class="num" id="LN8177">8177</td><td class="line">  <span class='keyword'>for</span> (b=b0+n+8; b&lt;b0+n+12; b++) <span class='keyword'>if</span> (*b!=DECFENCE)</td></tr>
<tr><td class="num" id="LN8178">8178</td><td class="line">    printf(<span class='string_literal'>"=== Corrupt byte [%02x] at offset +%d from %ld, n=%ld ===\n"</span>, *b,</td></tr>
<tr><td class="num" id="LN8179">8179</td><td class="line">           b-b0-8, (LI)b0, (LI)n);</td></tr>
<tr><td class="num" id="LN8180">8180</td><td class="line">  <span class='macro'>free(b0)<span class='expansion'>uprv_free_54(b0)</span></span>;                        <span class='comment'>/* drop the storage  */</span></td></tr>
<tr><td class="num" id="LN8181">8181</td><td class="line">  decAllocBytes-=n;                <span class='comment'>/* account for storage  */</span></td></tr>
<tr><td class="num" id="LN8182">8182</td><td class="line">  <span class='comment'>/* printf(" free -- dAB: %d (%d)\n", decAllocBytes, -n);  */</span></td></tr>
<tr><td class="num" id="LN8183">8183</td><td class="line">  } <span class='comment'>/* decFree  */</span></td></tr>
<tr><td class="num" id="LN8184">8184</td><td class="line"><span class='directive'>#define <span class='macro'>malloc(a)<span class='expansion'>uprv_malloc_54(a)</span></span> decMalloc(a)</span></td></tr>
<tr><td class="num" id="LN8185">8185</td><td class="line"><span class='directive'>#define <span class='macro'>free(a)<span class='expansion'>uprv_free_54(a)</span></span> decFree(a)</span></td></tr>
<tr><td class="num" id="LN8186">8186</td><td class="line"><span class='directive'>#endif</span></td></tr>
</table></body></html>

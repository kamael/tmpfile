<!doctype html>
<html>
<head>
<title>../src/compiler/register-allocator.cc</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000;   border-radius:5px;  box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndex { border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Called C++ object pointer is null -->

<!-- BUGTYPE Called C++ object pointer is null -->

<!-- BUGCATEGORY Logic error -->

<!-- BUGFILE /home/haha/code/v8_5_0/v8/out/../src/compiler/register-allocator.cc -->

<!-- FILENAME register-allocator.cc -->

<!-- FUNCTIONNAME SpillRange -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT c6c28c2d1e95f7a7a6285aa721ab9f62 -->

<!-- BUGLINE 1282 -->

<!-- BUGCOLUMN 19 -->

<!-- BUGPATHLENGTH 5 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>out/../src/compiler/register-allocator.cc</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 1282, column 19</a></td></tr>
<tr><td class="rowname">Description:</td><td>Called C++ object pointer is null</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>// Copyright 2014 the V8 project authors. All rights reserved.</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"><span class='comment'>// Use of this source code is governed by a BSD-style license that can be</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"><span class='comment'>// found in the LICENSE file.</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"><span class='directive'>#include "src/base/adapters.h"</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"><span class='directive'>#include "src/compiler/linkage.h"</span></td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"><span class='directive'>#include "src/compiler/register-allocator.h"</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"><span class='directive'>#include "src/string-stream.h"</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"> </td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"><span class='keyword'>namespace</span> v8 {</td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"><span class='keyword'>namespace</span> internal {</td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"><span class='keyword'>namespace</span> compiler {</td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"> </td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#define <span class='macro'>TRACE(...)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF(...); } while (false)</span></span>                             \</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line">  <span class='directive'>do {                                         \</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line">    <span class='directive'>if (FLAG_trace_alloc) PrintF(__VA_ARGS__); \</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line">  <span class='directive'>} while (false)</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"> </td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"> </td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='keyword'>namespace</span> {</td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"> </td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='keyword'>void</span> RemoveElement(ZoneVector&lt;LiveRange*&gt;* v, LiveRange* range) {</td></tr>
<tr><td class="num" id="LN23">23</td><td class="line">  <span class='keyword'>auto</span> it = std::find(v-&gt;begin(), v-&gt;end(), range);</td></tr>
<tr><td class="num" id="LN24">24</td><td class="line">  <span class='macro'>DCHECK(it != v-&gt;end())<span class='expansion'>do { if ((__builtin_expect(!!(!(it != v-&gt;end())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 24, "Check failed: %s."<br>, "it != v-&gt;end()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN25">25</td><td class="line">  v-&gt;erase(it);</td></tr>
<tr><td class="num" id="LN26">26</td><td class="line">}</td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"> </td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"> </td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='keyword'>int</span> GetRegisterCount(<span class='keyword'>const</span> RegisterConfiguration* cfg, RegisterKind kind) {</td></tr>
<tr><td class="num" id="LN30">30</td><td class="line">  <span class='keyword'>return</span> kind == DOUBLE_REGISTERS ? cfg-&gt;num_double_registers()</td></tr>
<tr><td class="num" id="LN31">31</td><td class="line">                                  : cfg-&gt;num_general_registers();</td></tr>
<tr><td class="num" id="LN32">32</td><td class="line">}</td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"> </td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"> </td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"><span class='keyword'>int</span> GetAllocatableRegisterCount(<span class='keyword'>const</span> RegisterConfiguration* cfg,</td></tr>
<tr><td class="num" id="LN36">36</td><td class="line">                                RegisterKind kind) {</td></tr>
<tr><td class="num" id="LN37">37</td><td class="line">  <span class='keyword'>return</span> kind == DOUBLE_REGISTERS</td></tr>
<tr><td class="num" id="LN38">38</td><td class="line">             ? cfg-&gt;num_allocatable_aliased_double_registers()</td></tr>
<tr><td class="num" id="LN39">39</td><td class="line">             : cfg-&gt;num_allocatable_general_registers();</td></tr>
<tr><td class="num" id="LN40">40</td><td class="line">}</td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"> </td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"> </td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>int</span>* GetAllocatableRegisterCodes(<span class='keyword'>const</span> RegisterConfiguration* cfg,</td></tr>
<tr><td class="num" id="LN44">44</td><td class="line">                                       RegisterKind kind) {</td></tr>
<tr><td class="num" id="LN45">45</td><td class="line">  <span class='keyword'>return</span> kind == DOUBLE_REGISTERS ? cfg-&gt;allocatable_double_codes()</td></tr>
<tr><td class="num" id="LN46">46</td><td class="line">                                  : cfg-&gt;allocatable_general_codes();</td></tr>
<tr><td class="num" id="LN47">47</td><td class="line">}</td></tr>
<tr><td class="num" id="LN48">48</td><td class="line"> </td></tr>
<tr><td class="num" id="LN49">49</td><td class="line"> </td></tr>
<tr><td class="num" id="LN50">50</td><td class="line"><span class='keyword'>const</span> InstructionBlock* GetContainingLoop(<span class='keyword'>const</span> InstructionSequence* sequence,</td></tr>
<tr><td class="num" id="LN51">51</td><td class="line">                                          <span class='keyword'>const</span> InstructionBlock* block) {</td></tr>
<tr><td class="num" id="LN52">52</td><td class="line">  RpoNumber index = block-&gt;loop_header();</td></tr>
<tr><td class="num" id="LN53">53</td><td class="line">  <span class='keyword'>if</span> (!index.IsValid()) <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN54">54</td><td class="line">  <span class='keyword'>return</span> sequence-&gt;InstructionBlockAt(index);</td></tr>
<tr><td class="num" id="LN55">55</td><td class="line">}</td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"> </td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"> </td></tr>
<tr><td class="num" id="LN58">58</td><td class="line"><span class='keyword'>const</span> InstructionBlock* GetInstructionBlock(<span class='keyword'>const</span> InstructionSequence* code,</td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">                                            LifetimePosition pos) {</td></tr>
<tr><td class="num" id="LN60">60</td><td class="line">  <span class='keyword'>return</span> code-&gt;GetInstructionBlock(pos.ToInstructionIndex());</td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">}</td></tr>
<tr><td class="num" id="LN62">62</td><td class="line"> </td></tr>
<tr><td class="num" id="LN63">63</td><td class="line"> </td></tr>
<tr><td class="num" id="LN64">64</td><td class="line">Instruction* GetLastInstruction(InstructionSequence* code,</td></tr>
<tr><td class="num" id="LN65">65</td><td class="line">                                <span class='keyword'>const</span> InstructionBlock* block) {</td></tr>
<tr><td class="num" id="LN66">66</td><td class="line">  <span class='keyword'>return</span> code-&gt;InstructionAt(block-&gt;last_instruction_index());</td></tr>
<tr><td class="num" id="LN67">67</td><td class="line">}</td></tr>
<tr><td class="num" id="LN68">68</td><td class="line"> </td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"> </td></tr>
<tr><td class="num" id="LN70">70</td><td class="line"><span class='keyword'>bool</span> IsOutputRegisterOf(Instruction* instr, Register reg) {</td></tr>
<tr><td class="num" id="LN71">71</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; instr-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN72">72</td><td class="line">    InstructionOperand* output = instr-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">    <span class='keyword'>if</span> (output-&gt;IsRegister() &amp;&amp;</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">        LocationOperand::cast(output)-&gt;GetRegister().is(reg)) {</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN78">78</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line">}</td></tr>
<tr><td class="num" id="LN80">80</td><td class="line"> </td></tr>
<tr><td class="num" id="LN81">81</td><td class="line"> </td></tr>
<tr><td class="num" id="LN82">82</td><td class="line"><span class='keyword'>bool</span> IsOutputDoubleRegisterOf(Instruction* instr, DoubleRegister reg) {</td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; instr-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">    InstructionOperand* output = instr-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">    <span class='keyword'>if</span> (output-&gt;IsDoubleRegister() &amp;&amp;</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">        LocationOperand::cast(output)-&gt;GetDoubleRegister().is(reg)) {</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">}</td></tr>
<tr><td class="num" id="LN92">92</td><td class="line"> </td></tr>
<tr><td class="num" id="LN93">93</td><td class="line"> </td></tr>
<tr><td class="num" id="LN94">94</td><td class="line"><span class='comment'>// TODO(dcarney): fix frame to allow frame accesses to half size location.</span></td></tr>
<tr><td class="num" id="LN95">95</td><td class="line"><span class='keyword'>int</span> GetByteWidth(MachineRepresentation rep) {</td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">  <span class='keyword'>switch</span> (rep) {</td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kBit:</td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kWord8:</td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kWord16:</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kWord32:</td></tr>
<tr><td class="num" id="LN101">101</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kTagged:</td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">      <span class='keyword'>return</span> kPointerSize;</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kFloat32:</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kWord64:</td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kFloat64:</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">      <span class='keyword'>return</span> 8;</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kSimd128:</td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">      <span class='keyword'>return</span> 16;</td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">    <span class='keyword'>case</span> MachineRepresentation::kNone:</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN111">111</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/compiler/register-allocator.cc", 112, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN114">114</td><td class="line">}</td></tr>
<tr><td class="num" id="LN115">115</td><td class="line"> </td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">}  <span class='comment'>// namespace</span></td></tr>
<tr><td class="num" id="LN117">117</td><td class="line"> </td></tr>
<tr><td class="num" id="LN118">118</td><td class="line"><span class='keyword'>class</span> LiveRangeBound {</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">  <span class='keyword'>explicit</span> LiveRangeBound(LiveRange* range, <span class='keyword'>bool</span> skip)</td></tr>
<tr><td class="num" id="LN121">121</td><td class="line">      : range_(range), start_(range-&gt;Start()), end_(range-&gt;End()), skip_(skip) {</td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">    <span class='macro'>DCHECK(!range-&gt;IsEmpty())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;IsEmpty())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 122, "Check failed: %s."<br>, "!range-&gt;IsEmpty()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN124">124</td><td class="line"> </td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">  <span class='keyword'>bool</span> CanCover(LifetimePosition position) {</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line">    <span class='keyword'>return</span> start_ &lt;= position &amp;&amp; position &lt; end_;</td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line"> </td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">  LiveRange* <span class='keyword'>const</span> range_;</td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">  <span class='keyword'>const</span> LifetimePosition start_;</td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">  <span class='keyword'>const</span> LifetimePosition end_;</td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>bool</span> skip_;</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line"> </td></tr>
<tr><td class="num" id="LN134">134</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">  <span class='macro'>DISALLOW_COPY_AND_ASSIGN(LiveRangeBound)<span class='expansion'>LiveRangeBound(const LiveRangeBound&amp;) = delete; void operator<br>=(const LiveRangeBound&amp;) = delete</span></span>;</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">};</td></tr>
<tr><td class="num" id="LN137">137</td><td class="line"> </td></tr>
<tr><td class="num" id="LN138">138</td><td class="line"> </td></tr>
<tr><td class="num" id="LN139">139</td><td class="line"><span class='keyword'>struct</span> FindResult {</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">  LiveRange* cur_cover_;</td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">  LiveRange* pred_cover_;</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">};</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line"> </td></tr>
<tr><td class="num" id="LN144">144</td><td class="line"> </td></tr>
<tr><td class="num" id="LN145">145</td><td class="line"><span class='keyword'>class</span> LiveRangeBoundArray {</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">  LiveRangeBoundArray() : length_(0), start_(<span class='keyword'>nullptr</span>) {}</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"> </td></tr>
<tr><td class="num" id="LN149">149</td><td class="line">  <span class='keyword'>bool</span> ShouldInitialize() { <span class='keyword'>return</span> start_ == <span class='keyword'>nullptr</span>; }</td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"> </td></tr>
<tr><td class="num" id="LN151">151</td><td class="line">  <span class='keyword'>void</span> Initialize(Zone* zone, TopLevelLiveRange* range) {</td></tr>
<tr><td class="num" id="LN152">152</td><td class="line">    length_ = range-&gt;GetChildCount();</td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"> </td></tr>
<tr><td class="num" id="LN154">154</td><td class="line">    start_ = zone-&gt;NewArray&lt;LiveRangeBound&gt;(length_);</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line">    LiveRangeBound* curr = start_;</td></tr>
<tr><td class="num" id="LN156">156</td><td class="line">    <span class='comment'>// Normally, spilled ranges do not need connecting moves, because the spill</span></td></tr>
<tr><td class="num" id="LN157">157</td><td class="line">    <span class='comment'>// location has been assigned at definition. For ranges spilled in deferred</span></td></tr>
<tr><td class="num" id="LN158">158</td><td class="line">    <span class='comment'>// blocks, that is not the case, so we need to connect the spilled children.</span></td></tr>
<tr><td class="num" id="LN159">159</td><td class="line">    <span class='keyword'>for</span> (LiveRange *i = range; i != <span class='keyword'>nullptr</span>; i = i-&gt;next(), ++curr) {</td></tr>
<tr><td class="num" id="LN160">160</td><td class="line">      <span class='keyword'>new</span> (curr) LiveRangeBound(i, i-&gt;spilled());</td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN163">163</td><td class="line"> </td></tr>
<tr><td class="num" id="LN164">164</td><td class="line">  LiveRangeBound* Find(<span class='keyword'>const</span> LifetimePosition position) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN165">165</td><td class="line">    size_t left_index = 0;</td></tr>
<tr><td class="num" id="LN166">166</td><td class="line">    size_t right_index = length_;</td></tr>
<tr><td class="num" id="LN167">167</td><td class="line">    <span class='keyword'>while</span> (<span class='keyword'>true</span>) {</td></tr>
<tr><td class="num" id="LN168">168</td><td class="line">      size_t current_index = left_index + (right_index - left_index) / 2;</td></tr>
<tr><td class="num" id="LN169">169</td><td class="line">      <span class='macro'>DCHECK(right_index &gt; current_index)<span class='expansion'>do { if ((__builtin_expect(!!(!(right_index &gt; current_index<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 169<br>, "Check failed: %s.", "right_index &gt; current_index"); } }<br> while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">      LiveRangeBound* bound = &amp;start_[current_index];</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line">      <span class='keyword'>if</span> (bound-&gt;start_ &lt;= position) {</td></tr>
<tr><td class="num" id="LN172">172</td><td class="line">        <span class='keyword'>if</span> (position &lt; bound-&gt;end_) <span class='keyword'>return</span> bound;</td></tr>
<tr><td class="num" id="LN173">173</td><td class="line">        <span class='macro'>DCHECK(left_index &lt; current_index)<span class='expansion'>do { if ((__builtin_expect(!!(!(left_index &lt; current_index<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 173<br>, "Check failed: %s.", "left_index &lt; current_index"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN174">174</td><td class="line">        left_index = current_index;</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN176">176</td><td class="line">        right_index = current_index;</td></tr>
<tr><td class="num" id="LN177">177</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN179">179</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"> </td></tr>
<tr><td class="num" id="LN181">181</td><td class="line">  LiveRangeBound* FindPred(<span class='keyword'>const</span> InstructionBlock* pred) {</td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">    LifetimePosition pred_end =</td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">        LifetimePosition::InstructionFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">            pred-&gt;last_instruction_index());</td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">    <span class='keyword'>return</span> Find(pred_end);</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN187">187</td><td class="line"> </td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">  LiveRangeBound* FindSucc(<span class='keyword'>const</span> InstructionBlock* succ) {</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">    LifetimePosition succ_start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN190">190</td><td class="line">        succ-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">    <span class='keyword'>return</span> Find(succ_start);</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN194">194</td><td class="line">  <span class='keyword'>bool</span> FindConnectableSubranges(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN195">195</td><td class="line">                                <span class='keyword'>const</span> InstructionBlock* pred,</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">                                FindResult* result) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">    LifetimePosition pred_end =</td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">        LifetimePosition::InstructionFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">            pred-&gt;last_instruction_index());</td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">    LiveRangeBound* bound = Find(pred_end);</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">    result-&gt;pred_cover_ = bound-&gt;range_;</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">    LifetimePosition cur_start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">        block-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN204">204</td><td class="line"> </td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">    <span class='keyword'>if</span> (bound-&gt;CanCover(cur_start)) {</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">      <span class='comment'>// Both blocks are covered by the same range, so there is nothing to</span></td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">      <span class='comment'>// connect.</span></td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">    bound = Find(cur_start);</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">    <span class='keyword'>if</span> (bound-&gt;skip_) {</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">    result-&gt;cur_cover_ = bound-&gt;range_;</td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">    <span class='macro'>DCHECK(result-&gt;pred_cover_ != <span class='keyword'>nullptr</span> &amp;&amp; result-&gt;cur_cover_ != <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(result-&gt;pred_cover_ != nullptr<br> &amp;&amp; result-&gt;cur_cover_ != nullptr)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 215, "Check failed: %s."<br>, "result-&gt;pred_cover_ != nullptr &amp;&amp; result-&gt;cur_cover_ != nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">    <span class='keyword'>return</span> (result-&gt;cur_cover_ != result-&gt;pred_cover_);</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN218">218</td><td class="line"> </td></tr>
<tr><td class="num" id="LN219">219</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">  size_t length_;</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">  LiveRangeBound* start_;</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line"> </td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">  <span class='macro'>DISALLOW_COPY_AND_ASSIGN(LiveRangeBoundArray)<span class='expansion'>LiveRangeBoundArray(const LiveRangeBoundArray&amp;) = delete;<br> void operator=(const LiveRangeBoundArray&amp;) = delete</span></span>;</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">};</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line"> </td></tr>
<tr><td class="num" id="LN226">226</td><td class="line"> </td></tr>
<tr><td class="num" id="LN227">227</td><td class="line"><span class='keyword'>class</span> LiveRangeFinder {</td></tr>
<tr><td class="num" id="LN228">228</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">  <span class='keyword'>explicit</span> LiveRangeFinder(<span class='keyword'>const</span> RegisterAllocationData* data, Zone* zone)</td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">      : data_(data),</td></tr>
<tr><td class="num" id="LN231">231</td><td class="line">        bounds_length_(<span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(data_-&gt;live_ranges().size())),</td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">        bounds_(zone-&gt;NewArray&lt;LiveRangeBoundArray&gt;(bounds_length_)),</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">        zone_(zone) {</td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; bounds_length_; ++i) {</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">      <span class='keyword'>new</span> (&amp;bounds_[i]) LiveRangeBoundArray();</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line"> </td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">  LiveRangeBoundArray* ArrayFor(<span class='keyword'>int</span> operand_index) {</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">    <span class='macro'>DCHECK(operand_index &lt; bounds_length_)<span class='expansion'>do { if ((__builtin_expect(!!(!(operand_index &lt; bounds_length_<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 240<br>, "Check failed: %s.", "operand_index &lt; bounds_length_"); }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">    TopLevelLiveRange* range = data_-&gt;live_ranges()[operand_index];</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">    <span class='macro'>DCHECK(range != <span class='keyword'>nullptr</span> &amp;&amp; !range-&gt;IsEmpty())<span class='expansion'>do { if ((__builtin_expect(!!(!(range != nullptr &amp;&amp; !<br>range-&gt;IsEmpty())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 242, "Check failed: %s.", "range != nullptr &amp;&amp; !range-&gt;IsEmpty()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">    LiveRangeBoundArray* array = &amp;bounds_[operand_index];</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">    <span class='keyword'>if</span> (array-&gt;ShouldInitialize()) {</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">      array-&gt;Initialize(zone_, range);</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line">    <span class='keyword'>return</span> array;</td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN249">249</td><td class="line"> </td></tr>
<tr><td class="num" id="LN250">250</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">  <span class='keyword'>const</span> RegisterAllocationData* <span class='keyword'>const</span> data_;</td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> bounds_length_;</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line">  LiveRangeBoundArray* <span class='keyword'>const</span> bounds_;</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">  Zone* <span class='keyword'>const</span> zone_;</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line"> </td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">  <span class='macro'>DISALLOW_COPY_AND_ASSIGN(LiveRangeFinder)<span class='expansion'>LiveRangeFinder(const LiveRangeFinder&amp;) = delete; void operator<br>=(const LiveRangeFinder&amp;) = delete</span></span>;</td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">};</td></tr>
<tr><td class="num" id="LN258">258</td><td class="line"> </td></tr>
<tr><td class="num" id="LN259">259</td><td class="line"> </td></tr>
<tr><td class="num" id="LN260">260</td><td class="line"><span class='keyword'>typedef</span> std::pair&lt;ParallelMove*, InstructionOperand&gt; DelayedInsertionMapKey;</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line"> </td></tr>
<tr><td class="num" id="LN262">262</td><td class="line"> </td></tr>
<tr><td class="num" id="LN263">263</td><td class="line"><span class='keyword'>struct</span> DelayedInsertionMapCompare {</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">  <span class='keyword'>bool</span> <span class='keyword'>operator</span>()(<span class='keyword'>const</span> DelayedInsertionMapKey&amp; a,</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line">                  <span class='keyword'>const</span> DelayedInsertionMapKey&amp; b) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">    <span class='keyword'>if</span> (a.first == b.first) {</td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">      <span class='keyword'>return</span> a.second.Compare(b.second);</td></tr>
<tr><td class="num" id="LN268">268</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">    <span class='keyword'>return</span> a.first &lt; b.first;</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">};</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN273">273</td><td class="line"> </td></tr>
<tr><td class="num" id="LN274">274</td><td class="line"><span class='keyword'>typedef</span> ZoneMap&lt;DelayedInsertionMapKey, InstructionOperand,</td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">                DelayedInsertionMapCompare&gt; DelayedInsertionMap;</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line"> </td></tr>
<tr><td class="num" id="LN277">277</td><td class="line"> </td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">UsePosition::UsePosition(LifetimePosition pos, InstructionOperand* operand,</td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">                         <span class='keyword'>void</span>* hint, UsePositionHintType hint_type)</td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">    : operand_(operand), hint_(hint), next_(<span class='keyword'>nullptr</span>), pos_(pos), flags_(0) {</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">  <span class='macro'>DCHECK_IMPLIES(hint == <span class='keyword'>nullptr</span>, hint_type == UsePositionHintType::kNone)<span class='expansion'>do { if ((__builtin_expect(!!(!(!(hint == nullptr) || (hint_type<br> == UsePositionHintType::kNone))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 281, "Check failed: %s.", "!(hint == nullptr) || (hint_type == UsePositionHintType::kNone)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">  <span class='keyword'>bool</span> register_beneficial = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line">  UsePositionType type = UsePositionType::kAny;</td></tr>
<tr><td class="num" id="LN284">284</td><td class="line">  <span class='keyword'>if</span> (operand_ != <span class='keyword'>nullptr</span> &amp;&amp; operand_-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN285">285</td><td class="line">    <span class='keyword'>const</span> UnallocatedOperand* unalloc = UnallocatedOperand::cast(operand_);</td></tr>
<tr><td class="num" id="LN286">286</td><td class="line">    <span class='keyword'>if</span> (unalloc-&gt;HasRegisterPolicy()) {</td></tr>
<tr><td class="num" id="LN287">287</td><td class="line">      type = UsePositionType::kRequiresRegister;</td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (unalloc-&gt;HasSlotPolicy()) {</td></tr>
<tr><td class="num" id="LN289">289</td><td class="line">      type = UsePositionType::kRequiresSlot;</td></tr>
<tr><td class="num" id="LN290">290</td><td class="line">      register_beneficial = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN291">291</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN292">292</td><td class="line">      register_beneficial = !unalloc-&gt;HasAnyPolicy();</td></tr>
<tr><td class="num" id="LN293">293</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN294">294</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">  flags_ = TypeField::encode(type) | HintTypeField::encode(hint_type) |</td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">           RegisterBeneficialField::encode(register_beneficial) |</td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">           AssignedRegisterField::encode(kUnassignedRegister);</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">  <span class='macro'>DCHECK(pos_.IsValid())<span class='expansion'>do { if ((__builtin_expect(!!(!(pos_.IsValid())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 298, "Check failed: %s."<br>, "pos_.IsValid()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">}</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line"> </td></tr>
<tr><td class="num" id="LN301">301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN302">302</td><td class="line"><span class='keyword'>bool</span> UsePosition::HasHint() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">  <span class='keyword'>int</span> hint_register;</td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">  <span class='keyword'>return</span> HintRegister(&amp;hint_register);</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">}</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line"> </td></tr>
<tr><td class="num" id="LN307">307</td><td class="line"> </td></tr>
<tr><td class="num" id="LN308">308</td><td class="line"><span class='keyword'>bool</span> UsePosition::HintRegister(<span class='keyword'>int</span>* register_code) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">  <span class='keyword'>if</span> (hint_ == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">  <span class='keyword'>switch</span> (HintTypeField::decode(flags_)) {</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">    <span class='keyword'>case</span> UsePositionHintType::kNone:</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">    <span class='keyword'>case</span> UsePositionHintType::kUnresolved:</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">    <span class='keyword'>case</span> UsePositionHintType::kUsePos: {</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">      UsePosition* use_pos = <span class='keyword'>reinterpret_cast</span>&lt;UsePosition*&gt;(hint_);</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">      <span class='keyword'>int</span> assigned_register = AssignedRegisterField::decode(use_pos-&gt;flags_);</td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">      <span class='keyword'>if</span> (assigned_register == kUnassignedRegister) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line">      *register_code = assigned_register;</td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">    <span class='keyword'>case</span> UsePositionHintType::kOperand: {</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">      InstructionOperand* operand =</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">          <span class='keyword'>reinterpret_cast</span>&lt;InstructionOperand*&gt;(hint_);</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">      <span class='keyword'>int</span> assigned_register =</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">          operand-&gt;IsRegister()</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">              ? LocationOperand::cast(operand)-&gt;GetRegister().code()</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">              : LocationOperand::cast(operand)-&gt;GetDoubleRegister().code();</td></tr>
<tr><td class="num" id="LN328">328</td><td class="line">      *register_code = assigned_register;</td></tr>
<tr><td class="num" id="LN329">329</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN330">330</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN331">331</td><td class="line">    <span class='keyword'>case</span> UsePositionHintType::kPhi: {</td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">      RegisterAllocationData::PhiMapValue* phi =</td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">          <span class='keyword'>reinterpret_cast</span>&lt;RegisterAllocationData::PhiMapValue*&gt;(hint_);</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">      <span class='keyword'>int</span> assigned_register = phi-&gt;assigned_register();</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">      <span class='keyword'>if</span> (assigned_register == kUnassignedRegister) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">      *register_code = assigned_register;</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/compiler/register-allocator.cc", 340, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">}</td></tr>
<tr><td class="num" id="LN343">343</td><td class="line"> </td></tr>
<tr><td class="num" id="LN344">344</td><td class="line"> </td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">UsePositionHintType UsePosition::HintTypeForOperand(</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">    <span class='keyword'>const</span> InstructionOperand&amp; op) {</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">  <span class='keyword'>switch</span> (op.kind()) {</td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::CONSTANT:</td></tr>
<tr><td class="num" id="LN349">349</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::IMMEDIATE:</td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::EXPLICIT:</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">      <span class='keyword'>return</span> UsePositionHintType::kNone;</td></tr>
<tr><td class="num" id="LN352">352</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::UNALLOCATED:</td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">      <span class='keyword'>return</span> UsePositionHintType::kUnresolved;</td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::ALLOCATED:</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">      <span class='keyword'>if</span> (op.IsRegister() || op.IsDoubleRegister()) {</td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">        <span class='keyword'>return</span> UsePositionHintType::kOperand;</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line">        <span class='macro'>DCHECK(op.IsStackSlot() || op.IsDoubleStackSlot())<span class='expansion'>do { if ((__builtin_expect(!!(!(op.IsStackSlot() || op.IsDoubleStackSlot<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 358, "Check failed: %s.", "op.IsStackSlot() || op.IsDoubleStackSlot()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">        <span class='keyword'>return</span> UsePositionHintType::kNone;</td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">    <span class='keyword'>case</span> InstructionOperand::INVALID:</td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/compiler/register-allocator.cc", 364, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">  <span class='keyword'>return</span> UsePositionHintType::kNone;</td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">}</td></tr>
<tr><td class="num" id="LN367">367</td><td class="line"> </td></tr>
<tr><td class="num" id="LN368">368</td><td class="line"> </td></tr>
<tr><td class="num" id="LN369">369</td><td class="line"><span class='keyword'>void</span> UsePosition::ResolveHint(UsePosition* use_pos) {</td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">  <span class='macro'>DCHECK_NOT_NULL(use_pos)<span class='expansion'>do { if ((__builtin_expect(!!(!((use_pos) != nullptr)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 370, "Check failed: %s."<br>, "(use_pos) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">  <span class='keyword'>if</span> (HintTypeField::decode(flags_) != UsePositionHintType::kUnresolved) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">  hint_ = use_pos;</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">  flags_ = HintTypeField::update(flags_, UsePositionHintType::kUsePos);</td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">}</td></tr>
<tr><td class="num" id="LN375">375</td><td class="line"> </td></tr>
<tr><td class="num" id="LN376">376</td><td class="line"> </td></tr>
<tr><td class="num" id="LN377">377</td><td class="line"><span class='keyword'>void</span> UsePosition::set_type(UsePositionType type, <span class='keyword'>bool</span> register_beneficial) {</td></tr>
<tr><td class="num" id="LN378">378</td><td class="line">  <span class='macro'>DCHECK_IMPLIES(type == UsePositionType::kRequiresSlot, !register_beneficial)<span class='expansion'>do { if ((__builtin_expect(!!(!(!(type == UsePositionType::kRequiresSlot<br>) || (!register_beneficial))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 378, "Check failed: %s.", "!(type == UsePositionType::kRequiresSlot) || (!register_beneficial)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN379">379</td><td class="line">  <span class='macro'>DCHECK_EQ(kUnassignedRegister, AssignedRegisterField::decode(flags_))<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (kUnassignedRegister<br>), (AssignedRegisterField::decode(flags_)), "kUnassignedRegister"<br> " " "==" " " "AssignedRegisterField::decode(flags_)")) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 379, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">  flags_ = TypeField::encode(type) |</td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">           RegisterBeneficialField::encode(register_beneficial) |</td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">           HintTypeField::encode(HintTypeField::decode(flags_)) |</td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">           AssignedRegisterField::encode(kUnassignedRegister);</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">}</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN386">386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">UseInterval* UseInterval::SplitAt(LifetimePosition pos, Zone* zone) {</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">  <span class='macro'>DCHECK(Contains(pos) &amp;&amp; pos != start())<span class='expansion'>do { if ((__builtin_expect(!!(!(Contains(pos) &amp;&amp; pos !=<br> start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 388, "Check failed: %s.", "Contains(pos) &amp;&amp; pos != start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">  UseInterval* after = <span class='keyword'>new</span> (zone) UseInterval(pos, end_);</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">  after-&gt;next_ = next_;</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">  next_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">  end_ = pos;</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">  <span class='keyword'>return</span> after;</td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">}</td></tr>
<tr><td class="num" id="LN395">395</td><td class="line"> </td></tr>
<tr><td class="num" id="LN396">396</td><td class="line"> </td></tr>
<tr><td class="num" id="LN397">397</td><td class="line"><span class='keyword'>void</span> LifetimePosition::Print() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">  OFStream os(<span class='macro'>stdout<span class='expansion'>stdout</span></span>);</td></tr>
<tr><td class="num" id="LN399">399</td><td class="line">  os &lt;&lt; *<span class='keyword'>this</span> &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN400">400</td><td class="line">}</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line"> </td></tr>
<tr><td class="num" id="LN402">402</td><td class="line"> </td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">std::ostream&amp; <span class='keyword'>operator</span>&lt;&lt;(std::ostream&amp; os, <span class='keyword'>const</span> LifetimePosition pos) {</td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">  os &lt;&lt; '@' &lt;&lt; pos.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">  <span class='keyword'>if</span> (pos.IsGapPosition()) {</td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">    os &lt;&lt; 'g';</td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">    os &lt;&lt; 'i';</td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">  <span class='keyword'>if</span> (pos.IsStart()) {</td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">    os &lt;&lt; 's';</td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">    os &lt;&lt; 'e';</td></tr>
<tr><td class="num" id="LN414">414</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">  <span class='keyword'>return</span> os;</td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">}</td></tr>
<tr><td class="num" id="LN417">417</td><td class="line"> </td></tr>
<tr><td class="num" id="LN418">418</td><td class="line"> </td></tr>
<tr><td class="num" id="LN419">419</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>float</span> LiveRange::kInvalidWeight = -1;</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>float</span> LiveRange::kMaxWeight = std::numeric_limits&lt;<span class='keyword'>float</span>&gt;::max();</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line"> </td></tr>
<tr><td class="num" id="LN422">422</td><td class="line"> </td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">LiveRange::LiveRange(<span class='keyword'>int</span> relative_id, MachineRepresentation rep,</td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">                     TopLevelLiveRange* top_level)</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">    : relative_id_(relative_id),</td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">      bits_(0),</td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">      last_interval_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">      first_interval_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">      first_pos_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">      top_level_(top_level),</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">      next_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">      current_interval_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">      last_processed_use_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">      current_hint_position_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">      splitting_pointer_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">      size_(kInvalidSize),</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">      weight_(kInvalidWeight),</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">      group_(<span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">  <span class='macro'>DCHECK(AllocatedOperand::IsSupportedRepresentation(rep))<span class='expansion'>do { if ((__builtin_expect(!!(!(AllocatedOperand::IsSupportedRepresentation<br>(rep))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 439, "Check failed: %s.", "AllocatedOperand::IsSupportedRepresentation(rep)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">  bits_ = AssignedRegisterField::encode(kUnassignedRegister) |</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">          RepresentationField::encode(rep);</td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">}</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line"> </td></tr>
<tr><td class="num" id="LN444">444</td><td class="line"> </td></tr>
<tr><td class="num" id="LN445">445</td><td class="line"><span class='keyword'>void</span> LiveRange::VerifyPositions() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">  <span class='comment'>// Walk the positions, verifying that each is in an interval.</span></td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">  UseInterval* interval = first_interval_;</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">  <span class='keyword'>for</span> (UsePosition* pos = first_pos_; pos != <span class='keyword'>nullptr</span>; pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">    <span class='macro'>CHECK(Start() &lt;= pos-&gt;pos())<span class='expansion'>do { if ((__builtin_expect(!!(!(Start() &lt;= pos-&gt;pos()))<br>, 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 449<br>, "Check failed: %s.", "Start() &lt;= pos-&gt;pos()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">    <span class='macro'>CHECK(pos-&gt;pos() &lt;= End())<span class='expansion'>do { if ((__builtin_expect(!!(!(pos-&gt;pos() &lt;= End())), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 450, "Check failed: %s."<br>, "pos-&gt;pos() &lt;= End()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">    <span class='macro'>CHECK_NOT_NULL(interval)<span class='expansion'>do { if ((__builtin_expect(!!(!((interval) != nullptr)), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 451, "Check failed: %s."<br>, "(interval) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">    <span class='keyword'>while</span> (!interval-&gt;Contains(pos-&gt;pos()) &amp;&amp; interval-&gt;end() != pos-&gt;pos()) {</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">      interval = interval-&gt;next();</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">      <span class='macro'>CHECK_NOT_NULL(interval)<span class='expansion'>do { if ((__builtin_expect(!!(!((interval) != nullptr)), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 454, "Check failed: %s."<br>, "(interval) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">}</td></tr>
<tr><td class="num" id="LN458">458</td><td class="line"> </td></tr>
<tr><td class="num" id="LN459">459</td><td class="line"> </td></tr>
<tr><td class="num" id="LN460">460</td><td class="line"><span class='keyword'>void</span> LiveRange::VerifyIntervals() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">  <span class='macro'>DCHECK(first_interval()-&gt;start() == Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(first_interval()-&gt;start() ==<br> Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 461, "Check failed: %s.", "first_interval()-&gt;start() == Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">  LifetimePosition last_end = first_interval()-&gt;end();</td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">  <span class='keyword'>for</span> (UseInterval* interval = first_interval()-&gt;next(); interval != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">       interval = interval-&gt;next()) {</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">    <span class='macro'>DCHECK(last_end &lt;= interval-&gt;start())<span class='expansion'>do { if ((__builtin_expect(!!(!(last_end &lt;= interval-&gt;start<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 465, "Check failed: %s.", "last_end &lt;= interval-&gt;start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">    last_end = interval-&gt;end();</td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">  <span class='macro'>DCHECK(last_end == End())<span class='expansion'>do { if ((__builtin_expect(!!(!(last_end == End())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 468, "Check failed: %s."<br>, "last_end == End()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">}</td></tr>
<tr><td class="num" id="LN470">470</td><td class="line"> </td></tr>
<tr><td class="num" id="LN471">471</td><td class="line"> </td></tr>
<tr><td class="num" id="LN472">472</td><td class="line"><span class='keyword'>void</span> LiveRange::set_assigned_register(<span class='keyword'>int</span> reg) {</td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">  <span class='macro'>DCHECK(!HasRegisterAssigned() &amp;&amp; !spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!HasRegisterAssigned() &amp;&amp;<br> !spilled())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 473, "Check failed: %s.", "!HasRegisterAssigned() &amp;&amp; !spilled()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">  bits_ = AssignedRegisterField::update(bits_, reg);</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line">}</td></tr>
<tr><td class="num" id="LN476">476</td><td class="line"> </td></tr>
<tr><td class="num" id="LN477">477</td><td class="line"> </td></tr>
<tr><td class="num" id="LN478">478</td><td class="line"><span class='keyword'>void</span> LiveRange::UnsetAssignedRegister() {</td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">  <span class='macro'>DCHECK(HasRegisterAssigned() &amp;&amp; !spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(HasRegisterAssigned() &amp;&amp;<br> !spilled())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 479, "Check failed: %s.", "HasRegisterAssigned() &amp;&amp; !spilled()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN480">480</td><td class="line">  bits_ = AssignedRegisterField::update(bits_, kUnassignedRegister);</td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">}</td></tr>
<tr><td class="num" id="LN482">482</td><td class="line"> </td></tr>
<tr><td class="num" id="LN483">483</td><td class="line"> </td></tr>
<tr><td class="num" id="LN484">484</td><td class="line"><span class='keyword'>void</span> LiveRange::Spill() {</td></tr>
<tr><td class="num" id="LN485">485</td><td class="line">  <span class='macro'>DCHECK(!spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!spilled())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 485, "Check failed: %s."<br>, "!spilled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN486">486</td><td class="line">  <span class='macro'>DCHECK(!TopLevel()-&gt;HasNoSpillType())<span class='expansion'>do { if ((__builtin_expect(!!(!(!TopLevel()-&gt;HasNoSpillType<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 486, "Check failed: %s.", "!TopLevel()-&gt;HasNoSpillType()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN487">487</td><td class="line">  set_spilled(<span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">  bits_ = AssignedRegisterField::update(bits_, kUnassignedRegister);</td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">}</td></tr>
<tr><td class="num" id="LN490">490</td><td class="line"> </td></tr>
<tr><td class="num" id="LN491">491</td><td class="line"> </td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">RegisterKind LiveRange::kind() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">  <span class='keyword'>return</span> IsFloatingPoint(representation()) ? DOUBLE_REGISTERS</td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">                                           : GENERAL_REGISTERS;</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line">}</td></tr>
<tr><td class="num" id="LN496">496</td><td class="line"> </td></tr>
<tr><td class="num" id="LN497">497</td><td class="line"> </td></tr>
<tr><td class="num" id="LN498">498</td><td class="line">UsePosition* LiveRange::FirstHintPosition(<span class='keyword'>int</span>* register_index) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN499">499</td><td class="line">  <span class='keyword'>for</span> (UsePosition* pos = first_pos_; pos != <span class='keyword'>nullptr</span>; pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN500">500</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;HintRegister(register_index)) <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN503">503</td><td class="line">}</td></tr>
<tr><td class="num" id="LN504">504</td><td class="line"> </td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"> </td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">UsePosition* LiveRange::NextUsePosition(LifetimePosition start) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line">  UsePosition* use_pos = last_processed_use_;</td></tr>
<tr><td class="num" id="LN508">508</td><td class="line">  <span class='keyword'>if</span> (use_pos == <span class='keyword'>nullptr</span> || use_pos-&gt;pos() &gt; start) {</td></tr>
<tr><td class="num" id="LN509">509</td><td class="line">    use_pos = first_pos();</td></tr>
<tr><td class="num" id="LN510">510</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN511">511</td><td class="line">  <span class='keyword'>while</span> (use_pos != <span class='keyword'>nullptr</span> &amp;&amp; use_pos-&gt;pos() &lt; start) {</td></tr>
<tr><td class="num" id="LN512">512</td><td class="line">    use_pos = use_pos-&gt;next();</td></tr>
<tr><td class="num" id="LN513">513</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN514">514</td><td class="line">  last_processed_use_ = use_pos;</td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">  <span class='keyword'>return</span> use_pos;</td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">}</td></tr>
<tr><td class="num" id="LN517">517</td><td class="line"> </td></tr>
<tr><td class="num" id="LN518">518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN519">519</td><td class="line">UsePosition* LiveRange::NextUsePositionRegisterIsBeneficial(</td></tr>
<tr><td class="num" id="LN520">520</td><td class="line">    LifetimePosition start) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN521">521</td><td class="line">  UsePosition* pos = NextUsePosition(start);</td></tr>
<tr><td class="num" id="LN522">522</td><td class="line">  <span class='keyword'>while</span> (pos != <span class='keyword'>nullptr</span> &amp;&amp; !pos-&gt;RegisterIsBeneficial()) {</td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">    pos = pos-&gt;next();</td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">  <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">}</td></tr>
<tr><td class="num" id="LN527">527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN528">528</td><td class="line"> </td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">UsePosition* LiveRange::PreviousUsePositionRegisterIsBeneficial(</td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">    LifetimePosition start) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">  UsePosition* pos = first_pos();</td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">  UsePosition* prev = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">  <span class='keyword'>while</span> (pos != <span class='keyword'>nullptr</span> &amp;&amp; pos-&gt;pos() &lt; start) {</td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;RegisterIsBeneficial()) prev = pos;</td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">    pos = pos-&gt;next();</td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">  <span class='keyword'>return</span> prev;</td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">}</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line"> </td></tr>
<tr><td class="num" id="LN540">540</td><td class="line"> </td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">UsePosition* LiveRange::NextRegisterPosition(LifetimePosition start) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">  UsePosition* pos = NextUsePosition(start);</td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">  <span class='keyword'>while</span> (pos != <span class='keyword'>nullptr</span> &amp;&amp; pos-&gt;type() != UsePositionType::kRequiresRegister) {</td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">    pos = pos-&gt;next();</td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">  <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">}</td></tr>
<tr><td class="num" id="LN548">548</td><td class="line"> </td></tr>
<tr><td class="num" id="LN549">549</td><td class="line"> </td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">UsePosition* LiveRange::NextSlotPosition(LifetimePosition start) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">  <span class='keyword'>for</span> (UsePosition* pos = NextUsePosition(start); pos != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">       pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;type() != UsePositionType::kRequiresSlot) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">    <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">}</td></tr>
<tr><td class="num" id="LN558">558</td><td class="line"> </td></tr>
<tr><td class="num" id="LN559">559</td><td class="line"> </td></tr>
<tr><td class="num" id="LN560">560</td><td class="line"><span class='keyword'>bool</span> LiveRange::CanBeSpilled(LifetimePosition pos) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">  <span class='comment'>// We cannot spill a live range that has a use requiring a register</span></td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">  <span class='comment'>// at the current or the immediate next position.</span></td></tr>
<tr><td class="num" id="LN563">563</td><td class="line">  UsePosition* use_pos = NextRegisterPosition(pos);</td></tr>
<tr><td class="num" id="LN564">564</td><td class="line">  <span class='keyword'>if</span> (use_pos == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">  <span class='keyword'>return</span> use_pos-&gt;pos() &gt; pos.NextStart().End();</td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">}</td></tr>
<tr><td class="num" id="LN567">567</td><td class="line"> </td></tr>
<tr><td class="num" id="LN568">568</td><td class="line"> </td></tr>
<tr><td class="num" id="LN569">569</td><td class="line"><span class='keyword'>bool</span> LiveRange::IsTopLevel() <span class='keyword'>const</span> { <span class='keyword'>return</span> top_level_ == <span class='keyword'>this</span>; }</td></tr>
<tr><td class="num" id="LN570">570</td><td class="line"> </td></tr>
<tr><td class="num" id="LN571">571</td><td class="line"> </td></tr>
<tr><td class="num" id="LN572">572</td><td class="line">InstructionOperand LiveRange::GetAssignedOperand() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">  <span class='keyword'>if</span> (HasRegisterAssigned()) {</td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">    <span class='macro'>DCHECK(!spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!spilled())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 574, "Check failed: %s."<br>, "!spilled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">    <span class='keyword'>return</span> AllocatedOperand(LocationOperand::REGISTER, representation(),</td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">                            assigned_register());</td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN578">578</td><td class="line">  <span class='macro'>DCHECK(spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(spilled())), 0))) { V8_Fatal(<br>"../src/compiler/register-allocator.cc", 578, "Check failed: %s."<br>, "spilled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">  <span class='macro'>DCHECK(!HasRegisterAssigned())<span class='expansion'>do { if ((__builtin_expect(!!(!(!HasRegisterAssigned())), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 579, "Check failed: %s."<br>, "!HasRegisterAssigned()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">  <span class='keyword'>if</span> (TopLevel()-&gt;HasSpillOperand()) {</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">    InstructionOperand* op = TopLevel()-&gt;GetSpillOperand();</td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">    <span class='macro'>DCHECK(!op-&gt;IsUnallocated())<span class='expansion'>do { if ((__builtin_expect(!!(!(!op-&gt;IsUnallocated())), 0)<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 582, "Check failed: %s."<br>, "!op-&gt;IsUnallocated()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">    <span class='keyword'>return</span> *op;</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">  <span class='keyword'>return</span> TopLevel()-&gt;GetSpillRangeOperand();</td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">}</td></tr>
<tr><td class="num" id="LN587">587</td><td class="line"> </td></tr>
<tr><td class="num" id="LN588">588</td><td class="line"> </td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">UseInterval* LiveRange::FirstSearchIntervalForPosition(</td></tr>
<tr><td class="num" id="LN590">590</td><td class="line">    LifetimePosition position) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">  <span class='keyword'>if</span> (current_interval_ == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> first_interval_;</td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">  <span class='keyword'>if</span> (current_interval_-&gt;start() &gt; position) {</td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">    current_interval_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">    <span class='keyword'>return</span> first_interval_;</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">  <span class='keyword'>return</span> current_interval_;</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">}</td></tr>
<tr><td class="num" id="LN598">598</td><td class="line"> </td></tr>
<tr><td class="num" id="LN599">599</td><td class="line"> </td></tr>
<tr><td class="num" id="LN600">600</td><td class="line"><span class='keyword'>void</span> LiveRange::AdvanceLastProcessedMarker(</td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">    UseInterval* to_start_of, LifetimePosition but_not_past) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">  <span class='keyword'>if</span> (to_start_of == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">  <span class='keyword'>if</span> (to_start_of-&gt;start() &gt; but_not_past) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">  LifetimePosition start = current_interval_ == <span class='keyword'>nullptr</span></td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">                               ? LifetimePosition::Invalid()</td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">                               : current_interval_-&gt;start();</td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">  <span class='keyword'>if</span> (to_start_of-&gt;start() &gt; start) {</td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">    current_interval_ = to_start_of;</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line">}</td></tr>
<tr><td class="num" id="LN611">611</td><td class="line"> </td></tr>
<tr><td class="num" id="LN612">612</td><td class="line"> </td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">LiveRange* LiveRange::SplitAt(LifetimePosition position, Zone* zone) {</td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">  <span class='keyword'>int</span> new_id = TopLevel()-&gt;GetNextChildId();</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">  LiveRange* child = <span class='keyword'>new</span> (zone) LiveRange(new_id, representation(), TopLevel());</td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">  DetachAt(position, child, zone);</td></tr>
<tr><td class="num" id="LN617">617</td><td class="line"> </td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">  child-&gt;top_level_ = TopLevel();</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">  child-&gt;next_ = next_;</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">  next_ = child;</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">  <span class='keyword'>return</span> child;</td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">}</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line"> </td></tr>
<tr><td class="num" id="LN624">624</td><td class="line"> </td></tr>
<tr><td class="num" id="LN625">625</td><td class="line">UsePosition* LiveRange::DetachAt(LifetimePosition position, LiveRange* result,</td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">                                 Zone* zone) {</td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">  <span class='macro'>DCHECK(Start() &lt; position)<span class='expansion'>do { if ((__builtin_expect(!!(!(Start() &lt; position)), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 627, "Check failed: %s."<br>, "Start() &lt; position"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">  <span class='macro'>DCHECK(End() &gt; position)<span class='expansion'>do { if ((__builtin_expect(!!(!(End() &gt; position)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 628, "Check failed: %s."<br>, "End() &gt; position"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">  <span class='macro'>DCHECK(result-&gt;IsEmpty())<span class='expansion'>do { if ((__builtin_expect(!!(!(result-&gt;IsEmpty())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 629, "Check failed: %s."<br>, "result-&gt;IsEmpty()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">  <span class='comment'>// Find the last interval that ends before the position. If the</span></td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">  <span class='comment'>// position is contained in one of the intervals in the chain, we</span></td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">  <span class='comment'>// split that interval and use the first part.</span></td></tr>
<tr><td class="num" id="LN633">633</td><td class="line">  UseInterval* current = FirstSearchIntervalForPosition(position);</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line"> </td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">  <span class='comment'>// If the split position coincides with the beginning of a use interval</span></td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">  <span class='comment'>// we need to split use positons in a special way.</span></td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">  <span class='keyword'>bool</span> split_at_start = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line"> </td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">  <span class='keyword'>if</span> (current-&gt;start() == position) {</td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">    <span class='comment'>// When splitting at start we need to locate the previous use interval.</span></td></tr>
<tr><td class="num" id="LN641">641</td><td class="line">    current = first_interval_;</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN643">643</td><td class="line"> </td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">  UseInterval* after = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line">  <span class='keyword'>while</span> (current != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">    <span class='keyword'>if</span> (current-&gt;Contains(position)) {</td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">      after = current-&gt;SplitAt(position, zone);</td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">    UseInterval* next = current-&gt;next();</td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">    <span class='keyword'>if</span> (next-&gt;start() &gt;= position) {</td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">      split_at_start = (next-&gt;start() == position);</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">      after = next;</td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">      current-&gt;set_next(<span class='keyword'>nullptr</span>);</td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">    current = next;</td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line">  <span class='macro'>DCHECK(<span class='keyword'>nullptr</span> != after)<span class='expansion'>do { if ((__builtin_expect(!!(!(nullptr != after)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 659, "Check failed: %s."<br>, "nullptr != after"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN660">660</td><td class="line"> </td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">  <span class='comment'>// Partition original use intervals to the two live ranges.</span></td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">  UseInterval* before = current;</td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">  result-&gt;last_interval_ =</td></tr>
<tr><td class="num" id="LN664">664</td><td class="line">      (last_interval_ == before)</td></tr>
<tr><td class="num" id="LN665">665</td><td class="line">          ? after            <span class='comment'>// Only interval in the range after split.</span></td></tr>
<tr><td class="num" id="LN666">666</td><td class="line">          : last_interval_;  <span class='comment'>// Last interval of the original range.</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line">  result-&gt;first_interval_ = after;</td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">  last_interval_ = before;</td></tr>
<tr><td class="num" id="LN669">669</td><td class="line"> </td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">  <span class='comment'>// Find the last use position before the split and the first use</span></td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">  <span class='comment'>// position after it.</span></td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">  UsePosition* use_after =</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">      splitting_pointer_ == <span class='keyword'>nullptr</span> || splitting_pointer_-&gt;pos() &gt; position</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">          ? first_pos()</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">          : splitting_pointer_;</td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">  UsePosition* use_before = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">  <span class='keyword'>if</span> (split_at_start) {</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">    <span class='comment'>// The split position coincides with the beginning of a use interval (the</span></td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">    <span class='comment'>// end of a lifetime hole). Use at this position should be attributed to</span></td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">    <span class='comment'>// the split child because split child owns use interval covering it.</span></td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">    <span class='keyword'>while</span> (use_after != <span class='keyword'>nullptr</span> &amp;&amp; use_after-&gt;pos() &lt; position) {</td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">      use_before = use_after;</td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">      use_after = use_after-&gt;next();</td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">    <span class='keyword'>while</span> (use_after != <span class='keyword'>nullptr</span> &amp;&amp; use_after-&gt;pos() &lt;= position) {</td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">      use_before = use_after;</td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">      use_after = use_after-&gt;next();</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN691">691</td><td class="line"> </td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">  <span class='comment'>// Partition original use positions to the two live ranges.</span></td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">  <span class='keyword'>if</span> (use_before != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">    use_before-&gt;set_next(<span class='keyword'>nullptr</span>);</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">    first_pos_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">  result-&gt;first_pos_ = use_after;</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line"> </td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">  <span class='comment'>// Discard cached iteration state. It might be pointing</span></td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">  <span class='comment'>// to the use that no longer belongs to this live range.</span></td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">  last_processed_use_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN703">703</td><td class="line">  current_interval_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN704">704</td><td class="line"> </td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">  <span class='comment'>// Invalidate size and weight of this range. The child range has them</span></td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">  <span class='comment'>// invalid at construction.</span></td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">  size_ = kInvalidSize;</td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">  weight_ = kInvalidWeight;</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">  VerifyChildStructure();</td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">  result-&gt;VerifyChildStructure();</td></tr>
<tr><td class="num" id="LN712">712</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">  <span class='keyword'>return</span> use_before;</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">}</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line"> </td></tr>
<tr><td class="num" id="LN716">716</td><td class="line"> </td></tr>
<tr><td class="num" id="LN717">717</td><td class="line"><span class='keyword'>void</span> LiveRange::UpdateParentForAllChildren(TopLevelLiveRange* new_top_level) {</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">  LiveRange* child = <span class='keyword'>this</span>;</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">  <span class='keyword'>for</span> (; child != <span class='keyword'>nullptr</span>; child = child-&gt;next()) {</td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">    child-&gt;top_level_ = new_top_level;</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">}</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line"> </td></tr>
<tr><td class="num" id="LN724">724</td><td class="line"> </td></tr>
<tr><td class="num" id="LN725">725</td><td class="line"><span class='keyword'>void</span> LiveRange::ConvertUsesToOperand(<span class='keyword'>const</span> InstructionOperand&amp; op,</td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">                                     <span class='keyword'>const</span> InstructionOperand&amp; spill_op) {</td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">  <span class='keyword'>for</span> (UsePosition* pos = first_pos(); pos != <span class='keyword'>nullptr</span>; pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">    <span class='macro'>DCHECK(Start() &lt;= pos-&gt;pos() &amp;&amp; pos-&gt;pos() &lt;= End())<span class='expansion'>do { if ((__builtin_expect(!!(!(Start() &lt;= pos-&gt;pos() &amp;&amp;<br> pos-&gt;pos() &lt;= End())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 728, "Check failed: %s.", "Start() &lt;= pos-&gt;pos() &amp;&amp; pos-&gt;pos() &lt;= End()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">    <span class='keyword'>if</span> (!pos-&gt;HasOperand()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">    <span class='keyword'>switch</span> (pos-&gt;type()) {</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kRequiresSlot:</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">        <span class='macro'>DCHECK(spill_op.IsStackSlot() || spill_op.IsDoubleStackSlot())<span class='expansion'>do { if ((__builtin_expect(!!(!(spill_op.IsStackSlot() || spill_op<br>.IsDoubleStackSlot())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 732, "Check failed: %s.", "spill_op.IsStackSlot() || spill_op.IsDoubleStackSlot()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">        InstructionOperand::ReplaceWith(pos-&gt;operand(), &amp;spill_op);</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kRequiresRegister:</td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">        <span class='macro'>DCHECK(op.IsRegister() || op.IsDoubleRegister())<span class='expansion'>do { if ((__builtin_expect(!!(!(op.IsRegister() || op.IsDoubleRegister<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 736, "Check failed: %s.", "op.IsRegister() || op.IsDoubleRegister()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">      <span class='comment'>// Fall through.</span></td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kAny:</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">        InstructionOperand::ReplaceWith(pos-&gt;operand(), &amp;op);</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN741">741</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN743">743</td><td class="line">}</td></tr>
<tr><td class="num" id="LN744">744</td><td class="line"> </td></tr>
<tr><td class="num" id="LN745">745</td><td class="line"> </td></tr>
<tr><td class="num" id="LN746">746</td><td class="line"><span class='comment'>// This implements an ordering on live ranges so that they are ordered by their</span></td></tr>
<tr><td class="num" id="LN747">747</td><td class="line"><span class='comment'>// start positions.  This is needed for the correctness of the register</span></td></tr>
<tr><td class="num" id="LN748">748</td><td class="line"><span class='comment'>// allocation algorithm.  If two live ranges start at the same offset then there</span></td></tr>
<tr><td class="num" id="LN749">749</td><td class="line"><span class='comment'>// is a tie breaker based on where the value is first used.  This part of the</span></td></tr>
<tr><td class="num" id="LN750">750</td><td class="line"><span class='comment'>// ordering is merely a heuristic.</span></td></tr>
<tr><td class="num" id="LN751">751</td><td class="line"><span class='keyword'>bool</span> LiveRange::ShouldBeAllocatedBefore(<span class='keyword'>const</span> LiveRange* other) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line">  LifetimePosition start = Start();</td></tr>
<tr><td class="num" id="LN753">753</td><td class="line">  LifetimePosition other_start = other-&gt;Start();</td></tr>
<tr><td class="num" id="LN754">754</td><td class="line">  <span class='keyword'>if</span> (start == other_start) {</td></tr>
<tr><td class="num" id="LN755">755</td><td class="line">    UsePosition* pos = first_pos();</td></tr>
<tr><td class="num" id="LN756">756</td><td class="line">    <span class='keyword'>if</span> (pos == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">    UsePosition* other_pos = other-&gt;first_pos();</td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">    <span class='keyword'>if</span> (other_pos == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">    <span class='keyword'>return</span> pos-&gt;pos() &lt; other_pos-&gt;pos();</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">  <span class='keyword'>return</span> start &lt; other_start;</td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">}</td></tr>
<tr><td class="num" id="LN763">763</td><td class="line"> </td></tr>
<tr><td class="num" id="LN764">764</td><td class="line"> </td></tr>
<tr><td class="num" id="LN765">765</td><td class="line"><span class='keyword'>void</span> LiveRange::SetUseHints(<span class='keyword'>int</span> register_index) {</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line">  <span class='keyword'>for</span> (UsePosition* pos = first_pos(); pos != <span class='keyword'>nullptr</span>; pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN767">767</td><td class="line">    <span class='keyword'>if</span> (!pos-&gt;HasOperand()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN768">768</td><td class="line">    <span class='keyword'>switch</span> (pos-&gt;type()) {</td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kRequiresSlot:</td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN771">771</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kRequiresRegister:</td></tr>
<tr><td class="num" id="LN772">772</td><td class="line">      <span class='keyword'>case</span> UsePositionType::kAny:</td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">        pos-&gt;set_assigned_register(register_index);</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN775">775</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN776">776</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN777">777</td><td class="line">}</td></tr>
<tr><td class="num" id="LN778">778</td><td class="line"> </td></tr>
<tr><td class="num" id="LN779">779</td><td class="line"> </td></tr>
<tr><td class="num" id="LN780">780</td><td class="line"><span class='keyword'>bool</span> LiveRange::CanCover(LifetimePosition position) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN781">781</td><td class="line">  <span class='keyword'>if</span> (IsEmpty()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">  <span class='keyword'>return</span> Start() &lt;= position &amp;&amp; position &lt; End();</td></tr>
<tr><td class="num" id="LN783">783</td><td class="line">}</td></tr>
<tr><td class="num" id="LN784">784</td><td class="line"> </td></tr>
<tr><td class="num" id="LN785">785</td><td class="line"> </td></tr>
<tr><td class="num" id="LN786">786</td><td class="line"><span class='keyword'>bool</span> LiveRange::Covers(LifetimePosition position) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN787">787</td><td class="line">  <span class='keyword'>if</span> (!CanCover(position)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN788">788</td><td class="line">  UseInterval* start_search = FirstSearchIntervalForPosition(position);</td></tr>
<tr><td class="num" id="LN789">789</td><td class="line">  <span class='keyword'>for</span> (UseInterval* interval = start_search; interval != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN790">790</td><td class="line">       interval = interval-&gt;next()) {</td></tr>
<tr><td class="num" id="LN791">791</td><td class="line">    <span class='macro'>DCHECK(interval-&gt;next() == <span class='keyword'>nullptr</span> ||<span class='expansion'>do { if ((__builtin_expect(!!(!(interval-&gt;next() == nullptr<br> || interval-&gt;next()-&gt;start() &gt;= interval-&gt;start(<br>))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc",<br> 792, "Check failed: %s.", "interval-&gt;next() == nullptr || interval-&gt;next()-&gt;start() &gt;= interval-&gt;start()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">           <span class='macro'>interval-&gt;next()-&gt;start() &gt;= interval-&gt;start())<span class='expansion'>do { if ((__builtin_expect(!!(!(interval-&gt;next() == nullptr<br> || interval-&gt;next()-&gt;start() &gt;= interval-&gt;start(<br>))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc",<br> 792, "Check failed: %s.", "interval-&gt;next() == nullptr || interval-&gt;next()-&gt;start() &gt;= interval-&gt;start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">    AdvanceLastProcessedMarker(interval, position);</td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">    <span class='keyword'>if</span> (interval-&gt;Contains(position)) <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">    <span class='keyword'>if</span> (interval-&gt;start() &gt; position) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">}</td></tr>
<tr><td class="num" id="LN799">799</td><td class="line"> </td></tr>
<tr><td class="num" id="LN800">800</td><td class="line"> </td></tr>
<tr><td class="num" id="LN801">801</td><td class="line">LifetimePosition LiveRange::FirstIntersection(LiveRange* other) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN802">802</td><td class="line">  UseInterval* b = other-&gt;first_interval();</td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">  <span class='keyword'>if</span> (b == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> LifetimePosition::Invalid();</td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">  LifetimePosition advance_last_processed_up_to = b-&gt;start();</td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">  UseInterval* a = FirstSearchIntervalForPosition(b-&gt;start());</td></tr>
<tr><td class="num" id="LN806">806</td><td class="line">  <span class='keyword'>while</span> (a != <span class='keyword'>nullptr</span> &amp;&amp; b != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN807">807</td><td class="line">    <span class='keyword'>if</span> (a-&gt;start() &gt; other-&gt;End()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">    <span class='keyword'>if</span> (b-&gt;start() &gt; End()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">    LifetimePosition cur_intersection = a-&gt;Intersect(b);</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">    <span class='keyword'>if</span> (cur_intersection.IsValid()) {</td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">      <span class='keyword'>return</span> cur_intersection;</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">    <span class='keyword'>if</span> (a-&gt;start() &lt; b-&gt;start()) {</td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">      a = a-&gt;next();</td></tr>
<tr><td class="num" id="LN815">815</td><td class="line">      <span class='keyword'>if</span> (a == <span class='keyword'>nullptr</span> || a-&gt;start() &gt; other-&gt;End()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN816">816</td><td class="line">      AdvanceLastProcessedMarker(a, advance_last_processed_up_to);</td></tr>
<tr><td class="num" id="LN817">817</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN818">818</td><td class="line">      b = b-&gt;next();</td></tr>
<tr><td class="num" id="LN819">819</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN820">820</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">  <span class='keyword'>return</span> LifetimePosition::Invalid();</td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">}</td></tr>
<tr><td class="num" id="LN823">823</td><td class="line"> </td></tr>
<tr><td class="num" id="LN824">824</td><td class="line"> </td></tr>
<tr><td class="num" id="LN825">825</td><td class="line"><span class='keyword'>unsigned</span> LiveRange::GetSize() {</td></tr>
<tr><td class="num" id="LN826">826</td><td class="line">  <span class='keyword'>if</span> (size_ == kInvalidSize) {</td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">    size_ = 0;</td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> UseInterval* interval = first_interval(); interval != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">         interval = interval-&gt;next()) {</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">      size_ += (interval-&gt;end().value() - interval-&gt;start().value());</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN833">833</td><td class="line"> </td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;<span class='keyword'>unsigned</span>&gt;(size_);</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">}</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line"> </td></tr>
<tr><td class="num" id="LN837">837</td><td class="line"> </td></tr>
<tr><td class="num" id="LN838">838</td><td class="line"><span class='keyword'>void</span> LiveRange::Print(<span class='keyword'>const</span> RegisterConfiguration* config,</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">                      <span class='keyword'>bool</span> with_children) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">  OFStream os(<span class='macro'>stdout<span class='expansion'>stdout</span></span>);</td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">  PrintableLiveRange wrapper;</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">  wrapper.register_configuration_ = config;</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> LiveRange* i = <span class='keyword'>this</span>; i != <span class='keyword'>nullptr</span>; i = i-&gt;next()) {</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">    wrapper.range_ = i;</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">    os &lt;&lt; wrapper &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">    <span class='keyword'>if</span> (!with_children) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">}</td></tr>
<tr><td class="num" id="LN849">849</td><td class="line"> </td></tr>
<tr><td class="num" id="LN850">850</td><td class="line"> </td></tr>
<tr><td class="num" id="LN851">851</td><td class="line"><span class='keyword'>void</span> LiveRange::Print(<span class='keyword'>bool</span> with_children) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">  <span class='keyword'>const</span> RegisterConfiguration* config =</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">      RegisterConfiguration::ArchDefault(RegisterConfiguration::TURBOFAN);</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">  Print(config, with_children);</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">}</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line"> </td></tr>
<tr><td class="num" id="LN857">857</td><td class="line"> </td></tr>
<tr><td class="num" id="LN858">858</td><td class="line"><span class='keyword'>struct</span> TopLevelLiveRange::SpillMoveInsertionList : ZoneObject {</td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">  SpillMoveInsertionList(<span class='keyword'>int</span> gap_index, InstructionOperand* operand,</td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">                         SpillMoveInsertionList* next)</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">      : gap_index(gap_index), operand(operand), next(next) {}</td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> gap_index;</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">  InstructionOperand* <span class='keyword'>const</span> operand;</td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">  SpillMoveInsertionList* <span class='keyword'>const</span> next;</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">};</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line"> </td></tr>
<tr><td class="num" id="LN867">867</td><td class="line"> </td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">TopLevelLiveRange::TopLevelLiveRange(<span class='keyword'>int</span> vreg, MachineRepresentation rep)</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">    : LiveRange(0, rep, <span class='keyword'>this</span>),</td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">      vreg_(vreg),</td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">      last_child_id_(0),</td></tr>
<tr><td class="num" id="LN872">872</td><td class="line">      splintered_from_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">      spill_operand_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">      spill_move_insertion_locations_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">      spilled_in_deferred_blocks_(<span class='keyword'>false</span>),</td></tr>
<tr><td class="num" id="LN876">876</td><td class="line">      spill_start_index_(kMaxInt),</td></tr>
<tr><td class="num" id="LN877">877</td><td class="line">      last_pos_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN878">878</td><td class="line">      splinter_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN879">879</td><td class="line">      has_preassigned_slot_(<span class='keyword'>false</span>) {</td></tr>
<tr><td class="num" id="LN880">880</td><td class="line">  bits_ |= SpillTypeField::encode(SpillType::kNoSpillType);</td></tr>
<tr><td class="num" id="LN881">881</td><td class="line">}</td></tr>
<tr><td class="num" id="LN882">882</td><td class="line"> </td></tr>
<tr><td class="num" id="LN883">883</td><td class="line"> </td></tr>
<tr><td class="num" id="LN884">884</td><td class="line"><span class='directive'>#if <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN885">885</td><td class="line"><span class='keyword'>int</span> TopLevelLiveRange::debug_virt_reg() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN886">886</td><td class="line">  <span class='keyword'>return</span> IsSplinter() ? splintered_from()-&gt;vreg() : vreg();</td></tr>
<tr><td class="num" id="LN887">887</td><td class="line">}</td></tr>
<tr><td class="num" id="LN888">888</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN889">889</td><td class="line"> </td></tr>
<tr><td class="num" id="LN890">890</td><td class="line"> </td></tr>
<tr><td class="num" id="LN891">891</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::RecordSpillLocation(Zone* zone, <span class='keyword'>int</span> gap_index,</td></tr>
<tr><td class="num" id="LN892">892</td><td class="line">                                            InstructionOperand* operand) {</td></tr>
<tr><td class="num" id="LN893">893</td><td class="line">  <span class='macro'>DCHECK(HasNoSpillType())<span class='expansion'>do { if ((__builtin_expect(!!(!(HasNoSpillType())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 893, "Check failed: %s."<br>, "HasNoSpillType()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN894">894</td><td class="line">  spill_move_insertion_locations_ = <span class='keyword'>new</span> (zone) SpillMoveInsertionList(</td></tr>
<tr><td class="num" id="LN895">895</td><td class="line">      gap_index, operand, spill_move_insertion_locations_);</td></tr>
<tr><td class="num" id="LN896">896</td><td class="line">}</td></tr>
<tr><td class="num" id="LN897">897</td><td class="line"> </td></tr>
<tr><td class="num" id="LN898">898</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::CommitSpillMoves(InstructionSequence* sequence,</td></tr>
<tr><td class="num" id="LN899">899</td><td class="line">                                         <span class='keyword'>const</span> InstructionOperand&amp; op,</td></tr>
<tr><td class="num" id="LN900">900</td><td class="line">                                         <span class='keyword'>bool</span> might_be_duplicated) {</td></tr>
<tr><td class="num" id="LN901">901</td><td class="line">  <span class='macro'>DCHECK_IMPLIES(op.IsConstant(), GetSpillMoveInsertionLocations() == <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(!(op.IsConstant()) || (GetSpillMoveInsertionLocations<br>() == nullptr))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 901, "Check failed: %s.", "!(op.IsConstant()) || (GetSpillMoveInsertionLocations() == nullptr)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN902">902</td><td class="line">  Zone* zone = sequence-&gt;zone();</td></tr>
<tr><td class="num" id="LN903">903</td><td class="line"> </td></tr>
<tr><td class="num" id="LN904">904</td><td class="line">  <span class='keyword'>for</span> (SpillMoveInsertionList* to_spill = GetSpillMoveInsertionLocations();</td></tr>
<tr><td class="num" id="LN905">905</td><td class="line">       to_spill != <span class='keyword'>nullptr</span>; to_spill = to_spill-&gt;next) {</td></tr>
<tr><td class="num" id="LN906">906</td><td class="line">    Instruction* instr = sequence-&gt;InstructionAt(to_spill-&gt;gap_index);</td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">    ParallelMove* move =</td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">        instr-&gt;GetOrCreateParallelMove(Instruction::START, zone);</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">    <span class='comment'>// Skip insertion if it's possible that the move exists already as a</span></td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">    <span class='comment'>// constraint move from a fixed output register to a slot.</span></td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">    <span class='keyword'>if</span> (might_be_duplicated || has_preassigned_slot()) {</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line">      <span class='keyword'>bool</span> found = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN913">913</td><td class="line">      <span class='keyword'>for</span> (MoveOperands* move_op : *move) {</td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">        <span class='keyword'>if</span> (move_op-&gt;IsEliminated()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">        <span class='keyword'>if</span> (move_op-&gt;source().Equals(*to_spill-&gt;operand) &amp;&amp;</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line">            move_op-&gt;destination().Equals(op)) {</td></tr>
<tr><td class="num" id="LN917">917</td><td class="line">          found = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN918">918</td><td class="line">          <span class='keyword'>if</span> (has_preassigned_slot()) move_op-&gt;Eliminate();</td></tr>
<tr><td class="num" id="LN919">919</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN922">922</td><td class="line">      <span class='keyword'>if</span> (found) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN923">923</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN924">924</td><td class="line">    <span class='keyword'>if</span> (!has_preassigned_slot()) {</td></tr>
<tr><td class="num" id="LN925">925</td><td class="line">      move-&gt;AddMove(*to_spill-&gt;operand, op);</td></tr>
<tr><td class="num" id="LN926">926</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">}</td></tr>
<tr><td class="num" id="LN929">929</td><td class="line"> </td></tr>
<tr><td class="num" id="LN930">930</td><td class="line"> </td></tr>
<tr><td class="num" id="LN931">931</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::SetSpillOperand(InstructionOperand* operand) {</td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">  <span class='macro'>DCHECK(HasNoSpillType())<span class='expansion'>do { if ((__builtin_expect(!!(!(HasNoSpillType())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 932, "Check failed: %s."<br>, "HasNoSpillType()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN933">933</td><td class="line">  <span class='macro'>DCHECK(!operand-&gt;IsUnallocated() &amp;&amp; !operand-&gt;IsImmediate())<span class='expansion'>do { if ((__builtin_expect(!!(!(!operand-&gt;IsUnallocated() &amp;&amp;<br> !operand-&gt;IsImmediate())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 933, "Check failed: %s.", "!operand-&gt;IsUnallocated() &amp;&amp; !operand-&gt;IsImmediate()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN934">934</td><td class="line">  set_spill_type(SpillType::kSpillOperand);</td></tr>
<tr><td class="num" id="LN935">935</td><td class="line">  spill_operand_ = operand;</td></tr>
<tr><td class="num" id="LN936">936</td><td class="line">}</td></tr>
<tr><td class="num" id="LN937">937</td><td class="line"> </td></tr>
<tr><td class="num" id="LN938">938</td><td class="line"> </td></tr>
<tr><td class="num" id="LN939">939</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::SetSpillRange(SpillRange* spill_range) {</td></tr>
<tr><td class="num" id="LN940">940</td><td class="line">  <span class='macro'>DCHECK(!HasSpillOperand())<span class='expansion'>do { if ((__builtin_expect(!!(!(!HasSpillOperand())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 940, "Check failed: %s."<br>, "!HasSpillOperand()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN941">941</td><td class="line">  <span class='macro'>DCHECK(spill_range)<span class='expansion'>do { if ((__builtin_expect(!!(!(spill_range)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 941, "Check failed: %s."<br>, "spill_range"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN942">942</td><td class="line">  spill_range_ = spill_range;</td></tr>
<tr><td class="num" id="LN943">943</td><td class="line">}</td></tr>
<tr><td class="num" id="LN944">944</td><td class="line"> </td></tr>
<tr><td class="num" id="LN945">945</td><td class="line"> </td></tr>
<tr><td class="num" id="LN946">946</td><td class="line">AllocatedOperand TopLevelLiveRange::GetSpillRangeOperand() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN947">947</td><td class="line">  SpillRange* spill_range = GetSpillRange();</td></tr>
<tr><td class="num" id="LN948">948</td><td class="line">  <span class='keyword'>int</span> index = spill_range-&gt;assigned_slot();</td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">  <span class='keyword'>return</span> AllocatedOperand(LocationOperand::STACK_SLOT, representation(), index);</td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">}</td></tr>
<tr><td class="num" id="LN951">951</td><td class="line"> </td></tr>
<tr><td class="num" id="LN952">952</td><td class="line"> </td></tr>
<tr><td class="num" id="LN953">953</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::Splinter(LifetimePosition start, LifetimePosition end,</td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">                                 Zone* zone) {</td></tr>
<tr><td class="num" id="LN955">955</td><td class="line">  <span class='macro'>DCHECK(start != Start() || end != End())<span class='expansion'>do { if ((__builtin_expect(!!(!(start != Start() || end != End<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 955, "Check failed: %s.", "start != Start() || end != End()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN956">956</td><td class="line">  <span class='macro'>DCHECK(start &lt; end)<span class='expansion'>do { if ((__builtin_expect(!!(!(start &lt; end)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 956, "Check failed: %s."<br>, "start &lt; end"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN957">957</td><td class="line"> </td></tr>
<tr><td class="num" id="LN958">958</td><td class="line">  TopLevelLiveRange splinter_temp(-1, representation());</td></tr>
<tr><td class="num" id="LN959">959</td><td class="line">  UsePosition* last_in_splinter = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN960">960</td><td class="line">  <span class='comment'>// Live ranges defined in deferred blocks stay in deferred blocks, so we</span></td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">  <span class='comment'>// don't need to splinter them. That means that start should always be</span></td></tr>
<tr><td class="num" id="LN962">962</td><td class="line">  <span class='comment'>// after the beginning of the range.</span></td></tr>
<tr><td class="num" id="LN963">963</td><td class="line">  <span class='macro'>DCHECK(start &gt; Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(start &gt; Start())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 963, "Check failed: %s."<br>, "start &gt; Start()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN964">964</td><td class="line"> </td></tr>
<tr><td class="num" id="LN965">965</td><td class="line">  <span class='keyword'>if</span> (end &gt;= End()) {</td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">    <span class='macro'>DCHECK(start &gt; Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(start &gt; Start())), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 966, "Check failed: %s."<br>, "start &gt; Start()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">    DetachAt(start, &amp;splinter_temp, zone);</td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">    next_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">    <span class='macro'>DCHECK(start &lt; End() &amp;&amp; Start() &lt; end)<span class='expansion'>do { if ((__builtin_expect(!!(!(start &lt; End() &amp;&amp; Start<br>() &lt; end)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 970, "Check failed: %s.", "start &lt; End() &amp;&amp; Start() &lt; end"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN971">971</td><td class="line"> </td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>int</span> kInvalidId = std::numeric_limits&lt;<span class='keyword'>int</span>&gt;::max();</td></tr>
<tr><td class="num" id="LN973">973</td><td class="line"> </td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">    UsePosition* last = DetachAt(start, &amp;splinter_temp, zone);</td></tr>
<tr><td class="num" id="LN975">975</td><td class="line"> </td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">    LiveRange end_part(kInvalidId, <span class='keyword'>this</span>-&gt;representation(), <span class='keyword'>nullptr</span>);</td></tr>
<tr><td class="num" id="LN977">977</td><td class="line">    last_in_splinter = splinter_temp.DetachAt(end, &amp;end_part, zone);</td></tr>
<tr><td class="num" id="LN978">978</td><td class="line"> </td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">    next_ = end_part.next_;</td></tr>
<tr><td class="num" id="LN980">980</td><td class="line">    last_interval_-&gt;set_next(end_part.first_interval_);</td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">    <span class='comment'>// The next splinter will happen either at or after the current interval.</span></td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">    <span class='comment'>// We can optimize DetachAt by setting current_interval_ accordingly,</span></td></tr>
<tr><td class="num" id="LN983">983</td><td class="line">    <span class='comment'>// which will then be picked up by FirstSearchIntervalForPosition.</span></td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">    current_interval_ = last_interval_;</td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">    last_interval_ = end_part.last_interval_;</td></tr>
<tr><td class="num" id="LN986">986</td><td class="line"> </td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">    <span class='keyword'>if</span> (first_pos_ == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN988">988</td><td class="line">      first_pos_ = end_part.first_pos_;</td></tr>
<tr><td class="num" id="LN989">989</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN990">990</td><td class="line">      splitting_pointer_ = last;</td></tr>
<tr><td class="num" id="LN991">991</td><td class="line">      <span class='keyword'>if</span> (last != <span class='keyword'>nullptr</span>) last-&gt;set_next(end_part.first_pos_);</td></tr>
<tr><td class="num" id="LN992">992</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN993">993</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN994">994</td><td class="line"> </td></tr>
<tr><td class="num" id="LN995">995</td><td class="line">  <span class='keyword'>if</span> (splinter()-&gt;IsEmpty()) {</td></tr>
<tr><td class="num" id="LN996">996</td><td class="line">    splinter()-&gt;first_interval_ = splinter_temp.first_interval_;</td></tr>
<tr><td class="num" id="LN997">997</td><td class="line">    splinter()-&gt;last_interval_ = splinter_temp.last_interval_;</td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN999">999</td><td class="line">    splinter()-&gt;last_interval_-&gt;set_next(splinter_temp.first_interval_);</td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line">    splinter()-&gt;last_interval_ = splinter_temp.last_interval_;</td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line">  <span class='keyword'>if</span> (splinter()-&gt;first_pos() == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line">    splinter()-&gt;first_pos_ = splinter_temp.first_pos_;</td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line">    splinter()-&gt;last_pos_-&gt;set_next(splinter_temp.first_pos_);</td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line">  <span class='keyword'>if</span> (last_in_splinter != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line">    splinter()-&gt;last_pos_ = last_in_splinter;</td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line">    <span class='keyword'>if</span> (splinter()-&gt;first_pos() != <span class='keyword'>nullptr</span> &amp;&amp;</td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line">        splinter()-&gt;last_pos_ == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line">      splinter()-&gt;last_pos_ = splinter()-&gt;first_pos();</td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">      <span class='keyword'>for</span> (UsePosition* pos = splinter()-&gt;first_pos(); pos != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">           pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">        splinter()-&gt;last_pos_ = pos;</td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line"><span class='directive'>#if <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">  Verify();</td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">  splinter()-&gt;Verify();</td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::SetSplinteredFrom(TopLevelLiveRange* splinter_parent) {</td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line">  splintered_from_ = splinter_parent;</td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line">  <span class='keyword'>if</span> (!HasSpillOperand() &amp;&amp; splinter_parent-&gt;spill_range_ != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line">    SetSpillRange(splinter_parent-&gt;spill_range_);</td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::UpdateSpillRangePostMerge(TopLevelLiveRange* merged) {</td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line">  <span class='macro'>DCHECK(merged-&gt;TopLevel() == <span class='keyword'>this</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(merged-&gt;TopLevel() == this<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1035<br>, "Check failed: %s.", "merged-&gt;TopLevel() == this"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">  <span class='keyword'>if</span> (HasNoSpillType() &amp;&amp; merged-&gt;HasSpillRange()) {</td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">    set_spill_type(merged-&gt;spill_type());</td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line">    <span class='macro'>DCHECK(GetSpillRange()-&gt;live_ranges().size() &gt; 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(GetSpillRange()-&gt;live_ranges<br>().size() &gt; 0)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1039, "Check failed: %s.", "GetSpillRange()-&gt;live_ranges().size() &gt; 0"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line">    merged-&gt;spill_range_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line">    merged-&gt;bits_ =</td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line">        SpillTypeField::update(merged-&gt;bits_, SpillType::kNoSpillType);</td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::Merge(TopLevelLiveRange* other, Zone* zone) {</td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line">  <span class='macro'>DCHECK(Start() &lt; other-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(Start() &lt; other-&gt;Start(<br>))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc",<br> 1048, "Check failed: %s.", "Start() &lt; other-&gt;Start()")<br>; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line">  <span class='macro'>DCHECK(other-&gt;splintered_from() == <span class='keyword'>this</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(other-&gt;splintered_from() ==<br> this)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1049, "Check failed: %s.", "other-&gt;splintered_from() == this"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line">  LiveRange* first = <span class='keyword'>this</span>;</td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line">  LiveRange* second = other;</td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line">  <span class='macro'>DCHECK(first-&gt;Start() &lt; second-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(first-&gt;Start() &lt; second<br>-&gt;Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1053, "Check failed: %s.", "first-&gt;Start() &lt; second-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line">  <span class='keyword'>while</span> (first != <span class='keyword'>nullptr</span> &amp;&amp; second != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line">    <span class='macro'>DCHECK(first != second)<span class='expansion'>do { if ((__builtin_expect(!!(!(first != second)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 1055, "Check failed: %s."<br>, "first != second"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line">    <span class='comment'>// Make sure the ranges are in order each time we iterate.</span></td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line">    <span class='keyword'>if</span> (second-&gt;Start() &lt; first-&gt;Start()) {</td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line">      LiveRange* tmp = second;</td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line">      second = first;</td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line">      first = tmp;</td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line">    <span class='keyword'>if</span> (first-&gt;End() &lt;= second-&gt;Start()) {</td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line">      <span class='keyword'>if</span> (first-&gt;next() == <span class='keyword'>nullptr</span> ||</td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line">          first-&gt;next()-&gt;Start() &gt; second-&gt;Start()) {</td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line">        <span class='comment'>// First is in order before second.</span></td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line">        LiveRange* temp = first-&gt;next();</td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line">        first-&gt;next_ = second;</td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line">        first = temp;</td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line">        <span class='comment'>// First is in order before its successor (or second), so advance first.</span></td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line">        first = first-&gt;next();</td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line">    <span class='macro'>DCHECK(first-&gt;Start() &lt; second-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(first-&gt;Start() &lt; second<br>-&gt;Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1078, "Check failed: %s.", "first-&gt;Start() &lt; second-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line">    <span class='comment'>// If first and second intersect, split first.</span></td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">    <span class='keyword'>if</span> (first-&gt;Start() &lt; second-&gt;End() &amp;&amp; second-&gt;Start() &lt; first-&gt;End()) {</td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line">      LiveRange* temp = first-&gt;SplitAt(second-&gt;Start(), zone);</td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">      <span class='macro'>CHECK(temp != first)<span class='expansion'>do { if ((__builtin_expect(!!(!(temp != first)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 1082, "Check failed: %s."<br>, "temp != first"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line">      temp-&gt;set_spilled(first-&gt;spilled());</td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">      <span class='keyword'>if</span> (!temp-&gt;spilled())</td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">        temp-&gt;set_assigned_register(first-&gt;assigned_register());</td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">      first-&gt;next_ = second;</td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line">      first = temp;</td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">    <span class='macro'>DCHECK(first-&gt;End() &lt;= second-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(first-&gt;End() &lt;= second-&gt;<br>Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1091, "Check failed: %s.", "first-&gt;End() &lt;= second-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line">  TopLevel()-&gt;UpdateParentForAllChildren(TopLevel());</td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line">  TopLevel()-&gt;UpdateSpillRangePostMerge(other);</td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line"><span class='directive'>#if <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line">  Verify();</td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::VerifyChildrenInOrder() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">  LifetimePosition last_end = End();</td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> LiveRange* child = <span class='keyword'>this</span>-&gt;next(); child != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line">       child = child-&gt;next()) {</td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line">    <span class='macro'>DCHECK(last_end &lt;= child-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(last_end &lt;= child-&gt;Start<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1107, "Check failed: %s.", "last_end &lt;= child-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line">    last_end = child-&gt;End();</td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::Verify() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line">  VerifyChildrenInOrder();</td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> LiveRange* child = <span class='keyword'>this</span>; child != <span class='keyword'>nullptr</span>; child = child-&gt;next()) {</td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line">    VerifyChildStructure();</td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::ShortenTo(LifetimePosition start) {</td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Shorten live range %d to [%d\n"</span>, vreg(), start.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Shorten live range %d to [%d\n"<br>, vreg(), start.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line">  <span class='macro'>DCHECK(first_interval_ != <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(first_interval_ != nullptr)),<br> 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1123<br>, "Check failed: %s.", "first_interval_ != nullptr"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line">  <span class='macro'>DCHECK(first_interval_-&gt;start() &lt;= start)<span class='expansion'>do { if ((__builtin_expect(!!(!(first_interval_-&gt;start() &lt;=<br> start)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1124, "Check failed: %s.", "first_interval_-&gt;start() &lt;= start"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line">  <span class='macro'>DCHECK(start &lt; first_interval_-&gt;end())<span class='expansion'>do { if ((__builtin_expect(!!(!(start &lt; first_interval_-&gt;<br>end())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1125, "Check failed: %s.", "start &lt; first_interval_-&gt;end()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line">  first_interval_-&gt;set_start(start);</td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::EnsureInterval(LifetimePosition start,</td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line">                                       LifetimePosition end, Zone* zone) {</td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Ensure live range %d in interval [%d %d[\n"</span>, vreg(), start.value(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Ensure live range %d in interval [%d %d[\n"<br>, vreg(), start.value(), end.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">        <span class='macro'>end.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Ensure live range %d in interval [%d %d[\n"<br>, vreg(), start.value(), end.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line">  LifetimePosition new_end = end;</td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line">  <span class='keyword'>while</span> (first_interval_ != <span class='keyword'>nullptr</span> &amp;&amp; first_interval_-&gt;start() &lt;= end) {</td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">    <span class='keyword'>if</span> (first_interval_-&gt;end() &gt; end) {</td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">      new_end = first_interval_-&gt;end();</td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line">    first_interval_ = first_interval_-&gt;next();</td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line">  UseInterval* new_interval = <span class='keyword'>new</span> (zone) UseInterval(start, new_end);</td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line">  new_interval-&gt;set_next(first_interval_);</td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line">  first_interval_ = new_interval;</td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">  <span class='keyword'>if</span> (new_interval-&gt;next() == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">    last_interval_ = new_interval;</td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::AddUseInterval(LifetimePosition start,</td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line">                                       LifetimePosition end, Zone* zone) {</td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add to live range %d interval [%d %d[\n"</span>, vreg(), start.value(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add to live range %d interval [%d %d[\n"<br>, vreg(), start.value(), end.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line">        <span class='macro'>end.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add to live range %d interval [%d %d[\n"<br>, vreg(), start.value(), end.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">  <span class='keyword'>if</span> (first_interval_ == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line">    UseInterval* interval = <span class='keyword'>new</span> (zone) UseInterval(start, end);</td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">    first_interval_ = interval;</td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line">    last_interval_ = interval;</td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line">    <span class='keyword'>if</span> (end == first_interval_-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line">      first_interval_-&gt;set_start(start);</td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (end &lt; first_interval_-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line">      UseInterval* interval = <span class='keyword'>new</span> (zone) UseInterval(start, end);</td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line">      interval-&gt;set_next(first_interval_);</td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line">      first_interval_ = interval;</td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line">      <span class='comment'>// Order of instruction's processing (see ProcessInstructions) guarantees</span></td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line">      <span class='comment'>// that each new use interval either precedes or intersects with</span></td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line">      <span class='comment'>// last added interval.</span></td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line">      <span class='macro'>DCHECK(start &lt; first_interval_-&gt;end())<span class='expansion'>do { if ((__builtin_expect(!!(!(start &lt; first_interval_-&gt;<br>end())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1170, "Check failed: %s.", "start &lt; first_interval_-&gt;end()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line">      first_interval_-&gt;set_start(Min(start, first_interval_-&gt;start()));</td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">      first_interval_-&gt;set_end(Max(end, first_interval_-&gt;end()));</td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line"><span class='keyword'>void</span> TopLevelLiveRange::AddUsePosition(UsePosition* use_pos) {</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">  LifetimePosition pos = use_pos-&gt;pos();</td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add to live range %d use position %d\n"</span>, vreg(), pos.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add to live range %d use position %d\n"<br>, vreg(), pos.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line">  UsePosition* prev_hint = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line">  UsePosition* prev = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line">  UsePosition* current = first_pos_;</td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line">  <span class='keyword'>while</span> (current != <span class='keyword'>nullptr</span> &amp;&amp; current-&gt;pos() &lt; pos) {</td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line">    prev_hint = current-&gt;HasHint() ? current : prev_hint;</td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line">    prev = current;</td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line">    current = current-&gt;next();</td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line">  <span class='keyword'>if</span> (prev == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line">    use_pos-&gt;set_next(first_pos_);</td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line">    first_pos_ = use_pos;</td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line">    use_pos-&gt;set_next(prev-&gt;next());</td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line">    prev-&gt;set_next(use_pos);</td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line">  <span class='keyword'>if</span> (prev_hint == <span class='keyword'>nullptr</span> &amp;&amp; use_pos-&gt;HasHint()) {</td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line">    current_hint_position_ = use_pos;</td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>bool</span> AreUseIntervalsIntersecting(UseInterval* interval1,</td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line">                                        UseInterval* interval2) {</td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line">  <span class='keyword'>while</span> (interval1 != <span class='keyword'>nullptr</span> &amp;&amp; interval2 != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line">    <span class='keyword'>if</span> (interval1-&gt;start() &lt; interval2-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line">      <span class='keyword'>if</span> (interval1-&gt;end() &gt; interval2-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line">        <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line">      interval1 = interval1-&gt;next();</td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line">      <span class='keyword'>if</span> (interval2-&gt;end() &gt; interval1-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line">        <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">      interval2 = interval2-&gt;next();</td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line">std::ostream&amp; <span class='keyword'>operator</span>&lt;&lt;(std::ostream&amp; os,</td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line">                         <span class='keyword'>const</span> PrintableLiveRange&amp; printable_range) {</td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line">  <span class='keyword'>const</span> LiveRange* range = printable_range.range_;</td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line">  os &lt;&lt; <span class='string_literal'>"Range: "</span> &lt;&lt; range-&gt;TopLevel()-&gt;vreg() &lt;&lt; <span class='string_literal'>":"</span> &lt;&lt; range-&gt;relative_id()</td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line">     &lt;&lt; <span class='string_literal'>" "</span>;</td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line">  <span class='keyword'>if</span> (range-&gt;TopLevel()-&gt;is_phi()) os &lt;&lt; <span class='string_literal'>"phi "</span>;</td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line">  <span class='keyword'>if</span> (range-&gt;TopLevel()-&gt;is_non_loop_phi()) os &lt;&lt; <span class='string_literal'>"nlphi "</span>;</td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">  os &lt;&lt; <span class='string_literal'>"{"</span> &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line">  UseInterval* interval = range-&gt;first_interval();</td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line">  UsePosition* use_pos = range-&gt;first_pos();</td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line">  PrintableInstructionOperand pio;</td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line">  pio.register_configuration_ = printable_range.register_configuration_;</td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">  <span class='keyword'>while</span> (use_pos != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">    <span class='keyword'>if</span> (use_pos-&gt;HasOperand()) {</td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line">      pio.op_ = *use_pos-&gt;operand();</td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line">      os &lt;&lt; pio &lt;&lt; use_pos-&gt;pos() &lt;&lt; <span class='string_literal'>" "</span>;</td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line">    use_pos = use_pos-&gt;next();</td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line">  os &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">  <span class='keyword'>while</span> (interval != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line">    os &lt;&lt; '[' &lt;&lt; interval-&gt;start() &lt;&lt; <span class='string_literal'>", "</span> &lt;&lt; interval-&gt;end() &lt;&lt; ')'</td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line">       &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">    interval = interval-&gt;next();</td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line">  os &lt;&lt; <span class='string_literal'>"}"</span>;</td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line">  <span class='keyword'>return</span> os;</td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line">SpillRange::SpillRange(TopLevelLiveRange* parent, Zone* zone)</td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line">    : live_ranges_(zone),</td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line">      assigned_slot_(kUnassignedSlot),</td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line">      byte_width_(GetByteWidth(parent-&gt;representation())),</td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line">      kind_(parent-&gt;kind()) {</td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line">  <span class='comment'>// Spill ranges are created for top level, non-splintered ranges. This is so</span></td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line">  <span class='comment'>// that, when merging decisions are made, we consider the full extent of the</span></td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line">  <span class='comment'>// virtual register, and avoid clobbering it.</span></td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line">  <span class='macro'>DCHECK(!parent-&gt;IsSplinter())<span class='expansion'>do { if ((__builtin_expect(!!(!(!parent-&gt;IsSplinter())), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 1263,<br> "Check failed: %s.", "!parent-&gt;IsSplinter()"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line">  UseInterval* result = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line">  <span class="mrange">UseInterval* node</span> = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path1" class="msg msgEvent" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">1</div></td><td>'node' initialized to a null pointer value</td><td><div class="PathNav"><a href="#Path2" title="Next event (2)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line">  <span class='comment'>// Copy the intervals for all ranges.</span></td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line">  <span class='keyword'>for</span> (LiveRange* range = parent; range != <span class='keyword'>nullptr</span>; range = range-&gt;next()) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path2" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">2</div></td><td><div class="PathNav"><a href="#Path1" title="Previous event (1)">&#x2190;</a></div></td></td><td>Loop condition is true.  Entering loop body</td><td><div class="PathNav"><a href="#Path3" title="Next event (3)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num"></td><td class="line"><div id="Path4" class="msg msgControl" style="margin-left:3ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">4</div></td><td><div class="PathNav"><a href="#Path3" title="Previous event (3)">&#x2190;</a></div></td></td><td>Loop condition is false. Execution continues on line 1280</td><td><div class="PathNav"><a href="#EndPath" title="Next event (5)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line">    UseInterval* src = range-&gt;first_interval();</td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line">    <span class='keyword'>while</span> (src != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path3" class="msg msgControl" style="margin-left:5ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">3</div></td><td><div class="PathNav"><a href="#Path2" title="Previous event (2)">&#x2190;</a></div></td></td><td>Loop condition is false. Execution continues on line 1267</td><td><div class="PathNav"><a href="#Path4" title="Next event (4)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line">      UseInterval* new_node = <span class='keyword'>new</span> (zone) UseInterval(src-&gt;start(), src-&gt;end());</td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line">      <span class='keyword'>if</span> (result == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line">        result = new_node;</td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line">        node-&gt;set_next(new_node);</td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line">      node = new_node;</td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line">      src = src-&gt;next();</td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line">  use_interval_ = result;</td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line">  live_ranges().push_back(parent);</td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line">  end_position_ = <span class="mrange">node</span>-&gt;end();</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:19ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">5</div></td><td><div class="PathNav"><a href="#Path4" title="Previous event (4)">&#x2190;</a></div></td></td><td>Called C++ object pointer is null</td></tr></table></div></td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line">  parent-&gt;SetSpillRange(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line"><span class='keyword'>int</span> SpillRange::ByteWidth() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line">  <span class='keyword'>return</span> GetByteWidth(live_ranges_[0]-&gt;representation());</td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line"><span class='keyword'>bool</span> SpillRange::IsIntersectingWith(SpillRange* other) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">  <span class='keyword'>if</span> (<span class='keyword'>this</span>-&gt;use_interval_ == <span class='keyword'>nullptr</span> || other-&gt;use_interval_ == <span class='keyword'>nullptr</span> ||</td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line">      <span class='keyword'>this</span>-&gt;End() &lt;= other-&gt;use_interval_-&gt;start() ||</td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">      other-&gt;End() &lt;= <span class='keyword'>this</span>-&gt;use_interval_-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line">  <span class='keyword'>return</span> AreUseIntervalsIntersecting(use_interval_, other-&gt;use_interval_);</td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line"><span class='keyword'>bool</span> SpillRange::TryMerge(SpillRange* other) {</td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line">  <span class='keyword'>if</span> (HasSlot() || other-&gt;HasSlot()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line">  <span class='comment'>// TODO(dcarney): byte widths should be compared here not kinds.</span></td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line">  <span class='keyword'>if</span> (live_ranges_[0]-&gt;kind() != other-&gt;live_ranges_[0]-&gt;kind() ||</td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line">      IsIntersectingWith(other)) {</td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line">  LifetimePosition max = LifetimePosition::MaxPosition();</td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line">  <span class='keyword'>if</span> (End() &lt; other-&gt;End() &amp;&amp; other-&gt;End() != max) {</td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line">    end_position_ = other-&gt;End();</td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line">  other-&gt;end_position_ = max;</td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line">  MergeDisjointIntervals(other-&gt;use_interval_);</td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line">  other-&gt;use_interval_ = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : other-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line">    <span class='macro'>DCHECK(range-&gt;GetSpillRange() == other)<span class='expansion'>do { if ((__builtin_expect(!!(!(range-&gt;GetSpillRange() == other<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1320<br>, "Check failed: %s.", "range-&gt;GetSpillRange() == other");<br> } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line">    range-&gt;SetSpillRange(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line">  live_ranges().insert(live_ranges().end(), other-&gt;live_ranges().begin(),</td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line">                       other-&gt;live_ranges().end());</td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line">  other-&gt;live_ranges().clear();</td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line"><span class='keyword'>void</span> SpillRange::MergeDisjointIntervals(UseInterval* other) {</td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line">  UseInterval* tail = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line">  UseInterval* current = use_interval_;</td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line">  <span class='keyword'>while</span> (other != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line">    <span class='comment'>// Make sure the 'current' list starts first</span></td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line">    <span class='keyword'>if</span> (current == <span class='keyword'>nullptr</span> || current-&gt;start() &gt; other-&gt;start()) {</td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line">      std::swap(current, other);</td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line">    <span class='comment'>// Check disjointness</span></td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line">    <span class='macro'>DCHECK(other == <span class='keyword'>nullptr</span> || current-&gt;end() &lt;= other-&gt;start())<span class='expansion'>do { if ((__builtin_expect(!!(!(other == nullptr || current-&gt;<br>end() &lt;= other-&gt;start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1341, "Check failed: %s.", "other == nullptr || current-&gt;end() &lt;= other-&gt;start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line">    <span class='comment'>// Append the 'current' node to the result accumulator and move forward</span></td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line">    <span class='keyword'>if</span> (tail == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line">      use_interval_ = current;</td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line">      tail-&gt;set_next(current);</td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line">    tail = current;</td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line">    current = current-&gt;next();</td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line">  <span class='comment'>// Other list is empty =&gt; we are done</span></td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line"><span class='keyword'>void</span> SpillRange::Print() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1356">1356</td><td class="line">  OFStream os(<span class='macro'>stdout<span class='expansion'>stdout</span></span>);</td></tr>
<tr><td class="num" id="LN1357">1357</td><td class="line">  os &lt;&lt; <span class='string_literal'>"{"</span> &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1358">1358</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : live_ranges()) {</td></tr>
<tr><td class="num" id="LN1359">1359</td><td class="line">    os &lt;&lt; range-&gt;vreg() &lt;&lt; <span class='string_literal'>" "</span>;</td></tr>
<tr><td class="num" id="LN1360">1360</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1361">1361</td><td class="line">  os &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1362">1362</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1363">1363</td><td class="line">  <span class='keyword'>for</span> (UseInterval* i = interval(); i != <span class='keyword'>nullptr</span>; i = i-&gt;next()) {</td></tr>
<tr><td class="num" id="LN1364">1364</td><td class="line">    os &lt;&lt; '[' &lt;&lt; i-&gt;start() &lt;&lt; <span class='string_literal'>", "</span> &lt;&lt; i-&gt;end() &lt;&lt; ')' &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1365">1365</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1366">1366</td><td class="line">  os &lt;&lt; <span class='string_literal'>"}"</span> &lt;&lt; std::endl;</td></tr>
<tr><td class="num" id="LN1367">1367</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1368">1368</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1369">1369</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1370">1370</td><td class="line">RegisterAllocationData::PhiMapValue::PhiMapValue(PhiInstruction* phi,</td></tr>
<tr><td class="num" id="LN1371">1371</td><td class="line">                                                 <span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN1372">1372</td><td class="line">                                                 Zone* zone)</td></tr>
<tr><td class="num" id="LN1373">1373</td><td class="line">    : phi_(phi),</td></tr>
<tr><td class="num" id="LN1374">1374</td><td class="line">      block_(block),</td></tr>
<tr><td class="num" id="LN1375">1375</td><td class="line">      incoming_operands_(zone),</td></tr>
<tr><td class="num" id="LN1376">1376</td><td class="line">      assigned_register_(kUnassignedRegister) {</td></tr>
<tr><td class="num" id="LN1377">1377</td><td class="line">  incoming_operands_.reserve(phi-&gt;operands().size());</td></tr>
<tr><td class="num" id="LN1378">1378</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1379">1379</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1380">1380</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1381">1381</td><td class="line"><span class='keyword'>void</span> RegisterAllocationData::PhiMapValue::AddOperand(</td></tr>
<tr><td class="num" id="LN1382">1382</td><td class="line">    InstructionOperand* operand) {</td></tr>
<tr><td class="num" id="LN1383">1383</td><td class="line">  incoming_operands_.push_back(operand);</td></tr>
<tr><td class="num" id="LN1384">1384</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1385">1385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1386">1386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1387">1387</td><td class="line"><span class='keyword'>void</span> RegisterAllocationData::PhiMapValue::CommitAssignment(</td></tr>
<tr><td class="num" id="LN1388">1388</td><td class="line">    <span class='keyword'>const</span> InstructionOperand&amp; assigned) {</td></tr>
<tr><td class="num" id="LN1389">1389</td><td class="line">  <span class='keyword'>for</span> (InstructionOperand* operand : incoming_operands_) {</td></tr>
<tr><td class="num" id="LN1390">1390</td><td class="line">    InstructionOperand::ReplaceWith(operand, &amp;assigned);</td></tr>
<tr><td class="num" id="LN1391">1391</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1392">1392</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1393">1393</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1394">1394</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1395">1395</td><td class="line">RegisterAllocationData::RegisterAllocationData(</td></tr>
<tr><td class="num" id="LN1396">1396</td><td class="line">    <span class='keyword'>const</span> RegisterConfiguration* config, Zone* zone, Frame* frame,</td></tr>
<tr><td class="num" id="LN1397">1397</td><td class="line">    InstructionSequence* code, <span class='keyword'>const</span> <span class='keyword'>char</span>* debug_name)</td></tr>
<tr><td class="num" id="LN1398">1398</td><td class="line">    : allocation_zone_(zone),</td></tr>
<tr><td class="num" id="LN1399">1399</td><td class="line">      frame_(frame),</td></tr>
<tr><td class="num" id="LN1400">1400</td><td class="line">      code_(code),</td></tr>
<tr><td class="num" id="LN1401">1401</td><td class="line">      debug_name_(debug_name),</td></tr>
<tr><td class="num" id="LN1402">1402</td><td class="line">      config_(config),</td></tr>
<tr><td class="num" id="LN1403">1403</td><td class="line">      phi_map_(allocation_zone()),</td></tr>
<tr><td class="num" id="LN1404">1404</td><td class="line">      allocatable_codes_(<span class='keyword'>this</span>-&gt;config()-&gt;num_general_registers(), -1,</td></tr>
<tr><td class="num" id="LN1405">1405</td><td class="line">                         allocation_zone()),</td></tr>
<tr><td class="num" id="LN1406">1406</td><td class="line">      allocatable_double_codes_(<span class='keyword'>this</span>-&gt;config()-&gt;num_double_registers(), -1,</td></tr>
<tr><td class="num" id="LN1407">1407</td><td class="line">                                allocation_zone()),</td></tr>
<tr><td class="num" id="LN1408">1408</td><td class="line">      live_in_sets_(code-&gt;InstructionBlockCount(), <span class='keyword'>nullptr</span>, allocation_zone()),</td></tr>
<tr><td class="num" id="LN1409">1409</td><td class="line">      live_out_sets_(code-&gt;InstructionBlockCount(), <span class='keyword'>nullptr</span>, allocation_zone()),</td></tr>
<tr><td class="num" id="LN1410">1410</td><td class="line">      live_ranges_(code-&gt;VirtualRegisterCount() * 2, <span class='keyword'>nullptr</span>,</td></tr>
<tr><td class="num" id="LN1411">1411</td><td class="line">                   allocation_zone()),</td></tr>
<tr><td class="num" id="LN1412">1412</td><td class="line">      fixed_live_ranges_(<span class='keyword'>this</span>-&gt;config()-&gt;num_general_registers(), <span class='keyword'>nullptr</span>,</td></tr>
<tr><td class="num" id="LN1413">1413</td><td class="line">                         allocation_zone()),</td></tr>
<tr><td class="num" id="LN1414">1414</td><td class="line">      fixed_double_live_ranges_(<span class='keyword'>this</span>-&gt;config()-&gt;num_double_registers(), <span class='keyword'>nullptr</span>,</td></tr>
<tr><td class="num" id="LN1415">1415</td><td class="line">                                allocation_zone()),</td></tr>
<tr><td class="num" id="LN1416">1416</td><td class="line">      spill_ranges_(code-&gt;VirtualRegisterCount(), <span class='keyword'>nullptr</span>, allocation_zone()),</td></tr>
<tr><td class="num" id="LN1417">1417</td><td class="line">      delayed_references_(allocation_zone()),</td></tr>
<tr><td class="num" id="LN1418">1418</td><td class="line">      assigned_registers_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN1419">1419</td><td class="line">      assigned_double_registers_(<span class='keyword'>nullptr</span>),</td></tr>
<tr><td class="num" id="LN1420">1420</td><td class="line">      virtual_register_count_(code-&gt;VirtualRegisterCount()),</td></tr>
<tr><td class="num" id="LN1421">1421</td><td class="line">      preassigned_slot_ranges_(zone) {</td></tr>
<tr><td class="num" id="LN1422">1422</td><td class="line">  <span class='macro'>DCHECK(<span class='keyword'>this</span>-&gt;config()-&gt;num_general_registers() &lt;=<span class='expansion'>do { if ((__builtin_expect(!!(!(this-&gt;config()-&gt;num_general_registers<br>() &lt;= RegisterConfiguration::kMaxGeneralRegisters)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1423, "Check failed: %s."<br>, "this-&gt;config()-&gt;num_general_registers() &lt;= RegisterConfiguration::kMaxGeneralRegisters"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1423">1423</td><td class="line">         <span class='macro'>RegisterConfiguration::kMaxGeneralRegisters)<span class='expansion'>do { if ((__builtin_expect(!!(!(this-&gt;config()-&gt;num_general_registers<br>() &lt;= RegisterConfiguration::kMaxGeneralRegisters)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1423, "Check failed: %s."<br>, "this-&gt;config()-&gt;num_general_registers() &lt;= RegisterConfiguration::kMaxGeneralRegisters"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1424">1424</td><td class="line">  <span class='macro'>DCHECK(<span class='keyword'>this</span>-&gt;config()-&gt;num_double_registers() &lt;=<span class='expansion'>do { if ((__builtin_expect(!!(!(this-&gt;config()-&gt;num_double_registers<br>() &lt;= RegisterConfiguration::kMaxDoubleRegisters)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1425, "Check failed: %s."<br>, "this-&gt;config()-&gt;num_double_registers() &lt;= RegisterConfiguration::kMaxDoubleRegisters"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1425">1425</td><td class="line">         <span class='macro'>RegisterConfiguration::kMaxDoubleRegisters)<span class='expansion'>do { if ((__builtin_expect(!!(!(this-&gt;config()-&gt;num_double_registers<br>() &lt;= RegisterConfiguration::kMaxDoubleRegisters)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1425, "Check failed: %s."<br>, "this-&gt;config()-&gt;num_double_registers() &lt;= RegisterConfiguration::kMaxDoubleRegisters"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1426">1426</td><td class="line">  assigned_registers_ = <span class='keyword'>new</span> (code_zone())</td></tr>
<tr><td class="num" id="LN1427">1427</td><td class="line">      BitVector(<span class='keyword'>this</span>-&gt;config()-&gt;num_general_registers(), code_zone());</td></tr>
<tr><td class="num" id="LN1428">1428</td><td class="line">  assigned_double_registers_ = <span class='keyword'>new</span> (code_zone())</td></tr>
<tr><td class="num" id="LN1429">1429</td><td class="line">      BitVector(<span class='keyword'>this</span>-&gt;config()-&gt;num_double_registers(), code_zone());</td></tr>
<tr><td class="num" id="LN1430">1430</td><td class="line">  <span class='keyword'>this</span>-&gt;frame()-&gt;SetAllocatedRegisters(assigned_registers_);</td></tr>
<tr><td class="num" id="LN1431">1431</td><td class="line">  <span class='keyword'>this</span>-&gt;frame()-&gt;SetAllocatedDoubleRegisters(assigned_double_registers_);</td></tr>
<tr><td class="num" id="LN1432">1432</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1433">1433</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1434">1434</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1435">1435</td><td class="line">MoveOperands* RegisterAllocationData::AddGapMove(</td></tr>
<tr><td class="num" id="LN1436">1436</td><td class="line">    <span class='keyword'>int</span> index, Instruction::GapPosition position,</td></tr>
<tr><td class="num" id="LN1437">1437</td><td class="line">    <span class='keyword'>const</span> InstructionOperand&amp; from, <span class='keyword'>const</span> InstructionOperand&amp; to) {</td></tr>
<tr><td class="num" id="LN1438">1438</td><td class="line">  Instruction* instr = code()-&gt;InstructionAt(index);</td></tr>
<tr><td class="num" id="LN1439">1439</td><td class="line">  ParallelMove* moves = instr-&gt;GetOrCreateParallelMove(position, code_zone());</td></tr>
<tr><td class="num" id="LN1440">1440</td><td class="line">  <span class='keyword'>return</span> moves-&gt;AddMove(from, to);</td></tr>
<tr><td class="num" id="LN1441">1441</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1442">1442</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1443">1443</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1444">1444</td><td class="line">MachineRepresentation RegisterAllocationData::RepresentationFor(</td></tr>
<tr><td class="num" id="LN1445">1445</td><td class="line">    <span class='keyword'>int</span> virtual_register) {</td></tr>
<tr><td class="num" id="LN1446">1446</td><td class="line">  <span class='macro'>DCHECK_LT(virtual_register, code()-&gt;VirtualRegisterCount())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLTImpl( (virtual_register<br>), (code()-&gt;VirtualRegisterCount()), "virtual_register" " "<br> "&lt;" " " "code()-&gt;VirtualRegisterCount()")) { V8_Fatal(<br>"../src/compiler/register-allocator.cc", 1446, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1447">1447</td><td class="line">  <span class='keyword'>return</span> code()-&gt;GetRepresentation(virtual_register);</td></tr>
<tr><td class="num" id="LN1448">1448</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1449">1449</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1450">1450</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1451">1451</td><td class="line">TopLevelLiveRange* RegisterAllocationData::GetOrCreateLiveRangeFor(<span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1452">1452</td><td class="line">  <span class='keyword'>if</span> (index &gt;= <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(live_ranges().size())) {</td></tr>
<tr><td class="num" id="LN1453">1453</td><td class="line">    live_ranges().resize(index + 1, <span class='keyword'>nullptr</span>);</td></tr>
<tr><td class="num" id="LN1454">1454</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1455">1455</td><td class="line">  TopLevelLiveRange* result = live_ranges()[index];</td></tr>
<tr><td class="num" id="LN1456">1456</td><td class="line">  <span class='keyword'>if</span> (result == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1457">1457</td><td class="line">    result = NewLiveRange(index, RepresentationFor(index));</td></tr>
<tr><td class="num" id="LN1458">1458</td><td class="line">    live_ranges()[index] = result;</td></tr>
<tr><td class="num" id="LN1459">1459</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1460">1460</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN1461">1461</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1462">1462</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1463">1463</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1464">1464</td><td class="line">TopLevelLiveRange* RegisterAllocationData::NewLiveRange(</td></tr>
<tr><td class="num" id="LN1465">1465</td><td class="line">    <span class='keyword'>int</span> index, MachineRepresentation rep) {</td></tr>
<tr><td class="num" id="LN1466">1466</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>new</span> (allocation_zone()) TopLevelLiveRange(index, rep);</td></tr>
<tr><td class="num" id="LN1467">1467</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1468">1468</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1469">1469</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1470">1470</td><td class="line"><span class='keyword'>int</span> RegisterAllocationData::GetNextLiveRangeId() {</td></tr>
<tr><td class="num" id="LN1471">1471</td><td class="line">  <span class='keyword'>int</span> vreg = virtual_register_count_++;</td></tr>
<tr><td class="num" id="LN1472">1472</td><td class="line">  <span class='keyword'>if</span> (vreg &gt;= <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(live_ranges().size())) {</td></tr>
<tr><td class="num" id="LN1473">1473</td><td class="line">    live_ranges().resize(vreg + 1, <span class='keyword'>nullptr</span>);</td></tr>
<tr><td class="num" id="LN1474">1474</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1475">1475</td><td class="line">  <span class='keyword'>return</span> vreg;</td></tr>
<tr><td class="num" id="LN1476">1476</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1477">1477</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1478">1478</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1479">1479</td><td class="line">TopLevelLiveRange* RegisterAllocationData::NextLiveRange(</td></tr>
<tr><td class="num" id="LN1480">1480</td><td class="line">    MachineRepresentation rep) {</td></tr>
<tr><td class="num" id="LN1481">1481</td><td class="line">  <span class='keyword'>int</span> vreg = GetNextLiveRangeId();</td></tr>
<tr><td class="num" id="LN1482">1482</td><td class="line">  TopLevelLiveRange* ret = NewLiveRange(vreg, rep);</td></tr>
<tr><td class="num" id="LN1483">1483</td><td class="line">  <span class='keyword'>return</span> ret;</td></tr>
<tr><td class="num" id="LN1484">1484</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1485">1485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1486">1486</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1487">1487</td><td class="line">RegisterAllocationData::PhiMapValue* RegisterAllocationData::InitializePhiMap(</td></tr>
<tr><td class="num" id="LN1488">1488</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* block, PhiInstruction* phi) {</td></tr>
<tr><td class="num" id="LN1489">1489</td><td class="line">  RegisterAllocationData::PhiMapValue* map_value = <span class='keyword'>new</span> (allocation_zone())</td></tr>
<tr><td class="num" id="LN1490">1490</td><td class="line">      RegisterAllocationData::PhiMapValue(phi, block, allocation_zone());</td></tr>
<tr><td class="num" id="LN1491">1491</td><td class="line">  <span class='keyword'>auto</span> res =</td></tr>
<tr><td class="num" id="LN1492">1492</td><td class="line">      phi_map_.insert(std::make_pair(phi-&gt;virtual_register(), map_value));</td></tr>
<tr><td class="num" id="LN1493">1493</td><td class="line">  <span class='macro'>DCHECK(res.second)<span class='expansion'>do { if ((__builtin_expect(!!(!(res.second)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 1493, "Check failed: %s."<br>, "res.second"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1494">1494</td><td class="line">  USE(res);</td></tr>
<tr><td class="num" id="LN1495">1495</td><td class="line">  <span class='keyword'>return</span> map_value;</td></tr>
<tr><td class="num" id="LN1496">1496</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1497">1497</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1498">1498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1499">1499</td><td class="line">RegisterAllocationData::PhiMapValue* RegisterAllocationData::GetPhiMapValueFor(</td></tr>
<tr><td class="num" id="LN1500">1500</td><td class="line">    <span class='keyword'>int</span> virtual_register) {</td></tr>
<tr><td class="num" id="LN1501">1501</td><td class="line">  <span class='keyword'>auto</span> it = phi_map_.find(virtual_register);</td></tr>
<tr><td class="num" id="LN1502">1502</td><td class="line">  <span class='macro'>DCHECK(it != phi_map_.end())<span class='expansion'>do { if ((__builtin_expect(!!(!(it != phi_map_.end())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1502, "Check failed: %s."<br>, "it != phi_map_.end()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1503">1503</td><td class="line">  <span class='keyword'>return</span> it-&gt;second;</td></tr>
<tr><td class="num" id="LN1504">1504</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1505">1505</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1506">1506</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1507">1507</td><td class="line">RegisterAllocationData::PhiMapValue* RegisterAllocationData::GetPhiMapValueFor(</td></tr>
<tr><td class="num" id="LN1508">1508</td><td class="line">    TopLevelLiveRange* top_range) {</td></tr>
<tr><td class="num" id="LN1509">1509</td><td class="line">  <span class='keyword'>return</span> GetPhiMapValueFor(top_range-&gt;vreg());</td></tr>
<tr><td class="num" id="LN1510">1510</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1511">1511</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1512">1512</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1513">1513</td><td class="line"><span class='keyword'>bool</span> RegisterAllocationData::ExistsUseWithoutDefinition() {</td></tr>
<tr><td class="num" id="LN1514">1514</td><td class="line">  <span class='keyword'>bool</span> found = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1515">1515</td><td class="line">  BitVector::Iterator iterator(live_in_sets()[0]);</td></tr>
<tr><td class="num" id="LN1516">1516</td><td class="line">  <span class='keyword'>while</span> (!iterator.Done()) {</td></tr>
<tr><td class="num" id="LN1517">1517</td><td class="line">    found = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1518">1518</td><td class="line">    <span class='keyword'>int</span> operand_index = iterator.Current();</td></tr>
<tr><td class="num" id="LN1519">1519</td><td class="line">    PrintF(<span class='string_literal'>"Register allocator error: live v%d reached first block.\n"</span>,</td></tr>
<tr><td class="num" id="LN1520">1520</td><td class="line">           operand_index);</td></tr>
<tr><td class="num" id="LN1521">1521</td><td class="line">    LiveRange* range = GetOrCreateLiveRangeFor(operand_index);</td></tr>
<tr><td class="num" id="LN1522">1522</td><td class="line">    PrintF(<span class='string_literal'>"  (first use is at %d)\n"</span>, range-&gt;first_pos()-&gt;pos().value());</td></tr>
<tr><td class="num" id="LN1523">1523</td><td class="line">    <span class='keyword'>if</span> (debug_name() == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1524">1524</td><td class="line">      PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1525">1525</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1526">1526</td><td class="line">      PrintF(<span class='string_literal'>"  (function: %s)\n"</span>, debug_name());</td></tr>
<tr><td class="num" id="LN1527">1527</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1528">1528</td><td class="line">    iterator.Advance();</td></tr>
<tr><td class="num" id="LN1529">1529</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1530">1530</td><td class="line">  <span class='keyword'>return</span> found;</td></tr>
<tr><td class="num" id="LN1531">1531</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1532">1532</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1533">1533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1534">1534</td><td class="line"><span class='comment'>// If a range is defined in a deferred block, we can expect all the range</span></td></tr>
<tr><td class="num" id="LN1535">1535</td><td class="line"><span class='comment'>// to only cover positions in deferred blocks. Otherwise, a block on the</span></td></tr>
<tr><td class="num" id="LN1536">1536</td><td class="line"><span class='comment'>// hot path would be dominated by a deferred block, meaning it is unreachable</span></td></tr>
<tr><td class="num" id="LN1537">1537</td><td class="line"><span class='comment'>// without passing through the deferred block, which is contradictory.</span></td></tr>
<tr><td class="num" id="LN1538">1538</td><td class="line"><span class='comment'>// In particular, when such a range contributes a result back on the hot</span></td></tr>
<tr><td class="num" id="LN1539">1539</td><td class="line"><span class='comment'>// path, it will be as one of the inputs of a phi. In that case, the value</span></td></tr>
<tr><td class="num" id="LN1540">1540</td><td class="line"><span class='comment'>// will be transferred via a move in the Gap::END's of the last instruction</span></td></tr>
<tr><td class="num" id="LN1541">1541</td><td class="line"><span class='comment'>// of a deferred block.</span></td></tr>
<tr><td class="num" id="LN1542">1542</td><td class="line"><span class='keyword'>bool</span> RegisterAllocationData::RangesDefinedInDeferredStayInDeferred() {</td></tr>
<tr><td class="num" id="LN1543">1543</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> TopLevelLiveRange* range : live_ranges()) {</td></tr>
<tr><td class="num" id="LN1544">1544</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span> || range-&gt;IsEmpty() ||</td></tr>
<tr><td class="num" id="LN1545">1545</td><td class="line">        !code()</td></tr>
<tr><td class="num" id="LN1546">1546</td><td class="line">             -&gt;GetInstructionBlock(range-&gt;Start().ToInstructionIndex())</td></tr>
<tr><td class="num" id="LN1547">1547</td><td class="line">             -&gt;IsDeferred()) {</td></tr>
<tr><td class="num" id="LN1548">1548</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1549">1549</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1550">1550</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> UseInterval* i = range-&gt;first_interval(); i != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1551">1551</td><td class="line">         i = i-&gt;next()) {</td></tr>
<tr><td class="num" id="LN1552">1552</td><td class="line">      <span class='keyword'>int</span> first = i-&gt;FirstGapIndex();</td></tr>
<tr><td class="num" id="LN1553">1553</td><td class="line">      <span class='keyword'>int</span> last = i-&gt;LastGapIndex();</td></tr>
<tr><td class="num" id="LN1554">1554</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> instr = first; instr &lt;= last;) {</td></tr>
<tr><td class="num" id="LN1555">1555</td><td class="line">        <span class='keyword'>const</span> InstructionBlock* block = code()-&gt;GetInstructionBlock(instr);</td></tr>
<tr><td class="num" id="LN1556">1556</td><td class="line">        <span class='keyword'>if</span> (!block-&gt;IsDeferred()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1557">1557</td><td class="line">        instr = block-&gt;last_instruction_index() + 1;</td></tr>
<tr><td class="num" id="LN1558">1558</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1559">1559</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1560">1560</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1561">1561</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1562">1562</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1563">1563</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1564">1564</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1565">1565</td><td class="line">SpillRange* RegisterAllocationData::AssignSpillRangeToLiveRange(</td></tr>
<tr><td class="num" id="LN1566">1566</td><td class="line">    TopLevelLiveRange* range) {</td></tr>
<tr><td class="num" id="LN1567">1567</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;HasSpillOperand())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;HasSpillOperand())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1567<br>, "Check failed: %s.", "!range-&gt;HasSpillOperand()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1568">1568</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1569">1569</td><td class="line">  SpillRange* spill_range = range-&gt;GetAllocatedSpillRange();</td></tr>
<tr><td class="num" id="LN1570">1570</td><td class="line">  <span class='keyword'>if</span> (spill_range == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1571">1571</td><td class="line">    <span class='macro'>DCHECK(!range-&gt;IsSplinter())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;IsSplinter())), 0)<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 1571, "Check failed: %s."<br>, "!range-&gt;IsSplinter()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1572">1572</td><td class="line">    spill_range = <span class='keyword'>new</span> (allocation_zone()) SpillRange(range, allocation_zone());</td></tr>
<tr><td class="num" id="LN1573">1573</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1574">1574</td><td class="line">  range-&gt;set_spill_type(TopLevelLiveRange::SpillType::kSpillRange);</td></tr>
<tr><td class="num" id="LN1575">1575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1576">1576</td><td class="line">  <span class='keyword'>int</span> spill_range_index =</td></tr>
<tr><td class="num" id="LN1577">1577</td><td class="line">      range-&gt;IsSplinter() ? range-&gt;splintered_from()-&gt;vreg() : range-&gt;vreg();</td></tr>
<tr><td class="num" id="LN1578">1578</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1579">1579</td><td class="line">  spill_ranges()[spill_range_index] = spill_range;</td></tr>
<tr><td class="num" id="LN1580">1580</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1581">1581</td><td class="line">  <span class='keyword'>return</span> spill_range;</td></tr>
<tr><td class="num" id="LN1582">1582</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1583">1583</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1584">1584</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1585">1585</td><td class="line">SpillRange* RegisterAllocationData::CreateSpillRangeForLiveRange(</td></tr>
<tr><td class="num" id="LN1586">1586</td><td class="line">    TopLevelLiveRange* range) {</td></tr>
<tr><td class="num" id="LN1587">1587</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;HasSpillOperand())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;HasSpillOperand())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1587<br>, "Check failed: %s.", "!range-&gt;HasSpillOperand()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1588">1588</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;IsSplinter())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;IsSplinter())), 0)<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 1588, "Check failed: %s."<br>, "!range-&gt;IsSplinter()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1589">1589</td><td class="line">  SpillRange* spill_range =</td></tr>
<tr><td class="num" id="LN1590">1590</td><td class="line">      <span class='keyword'>new</span> (allocation_zone()) SpillRange(range, allocation_zone());</td></tr>
<tr><td class="num" id="LN1591">1591</td><td class="line">  <span class='keyword'>return</span> spill_range;</td></tr>
<tr><td class="num" id="LN1592">1592</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1593">1593</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1594">1594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1595">1595</td><td class="line"><span class='keyword'>void</span> RegisterAllocationData::MarkAllocated(RegisterKind kind, <span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1596">1596</td><td class="line">  <span class='keyword'>if</span> (kind == DOUBLE_REGISTERS) {</td></tr>
<tr><td class="num" id="LN1597">1597</td><td class="line">    assigned_double_registers_-&gt;Add(index);</td></tr>
<tr><td class="num" id="LN1598">1598</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1599">1599</td><td class="line">    <span class='macro'>DCHECK(kind == GENERAL_REGISTERS)<span class='expansion'>do { if ((__builtin_expect(!!(!(kind == GENERAL_REGISTERS)), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 1599,<br> "Check failed: %s.", "kind == GENERAL_REGISTERS"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1600">1600</td><td class="line">    assigned_registers_-&gt;Add(index);</td></tr>
<tr><td class="num" id="LN1601">1601</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1602">1602</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1603">1603</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1604">1604</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1605">1605</td><td class="line"><span class='keyword'>bool</span> RegisterAllocationData::IsBlockBoundary(LifetimePosition pos) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1606">1606</td><td class="line">  <span class='keyword'>return</span> pos.IsFullStart() &amp;&amp;</td></tr>
<tr><td class="num" id="LN1607">1607</td><td class="line">         code()-&gt;GetInstructionBlock(pos.ToInstructionIndex())-&gt;code_start() ==</td></tr>
<tr><td class="num" id="LN1608">1608</td><td class="line">             pos.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN1609">1609</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1610">1610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1611">1611</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1612">1612</td><td class="line">ConstraintBuilder::ConstraintBuilder(RegisterAllocationData* data)</td></tr>
<tr><td class="num" id="LN1613">1613</td><td class="line">    : data_(data) {}</td></tr>
<tr><td class="num" id="LN1614">1614</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1615">1615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1616">1616</td><td class="line">InstructionOperand* ConstraintBuilder::AllocateFixed(</td></tr>
<tr><td class="num" id="LN1617">1617</td><td class="line">    UnallocatedOperand* operand, <span class='keyword'>int</span> pos, <span class='keyword'>bool</span> is_tagged) {</td></tr>
<tr><td class="num" id="LN1618">1618</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Allocating fixed reg for op %d\n"</span>, operand-&gt;virtual_register())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Allocating fixed reg for op %d\n"<br>, operand-&gt;virtual_register()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1619">1619</td><td class="line">  <span class='macro'>DCHECK(operand-&gt;HasFixedPolicy())<span class='expansion'>do { if ((__builtin_expect(!!(!(operand-&gt;HasFixedPolicy())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1619<br>, "Check failed: %s.", "operand-&gt;HasFixedPolicy()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1620">1620</td><td class="line">  InstructionOperand allocated;</td></tr>
<tr><td class="num" id="LN1621">1621</td><td class="line">  MachineRepresentation rep = InstructionSequence::DefaultRepresentation();</td></tr>
<tr><td class="num" id="LN1622">1622</td><td class="line">  <span class='keyword'>int</span> virtual_register = operand-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1623">1623</td><td class="line">  <span class='keyword'>if</span> (virtual_register != InstructionOperand::kInvalidVirtualRegister) {</td></tr>
<tr><td class="num" id="LN1624">1624</td><td class="line">    rep = data()-&gt;RepresentationFor(virtual_register);</td></tr>
<tr><td class="num" id="LN1625">1625</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1626">1626</td><td class="line">  <span class='keyword'>if</span> (operand-&gt;HasFixedSlotPolicy()) {</td></tr>
<tr><td class="num" id="LN1627">1627</td><td class="line">    allocated = AllocatedOperand(AllocatedOperand::STACK_SLOT, rep,</td></tr>
<tr><td class="num" id="LN1628">1628</td><td class="line">                                 operand-&gt;fixed_slot_index());</td></tr>
<tr><td class="num" id="LN1629">1629</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (operand-&gt;HasFixedRegisterPolicy()) {</td></tr>
<tr><td class="num" id="LN1630">1630</td><td class="line">    <span class='macro'>DCHECK(!IsFloatingPoint(rep))<span class='expansion'>do { if ((__builtin_expect(!!(!(!IsFloatingPoint(rep))), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 1630, "Check failed: %s."<br>, "!IsFloatingPoint(rep)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1631">1631</td><td class="line">    allocated = AllocatedOperand(AllocatedOperand::REGISTER, rep,</td></tr>
<tr><td class="num" id="LN1632">1632</td><td class="line">                                 operand-&gt;fixed_register_index());</td></tr>
<tr><td class="num" id="LN1633">1633</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (operand-&gt;HasFixedDoubleRegisterPolicy()) {</td></tr>
<tr><td class="num" id="LN1634">1634</td><td class="line">    <span class='macro'>DCHECK(IsFloatingPoint(rep))<span class='expansion'>do { if ((__builtin_expect(!!(!(IsFloatingPoint(rep))), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1634, "Check failed: %s."<br>, "IsFloatingPoint(rep)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1635">1635</td><td class="line">    <span class='macro'>DCHECK_NE(InstructionOperand::kInvalidVirtualRegister, virtual_register)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckNEImpl( (InstructionOperand<br>::kInvalidVirtualRegister), (virtual_register), "InstructionOperand::kInvalidVirtualRegister"<br> " " "!=" " " "virtual_register")) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1635, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1636">1636</td><td class="line">    allocated = AllocatedOperand(AllocatedOperand::REGISTER, rep,</td></tr>
<tr><td class="num" id="LN1637">1637</td><td class="line">                                 operand-&gt;fixed_register_index());</td></tr>
<tr><td class="num" id="LN1638">1638</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1639">1639</td><td class="line">    <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/compiler/register-allocator.cc", 1639, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1640">1640</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1641">1641</td><td class="line">  InstructionOperand::ReplaceWith(operand, &amp;allocated);</td></tr>
<tr><td class="num" id="LN1642">1642</td><td class="line">  <span class='keyword'>if</span> (is_tagged) {</td></tr>
<tr><td class="num" id="LN1643">1643</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Fixed reg is tagged at %d\n"</span>, pos)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Fixed reg is tagged at %d\n"<br>, pos); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1644">1644</td><td class="line">    Instruction* instr = code()-&gt;InstructionAt(pos);</td></tr>
<tr><td class="num" id="LN1645">1645</td><td class="line">    <span class='keyword'>if</span> (instr-&gt;HasReferenceMap()) {</td></tr>
<tr><td class="num" id="LN1646">1646</td><td class="line">      instr-&gt;reference_map()-&gt;RecordReference(*AllocatedOperand::cast(operand));</td></tr>
<tr><td class="num" id="LN1647">1647</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1648">1648</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1649">1649</td><td class="line">  <span class='keyword'>return</span> operand;</td></tr>
<tr><td class="num" id="LN1650">1650</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1651">1651</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1652">1652</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1653">1653</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::MeetRegisterConstraints() {</td></tr>
<tr><td class="num" id="LN1654">1654</td><td class="line">  <span class='keyword'>for</span> (InstructionBlock* block : code()-&gt;instruction_blocks()) {</td></tr>
<tr><td class="num" id="LN1655">1655</td><td class="line">    MeetRegisterConstraints(block);</td></tr>
<tr><td class="num" id="LN1656">1656</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1657">1657</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1658">1658</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1659">1659</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1660">1660</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::MeetRegisterConstraints(<span class='keyword'>const</span> InstructionBlock* block) {</td></tr>
<tr><td class="num" id="LN1661">1661</td><td class="line">  <span class='keyword'>int</span> start = block-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN1662">1662</td><td class="line">  <span class='keyword'>int</span> end = block-&gt;last_instruction_index();</td></tr>
<tr><td class="num" id="LN1663">1663</td><td class="line">  <span class='macro'>DCHECK_NE(-1, start)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckNEImpl( (-1), (<br>start), "-1" " " "!=" " " "start")) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1663, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1664">1664</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = start; i &lt;= end; ++i) {</td></tr>
<tr><td class="num" id="LN1665">1665</td><td class="line">    MeetConstraintsBefore(i);</td></tr>
<tr><td class="num" id="LN1666">1666</td><td class="line">    <span class='keyword'>if</span> (i != end) MeetConstraintsAfter(i);</td></tr>
<tr><td class="num" id="LN1667">1667</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1668">1668</td><td class="line">  <span class='comment'>// Meet register constraints for the instruction in the end.</span></td></tr>
<tr><td class="num" id="LN1669">1669</td><td class="line">  MeetRegisterConstraintsForLastInstructionInBlock(block);</td></tr>
<tr><td class="num" id="LN1670">1670</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1671">1671</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1672">1672</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1673">1673</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::MeetRegisterConstraintsForLastInstructionInBlock(</td></tr>
<tr><td class="num" id="LN1674">1674</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* block) {</td></tr>
<tr><td class="num" id="LN1675">1675</td><td class="line">  <span class='keyword'>int</span> end = block-&gt;last_instruction_index();</td></tr>
<tr><td class="num" id="LN1676">1676</td><td class="line">  Instruction* last_instruction = code()-&gt;InstructionAt(end);</td></tr>
<tr><td class="num" id="LN1677">1677</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; last_instruction-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN1678">1678</td><td class="line">    InstructionOperand* output_operand = last_instruction-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN1679">1679</td><td class="line">    <span class='macro'>DCHECK(!output_operand-&gt;IsConstant())<span class='expansion'>do { if ((__builtin_expect(!!(!(!output_operand-&gt;IsConstant<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1679, "Check failed: %s.", "!output_operand-&gt;IsConstant()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1680">1680</td><td class="line">    UnallocatedOperand* output = UnallocatedOperand::cast(output_operand);</td></tr>
<tr><td class="num" id="LN1681">1681</td><td class="line">    <span class='keyword'>int</span> output_vreg = output-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1682">1682</td><td class="line">    TopLevelLiveRange* range = data()-&gt;GetOrCreateLiveRangeFor(output_vreg);</td></tr>
<tr><td class="num" id="LN1683">1683</td><td class="line">    <span class='keyword'>bool</span> assigned = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1684">1684</td><td class="line">    <span class='keyword'>if</span> (output-&gt;HasFixedPolicy()) {</td></tr>
<tr><td class="num" id="LN1685">1685</td><td class="line">      AllocateFixed(output, -1, <span class='keyword'>false</span>);</td></tr>
<tr><td class="num" id="LN1686">1686</td><td class="line">      <span class='comment'>// This value is produced on the stack, we never need to spill it.</span></td></tr>
<tr><td class="num" id="LN1687">1687</td><td class="line">      <span class='keyword'>if</span> (output-&gt;IsStackSlot()) {</td></tr>
<tr><td class="num" id="LN1688">1688</td><td class="line">        <span class='macro'>DCHECK(LocationOperand::cast(output)-&gt;index() &lt;<span class='expansion'>do { if ((__builtin_expect(!!(!(LocationOperand::cast(output)<br>-&gt;index() &lt; data()-&gt;frame()-&gt;GetSpillSlotCount())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1689<br>, "Check failed: %s.", "LocationOperand::cast(output)-&gt;index() &lt; data()-&gt;frame()-&gt;GetSpillSlotCount()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1689">1689</td><td class="line">               <span class='macro'>data()-&gt;frame()-&gt;GetSpillSlotCount())<span class='expansion'>do { if ((__builtin_expect(!!(!(LocationOperand::cast(output)<br>-&gt;index() &lt; data()-&gt;frame()-&gt;GetSpillSlotCount())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 1689<br>, "Check failed: %s.", "LocationOperand::cast(output)-&gt;index() &lt; data()-&gt;frame()-&gt;GetSpillSlotCount()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1690">1690</td><td class="line">        range-&gt;SetSpillOperand(LocationOperand::cast(output));</td></tr>
<tr><td class="num" id="LN1691">1691</td><td class="line">        range-&gt;SetSpillStartIndex(end);</td></tr>
<tr><td class="num" id="LN1692">1692</td><td class="line">        assigned = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1693">1693</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1694">1694</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1695">1695</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>const</span> RpoNumber&amp; succ : block-&gt;successors()) {</td></tr>
<tr><td class="num" id="LN1696">1696</td><td class="line">        <span class='keyword'>const</span> InstructionBlock* successor = code()-&gt;InstructionBlockAt(succ);</td></tr>
<tr><td class="num" id="LN1697">1697</td><td class="line">        <span class='macro'>DCHECK(successor-&gt;PredecessorCount() == 1)<span class='expansion'>do { if ((__builtin_expect(!!(!(successor-&gt;PredecessorCount<br>() == 1)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1697, "Check failed: %s.", "successor-&gt;PredecessorCount() == 1"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1698">1698</td><td class="line">        <span class='keyword'>int</span> gap_index = successor-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN1699">1699</td><td class="line">        <span class='comment'>// Create an unconstrained operand for the same virtual register</span></td></tr>
<tr><td class="num" id="LN1700">1700</td><td class="line">        <span class='comment'>// and insert a gap move from the fixed output to the operand.</span></td></tr>
<tr><td class="num" id="LN1701">1701</td><td class="line">        UnallocatedOperand output_copy(UnallocatedOperand::ANY, output_vreg);</td></tr>
<tr><td class="num" id="LN1702">1702</td><td class="line">        data()-&gt;AddGapMove(gap_index, Instruction::START, *output, output_copy);</td></tr>
<tr><td class="num" id="LN1703">1703</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1704">1704</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1705">1705</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1706">1706</td><td class="line">    <span class='keyword'>if</span> (!assigned) {</td></tr>
<tr><td class="num" id="LN1707">1707</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>const</span> RpoNumber&amp; succ : block-&gt;successors()) {</td></tr>
<tr><td class="num" id="LN1708">1708</td><td class="line">        <span class='keyword'>const</span> InstructionBlock* successor = code()-&gt;InstructionBlockAt(succ);</td></tr>
<tr><td class="num" id="LN1709">1709</td><td class="line">        <span class='macro'>DCHECK(successor-&gt;PredecessorCount() == 1)<span class='expansion'>do { if ((__builtin_expect(!!(!(successor-&gt;PredecessorCount<br>() == 1)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1709, "Check failed: %s.", "successor-&gt;PredecessorCount() == 1"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1710">1710</td><td class="line">        <span class='keyword'>int</span> gap_index = successor-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN1711">1711</td><td class="line">        range-&gt;RecordSpillLocation(allocation_zone(), gap_index, output);</td></tr>
<tr><td class="num" id="LN1712">1712</td><td class="line">        range-&gt;SetSpillStartIndex(gap_index);</td></tr>
<tr><td class="num" id="LN1713">1713</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1714">1714</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1715">1715</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1716">1716</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1717">1717</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1718">1718</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1719">1719</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::MeetConstraintsAfter(<span class='keyword'>int</span> instr_index) {</td></tr>
<tr><td class="num" id="LN1720">1720</td><td class="line">  Instruction* first = code()-&gt;InstructionAt(instr_index);</td></tr>
<tr><td class="num" id="LN1721">1721</td><td class="line">  <span class='comment'>// Handle fixed temporaries.</span></td></tr>
<tr><td class="num" id="LN1722">1722</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; first-&gt;TempCount(); i++) {</td></tr>
<tr><td class="num" id="LN1723">1723</td><td class="line">    UnallocatedOperand* temp = UnallocatedOperand::cast(first-&gt;TempAt(i));</td></tr>
<tr><td class="num" id="LN1724">1724</td><td class="line">    <span class='keyword'>if</span> (temp-&gt;HasFixedPolicy()) AllocateFixed(temp, instr_index, <span class='keyword'>false</span>);</td></tr>
<tr><td class="num" id="LN1725">1725</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1726">1726</td><td class="line">  <span class='comment'>// Handle constant/fixed output operands.</span></td></tr>
<tr><td class="num" id="LN1727">1727</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; first-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN1728">1728</td><td class="line">    InstructionOperand* output = first-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN1729">1729</td><td class="line">    <span class='keyword'>if</span> (output-&gt;IsConstant()) {</td></tr>
<tr><td class="num" id="LN1730">1730</td><td class="line">      <span class='keyword'>int</span> output_vreg = ConstantOperand::cast(output)-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1731">1731</td><td class="line">      TopLevelLiveRange* range = data()-&gt;GetOrCreateLiveRangeFor(output_vreg);</td></tr>
<tr><td class="num" id="LN1732">1732</td><td class="line">      range-&gt;SetSpillStartIndex(instr_index + 1);</td></tr>
<tr><td class="num" id="LN1733">1733</td><td class="line">      range-&gt;SetSpillOperand(output);</td></tr>
<tr><td class="num" id="LN1734">1734</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1735">1735</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1736">1736</td><td class="line">    UnallocatedOperand* first_output = UnallocatedOperand::cast(output);</td></tr>
<tr><td class="num" id="LN1737">1737</td><td class="line">    TopLevelLiveRange* range =</td></tr>
<tr><td class="num" id="LN1738">1738</td><td class="line">        data()-&gt;GetOrCreateLiveRangeFor(first_output-&gt;virtual_register());</td></tr>
<tr><td class="num" id="LN1739">1739</td><td class="line">    <span class='keyword'>bool</span> assigned = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1740">1740</td><td class="line">    <span class='keyword'>if</span> (first_output-&gt;HasFixedPolicy()) {</td></tr>
<tr><td class="num" id="LN1741">1741</td><td class="line">      <span class='keyword'>int</span> output_vreg = first_output-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1742">1742</td><td class="line">      UnallocatedOperand output_copy(UnallocatedOperand::ANY, output_vreg);</td></tr>
<tr><td class="num" id="LN1743">1743</td><td class="line">      <span class='keyword'>bool</span> is_tagged = code()-&gt;IsReference(output_vreg);</td></tr>
<tr><td class="num" id="LN1744">1744</td><td class="line">      <span class='keyword'>if</span> (first_output-&gt;HasSecondaryStorage()) {</td></tr>
<tr><td class="num" id="LN1745">1745</td><td class="line">        range-&gt;MarkHasPreassignedSlot();</td></tr>
<tr><td class="num" id="LN1746">1746</td><td class="line">        data()-&gt;preassigned_slot_ranges().push_back(</td></tr>
<tr><td class="num" id="LN1747">1747</td><td class="line">            std::make_pair(range, first_output-&gt;GetSecondaryStorage()));</td></tr>
<tr><td class="num" id="LN1748">1748</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1749">1749</td><td class="line">      AllocateFixed(first_output, instr_index, is_tagged);</td></tr>
<tr><td class="num" id="LN1750">1750</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1751">1751</td><td class="line">      <span class='comment'>// This value is produced on the stack, we never need to spill it.</span></td></tr>
<tr><td class="num" id="LN1752">1752</td><td class="line">      <span class='keyword'>if</span> (first_output-&gt;IsStackSlot()) {</td></tr>
<tr><td class="num" id="LN1753">1753</td><td class="line">        <span class='macro'>DCHECK(LocationOperand::cast(first_output)-&gt;index() &lt;<span class='expansion'>do { if ((__builtin_expect(!!(!(LocationOperand::cast(first_output<br>)-&gt;index() &lt; data()-&gt;frame()-&gt;GetTotalFrameSlotCount<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1754, "Check failed: %s.", "LocationOperand::cast(first_output)-&gt;index() &lt; data()-&gt;frame()-&gt;GetTotalFrameSlotCount()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1754">1754</td><td class="line">               <span class='macro'>data()-&gt;frame()-&gt;GetTotalFrameSlotCount())<span class='expansion'>do { if ((__builtin_expect(!!(!(LocationOperand::cast(first_output<br>)-&gt;index() &lt; data()-&gt;frame()-&gt;GetTotalFrameSlotCount<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1754, "Check failed: %s.", "LocationOperand::cast(first_output)-&gt;index() &lt; data()-&gt;frame()-&gt;GetTotalFrameSlotCount()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1755">1755</td><td class="line">        range-&gt;SetSpillOperand(LocationOperand::cast(first_output));</td></tr>
<tr><td class="num" id="LN1756">1756</td><td class="line">        range-&gt;SetSpillStartIndex(instr_index + 1);</td></tr>
<tr><td class="num" id="LN1757">1757</td><td class="line">        assigned = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1758">1758</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1759">1759</td><td class="line">      data()-&gt;AddGapMove(instr_index + 1, Instruction::START, *first_output,</td></tr>
<tr><td class="num" id="LN1760">1760</td><td class="line">                         output_copy);</td></tr>
<tr><td class="num" id="LN1761">1761</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1762">1762</td><td class="line">    <span class='comment'>// Make sure we add a gap move for spilling (if we have not done</span></td></tr>
<tr><td class="num" id="LN1763">1763</td><td class="line">    <span class='comment'>// so already).</span></td></tr>
<tr><td class="num" id="LN1764">1764</td><td class="line">    <span class='keyword'>if</span> (!assigned) {</td></tr>
<tr><td class="num" id="LN1765">1765</td><td class="line">      range-&gt;RecordSpillLocation(allocation_zone(), instr_index + 1,</td></tr>
<tr><td class="num" id="LN1766">1766</td><td class="line">                                 first_output);</td></tr>
<tr><td class="num" id="LN1767">1767</td><td class="line">      range-&gt;SetSpillStartIndex(instr_index + 1);</td></tr>
<tr><td class="num" id="LN1768">1768</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1769">1769</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1770">1770</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1771">1771</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1772">1772</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1773">1773</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::MeetConstraintsBefore(<span class='keyword'>int</span> instr_index) {</td></tr>
<tr><td class="num" id="LN1774">1774</td><td class="line">  Instruction* second = code()-&gt;InstructionAt(instr_index);</td></tr>
<tr><td class="num" id="LN1775">1775</td><td class="line">  <span class='comment'>// Handle fixed input operands of second instruction.</span></td></tr>
<tr><td class="num" id="LN1776">1776</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; second-&gt;InputCount(); i++) {</td></tr>
<tr><td class="num" id="LN1777">1777</td><td class="line">    InstructionOperand* input = second-&gt;InputAt(i);</td></tr>
<tr><td class="num" id="LN1778">1778</td><td class="line">    <span class='keyword'>if</span> (input-&gt;IsImmediate() || input-&gt;IsExplicit()) {</td></tr>
<tr><td class="num" id="LN1779">1779</td><td class="line">      <span class='keyword'>continue</span>;  <span class='comment'>// Ignore immediates and explicitly reserved registers.</span></td></tr>
<tr><td class="num" id="LN1780">1780</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1781">1781</td><td class="line">    UnallocatedOperand* cur_input = UnallocatedOperand::cast(input);</td></tr>
<tr><td class="num" id="LN1782">1782</td><td class="line">    <span class='keyword'>if</span> (cur_input-&gt;HasFixedPolicy()) {</td></tr>
<tr><td class="num" id="LN1783">1783</td><td class="line">      <span class='keyword'>int</span> input_vreg = cur_input-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1784">1784</td><td class="line">      UnallocatedOperand input_copy(UnallocatedOperand::ANY, input_vreg);</td></tr>
<tr><td class="num" id="LN1785">1785</td><td class="line">      <span class='keyword'>bool</span> is_tagged = code()-&gt;IsReference(input_vreg);</td></tr>
<tr><td class="num" id="LN1786">1786</td><td class="line">      AllocateFixed(cur_input, instr_index, is_tagged);</td></tr>
<tr><td class="num" id="LN1787">1787</td><td class="line">      data()-&gt;AddGapMove(instr_index, Instruction::END, input_copy, *cur_input);</td></tr>
<tr><td class="num" id="LN1788">1788</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1789">1789</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1790">1790</td><td class="line">  <span class='comment'>// Handle "output same as input" for second instruction.</span></td></tr>
<tr><td class="num" id="LN1791">1791</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; second-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN1792">1792</td><td class="line">    InstructionOperand* output = second-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN1793">1793</td><td class="line">    <span class='keyword'>if</span> (!output-&gt;IsUnallocated()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1794">1794</td><td class="line">    UnallocatedOperand* second_output = UnallocatedOperand::cast(output);</td></tr>
<tr><td class="num" id="LN1795">1795</td><td class="line">    <span class='keyword'>if</span> (!second_output-&gt;HasSameAsInputPolicy()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1796">1796</td><td class="line">    <span class='macro'>DCHECK(i == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(i == 0)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1796, "Check failed: %s.", "i == 0"); } } while (0)</span></span>;  <span class='comment'>// Only valid for first output.</span></td></tr>
<tr><td class="num" id="LN1797">1797</td><td class="line">    UnallocatedOperand* cur_input =</td></tr>
<tr><td class="num" id="LN1798">1798</td><td class="line">        UnallocatedOperand::cast(second-&gt;InputAt(0));</td></tr>
<tr><td class="num" id="LN1799">1799</td><td class="line">    <span class='keyword'>int</span> output_vreg = second_output-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1800">1800</td><td class="line">    <span class='keyword'>int</span> input_vreg = cur_input-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1801">1801</td><td class="line">    UnallocatedOperand input_copy(UnallocatedOperand::ANY, input_vreg);</td></tr>
<tr><td class="num" id="LN1802">1802</td><td class="line">    cur_input-&gt;set_virtual_register(second_output-&gt;virtual_register());</td></tr>
<tr><td class="num" id="LN1803">1803</td><td class="line">    MoveOperands* gap_move = data()-&gt;AddGapMove(instr_index, Instruction::END,</td></tr>
<tr><td class="num" id="LN1804">1804</td><td class="line">                                                input_copy, *cur_input);</td></tr>
<tr><td class="num" id="LN1805">1805</td><td class="line">    <span class='keyword'>if</span> (code()-&gt;IsReference(input_vreg) &amp;&amp; !code()-&gt;IsReference(output_vreg)) {</td></tr>
<tr><td class="num" id="LN1806">1806</td><td class="line">      <span class='keyword'>if</span> (second-&gt;HasReferenceMap()) {</td></tr>
<tr><td class="num" id="LN1807">1807</td><td class="line">        RegisterAllocationData::DelayedReference delayed_reference = {</td></tr>
<tr><td class="num" id="LN1808">1808</td><td class="line">            second-&gt;reference_map(), &amp;gap_move-&gt;source()};</td></tr>
<tr><td class="num" id="LN1809">1809</td><td class="line">        data()-&gt;delayed_references().push_back(delayed_reference);</td></tr>
<tr><td class="num" id="LN1810">1810</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1811">1811</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (!code()-&gt;IsReference(input_vreg) &amp;&amp;</td></tr>
<tr><td class="num" id="LN1812">1812</td><td class="line">               code()-&gt;IsReference(output_vreg)) {</td></tr>
<tr><td class="num" id="LN1813">1813</td><td class="line">      <span class='comment'>// The input is assumed to immediately have a tagged representation,</span></td></tr>
<tr><td class="num" id="LN1814">1814</td><td class="line">      <span class='comment'>// before the pointer map can be used. I.e. the pointer map at the</span></td></tr>
<tr><td class="num" id="LN1815">1815</td><td class="line">      <span class='comment'>// instruction will include the output operand (whose value at the</span></td></tr>
<tr><td class="num" id="LN1816">1816</td><td class="line">      <span class='comment'>// beginning of the instruction is equal to the input operand). If</span></td></tr>
<tr><td class="num" id="LN1817">1817</td><td class="line">      <span class='comment'>// this is not desired, then the pointer map at this instruction needs</span></td></tr>
<tr><td class="num" id="LN1818">1818</td><td class="line">      <span class='comment'>// to be adjusted manually.</span></td></tr>
<tr><td class="num" id="LN1819">1819</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1820">1820</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1821">1821</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1822">1822</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1823">1823</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1824">1824</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::ResolvePhis() {</td></tr>
<tr><td class="num" id="LN1825">1825</td><td class="line">  <span class='comment'>// Process the blocks in reverse order.</span></td></tr>
<tr><td class="num" id="LN1826">1826</td><td class="line">  <span class='keyword'>for</span> (InstructionBlock* block : base::Reversed(code()-&gt;instruction_blocks())) {</td></tr>
<tr><td class="num" id="LN1827">1827</td><td class="line">    ResolvePhis(block);</td></tr>
<tr><td class="num" id="LN1828">1828</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1829">1829</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1830">1830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1831">1831</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1832">1832</td><td class="line"><span class='keyword'>void</span> ConstraintBuilder::ResolvePhis(<span class='keyword'>const</span> InstructionBlock* block) {</td></tr>
<tr><td class="num" id="LN1833">1833</td><td class="line">  <span class='keyword'>for</span> (PhiInstruction* phi : block-&gt;phis()) {</td></tr>
<tr><td class="num" id="LN1834">1834</td><td class="line">    <span class='keyword'>int</span> phi_vreg = phi-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN1835">1835</td><td class="line">    RegisterAllocationData::PhiMapValue* map_value =</td></tr>
<tr><td class="num" id="LN1836">1836</td><td class="line">        data()-&gt;InitializePhiMap(block, phi);</td></tr>
<tr><td class="num" id="LN1837">1837</td><td class="line">    InstructionOperand&amp; output = phi-&gt;output();</td></tr>
<tr><td class="num" id="LN1838">1838</td><td class="line">    <span class='comment'>// Map the destination operands, so the commitment phase can find them.</span></td></tr>
<tr><td class="num" id="LN1839">1839</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; phi-&gt;operands().size(); ++i) {</td></tr>
<tr><td class="num" id="LN1840">1840</td><td class="line">      InstructionBlock* cur_block =</td></tr>
<tr><td class="num" id="LN1841">1841</td><td class="line">          code()-&gt;InstructionBlockAt(block-&gt;predecessors()[i]);</td></tr>
<tr><td class="num" id="LN1842">1842</td><td class="line">      UnallocatedOperand input(UnallocatedOperand::ANY, phi-&gt;operands()[i]);</td></tr>
<tr><td class="num" id="LN1843">1843</td><td class="line">      MoveOperands* move = data()-&gt;AddGapMove(</td></tr>
<tr><td class="num" id="LN1844">1844</td><td class="line">          cur_block-&gt;last_instruction_index(), Instruction::END, input, output);</td></tr>
<tr><td class="num" id="LN1845">1845</td><td class="line">      map_value-&gt;AddOperand(&amp;move-&gt;destination());</td></tr>
<tr><td class="num" id="LN1846">1846</td><td class="line">      <span class='macro'>DCHECK(!code()<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(cur_block<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 1848, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(cur_block-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1847">1847</td><td class="line">                  <span class='macro'>-&gt;InstructionAt(cur_block-&gt;last_instruction_index())<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(cur_block<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 1848, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(cur_block-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1848">1848</td><td class="line">                  <span class='macro'>-&gt;HasReferenceMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(cur_block<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 1848, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(cur_block-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1849">1849</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1850">1850</td><td class="line">    TopLevelLiveRange* live_range = data()-&gt;GetOrCreateLiveRangeFor(phi_vreg);</td></tr>
<tr><td class="num" id="LN1851">1851</td><td class="line">    <span class='keyword'>int</span> gap_index = block-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN1852">1852</td><td class="line">    live_range-&gt;RecordSpillLocation(allocation_zone(), gap_index, &amp;output);</td></tr>
<tr><td class="num" id="LN1853">1853</td><td class="line">    live_range-&gt;SetSpillStartIndex(gap_index);</td></tr>
<tr><td class="num" id="LN1854">1854</td><td class="line">    <span class='comment'>// We use the phi-ness of some nodes in some later heuristics.</span></td></tr>
<tr><td class="num" id="LN1855">1855</td><td class="line">    live_range-&gt;set_is_phi(<span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN1856">1856</td><td class="line">    live_range-&gt;set_is_non_loop_phi(!block-&gt;IsLoopHeader());</td></tr>
<tr><td class="num" id="LN1857">1857</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1858">1858</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1859">1859</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1860">1860</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1861">1861</td><td class="line">LiveRangeBuilder::LiveRangeBuilder(RegisterAllocationData* data,</td></tr>
<tr><td class="num" id="LN1862">1862</td><td class="line">                                   Zone* local_zone)</td></tr>
<tr><td class="num" id="LN1863">1863</td><td class="line">    : data_(data), phi_hints_(local_zone) {}</td></tr>
<tr><td class="num" id="LN1864">1864</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1865">1865</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1866">1866</td><td class="line">BitVector* LiveRangeBuilder::ComputeLiveOut(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN1867">1867</td><td class="line">                                            RegisterAllocationData* data) {</td></tr>
<tr><td class="num" id="LN1868">1868</td><td class="line">  size_t block_index = block-&gt;rpo_number().ToSize();</td></tr>
<tr><td class="num" id="LN1869">1869</td><td class="line">  BitVector* live_out = data-&gt;live_out_sets()[block_index];</td></tr>
<tr><td class="num" id="LN1870">1870</td><td class="line">  <span class='keyword'>if</span> (live_out == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1871">1871</td><td class="line">    <span class='comment'>// Compute live out for the given block, except not including backward</span></td></tr>
<tr><td class="num" id="LN1872">1872</td><td class="line">    <span class='comment'>// successor edges.</span></td></tr>
<tr><td class="num" id="LN1873">1873</td><td class="line">    Zone* zone = data-&gt;allocation_zone();</td></tr>
<tr><td class="num" id="LN1874">1874</td><td class="line">    <span class='keyword'>const</span> InstructionSequence* code = data-&gt;code();</td></tr>
<tr><td class="num" id="LN1875">1875</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1876">1876</td><td class="line">    live_out = <span class='keyword'>new</span> (zone) BitVector(code-&gt;VirtualRegisterCount(), zone);</td></tr>
<tr><td class="num" id="LN1877">1877</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1878">1878</td><td class="line">    <span class='comment'>// Process all successor blocks.</span></td></tr>
<tr><td class="num" id="LN1879">1879</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> RpoNumber&amp; succ : block-&gt;successors()) {</td></tr>
<tr><td class="num" id="LN1880">1880</td><td class="line">      <span class='comment'>// Add values live on entry to the successor.</span></td></tr>
<tr><td class="num" id="LN1881">1881</td><td class="line">      <span class='keyword'>if</span> (succ &lt;= block-&gt;rpo_number()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1882">1882</td><td class="line">      BitVector* live_in = data-&gt;live_in_sets()[succ.ToSize()];</td></tr>
<tr><td class="num" id="LN1883">1883</td><td class="line">      <span class='keyword'>if</span> (live_in != <span class='keyword'>nullptr</span>) live_out-&gt;Union(*live_in);</td></tr>
<tr><td class="num" id="LN1884">1884</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1885">1885</td><td class="line">      <span class='comment'>// All phi input operands corresponding to this successor edge are live</span></td></tr>
<tr><td class="num" id="LN1886">1886</td><td class="line">      <span class='comment'>// out from this block.</span></td></tr>
<tr><td class="num" id="LN1887">1887</td><td class="line">      <span class='keyword'>const</span> InstructionBlock* successor = code-&gt;InstructionBlockAt(succ);</td></tr>
<tr><td class="num" id="LN1888">1888</td><td class="line">      size_t index = successor-&gt;PredecessorIndexOf(block-&gt;rpo_number());</td></tr>
<tr><td class="num" id="LN1889">1889</td><td class="line">      <span class='macro'>DCHECK(index &lt; successor-&gt;PredecessorCount())<span class='expansion'>do { if ((__builtin_expect(!!(!(index &lt; successor-&gt;PredecessorCount<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1889, "Check failed: %s.", "index &lt; successor-&gt;PredecessorCount()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1890">1890</td><td class="line">      <span class='keyword'>for</span> (PhiInstruction* phi : successor-&gt;phis()) {</td></tr>
<tr><td class="num" id="LN1891">1891</td><td class="line">        live_out-&gt;Add(phi-&gt;operands()[index]);</td></tr>
<tr><td class="num" id="LN1892">1892</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1893">1893</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1894">1894</td><td class="line">    data-&gt;live_out_sets()[block_index] = live_out;</td></tr>
<tr><td class="num" id="LN1895">1895</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1896">1896</td><td class="line">  <span class='keyword'>return</span> live_out;</td></tr>
<tr><td class="num" id="LN1897">1897</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1898">1898</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1899">1899</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1900">1900</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::AddInitialIntervals(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN1901">1901</td><td class="line">                                           BitVector* live_out) {</td></tr>
<tr><td class="num" id="LN1902">1902</td><td class="line">  <span class='comment'>// Add an interval that includes the entire block to the live range for</span></td></tr>
<tr><td class="num" id="LN1903">1903</td><td class="line">  <span class='comment'>// each live_out value.</span></td></tr>
<tr><td class="num" id="LN1904">1904</td><td class="line">  LifetimePosition start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN1905">1905</td><td class="line">      block-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN1906">1906</td><td class="line">  LifetimePosition end = LifetimePosition::InstructionFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN1907">1907</td><td class="line">                             block-&gt;last_instruction_index())</td></tr>
<tr><td class="num" id="LN1908">1908</td><td class="line">                             .NextStart();</td></tr>
<tr><td class="num" id="LN1909">1909</td><td class="line">  BitVector::Iterator iterator(live_out);</td></tr>
<tr><td class="num" id="LN1910">1910</td><td class="line">  <span class='keyword'>while</span> (!iterator.Done()) {</td></tr>
<tr><td class="num" id="LN1911">1911</td><td class="line">    <span class='keyword'>int</span> operand_index = iterator.Current();</td></tr>
<tr><td class="num" id="LN1912">1912</td><td class="line">    TopLevelLiveRange* range = data()-&gt;GetOrCreateLiveRangeFor(operand_index);</td></tr>
<tr><td class="num" id="LN1913">1913</td><td class="line">    range-&gt;AddUseInterval(start, end, allocation_zone());</td></tr>
<tr><td class="num" id="LN1914">1914</td><td class="line">    iterator.Advance();</td></tr>
<tr><td class="num" id="LN1915">1915</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1916">1916</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1917">1917</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1918">1918</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1919">1919</td><td class="line"><span class='keyword'>int</span> LiveRangeBuilder::FixedDoubleLiveRangeID(<span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1920">1920</td><td class="line">  <span class='keyword'>return</span> -index - 1 - config()-&gt;num_general_registers();</td></tr>
<tr><td class="num" id="LN1921">1921</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1922">1922</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1923">1923</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1924">1924</td><td class="line">TopLevelLiveRange* LiveRangeBuilder::FixedLiveRangeFor(<span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1925">1925</td><td class="line">  <span class='macro'>DCHECK(index &lt; config()-&gt;num_general_registers())<span class='expansion'>do { if ((__builtin_expect(!!(!(index &lt; config()-&gt;num_general_registers<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1925, "Check failed: %s.", "index &lt; config()-&gt;num_general_registers()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1926">1926</td><td class="line">  TopLevelLiveRange* result = data()-&gt;fixed_live_ranges()[index];</td></tr>
<tr><td class="num" id="LN1927">1927</td><td class="line">  <span class='keyword'>if</span> (result == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1928">1928</td><td class="line">    result = data()-&gt;NewLiveRange(FixedLiveRangeID(index),</td></tr>
<tr><td class="num" id="LN1929">1929</td><td class="line">                                  InstructionSequence::DefaultRepresentation());</td></tr>
<tr><td class="num" id="LN1930">1930</td><td class="line">    <span class='macro'>DCHECK(result-&gt;IsFixed())<span class='expansion'>do { if ((__builtin_expect(!!(!(result-&gt;IsFixed())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1930, "Check failed: %s."<br>, "result-&gt;IsFixed()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1931">1931</td><td class="line">    result-&gt;set_assigned_register(index);</td></tr>
<tr><td class="num" id="LN1932">1932</td><td class="line">    data()-&gt;MarkAllocated(GENERAL_REGISTERS, index);</td></tr>
<tr><td class="num" id="LN1933">1933</td><td class="line">    data()-&gt;fixed_live_ranges()[index] = result;</td></tr>
<tr><td class="num" id="LN1934">1934</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1935">1935</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN1936">1936</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1937">1937</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1938">1938</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1939">1939</td><td class="line">TopLevelLiveRange* LiveRangeBuilder::FixedDoubleLiveRangeFor(<span class='keyword'>int</span> index) {</td></tr>
<tr><td class="num" id="LN1940">1940</td><td class="line">  <span class='macro'>DCHECK(index &lt; config()-&gt;num_double_registers())<span class='expansion'>do { if ((__builtin_expect(!!(!(index &lt; config()-&gt;num_double_registers<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 1940, "Check failed: %s.", "index &lt; config()-&gt;num_double_registers()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1941">1941</td><td class="line">  TopLevelLiveRange* result = data()-&gt;fixed_double_live_ranges()[index];</td></tr>
<tr><td class="num" id="LN1942">1942</td><td class="line">  <span class='keyword'>if</span> (result == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1943">1943</td><td class="line">    result = data()-&gt;NewLiveRange(FixedDoubleLiveRangeID(index),</td></tr>
<tr><td class="num" id="LN1944">1944</td><td class="line">                                  MachineRepresentation::kFloat64);</td></tr>
<tr><td class="num" id="LN1945">1945</td><td class="line">    <span class='macro'>DCHECK(result-&gt;IsFixed())<span class='expansion'>do { if ((__builtin_expect(!!(!(result-&gt;IsFixed())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 1945, "Check failed: %s."<br>, "result-&gt;IsFixed()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1946">1946</td><td class="line">    result-&gt;set_assigned_register(index);</td></tr>
<tr><td class="num" id="LN1947">1947</td><td class="line">    data()-&gt;MarkAllocated(DOUBLE_REGISTERS, index);</td></tr>
<tr><td class="num" id="LN1948">1948</td><td class="line">    data()-&gt;fixed_double_live_ranges()[index] = result;</td></tr>
<tr><td class="num" id="LN1949">1949</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1950">1950</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN1951">1951</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1952">1952</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1953">1953</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1954">1954</td><td class="line">TopLevelLiveRange* LiveRangeBuilder::LiveRangeFor(InstructionOperand* operand) {</td></tr>
<tr><td class="num" id="LN1955">1955</td><td class="line">  <span class='keyword'>if</span> (operand-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN1956">1956</td><td class="line">    <span class='keyword'>return</span> data()-&gt;GetOrCreateLiveRangeFor(</td></tr>
<tr><td class="num" id="LN1957">1957</td><td class="line">        UnallocatedOperand::cast(operand)-&gt;virtual_register());</td></tr>
<tr><td class="num" id="LN1958">1958</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (operand-&gt;IsConstant()) {</td></tr>
<tr><td class="num" id="LN1959">1959</td><td class="line">    <span class='keyword'>return</span> data()-&gt;GetOrCreateLiveRangeFor(</td></tr>
<tr><td class="num" id="LN1960">1960</td><td class="line">        ConstantOperand::cast(operand)-&gt;virtual_register());</td></tr>
<tr><td class="num" id="LN1961">1961</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (operand-&gt;IsRegister()) {</td></tr>
<tr><td class="num" id="LN1962">1962</td><td class="line">    <span class='keyword'>return</span> FixedLiveRangeFor(</td></tr>
<tr><td class="num" id="LN1963">1963</td><td class="line">        LocationOperand::cast(operand)-&gt;GetRegister().code());</td></tr>
<tr><td class="num" id="LN1964">1964</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (operand-&gt;IsDoubleRegister()) {</td></tr>
<tr><td class="num" id="LN1965">1965</td><td class="line">    <span class='keyword'>return</span> FixedDoubleLiveRangeFor(</td></tr>
<tr><td class="num" id="LN1966">1966</td><td class="line">        LocationOperand::cast(operand)-&gt;GetDoubleRegister().code());</td></tr>
<tr><td class="num" id="LN1967">1967</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1968">1968</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1969">1969</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1970">1970</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1971">1971</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1972">1972</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1973">1973</td><td class="line">UsePosition* LiveRangeBuilder::NewUsePosition(LifetimePosition pos,</td></tr>
<tr><td class="num" id="LN1974">1974</td><td class="line">                                              InstructionOperand* operand,</td></tr>
<tr><td class="num" id="LN1975">1975</td><td class="line">                                              <span class='keyword'>void</span>* hint,</td></tr>
<tr><td class="num" id="LN1976">1976</td><td class="line">                                              UsePositionHintType hint_type) {</td></tr>
<tr><td class="num" id="LN1977">1977</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>new</span> (allocation_zone()) UsePosition(pos, operand, hint, hint_type);</td></tr>
<tr><td class="num" id="LN1978">1978</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1979">1979</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1980">1980</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1981">1981</td><td class="line">UsePosition* LiveRangeBuilder::Define(LifetimePosition position,</td></tr>
<tr><td class="num" id="LN1982">1982</td><td class="line">                                      InstructionOperand* operand, <span class='keyword'>void</span>* hint,</td></tr>
<tr><td class="num" id="LN1983">1983</td><td class="line">                                      UsePositionHintType hint_type) {</td></tr>
<tr><td class="num" id="LN1984">1984</td><td class="line">  TopLevelLiveRange* range = LiveRangeFor(operand);</td></tr>
<tr><td class="num" id="LN1985">1985</td><td class="line">  <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1986">1986</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1987">1987</td><td class="line">  <span class='keyword'>if</span> (range-&gt;IsEmpty() || range-&gt;Start() &gt; position) {</td></tr>
<tr><td class="num" id="LN1988">1988</td><td class="line">    <span class='comment'>// Can happen if there is a definition without use.</span></td></tr>
<tr><td class="num" id="LN1989">1989</td><td class="line">    range-&gt;AddUseInterval(position, position.NextStart(), allocation_zone());</td></tr>
<tr><td class="num" id="LN1990">1990</td><td class="line">    range-&gt;AddUsePosition(NewUsePosition(position.NextStart()));</td></tr>
<tr><td class="num" id="LN1991">1991</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1992">1992</td><td class="line">    range-&gt;ShortenTo(position);</td></tr>
<tr><td class="num" id="LN1993">1993</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1994">1994</td><td class="line">  <span class='keyword'>if</span> (!operand-&gt;IsUnallocated()) <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN1995">1995</td><td class="line">  UnallocatedOperand* unalloc_operand = UnallocatedOperand::cast(operand);</td></tr>
<tr><td class="num" id="LN1996">1996</td><td class="line">  UsePosition* use_pos =</td></tr>
<tr><td class="num" id="LN1997">1997</td><td class="line">      NewUsePosition(position, unalloc_operand, hint, hint_type);</td></tr>
<tr><td class="num" id="LN1998">1998</td><td class="line">  range-&gt;AddUsePosition(use_pos);</td></tr>
<tr><td class="num" id="LN1999">1999</td><td class="line">  <span class='keyword'>return</span> use_pos;</td></tr>
<tr><td class="num" id="LN2000">2000</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2001">2001</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2002">2002</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2003">2003</td><td class="line">UsePosition* LiveRangeBuilder::Use(LifetimePosition block_start,</td></tr>
<tr><td class="num" id="LN2004">2004</td><td class="line">                                   LifetimePosition position,</td></tr>
<tr><td class="num" id="LN2005">2005</td><td class="line">                                   InstructionOperand* operand, <span class='keyword'>void</span>* hint,</td></tr>
<tr><td class="num" id="LN2006">2006</td><td class="line">                                   UsePositionHintType hint_type) {</td></tr>
<tr><td class="num" id="LN2007">2007</td><td class="line">  TopLevelLiveRange* range = LiveRangeFor(operand);</td></tr>
<tr><td class="num" id="LN2008">2008</td><td class="line">  <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2009">2009</td><td class="line">  UsePosition* use_pos = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2010">2010</td><td class="line">  <span class='keyword'>if</span> (operand-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2011">2011</td><td class="line">    UnallocatedOperand* unalloc_operand = UnallocatedOperand::cast(operand);</td></tr>
<tr><td class="num" id="LN2012">2012</td><td class="line">    use_pos = NewUsePosition(position, unalloc_operand, hint, hint_type);</td></tr>
<tr><td class="num" id="LN2013">2013</td><td class="line">    range-&gt;AddUsePosition(use_pos);</td></tr>
<tr><td class="num" id="LN2014">2014</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2015">2015</td><td class="line">  range-&gt;AddUseInterval(block_start, position, allocation_zone());</td></tr>
<tr><td class="num" id="LN2016">2016</td><td class="line">  <span class='keyword'>return</span> use_pos;</td></tr>
<tr><td class="num" id="LN2017">2017</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2018">2018</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2019">2019</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2020">2020</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::ProcessInstructions(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN2021">2021</td><td class="line">                                           BitVector* live) {</td></tr>
<tr><td class="num" id="LN2022">2022</td><td class="line">  <span class='keyword'>int</span> block_start = block-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN2023">2023</td><td class="line">  LifetimePosition block_start_position =</td></tr>
<tr><td class="num" id="LN2024">2024</td><td class="line">      LifetimePosition::GapFromInstructionIndex(block_start);</td></tr>
<tr><td class="num" id="LN2025">2025</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2026">2026</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> index = block-&gt;last_instruction_index(); index &gt;= block_start;</td></tr>
<tr><td class="num" id="LN2027">2027</td><td class="line">       index--) {</td></tr>
<tr><td class="num" id="LN2028">2028</td><td class="line">    LifetimePosition curr_position =</td></tr>
<tr><td class="num" id="LN2029">2029</td><td class="line">        LifetimePosition::InstructionFromInstructionIndex(index);</td></tr>
<tr><td class="num" id="LN2030">2030</td><td class="line">    Instruction* instr = code()-&gt;InstructionAt(index);</td></tr>
<tr><td class="num" id="LN2031">2031</td><td class="line">    <span class='macro'>DCHECK(instr != <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(instr != nullptr)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 2031, "Check failed: %s."<br>, "instr != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2032">2032</td><td class="line">    <span class='macro'>DCHECK(curr_position.IsInstructionPosition())<span class='expansion'>do { if ((__builtin_expect(!!(!(curr_position.IsInstructionPosition<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2032, "Check failed: %s.", "curr_position.IsInstructionPosition()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2033">2033</td><td class="line">    <span class='comment'>// Process output, inputs, and temps of this instruction.</span></td></tr>
<tr><td class="num" id="LN2034">2034</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; instr-&gt;OutputCount(); i++) {</td></tr>
<tr><td class="num" id="LN2035">2035</td><td class="line">      InstructionOperand* output = instr-&gt;OutputAt(i);</td></tr>
<tr><td class="num" id="LN2036">2036</td><td class="line">      <span class='keyword'>if</span> (output-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2037">2037</td><td class="line">        <span class='comment'>// Unsupported.</span></td></tr>
<tr><td class="num" id="LN2038">2038</td><td class="line">        <span class='macro'>DCHECK(!UnallocatedOperand::cast(output)-&gt;HasSlotPolicy())<span class='expansion'>do { if ((__builtin_expect(!!(!(!UnallocatedOperand::cast(output<br>)-&gt;HasSlotPolicy())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2038, "Check failed: %s.", "!UnallocatedOperand::cast(output)-&gt;HasSlotPolicy()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2039">2039</td><td class="line">        <span class='keyword'>int</span> out_vreg = UnallocatedOperand::cast(output)-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN2040">2040</td><td class="line">        live-&gt;Remove(out_vreg);</td></tr>
<tr><td class="num" id="LN2041">2041</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (output-&gt;IsConstant()) {</td></tr>
<tr><td class="num" id="LN2042">2042</td><td class="line">        <span class='keyword'>int</span> out_vreg = ConstantOperand::cast(output)-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN2043">2043</td><td class="line">        live-&gt;Remove(out_vreg);</td></tr>
<tr><td class="num" id="LN2044">2044</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2045">2045</td><td class="line">      <span class='keyword'>if</span> (block-&gt;IsHandler() &amp;&amp; index == block_start &amp;&amp; output-&gt;IsAllocated() &amp;&amp;</td></tr>
<tr><td class="num" id="LN2046">2046</td><td class="line">          output-&gt;IsRegister() &amp;&amp;</td></tr>
<tr><td class="num" id="LN2047">2047</td><td class="line">          AllocatedOperand::cast(output)-&gt;GetRegister().is(</td></tr>
<tr><td class="num" id="LN2048">2048</td><td class="line">              v8::internal::kReturnRegister0)) {</td></tr>
<tr><td class="num" id="LN2049">2049</td><td class="line">        <span class='comment'>// The register defined here is blocked from gap start - it is the</span></td></tr>
<tr><td class="num" id="LN2050">2050</td><td class="line">        <span class='comment'>// exception value.</span></td></tr>
<tr><td class="num" id="LN2051">2051</td><td class="line">        <span class='comment'>// TODO(mtrofin): should we explore an explicit opcode for</span></td></tr>
<tr><td class="num" id="LN2052">2052</td><td class="line">        <span class='comment'>// the first instruction in the handler?</span></td></tr>
<tr><td class="num" id="LN2053">2053</td><td class="line">        Define(LifetimePosition::GapFromInstructionIndex(index), output);</td></tr>
<tr><td class="num" id="LN2054">2054</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2055">2055</td><td class="line">        Define(curr_position, output);</td></tr>
<tr><td class="num" id="LN2056">2056</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2057">2057</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2058">2058</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2059">2059</td><td class="line">    <span class='keyword'>if</span> (instr-&gt;ClobbersRegisters()) {</td></tr>
<tr><td class="num" id="LN2060">2060</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; config()-&gt;num_allocatable_general_registers(); ++i) {</td></tr>
<tr><td class="num" id="LN2061">2061</td><td class="line">        <span class='keyword'>int</span> code = config()-&gt;GetAllocatableGeneralCode(i);</td></tr>
<tr><td class="num" id="LN2062">2062</td><td class="line">        <span class='keyword'>if</span> (!IsOutputRegisterOf(instr, Register::from_code(code))) {</td></tr>
<tr><td class="num" id="LN2063">2063</td><td class="line">          TopLevelLiveRange* range = FixedLiveRangeFor(code);</td></tr>
<tr><td class="num" id="LN2064">2064</td><td class="line">          range-&gt;AddUseInterval(curr_position, curr_position.End(),</td></tr>
<tr><td class="num" id="LN2065">2065</td><td class="line">                                allocation_zone());</td></tr>
<tr><td class="num" id="LN2066">2066</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2067">2067</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2068">2068</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2069">2069</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2070">2070</td><td class="line">    <span class='keyword'>if</span> (instr-&gt;ClobbersDoubleRegisters()) {</td></tr>
<tr><td class="num" id="LN2071">2071</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; config()-&gt;num_allocatable_aliased_double_registers();</td></tr>
<tr><td class="num" id="LN2072">2072</td><td class="line">           ++i) {</td></tr>
<tr><td class="num" id="LN2073">2073</td><td class="line">        <span class='keyword'>int</span> code = config()-&gt;GetAllocatableDoubleCode(i);</td></tr>
<tr><td class="num" id="LN2074">2074</td><td class="line">        <span class='keyword'>if</span> (!IsOutputDoubleRegisterOf(instr, DoubleRegister::from_code(code))) {</td></tr>
<tr><td class="num" id="LN2075">2075</td><td class="line">          TopLevelLiveRange* range = FixedDoubleLiveRangeFor(code);</td></tr>
<tr><td class="num" id="LN2076">2076</td><td class="line">          range-&gt;AddUseInterval(curr_position, curr_position.End(),</td></tr>
<tr><td class="num" id="LN2077">2077</td><td class="line">                                allocation_zone());</td></tr>
<tr><td class="num" id="LN2078">2078</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2079">2079</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2080">2080</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2081">2081</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2082">2082</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; instr-&gt;InputCount(); i++) {</td></tr>
<tr><td class="num" id="LN2083">2083</td><td class="line">      InstructionOperand* input = instr-&gt;InputAt(i);</td></tr>
<tr><td class="num" id="LN2084">2084</td><td class="line">      <span class='keyword'>if</span> (input-&gt;IsImmediate() || input-&gt;IsExplicit()) {</td></tr>
<tr><td class="num" id="LN2085">2085</td><td class="line">        <span class='keyword'>continue</span>;  <span class='comment'>// Ignore immediates and explicitly reserved registers.</span></td></tr>
<tr><td class="num" id="LN2086">2086</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2087">2087</td><td class="line">      LifetimePosition use_pos;</td></tr>
<tr><td class="num" id="LN2088">2088</td><td class="line">      <span class='keyword'>if</span> (input-&gt;IsUnallocated() &amp;&amp;</td></tr>
<tr><td class="num" id="LN2089">2089</td><td class="line">          UnallocatedOperand::cast(input)-&gt;IsUsedAtStart()) {</td></tr>
<tr><td class="num" id="LN2090">2090</td><td class="line">        use_pos = curr_position;</td></tr>
<tr><td class="num" id="LN2091">2091</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2092">2092</td><td class="line">        use_pos = curr_position.End();</td></tr>
<tr><td class="num" id="LN2093">2093</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2094">2094</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2095">2095</td><td class="line">      <span class='keyword'>if</span> (input-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2096">2096</td><td class="line">        UnallocatedOperand* unalloc = UnallocatedOperand::cast(input);</td></tr>
<tr><td class="num" id="LN2097">2097</td><td class="line">        <span class='keyword'>int</span> vreg = unalloc-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN2098">2098</td><td class="line">        live-&gt;Add(vreg);</td></tr>
<tr><td class="num" id="LN2099">2099</td><td class="line">        <span class='keyword'>if</span> (unalloc-&gt;HasSlotPolicy()) {</td></tr>
<tr><td class="num" id="LN2100">2100</td><td class="line">          data()-&gt;GetOrCreateLiveRangeFor(vreg)-&gt;set_has_slot_use(<span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN2101">2101</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2102">2102</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2103">2103</td><td class="line">      Use(block_start_position, use_pos, input);</td></tr>
<tr><td class="num" id="LN2104">2104</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2105">2105</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2106">2106</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; instr-&gt;TempCount(); i++) {</td></tr>
<tr><td class="num" id="LN2107">2107</td><td class="line">      InstructionOperand* temp = instr-&gt;TempAt(i);</td></tr>
<tr><td class="num" id="LN2108">2108</td><td class="line">      <span class='comment'>// Unsupported.</span></td></tr>
<tr><td class="num" id="LN2109">2109</td><td class="line">      <span class='macro'>DCHECK_IMPLIES(temp-&gt;IsUnallocated(),<span class='expansion'>do { if ((__builtin_expect(!!(!(!(temp-&gt;IsUnallocated()) ||<br> (!UnallocatedOperand::cast(temp)-&gt;HasSlotPolicy()))), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 2110, "Check failed: %s."<br>, "!(temp-&gt;IsUnallocated()) || (!UnallocatedOperand::cast(temp)-&gt;HasSlotPolicy())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2110">2110</td><td class="line">                     <span class='macro'>!UnallocatedOperand::cast(temp)-&gt;HasSlotPolicy())<span class='expansion'>do { if ((__builtin_expect(!!(!(!(temp-&gt;IsUnallocated()) ||<br> (!UnallocatedOperand::cast(temp)-&gt;HasSlotPolicy()))), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 2110, "Check failed: %s."<br>, "!(temp-&gt;IsUnallocated()) || (!UnallocatedOperand::cast(temp)-&gt;HasSlotPolicy())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2111">2111</td><td class="line">      <span class='keyword'>if</span> (instr-&gt;ClobbersTemps()) {</td></tr>
<tr><td class="num" id="LN2112">2112</td><td class="line">        <span class='keyword'>if</span> (temp-&gt;IsRegister()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2113">2113</td><td class="line">        <span class='keyword'>if</span> (temp-&gt;IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2114">2114</td><td class="line">          UnallocatedOperand* temp_unalloc = UnallocatedOperand::cast(temp);</td></tr>
<tr><td class="num" id="LN2115">2115</td><td class="line">          <span class='keyword'>if</span> (temp_unalloc-&gt;HasFixedPolicy()) {</td></tr>
<tr><td class="num" id="LN2116">2116</td><td class="line">            <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2117">2117</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2118">2118</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2119">2119</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2120">2120</td><td class="line">      Use(block_start_position, curr_position.End(), temp);</td></tr>
<tr><td class="num" id="LN2121">2121</td><td class="line">      Define(curr_position, temp);</td></tr>
<tr><td class="num" id="LN2122">2122</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2123">2123</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2124">2124</td><td class="line">    <span class='comment'>// Process the moves of the instruction's gaps, making their sources live.</span></td></tr>
<tr><td class="num" id="LN2125">2125</td><td class="line">    <span class='keyword'>const</span> Instruction::GapPosition kPositions[] = {Instruction::END,</td></tr>
<tr><td class="num" id="LN2126">2126</td><td class="line">                                                   Instruction::START};</td></tr>
<tr><td class="num" id="LN2127">2127</td><td class="line">    curr_position = curr_position.PrevStart();</td></tr>
<tr><td class="num" id="LN2128">2128</td><td class="line">    <span class='macro'>DCHECK(curr_position.IsGapPosition())<span class='expansion'>do { if ((__builtin_expect(!!(!(curr_position.IsGapPosition()<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2128<br>, "Check failed: %s.", "curr_position.IsGapPosition()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2129">2129</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> Instruction::GapPosition&amp; position : kPositions) {</td></tr>
<tr><td class="num" id="LN2130">2130</td><td class="line">      ParallelMove* move = instr-&gt;GetParallelMove(position);</td></tr>
<tr><td class="num" id="LN2131">2131</td><td class="line">      <span class='keyword'>if</span> (move == <span class='keyword'>nullptr</span>) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2132">2132</td><td class="line">      <span class='keyword'>if</span> (position == Instruction::END) {</td></tr>
<tr><td class="num" id="LN2133">2133</td><td class="line">        curr_position = curr_position.End();</td></tr>
<tr><td class="num" id="LN2134">2134</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2135">2135</td><td class="line">        curr_position = curr_position.Start();</td></tr>
<tr><td class="num" id="LN2136">2136</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2137">2137</td><td class="line">      <span class='keyword'>for</span> (MoveOperands* cur : *move) {</td></tr>
<tr><td class="num" id="LN2138">2138</td><td class="line">        InstructionOperand&amp; from = cur-&gt;source();</td></tr>
<tr><td class="num" id="LN2139">2139</td><td class="line">        InstructionOperand&amp; to = cur-&gt;destination();</td></tr>
<tr><td class="num" id="LN2140">2140</td><td class="line">        <span class='keyword'>void</span>* hint = &amp;to;</td></tr>
<tr><td class="num" id="LN2141">2141</td><td class="line">        UsePositionHintType hint_type = UsePosition::HintTypeForOperand(to);</td></tr>
<tr><td class="num" id="LN2142">2142</td><td class="line">        UsePosition* to_use = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2143">2143</td><td class="line">        <span class='keyword'>int</span> phi_vreg = -1;</td></tr>
<tr><td class="num" id="LN2144">2144</td><td class="line">        <span class='keyword'>if</span> (to.IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2145">2145</td><td class="line">          <span class='keyword'>int</span> to_vreg = UnallocatedOperand::cast(to).virtual_register();</td></tr>
<tr><td class="num" id="LN2146">2146</td><td class="line">          TopLevelLiveRange* to_range =</td></tr>
<tr><td class="num" id="LN2147">2147</td><td class="line">              data()-&gt;GetOrCreateLiveRangeFor(to_vreg);</td></tr>
<tr><td class="num" id="LN2148">2148</td><td class="line">          <span class='keyword'>if</span> (to_range-&gt;is_phi()) {</td></tr>
<tr><td class="num" id="LN2149">2149</td><td class="line">            phi_vreg = to_vreg;</td></tr>
<tr><td class="num" id="LN2150">2150</td><td class="line">            <span class='keyword'>if</span> (to_range-&gt;is_non_loop_phi()) {</td></tr>
<tr><td class="num" id="LN2151">2151</td><td class="line">              hint = to_range-&gt;current_hint_position();</td></tr>
<tr><td class="num" id="LN2152">2152</td><td class="line">              hint_type = hint == <span class='keyword'>nullptr</span> ? UsePositionHintType::kNone</td></tr>
<tr><td class="num" id="LN2153">2153</td><td class="line">                                          : UsePositionHintType::kUsePos;</td></tr>
<tr><td class="num" id="LN2154">2154</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2155">2155</td><td class="line">              hint_type = UsePositionHintType::kPhi;</td></tr>
<tr><td class="num" id="LN2156">2156</td><td class="line">              hint = data()-&gt;GetPhiMapValueFor(to_vreg);</td></tr>
<tr><td class="num" id="LN2157">2157</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2158">2158</td><td class="line">          } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2159">2159</td><td class="line">            <span class='keyword'>if</span> (live-&gt;Contains(to_vreg)) {</td></tr>
<tr><td class="num" id="LN2160">2160</td><td class="line">              to_use = Define(curr_position, &amp;to, &amp;from,</td></tr>
<tr><td class="num" id="LN2161">2161</td><td class="line">                              UsePosition::HintTypeForOperand(from));</td></tr>
<tr><td class="num" id="LN2162">2162</td><td class="line">              live-&gt;Remove(to_vreg);</td></tr>
<tr><td class="num" id="LN2163">2163</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2164">2164</td><td class="line">              cur-&gt;Eliminate();</td></tr>
<tr><td class="num" id="LN2165">2165</td><td class="line">              <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2166">2166</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN2167">2167</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN2168">2168</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2169">2169</td><td class="line">          Define(curr_position, &amp;to);</td></tr>
<tr><td class="num" id="LN2170">2170</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2171">2171</td><td class="line">        UsePosition* from_use =</td></tr>
<tr><td class="num" id="LN2172">2172</td><td class="line">            Use(block_start_position, curr_position, &amp;from, hint, hint_type);</td></tr>
<tr><td class="num" id="LN2173">2173</td><td class="line">        <span class='comment'>// Mark range live.</span></td></tr>
<tr><td class="num" id="LN2174">2174</td><td class="line">        <span class='keyword'>if</span> (from.IsUnallocated()) {</td></tr>
<tr><td class="num" id="LN2175">2175</td><td class="line">          live-&gt;Add(UnallocatedOperand::cast(from).virtual_register());</td></tr>
<tr><td class="num" id="LN2176">2176</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2177">2177</td><td class="line">        <span class='comment'>// Resolve use position hints just created.</span></td></tr>
<tr><td class="num" id="LN2178">2178</td><td class="line">        <span class='keyword'>if</span> (to_use != <span class='keyword'>nullptr</span> &amp;&amp; from_use != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2179">2179</td><td class="line">          to_use-&gt;ResolveHint(from_use);</td></tr>
<tr><td class="num" id="LN2180">2180</td><td class="line">          from_use-&gt;ResolveHint(to_use);</td></tr>
<tr><td class="num" id="LN2181">2181</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2182">2182</td><td class="line">        <span class='macro'>DCHECK_IMPLIES(to_use != <span class='keyword'>nullptr</span>, to_use-&gt;IsResolved())<span class='expansion'>do { if ((__builtin_expect(!!(!(!(to_use != nullptr) || (to_use<br>-&gt;IsResolved()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2182, "Check failed: %s.", "!(to_use != nullptr) || (to_use-&gt;IsResolved())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2183">2183</td><td class="line">        <span class='macro'>DCHECK_IMPLIES(from_use != <span class='keyword'>nullptr</span>, from_use-&gt;IsResolved())<span class='expansion'>do { if ((__builtin_expect(!!(!(!(from_use != nullptr) || (from_use<br>-&gt;IsResolved()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2183, "Check failed: %s.", "!(from_use != nullptr) || (from_use-&gt;IsResolved())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2184">2184</td><td class="line">        <span class='comment'>// Potentially resolve phi hint.</span></td></tr>
<tr><td class="num" id="LN2185">2185</td><td class="line">        <span class='keyword'>if</span> (phi_vreg != -1) ResolvePhiHint(&amp;from, from_use);</td></tr>
<tr><td class="num" id="LN2186">2186</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2187">2187</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2188">2188</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2189">2189</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2190">2190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2191">2191</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2192">2192</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::ProcessPhis(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN2193">2193</td><td class="line">                                   BitVector* live) {</td></tr>
<tr><td class="num" id="LN2194">2194</td><td class="line">  <span class='keyword'>for</span> (PhiInstruction* phi : block-&gt;phis()) {</td></tr>
<tr><td class="num" id="LN2195">2195</td><td class="line">    <span class='comment'>// The live range interval already ends at the first instruction of the</span></td></tr>
<tr><td class="num" id="LN2196">2196</td><td class="line">    <span class='comment'>// block.</span></td></tr>
<tr><td class="num" id="LN2197">2197</td><td class="line">    <span class='keyword'>int</span> phi_vreg = phi-&gt;virtual_register();</td></tr>
<tr><td class="num" id="LN2198">2198</td><td class="line">    live-&gt;Remove(phi_vreg);</td></tr>
<tr><td class="num" id="LN2199">2199</td><td class="line">    InstructionOperand* hint = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2200">2200</td><td class="line">    Instruction* instr = GetLastInstruction(</td></tr>
<tr><td class="num" id="LN2201">2201</td><td class="line">        code(), code()-&gt;InstructionBlockAt(block-&gt;predecessors()[0]));</td></tr>
<tr><td class="num" id="LN2202">2202</td><td class="line">    <span class='keyword'>for</span> (MoveOperands* move : *instr-&gt;GetParallelMove(Instruction::END)) {</td></tr>
<tr><td class="num" id="LN2203">2203</td><td class="line">      InstructionOperand&amp; to = move-&gt;destination();</td></tr>
<tr><td class="num" id="LN2204">2204</td><td class="line">      <span class='keyword'>if</span> (to.IsUnallocated() &amp;&amp;</td></tr>
<tr><td class="num" id="LN2205">2205</td><td class="line">          UnallocatedOperand::cast(to).virtual_register() == phi_vreg) {</td></tr>
<tr><td class="num" id="LN2206">2206</td><td class="line">        hint = &amp;move-&gt;source();</td></tr>
<tr><td class="num" id="LN2207">2207</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2208">2208</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2209">2209</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2210">2210</td><td class="line">    <span class='macro'>DCHECK(hint != <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(hint != nullptr)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 2210, "Check failed: %s."<br>, "hint != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2211">2211</td><td class="line">    LifetimePosition block_start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2212">2212</td><td class="line">        block-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN2213">2213</td><td class="line">    UsePosition* use_pos = Define(block_start, &amp;phi-&gt;output(), hint,</td></tr>
<tr><td class="num" id="LN2214">2214</td><td class="line">                                  UsePosition::HintTypeForOperand(*hint));</td></tr>
<tr><td class="num" id="LN2215">2215</td><td class="line">    MapPhiHint(hint, use_pos);</td></tr>
<tr><td class="num" id="LN2216">2216</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2217">2217</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2218">2218</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2219">2219</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2220">2220</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::ProcessLoopHeader(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN2221">2221</td><td class="line">                                         BitVector* live) {</td></tr>
<tr><td class="num" id="LN2222">2222</td><td class="line">  <span class='macro'>DCHECK(block-&gt;IsLoopHeader())<span class='expansion'>do { if ((__builtin_expect(!!(!(block-&gt;IsLoopHeader())), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 2222,<br> "Check failed: %s.", "block-&gt;IsLoopHeader()"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN2223">2223</td><td class="line">  <span class='comment'>// Add a live range stretching from the first loop instruction to the last</span></td></tr>
<tr><td class="num" id="LN2224">2224</td><td class="line">  <span class='comment'>// for each value live on entry to the header.</span></td></tr>
<tr><td class="num" id="LN2225">2225</td><td class="line">  BitVector::Iterator iterator(live);</td></tr>
<tr><td class="num" id="LN2226">2226</td><td class="line">  LifetimePosition start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2227">2227</td><td class="line">      block-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN2228">2228</td><td class="line">  LifetimePosition end = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2229">2229</td><td class="line">                             code()-&gt;LastLoopInstructionIndex(block))</td></tr>
<tr><td class="num" id="LN2230">2230</td><td class="line">                             .NextFullStart();</td></tr>
<tr><td class="num" id="LN2231">2231</td><td class="line">  <span class='keyword'>while</span> (!iterator.Done()) {</td></tr>
<tr><td class="num" id="LN2232">2232</td><td class="line">    <span class='keyword'>int</span> operand_index = iterator.Current();</td></tr>
<tr><td class="num" id="LN2233">2233</td><td class="line">    TopLevelLiveRange* range = data()-&gt;GetOrCreateLiveRangeFor(operand_index);</td></tr>
<tr><td class="num" id="LN2234">2234</td><td class="line">    range-&gt;EnsureInterval(start, end, allocation_zone());</td></tr>
<tr><td class="num" id="LN2235">2235</td><td class="line">    iterator.Advance();</td></tr>
<tr><td class="num" id="LN2236">2236</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2237">2237</td><td class="line">  <span class='comment'>// Insert all values into the live in sets of all blocks in the loop.</span></td></tr>
<tr><td class="num" id="LN2238">2238</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = block-&gt;rpo_number().ToInt() + 1; i &lt; block-&gt;loop_end().ToInt();</td></tr>
<tr><td class="num" id="LN2239">2239</td><td class="line">       ++i) {</td></tr>
<tr><td class="num" id="LN2240">2240</td><td class="line">    live_in_sets()[i]-&gt;Union(*live);</td></tr>
<tr><td class="num" id="LN2241">2241</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2242">2242</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2243">2243</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2244">2244</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2245">2245</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::BuildLiveRanges() {</td></tr>
<tr><td class="num" id="LN2246">2246</td><td class="line">  <span class='comment'>// Process the blocks in reverse order.</span></td></tr>
<tr><td class="num" id="LN2247">2247</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> block_id = code()-&gt;InstructionBlockCount() - 1; block_id &gt;= 0;</td></tr>
<tr><td class="num" id="LN2248">2248</td><td class="line">       --block_id) {</td></tr>
<tr><td class="num" id="LN2249">2249</td><td class="line">    InstructionBlock* block =</td></tr>
<tr><td class="num" id="LN2250">2250</td><td class="line">        code()-&gt;InstructionBlockAt(RpoNumber::FromInt(block_id));</td></tr>
<tr><td class="num" id="LN2251">2251</td><td class="line">    BitVector* live = ComputeLiveOut(block, data());</td></tr>
<tr><td class="num" id="LN2252">2252</td><td class="line">    <span class='comment'>// Initially consider all live_out values live for the entire block. We</span></td></tr>
<tr><td class="num" id="LN2253">2253</td><td class="line">    <span class='comment'>// will shorten these intervals if necessary.</span></td></tr>
<tr><td class="num" id="LN2254">2254</td><td class="line">    AddInitialIntervals(block, live);</td></tr>
<tr><td class="num" id="LN2255">2255</td><td class="line">    <span class='comment'>// Process the instructions in reverse order, generating and killing</span></td></tr>
<tr><td class="num" id="LN2256">2256</td><td class="line">    <span class='comment'>// live values.</span></td></tr>
<tr><td class="num" id="LN2257">2257</td><td class="line">    ProcessInstructions(block, live);</td></tr>
<tr><td class="num" id="LN2258">2258</td><td class="line">    <span class='comment'>// All phi output operands are killed by this block.</span></td></tr>
<tr><td class="num" id="LN2259">2259</td><td class="line">    ProcessPhis(block, live);</td></tr>
<tr><td class="num" id="LN2260">2260</td><td class="line">    <span class='comment'>// Now live is live_in for this block except not including values live</span></td></tr>
<tr><td class="num" id="LN2261">2261</td><td class="line">    <span class='comment'>// out on backward successor edges.</span></td></tr>
<tr><td class="num" id="LN2262">2262</td><td class="line">    <span class='keyword'>if</span> (block-&gt;IsLoopHeader()) ProcessLoopHeader(block, live);</td></tr>
<tr><td class="num" id="LN2263">2263</td><td class="line">    live_in_sets()[block_id] = live;</td></tr>
<tr><td class="num" id="LN2264">2264</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2265">2265</td><td class="line">  <span class='comment'>// Postprocess the ranges.</span></td></tr>
<tr><td class="num" id="LN2266">2266</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN2267">2267</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span>) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2268">2268</td><td class="line">    <span class='comment'>// Give slots to all ranges with a non fixed slot use.</span></td></tr>
<tr><td class="num" id="LN2269">2269</td><td class="line">    <span class='keyword'>if</span> (range-&gt;has_slot_use() &amp;&amp; range-&gt;HasNoSpillType()) {</td></tr>
<tr><td class="num" id="LN2270">2270</td><td class="line">      data()-&gt;AssignSpillRangeToLiveRange(range);</td></tr>
<tr><td class="num" id="LN2271">2271</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2272">2272</td><td class="line">    <span class='comment'>// TODO(bmeurer): This is a horrible hack to make sure that for constant</span></td></tr>
<tr><td class="num" id="LN2273">2273</td><td class="line">    <span class='comment'>// live ranges, every use requires the constant to be in a register.</span></td></tr>
<tr><td class="num" id="LN2274">2274</td><td class="line">    <span class='comment'>// Without this hack, all uses with "any" policy would get the constant</span></td></tr>
<tr><td class="num" id="LN2275">2275</td><td class="line">    <span class='comment'>// operand assigned.</span></td></tr>
<tr><td class="num" id="LN2276">2276</td><td class="line">    <span class='keyword'>if</span> (range-&gt;HasSpillOperand() &amp;&amp; range-&gt;GetSpillOperand()-&gt;IsConstant()) {</td></tr>
<tr><td class="num" id="LN2277">2277</td><td class="line">      <span class='keyword'>for</span> (UsePosition* pos = range-&gt;first_pos(); pos != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2278">2278</td><td class="line">           pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN2279">2279</td><td class="line">        <span class='keyword'>if</span> (pos-&gt;type() == UsePositionType::kRequiresSlot) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2280">2280</td><td class="line">        UsePositionType new_type = UsePositionType::kAny;</td></tr>
<tr><td class="num" id="LN2281">2281</td><td class="line">        <span class='comment'>// Can't mark phis as needing a register.</span></td></tr>
<tr><td class="num" id="LN2282">2282</td><td class="line">        <span class='keyword'>if</span> (!pos-&gt;pos().IsGapPosition()) {</td></tr>
<tr><td class="num" id="LN2283">2283</td><td class="line">          new_type = UsePositionType::kRequiresRegister;</td></tr>
<tr><td class="num" id="LN2284">2284</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2285">2285</td><td class="line">        pos-&gt;set_type(new_type, <span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN2286">2286</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2287">2287</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2288">2288</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2289">2289</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>auto</span> preassigned : data()-&gt;preassigned_slot_ranges()) {</td></tr>
<tr><td class="num" id="LN2290">2290</td><td class="line">    TopLevelLiveRange* range = preassigned.first;</td></tr>
<tr><td class="num" id="LN2291">2291</td><td class="line">    <span class='keyword'>int</span> slot_id = preassigned.second;</td></tr>
<tr><td class="num" id="LN2292">2292</td><td class="line">    SpillRange* spill = range-&gt;HasSpillRange()</td></tr>
<tr><td class="num" id="LN2293">2293</td><td class="line">                            ? range-&gt;GetSpillRange()</td></tr>
<tr><td class="num" id="LN2294">2294</td><td class="line">                            : data()-&gt;AssignSpillRangeToLiveRange(range);</td></tr>
<tr><td class="num" id="LN2295">2295</td><td class="line">    spill-&gt;set_assigned_slot(slot_id);</td></tr>
<tr><td class="num" id="LN2296">2296</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2297">2297</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN2298">2298</td><td class="line">  Verify();</td></tr>
<tr><td class="num" id="LN2299">2299</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2300">2300</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2301">2301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2302">2302</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2303">2303</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::MapPhiHint(InstructionOperand* operand,</td></tr>
<tr><td class="num" id="LN2304">2304</td><td class="line">                                  UsePosition* use_pos) {</td></tr>
<tr><td class="num" id="LN2305">2305</td><td class="line">  <span class='macro'>DCHECK(!use_pos-&gt;IsResolved())<span class='expansion'>do { if ((__builtin_expect(!!(!(!use_pos-&gt;IsResolved())), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 2305,<br> "Check failed: %s.", "!use_pos-&gt;IsResolved()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2306">2306</td><td class="line">  <span class='keyword'>auto</span> res = phi_hints_.insert(std::make_pair(operand, use_pos));</td></tr>
<tr><td class="num" id="LN2307">2307</td><td class="line">  <span class='macro'>DCHECK(res.second)<span class='expansion'>do { if ((__builtin_expect(!!(!(res.second)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 2307, "Check failed: %s."<br>, "res.second"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2308">2308</td><td class="line">  USE(res);</td></tr>
<tr><td class="num" id="LN2309">2309</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2310">2310</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2311">2311</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2312">2312</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::ResolvePhiHint(InstructionOperand* operand,</td></tr>
<tr><td class="num" id="LN2313">2313</td><td class="line">                                      UsePosition* use_pos) {</td></tr>
<tr><td class="num" id="LN2314">2314</td><td class="line">  <span class='keyword'>auto</span> it = phi_hints_.find(operand);</td></tr>
<tr><td class="num" id="LN2315">2315</td><td class="line">  <span class='keyword'>if</span> (it == phi_hints_.end()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2316">2316</td><td class="line">  <span class='macro'>DCHECK(!it-&gt;second-&gt;IsResolved())<span class='expansion'>do { if ((__builtin_expect(!!(!(!it-&gt;second-&gt;IsResolved<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2316, "Check failed: %s.", "!it-&gt;second-&gt;IsResolved()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2317">2317</td><td class="line">  it-&gt;second-&gt;ResolveHint(use_pos);</td></tr>
<tr><td class="num" id="LN2318">2318</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2319">2319</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2320">2320</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2321">2321</td><td class="line"><span class='keyword'>void</span> LiveRangeBuilder::Verify() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2322">2322</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>auto</span>&amp; hint : phi_hints_) {</td></tr>
<tr><td class="num" id="LN2323">2323</td><td class="line">    <span class='macro'>CHECK(hint.second-&gt;IsResolved())<span class='expansion'>do { if ((__builtin_expect(!!(!(hint.second-&gt;IsResolved())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2323<br>, "Check failed: %s.", "hint.second-&gt;IsResolved()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2324">2324</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2325">2325</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* current : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN2326">2326</td><td class="line">    <span class='keyword'>if</span> (current != <span class='keyword'>nullptr</span> &amp;&amp; !current-&gt;IsEmpty()) current-&gt;Verify();</td></tr>
<tr><td class="num" id="LN2327">2327</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2328">2328</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2329">2329</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2330">2330</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2331">2331</td><td class="line">RegisterAllocator::RegisterAllocator(RegisterAllocationData* data,</td></tr>
<tr><td class="num" id="LN2332">2332</td><td class="line">                                     RegisterKind kind)</td></tr>
<tr><td class="num" id="LN2333">2333</td><td class="line">    : data_(data),</td></tr>
<tr><td class="num" id="LN2334">2334</td><td class="line">      mode_(kind),</td></tr>
<tr><td class="num" id="LN2335">2335</td><td class="line">      num_registers_(GetRegisterCount(data-&gt;config(), kind)),</td></tr>
<tr><td class="num" id="LN2336">2336</td><td class="line">      num_allocatable_registers_(</td></tr>
<tr><td class="num" id="LN2337">2337</td><td class="line">          GetAllocatableRegisterCount(data-&gt;config(), kind)),</td></tr>
<tr><td class="num" id="LN2338">2338</td><td class="line">      allocatable_register_codes_(</td></tr>
<tr><td class="num" id="LN2339">2339</td><td class="line">          GetAllocatableRegisterCodes(data-&gt;config(), kind)) {}</td></tr>
<tr><td class="num" id="LN2340">2340</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2341">2341</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2342">2342</td><td class="line">LifetimePosition RegisterAllocator::GetSplitPositionForInstruction(</td></tr>
<tr><td class="num" id="LN2343">2343</td><td class="line">    <span class='keyword'>const</span> LiveRange* range, <span class='keyword'>int</span> instruction_index) {</td></tr>
<tr><td class="num" id="LN2344">2344</td><td class="line">  LifetimePosition ret = LifetimePosition::Invalid();</td></tr>
<tr><td class="num" id="LN2345">2345</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2346">2346</td><td class="line">  ret = LifetimePosition::GapFromInstructionIndex(instruction_index);</td></tr>
<tr><td class="num" id="LN2347">2347</td><td class="line">  <span class='keyword'>if</span> (range-&gt;Start() &gt;= ret || ret &gt;= range-&gt;End()) {</td></tr>
<tr><td class="num" id="LN2348">2348</td><td class="line">    <span class='keyword'>return</span> LifetimePosition::Invalid();</td></tr>
<tr><td class="num" id="LN2349">2349</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2350">2350</td><td class="line">  <span class='keyword'>return</span> ret;</td></tr>
<tr><td class="num" id="LN2351">2351</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2352">2352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2353">2353</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2354">2354</td><td class="line"><span class='keyword'>void</span> RegisterAllocator::SplitAndSpillRangesDefinedByMemoryOperand(</td></tr>
<tr><td class="num" id="LN2355">2355</td><td class="line">    <span class='keyword'>bool</span> operands_only) {</td></tr>
<tr><td class="num" id="LN2356">2356</td><td class="line">  size_t initial_range_count = data()-&gt;live_ranges().size();</td></tr>
<tr><td class="num" id="LN2357">2357</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; initial_range_count; ++i) {</td></tr>
<tr><td class="num" id="LN2358">2358</td><td class="line">    TopLevelLiveRange* range = data()-&gt;live_ranges()[i];</td></tr>
<tr><td class="num" id="LN2359">2359</td><td class="line">    <span class='keyword'>if</span> (!CanProcessRange(range)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2360">2360</td><td class="line">    <span class='keyword'>if</span> (range-&gt;HasNoSpillType() || (operands_only &amp;&amp; range-&gt;HasSpillRange())) {</td></tr>
<tr><td class="num" id="LN2361">2361</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2362">2362</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2363">2363</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2364">2364</td><td class="line">    LifetimePosition start = range-&gt;Start();</td></tr>
<tr><td class="num" id="LN2365">2365</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Live range %d:%d is defined by a spill operand.\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Live range %d:%d is defined by a spill operand.\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2366">2366</td><td class="line">          <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Live range %d:%d is defined by a spill operand.\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2367">2367</td><td class="line">    LifetimePosition next_pos = start;</td></tr>
<tr><td class="num" id="LN2368">2368</td><td class="line">    <span class='keyword'>if</span> (next_pos.IsGapPosition()) {</td></tr>
<tr><td class="num" id="LN2369">2369</td><td class="line">      next_pos = next_pos.NextStart();</td></tr>
<tr><td class="num" id="LN2370">2370</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2371">2371</td><td class="line">    UsePosition* pos = range-&gt;NextUsePositionRegisterIsBeneficial(next_pos);</td></tr>
<tr><td class="num" id="LN2372">2372</td><td class="line">    <span class='comment'>// If the range already has a spill operand and it doesn't need a</span></td></tr>
<tr><td class="num" id="LN2373">2373</td><td class="line">    <span class='comment'>// register immediately, split it and spill the first part of the range.</span></td></tr>
<tr><td class="num" id="LN2374">2374</td><td class="line">    <span class='keyword'>if</span> (pos == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2375">2375</td><td class="line">      Spill(range);</td></tr>
<tr><td class="num" id="LN2376">2376</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (pos-&gt;pos() &gt; range-&gt;Start().NextStart()) {</td></tr>
<tr><td class="num" id="LN2377">2377</td><td class="line">      <span class='comment'>// Do not spill live range eagerly if use position that can benefit from</span></td></tr>
<tr><td class="num" id="LN2378">2378</td><td class="line">      <span class='comment'>// the register is too close to the start of live range.</span></td></tr>
<tr><td class="num" id="LN2379">2379</td><td class="line">      LifetimePosition split_pos = GetSplitPositionForInstruction(</td></tr>
<tr><td class="num" id="LN2380">2380</td><td class="line">          range, pos-&gt;pos().ToInstructionIndex());</td></tr>
<tr><td class="num" id="LN2381">2381</td><td class="line">      <span class='comment'>// There is no place to split, so we can't split and spill.</span></td></tr>
<tr><td class="num" id="LN2382">2382</td><td class="line">      <span class='keyword'>if</span> (!split_pos.IsValid()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2383">2383</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2384">2384</td><td class="line">      split_pos =</td></tr>
<tr><td class="num" id="LN2385">2385</td><td class="line">          FindOptimalSplitPos(range-&gt;Start().NextFullStart(), split_pos);</td></tr>
<tr><td class="num" id="LN2386">2386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2387">2387</td><td class="line">      SplitRangeAt(range, split_pos);</td></tr>
<tr><td class="num" id="LN2388">2388</td><td class="line">      Spill(range);</td></tr>
<tr><td class="num" id="LN2389">2389</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2390">2390</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2391">2391</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2392">2392</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2393">2393</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2394">2394</td><td class="line">LiveRange* RegisterAllocator::SplitRangeAt(LiveRange* range,</td></tr>
<tr><td class="num" id="LN2395">2395</td><td class="line">                                           LifetimePosition pos) {</td></tr>
<tr><td class="num" id="LN2396">2396</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;TopLevel()-&gt;IsFixed())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;TopLevel()-&gt;IsFixed<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2396, "Check failed: %s.", "!range-&gt;TopLevel()-&gt;IsFixed()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2397">2397</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Splitting live range %d:%d at %d\n"</span>, range-&gt;TopLevel()-&gt;vreg(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Splitting live range %d:%d at %d\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), pos<br>.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2398">2398</td><td class="line">        <span class='macro'>range-&gt;relative_id(), pos.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Splitting live range %d:%d at %d\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), pos<br>.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2399">2399</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2400">2400</td><td class="line">  <span class='keyword'>if</span> (pos &lt;= range-&gt;Start()) <span class='keyword'>return</span> range;</td></tr>
<tr><td class="num" id="LN2401">2401</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2402">2402</td><td class="line">  <span class='comment'>// We can't properly connect liveranges if splitting occurred at the end</span></td></tr>
<tr><td class="num" id="LN2403">2403</td><td class="line">  <span class='comment'>// a block.</span></td></tr>
<tr><td class="num" id="LN2404">2404</td><td class="line">  <span class='macro'>DCHECK(pos.IsStart() || pos.IsGapPosition() ||<span class='expansion'>do { if ((__builtin_expect(!!(!(pos.IsStart() || pos.IsGapPosition<br>() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index<br>() != pos.ToInstructionIndex()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2406, "Check failed: %s.", "pos.IsStart() || pos.IsGapPosition() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index() != pos.ToInstructionIndex())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2405">2405</td><td class="line">         <span class='macro'>(GetInstructionBlock(code(), pos)-&gt;last_instruction_index() !=<span class='expansion'>do { if ((__builtin_expect(!!(!(pos.IsStart() || pos.IsGapPosition<br>() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index<br>() != pos.ToInstructionIndex()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2406, "Check failed: %s.", "pos.IsStart() || pos.IsGapPosition() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index() != pos.ToInstructionIndex())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2406">2406</td><td class="line">          <span class='macro'>pos.ToInstructionIndex()))<span class='expansion'>do { if ((__builtin_expect(!!(!(pos.IsStart() || pos.IsGapPosition<br>() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index<br>() != pos.ToInstructionIndex()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2406, "Check failed: %s.", "pos.IsStart() || pos.IsGapPosition() || (GetInstructionBlock(code(), pos)-&gt;last_instruction_index() != pos.ToInstructionIndex())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2407">2407</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2408">2408</td><td class="line">  LiveRange* result = range-&gt;SplitAt(pos, allocation_zone());</td></tr>
<tr><td class="num" id="LN2409">2409</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN2410">2410</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2411">2411</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2412">2412</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2413">2413</td><td class="line">LiveRange* RegisterAllocator::SplitBetween(LiveRange* range,</td></tr>
<tr><td class="num" id="LN2414">2414</td><td class="line">                                           LifetimePosition start,</td></tr>
<tr><td class="num" id="LN2415">2415</td><td class="line">                                           LifetimePosition end) {</td></tr>
<tr><td class="num" id="LN2416">2416</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;TopLevel()-&gt;IsFixed())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;TopLevel()-&gt;IsFixed<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2416, "Check failed: %s.", "!range-&gt;TopLevel()-&gt;IsFixed()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2417">2417</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Splitting live range %d:%d in position between [%d, %d]\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Splitting live range %d:%d in position between [%d, %d]\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), start<br>.value(), end.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2418">2418</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), start.value(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Splitting live range %d:%d in position between [%d, %d]\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), start<br>.value(), end.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2419">2419</td><td class="line">        <span class='macro'>end.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Splitting live range %d:%d in position between [%d, %d]\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), start<br>.value(), end.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2420">2420</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2421">2421</td><td class="line">  LifetimePosition split_pos = FindOptimalSplitPos(start, end);</td></tr>
<tr><td class="num" id="LN2422">2422</td><td class="line">  <span class='macro'>DCHECK(split_pos &gt;= start)<span class='expansion'>do { if ((__builtin_expect(!!(!(split_pos &gt;= start)), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 2422, "Check failed: %s."<br>, "split_pos &gt;= start"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2423">2423</td><td class="line">  <span class='keyword'>return</span> SplitRangeAt(range, split_pos);</td></tr>
<tr><td class="num" id="LN2424">2424</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2425">2425</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2426">2426</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2427">2427</td><td class="line">LifetimePosition RegisterAllocator::FindOptimalSplitPos(LifetimePosition start,</td></tr>
<tr><td class="num" id="LN2428">2428</td><td class="line">                                                        LifetimePosition end) {</td></tr>
<tr><td class="num" id="LN2429">2429</td><td class="line">  <span class='keyword'>int</span> start_instr = start.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN2430">2430</td><td class="line">  <span class='keyword'>int</span> end_instr = end.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN2431">2431</td><td class="line">  <span class='macro'>DCHECK(start_instr &lt;= end_instr)<span class='expansion'>do { if ((__builtin_expect(!!(!(start_instr &lt;= end_instr))<br>, 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2431<br>, "Check failed: %s.", "start_instr &lt;= end_instr"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2432">2432</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2433">2433</td><td class="line">  <span class='comment'>// We have no choice</span></td></tr>
<tr><td class="num" id="LN2434">2434</td><td class="line">  <span class='keyword'>if</span> (start_instr == end_instr) <span class='keyword'>return</span> end;</td></tr>
<tr><td class="num" id="LN2435">2435</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2436">2436</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* start_block = GetInstructionBlock(code(), start);</td></tr>
<tr><td class="num" id="LN2437">2437</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* end_block = GetInstructionBlock(code(), end);</td></tr>
<tr><td class="num" id="LN2438">2438</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2439">2439</td><td class="line">  <span class='keyword'>if</span> (end_block == start_block) {</td></tr>
<tr><td class="num" id="LN2440">2440</td><td class="line">    <span class='comment'>// The interval is split in the same basic block. Split at the latest</span></td></tr>
<tr><td class="num" id="LN2441">2441</td><td class="line">    <span class='comment'>// possible position.</span></td></tr>
<tr><td class="num" id="LN2442">2442</td><td class="line">    <span class='keyword'>return</span> end;</td></tr>
<tr><td class="num" id="LN2443">2443</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2444">2444</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2445">2445</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* block = end_block;</td></tr>
<tr><td class="num" id="LN2446">2446</td><td class="line">  <span class='comment'>// Find header of outermost loop.</span></td></tr>
<tr><td class="num" id="LN2447">2447</td><td class="line">  <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN2448">2448</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* loop = GetContainingLoop(code(), block);</td></tr>
<tr><td class="num" id="LN2449">2449</td><td class="line">    <span class='keyword'>if</span> (loop == <span class='keyword'>nullptr</span> ||</td></tr>
<tr><td class="num" id="LN2450">2450</td><td class="line">        loop-&gt;rpo_number().ToInt() &lt;= start_block-&gt;rpo_number().ToInt()) {</td></tr>
<tr><td class="num" id="LN2451">2451</td><td class="line">      <span class='comment'>// No more loops or loop starts before the lifetime start.</span></td></tr>
<tr><td class="num" id="LN2452">2452</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN2453">2453</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2454">2454</td><td class="line">    block = loop;</td></tr>
<tr><td class="num" id="LN2455">2455</td><td class="line">  } <span class='keyword'>while</span> (<span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN2456">2456</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2457">2457</td><td class="line">  <span class='comment'>// We did not find any suitable outer loop. Split at the latest possible</span></td></tr>
<tr><td class="num" id="LN2458">2458</td><td class="line">  <span class='comment'>// position unless end_block is a loop header itself.</span></td></tr>
<tr><td class="num" id="LN2459">2459</td><td class="line">  <span class='keyword'>if</span> (block == end_block &amp;&amp; !end_block-&gt;IsLoopHeader()) <span class='keyword'>return</span> end;</td></tr>
<tr><td class="num" id="LN2460">2460</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2461">2461</td><td class="line">  <span class='keyword'>return</span> LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2462">2462</td><td class="line">      block-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN2463">2463</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2464">2464</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2465">2465</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2466">2466</td><td class="line">LifetimePosition RegisterAllocator::FindOptimalSpillingPos(</td></tr>
<tr><td class="num" id="LN2467">2467</td><td class="line">    LiveRange* range, LifetimePosition pos) {</td></tr>
<tr><td class="num" id="LN2468">2468</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* block = GetInstructionBlock(code(), pos.Start());</td></tr>
<tr><td class="num" id="LN2469">2469</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* loop_header =</td></tr>
<tr><td class="num" id="LN2470">2470</td><td class="line">      block-&gt;IsLoopHeader() ? block : GetContainingLoop(code(), block);</td></tr>
<tr><td class="num" id="LN2471">2471</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2472">2472</td><td class="line">  <span class='keyword'>if</span> (loop_header == <span class='keyword'>nullptr</span>) <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN2473">2473</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2474">2474</td><td class="line">  <span class='keyword'>const</span> UsePosition* prev_use =</td></tr>
<tr><td class="num" id="LN2475">2475</td><td class="line">      range-&gt;PreviousUsePositionRegisterIsBeneficial(pos);</td></tr>
<tr><td class="num" id="LN2476">2476</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2477">2477</td><td class="line">  <span class='keyword'>while</span> (loop_header != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2478">2478</td><td class="line">    <span class='comment'>// We are going to spill live range inside the loop.</span></td></tr>
<tr><td class="num" id="LN2479">2479</td><td class="line">    <span class='comment'>// If possible try to move spilling position backwards to loop header.</span></td></tr>
<tr><td class="num" id="LN2480">2480</td><td class="line">    <span class='comment'>// This will reduce number of memory moves on the back edge.</span></td></tr>
<tr><td class="num" id="LN2481">2481</td><td class="line">    LifetimePosition loop_start = LifetimePosition::GapFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2482">2482</td><td class="line">        loop_header-&gt;first_instruction_index());</td></tr>
<tr><td class="num" id="LN2483">2483</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2484">2484</td><td class="line">    <span class='keyword'>if</span> (range-&gt;Covers(loop_start)) {</td></tr>
<tr><td class="num" id="LN2485">2485</td><td class="line">      <span class='keyword'>if</span> (prev_use == <span class='keyword'>nullptr</span> || prev_use-&gt;pos() &lt; loop_start) {</td></tr>
<tr><td class="num" id="LN2486">2486</td><td class="line">        <span class='comment'>// No register beneficial use inside the loop before the pos.</span></td></tr>
<tr><td class="num" id="LN2487">2487</td><td class="line">        pos = loop_start;</td></tr>
<tr><td class="num" id="LN2488">2488</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2489">2489</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2490">2490</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2491">2491</td><td class="line">    <span class='comment'>// Try hoisting out to an outer loop.</span></td></tr>
<tr><td class="num" id="LN2492">2492</td><td class="line">    loop_header = GetContainingLoop(code(), loop_header);</td></tr>
<tr><td class="num" id="LN2493">2493</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2494">2494</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2495">2495</td><td class="line">  <span class='keyword'>return</span> pos;</td></tr>
<tr><td class="num" id="LN2496">2496</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2497">2497</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2498">2498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2499">2499</td><td class="line"><span class='keyword'>void</span> RegisterAllocator::Spill(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2500">2500</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;spilled())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2500, "Check failed: %s."<br>, "!range-&gt;spilled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2501">2501</td><td class="line">  TopLevelLiveRange* first = range-&gt;TopLevel();</td></tr>
<tr><td class="num" id="LN2502">2502</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Spilling live range %d:%d\n"</span>, first-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Spilling live range %d:%d\n"<br>, first-&gt;vreg(), range-&gt;relative_id()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2503">2503</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2504">2504</td><td class="line">  <span class='keyword'>if</span> (first-&gt;HasNoSpillType()) {</td></tr>
<tr><td class="num" id="LN2505">2505</td><td class="line">    data()-&gt;AssignSpillRangeToLiveRange(first);</td></tr>
<tr><td class="num" id="LN2506">2506</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2507">2507</td><td class="line">  range-&gt;Spill();</td></tr>
<tr><td class="num" id="LN2508">2508</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2509">2509</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2510">2510</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2511">2511</td><td class="line"><span class='keyword'>const</span> ZoneVector&lt;TopLevelLiveRange*&gt;&amp; RegisterAllocator::GetFixedRegisters()</td></tr>
<tr><td class="num" id="LN2512">2512</td><td class="line">    <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2513">2513</td><td class="line">  <span class='keyword'>return</span> mode() == DOUBLE_REGISTERS ? data()-&gt;fixed_double_live_ranges()</td></tr>
<tr><td class="num" id="LN2514">2514</td><td class="line">                                    : data()-&gt;fixed_live_ranges();</td></tr>
<tr><td class="num" id="LN2515">2515</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2516">2516</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2517">2517</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2518">2518</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>char</span>* RegisterAllocator::RegisterName(<span class='keyword'>int</span> register_code) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2519">2519</td><td class="line">  <span class='keyword'>if</span> (mode() == GENERAL_REGISTERS) {</td></tr>
<tr><td class="num" id="LN2520">2520</td><td class="line">    <span class='keyword'>return</span> data()-&gt;config()-&gt;GetGeneralRegisterName(register_code);</td></tr>
<tr><td class="num" id="LN2521">2521</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2522">2522</td><td class="line">    <span class='keyword'>return</span> data()-&gt;config()-&gt;GetDoubleRegisterName(register_code);</td></tr>
<tr><td class="num" id="LN2523">2523</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2524">2524</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2525">2525</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2526">2526</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2527">2527</td><td class="line">LinearScanAllocator::LinearScanAllocator(RegisterAllocationData* data,</td></tr>
<tr><td class="num" id="LN2528">2528</td><td class="line">                                         RegisterKind kind, Zone* local_zone)</td></tr>
<tr><td class="num" id="LN2529">2529</td><td class="line">    : RegisterAllocator(data, kind),</td></tr>
<tr><td class="num" id="LN2530">2530</td><td class="line">      unhandled_live_ranges_(local_zone),</td></tr>
<tr><td class="num" id="LN2531">2531</td><td class="line">      active_live_ranges_(local_zone),</td></tr>
<tr><td class="num" id="LN2532">2532</td><td class="line">      inactive_live_ranges_(local_zone) {</td></tr>
<tr><td class="num" id="LN2533">2533</td><td class="line">  unhandled_live_ranges().reserve(</td></tr>
<tr><td class="num" id="LN2534">2534</td><td class="line">      <span class='keyword'>static_cast</span>&lt;size_t&gt;(code()-&gt;VirtualRegisterCount() * 2));</td></tr>
<tr><td class="num" id="LN2535">2535</td><td class="line">  active_live_ranges().reserve(8);</td></tr>
<tr><td class="num" id="LN2536">2536</td><td class="line">  inactive_live_ranges().reserve(8);</td></tr>
<tr><td class="num" id="LN2537">2537</td><td class="line">  <span class='comment'>// TryAllocateFreeReg and AllocateBlockedReg assume this</span></td></tr>
<tr><td class="num" id="LN2538">2538</td><td class="line">  <span class='comment'>// when allocating local arrays.</span></td></tr>
<tr><td class="num" id="LN2539">2539</td><td class="line">  <span class='macro'>DCHECK(RegisterConfiguration::kMaxDoubleRegisters &gt;=<span class='expansion'>do { if ((__builtin_expect(!!(!(RegisterConfiguration::kMaxDoubleRegisters<br> &gt;= this-&gt;data()-&gt;config()-&gt;num_general_registers<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2540, "Check failed: %s.", "RegisterConfiguration::kMaxDoubleRegisters &gt;= this-&gt;data()-&gt;config()-&gt;num_general_registers()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2540">2540</td><td class="line">         <span class='keyword'><span class='macro'>this</span>-&gt;data()-&gt;config()-&gt;num_general_registers())<span class='expansion'>do { if ((__builtin_expect(!!(!(RegisterConfiguration::kMaxDoubleRegisters<br> &gt;= this-&gt;data()-&gt;config()-&gt;num_general_registers<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2540, "Check failed: %s.", "RegisterConfiguration::kMaxDoubleRegisters &gt;= this-&gt;data()-&gt;config()-&gt;num_general_registers()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2541">2541</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2542">2542</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2543">2543</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2544">2544</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AllocateRegisters() {</td></tr>
<tr><td class="num" id="LN2545">2545</td><td class="line">  <span class='macro'>DCHECK(unhandled_live_ranges().empty())<span class='expansion'>do { if ((__builtin_expect(!!(!(unhandled_live_ranges().empty<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2545, "Check failed: %s.", "unhandled_live_ranges().empty()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2546">2546</td><td class="line">  <span class='macro'>DCHECK(active_live_ranges().empty())<span class='expansion'>do { if ((__builtin_expect(!!(!(active_live_ranges().empty())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2546<br>, "Check failed: %s.", "active_live_ranges().empty()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2547">2547</td><td class="line">  <span class='macro'>DCHECK(inactive_live_ranges().empty())<span class='expansion'>do { if ((__builtin_expect(!!(!(inactive_live_ranges().empty(<br>))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc",<br> 2547, "Check failed: %s.", "inactive_live_ranges().empty()")<br>; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2548">2548</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2549">2549</td><td class="line">  SplitAndSpillRangesDefinedByMemoryOperand(code()-&gt;VirtualRegisterCount() &lt;=</td></tr>
<tr><td class="num" id="LN2550">2550</td><td class="line">                                            num_allocatable_registers());</td></tr>
<tr><td class="num" id="LN2551">2551</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2552">2552</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN2553">2553</td><td class="line">    <span class='keyword'>if</span> (!CanProcessRange(range)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2554">2554</td><td class="line">    <span class='keyword'>for</span> (LiveRange* to_add = range; to_add != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2555">2555</td><td class="line">         to_add = to_add-&gt;next()) {</td></tr>
<tr><td class="num" id="LN2556">2556</td><td class="line">      <span class='keyword'>if</span> (!to_add-&gt;spilled()) {</td></tr>
<tr><td class="num" id="LN2557">2557</td><td class="line">        AddToUnhandledUnsorted(to_add);</td></tr>
<tr><td class="num" id="LN2558">2558</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2559">2559</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2560">2560</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2561">2561</td><td class="line">  SortUnhandled();</td></tr>
<tr><td class="num" id="LN2562">2562</td><td class="line">  <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2562, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2563">2563</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2564">2564</td><td class="line">  <span class='keyword'>auto</span>&amp; fixed_ranges = GetFixedRegisters();</td></tr>
<tr><td class="num" id="LN2565">2565</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* current : fixed_ranges) {</td></tr>
<tr><td class="num" id="LN2566">2566</td><td class="line">    <span class='keyword'>if</span> (current != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2567">2567</td><td class="line">      <span class='macro'>DCHECK_EQ(mode(), current-&gt;kind())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (mode()<br>), (current-&gt;kind()), "mode()" " " "==" " " "current-&gt;kind()"<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 2567, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2568">2568</td><td class="line">      AddToInactive(current);</td></tr>
<tr><td class="num" id="LN2569">2569</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2570">2570</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2571">2571</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2572">2572</td><td class="line">  <span class='keyword'>while</span> (!unhandled_live_ranges().empty()) {</td></tr>
<tr><td class="num" id="LN2573">2573</td><td class="line">    <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2573, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2574">2574</td><td class="line">    LiveRange* current = unhandled_live_ranges().back();</td></tr>
<tr><td class="num" id="LN2575">2575</td><td class="line">    unhandled_live_ranges().pop_back();</td></tr>
<tr><td class="num" id="LN2576">2576</td><td class="line">    <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2576, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2577">2577</td><td class="line">    LifetimePosition position = current-&gt;Start();</td></tr>
<tr><td class="num" id="LN2578">2578</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN2579">2579</td><td class="line">    allocation_finger_ = position;</td></tr>
<tr><td class="num" id="LN2580">2580</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN2581">2581</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Processing interval %d:%d start=%d\n"</span>, current-&gt;TopLevel()-&gt;vreg(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Processing interval %d:%d start=%d\n"<br>, current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id(<br>), position.value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2582">2582</td><td class="line">          <span class='macro'>current-&gt;relative_id(), position.value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Processing interval %d:%d start=%d\n"<br>, current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id(<br>), position.value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2583">2583</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2584">2584</td><td class="line">    <span class='keyword'>if</span> (current-&gt;IsTopLevel() &amp;&amp; TryReuseSpillForPhi(current-&gt;TopLevel()))</td></tr>
<tr><td class="num" id="LN2585">2585</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2586">2586</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2587">2587</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; active_live_ranges().size(); ++i) {</td></tr>
<tr><td class="num" id="LN2588">2588</td><td class="line">      LiveRange* cur_active = active_live_ranges()[i];</td></tr>
<tr><td class="num" id="LN2589">2589</td><td class="line">      <span class='keyword'>if</span> (cur_active-&gt;End() &lt;= position) {</td></tr>
<tr><td class="num" id="LN2590">2590</td><td class="line">        ActiveToHandled(cur_active);</td></tr>
<tr><td class="num" id="LN2591">2591</td><td class="line">        --i;  <span class='comment'>// The live range was removed from the list of active live ranges.</span></td></tr>
<tr><td class="num" id="LN2592">2592</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (!cur_active-&gt;Covers(position)) {</td></tr>
<tr><td class="num" id="LN2593">2593</td><td class="line">        ActiveToInactive(cur_active);</td></tr>
<tr><td class="num" id="LN2594">2594</td><td class="line">        --i;  <span class='comment'>// The live range was removed from the list of active live ranges.</span></td></tr>
<tr><td class="num" id="LN2595">2595</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2596">2596</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2597">2597</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2598">2598</td><td class="line">    <span class='keyword'>for</span> (size_t i = 0; i &lt; inactive_live_ranges().size(); ++i) {</td></tr>
<tr><td class="num" id="LN2599">2599</td><td class="line">      LiveRange* cur_inactive = inactive_live_ranges()[i];</td></tr>
<tr><td class="num" id="LN2600">2600</td><td class="line">      <span class='keyword'>if</span> (cur_inactive-&gt;End() &lt;= position) {</td></tr>
<tr><td class="num" id="LN2601">2601</td><td class="line">        InactiveToHandled(cur_inactive);</td></tr>
<tr><td class="num" id="LN2602">2602</td><td class="line">        --i;  <span class='comment'>// Live range was removed from the list of inactive live ranges.</span></td></tr>
<tr><td class="num" id="LN2603">2603</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (cur_inactive-&gt;Covers(position)) {</td></tr>
<tr><td class="num" id="LN2604">2604</td><td class="line">        InactiveToActive(cur_inactive);</td></tr>
<tr><td class="num" id="LN2605">2605</td><td class="line">        --i;  <span class='comment'>// Live range was removed from the list of inactive live ranges.</span></td></tr>
<tr><td class="num" id="LN2606">2606</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2607">2607</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2608">2608</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2609">2609</td><td class="line">    <span class='macro'>DCHECK(!current-&gt;HasRegisterAssigned() &amp;&amp; !current-&gt;spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!current-&gt;HasRegisterAssigned<br>() &amp;&amp; !current-&gt;spilled())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2609, "Check failed: %s.", "!current-&gt;HasRegisterAssigned() &amp;&amp; !current-&gt;spilled()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2610">2610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2611">2611</td><td class="line">    <span class='keyword'>bool</span> result = TryAllocateFreeReg(current);</td></tr>
<tr><td class="num" id="LN2612">2612</td><td class="line">    <span class='keyword'>if</span> (!result) AllocateBlockedReg(current);</td></tr>
<tr><td class="num" id="LN2613">2613</td><td class="line">    <span class='keyword'>if</span> (current-&gt;HasRegisterAssigned()) {</td></tr>
<tr><td class="num" id="LN2614">2614</td><td class="line">      AddToActive(current);</td></tr>
<tr><td class="num" id="LN2615">2615</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2616">2616</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2617">2617</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2618">2618</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2619">2619</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2620">2620</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SetLiveRangeAssignedRegister(LiveRange* range,</td></tr>
<tr><td class="num" id="LN2621">2621</td><td class="line">                                                       <span class='keyword'>int</span> reg) {</td></tr>
<tr><td class="num" id="LN2622">2622</td><td class="line">  data()-&gt;MarkAllocated(range-&gt;kind(), reg);</td></tr>
<tr><td class="num" id="LN2623">2623</td><td class="line">  range-&gt;set_assigned_register(reg);</td></tr>
<tr><td class="num" id="LN2624">2624</td><td class="line">  range-&gt;SetUseHints(reg);</td></tr>
<tr><td class="num" id="LN2625">2625</td><td class="line">  <span class='keyword'>if</span> (range-&gt;IsTopLevel() &amp;&amp; range-&gt;TopLevel()-&gt;is_phi()) {</td></tr>
<tr><td class="num" id="LN2626">2626</td><td class="line">    data()-&gt;GetPhiMapValueFor(range-&gt;TopLevel())-&gt;set_assigned_register(reg);</td></tr>
<tr><td class="num" id="LN2627">2627</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2628">2628</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2629">2629</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2630">2630</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2631">2631</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AddToActive(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2632">2632</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add live range %d:%d to active\n"</span>, range-&gt;TopLevel()-&gt;vreg(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to active\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2633">2633</td><td class="line">        <span class='macro'>range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to active\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2634">2634</td><td class="line">  active_live_ranges().push_back(range);</td></tr>
<tr><td class="num" id="LN2635">2635</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2636">2636</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2637">2637</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2638">2638</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AddToInactive(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2639">2639</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add live range %d:%d to inactive\n"</span>, range-&gt;TopLevel()-&gt;vreg(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to inactive\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2640">2640</td><td class="line">        <span class='macro'>range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to inactive\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2641">2641</td><td class="line">  inactive_live_ranges().push_back(range);</td></tr>
<tr><td class="num" id="LN2642">2642</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2643">2643</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2644">2644</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2645">2645</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AddToUnhandledSorted(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2646">2646</td><td class="line">  <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span> || range-&gt;IsEmpty()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2647">2647</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;HasRegisterAssigned() &amp;&amp; !range-&gt;spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;HasRegisterAssigned<br>() &amp;&amp; !range-&gt;spilled())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2647, "Check failed: %s.", "!range-&gt;HasRegisterAssigned() &amp;&amp; !range-&gt;spilled()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2648">2648</td><td class="line">  <span class='macro'>DCHECK(allocation_finger_ &lt;= range-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(allocation_finger_ &lt;= range<br>-&gt;Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2648, "Check failed: %s.", "allocation_finger_ &lt;= range-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2649">2649</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(unhandled_live_ranges().size() - 1); i &gt;= 0;</td></tr>
<tr><td class="num" id="LN2650">2650</td><td class="line">       --i) {</td></tr>
<tr><td class="num" id="LN2651">2651</td><td class="line">    LiveRange* cur_range = unhandled_live_ranges().at(i);</td></tr>
<tr><td class="num" id="LN2652">2652</td><td class="line">    <span class='keyword'>if</span> (!range-&gt;ShouldBeAllocatedBefore(cur_range)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2653">2653</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Add live range %d:%d to unhandled at %d\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled at %d\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), i<br> + 1); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2654">2654</td><td class="line">          <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), i + 1)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled at %d\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id(), i<br> + 1); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2655">2655</td><td class="line">    <span class='keyword'>auto</span> it = unhandled_live_ranges().begin() + (i + 1);</td></tr>
<tr><td class="num" id="LN2656">2656</td><td class="line">    unhandled_live_ranges().insert(it, range);</td></tr>
<tr><td class="num" id="LN2657">2657</td><td class="line">    <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2657, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2658">2658</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2659">2659</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2660">2660</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add live range %d:%d to unhandled at start\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled at start\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2661">2661</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled at start\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2662">2662</td><td class="line">  unhandled_live_ranges().insert(unhandled_live_ranges().begin(), range);</td></tr>
<tr><td class="num" id="LN2663">2663</td><td class="line">  <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2663, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2664">2664</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2665">2665</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2666">2666</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2667">2667</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AddToUnhandledUnsorted(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2668">2668</td><td class="line">  <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span> || range-&gt;IsEmpty()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2669">2669</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;HasRegisterAssigned() &amp;&amp; !range-&gt;spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;HasRegisterAssigned<br>() &amp;&amp; !range-&gt;spilled())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2669, "Check failed: %s.", "!range-&gt;HasRegisterAssigned() &amp;&amp; !range-&gt;spilled()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2670">2670</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Add live range %d:%d to unhandled unsorted at end\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled unsorted at end\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2671">2671</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Add live range %d:%d to unhandled unsorted at end\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2672">2672</td><td class="line">  unhandled_live_ranges().push_back(range);</td></tr>
<tr><td class="num" id="LN2673">2673</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2674">2674</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2675">2675</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2676">2676</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>bool</span> UnhandledSortHelper(LiveRange* a, LiveRange* b) {</td></tr>
<tr><td class="num" id="LN2677">2677</td><td class="line">  <span class='macro'>DCHECK(!a-&gt;ShouldBeAllocatedBefore(b) || !b-&gt;ShouldBeAllocatedBefore(a))<span class='expansion'>do { if ((__builtin_expect(!!(!(!a-&gt;ShouldBeAllocatedBefore<br>(b) || !b-&gt;ShouldBeAllocatedBefore(a))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2677, "Check failed: %s.", "!a-&gt;ShouldBeAllocatedBefore(b) || !b-&gt;ShouldBeAllocatedBefore(a)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2678">2678</td><td class="line">  <span class='keyword'>if</span> (a-&gt;ShouldBeAllocatedBefore(b)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2679">2679</td><td class="line">  <span class='keyword'>if</span> (b-&gt;ShouldBeAllocatedBefore(a)) <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2680">2680</td><td class="line">  <span class='keyword'>return</span> a-&gt;TopLevel()-&gt;vreg() &lt; b-&gt;TopLevel()-&gt;vreg();</td></tr>
<tr><td class="num" id="LN2681">2681</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2682">2682</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2683">2683</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2684">2684</td><td class="line"><span class='comment'>// Sort the unhandled live ranges so that the ranges to be processed first are</span></td></tr>
<tr><td class="num" id="LN2685">2685</td><td class="line"><span class='comment'>// at the end of the array list.  This is convenient for the register allocation</span></td></tr>
<tr><td class="num" id="LN2686">2686</td><td class="line"><span class='comment'>// algorithm because it is efficient to remove elements from the end.</span></td></tr>
<tr><td class="num" id="LN2687">2687</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SortUnhandled() {</td></tr>
<tr><td class="num" id="LN2688">2688</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Sort unhandled\n"</span>)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Sort unhandled\n"); } while<br> (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2689">2689</td><td class="line">  std::sort(unhandled_live_ranges().begin(), unhandled_live_ranges().end(),</td></tr>
<tr><td class="num" id="LN2690">2690</td><td class="line">            &amp;UnhandledSortHelper);</td></tr>
<tr><td class="num" id="LN2691">2691</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2692">2692</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2693">2693</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2694">2694</td><td class="line"><span class='keyword'>bool</span> LinearScanAllocator::UnhandledIsSorted() {</td></tr>
<tr><td class="num" id="LN2695">2695</td><td class="line">  size_t len = unhandled_live_ranges().size();</td></tr>
<tr><td class="num" id="LN2696">2696</td><td class="line">  <span class='keyword'>for</span> (size_t i = 1; i &lt; len; i++) {</td></tr>
<tr><td class="num" id="LN2697">2697</td><td class="line">    LiveRange* a = unhandled_live_ranges().at(i - 1);</td></tr>
<tr><td class="num" id="LN2698">2698</td><td class="line">    LiveRange* b = unhandled_live_ranges().at(i);</td></tr>
<tr><td class="num" id="LN2699">2699</td><td class="line">    <span class='keyword'>if</span> (a-&gt;Start() &lt; b-&gt;Start()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2700">2700</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2701">2701</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2702">2702</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2703">2703</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2704">2704</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2705">2705</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::ActiveToHandled(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2706">2706</td><td class="line">  RemoveElement(&amp;active_live_ranges(), range);</td></tr>
<tr><td class="num" id="LN2707">2707</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Moving live range %d:%d from active to handled\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from active to handled\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2708">2708</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from active to handled\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2709">2709</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2710">2710</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2711">2711</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2712">2712</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::ActiveToInactive(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2713">2713</td><td class="line">  RemoveElement(&amp;active_live_ranges(), range);</td></tr>
<tr><td class="num" id="LN2714">2714</td><td class="line">  inactive_live_ranges().push_back(range);</td></tr>
<tr><td class="num" id="LN2715">2715</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Moving live range %d:%d from active to inactive\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from active to inactive\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2716">2716</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from active to inactive\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2717">2717</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2718">2718</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2719">2719</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2720">2720</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::InactiveToHandled(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2721">2721</td><td class="line">  RemoveElement(&amp;inactive_live_ranges(), range);</td></tr>
<tr><td class="num" id="LN2722">2722</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Moving live range %d:%d from inactive to handled\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from inactive to handled\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2723">2723</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from inactive to handled\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2724">2724</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2725">2725</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2726">2726</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2727">2727</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::InactiveToActive(LiveRange* range) {</td></tr>
<tr><td class="num" id="LN2728">2728</td><td class="line">  RemoveElement(&amp;inactive_live_ranges(), range);</td></tr>
<tr><td class="num" id="LN2729">2729</td><td class="line">  active_live_ranges().push_back(range);</td></tr>
<tr><td class="num" id="LN2730">2730</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Moving live range %d:%d from inactive to active\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from inactive to active\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span></td></tr>
<tr><td class="num" id="LN2731">2731</td><td class="line">        <span class='macro'>range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Moving live range %d:%d from inactive to active\n"<br>, range-&gt;TopLevel()-&gt;vreg(), range-&gt;relative_id()); }<br> while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2732">2732</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2733">2733</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2734">2734</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2735">2735</td><td class="line"><span class='keyword'>bool</span> LinearScanAllocator::TryAllocateFreeReg(LiveRange* current) {</td></tr>
<tr><td class="num" id="LN2736">2736</td><td class="line">  LifetimePosition free_until_pos[RegisterConfiguration::kMaxDoubleRegisters];</td></tr>
<tr><td class="num" id="LN2737">2737</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2738">2738</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; num_registers(); i++) {</td></tr>
<tr><td class="num" id="LN2739">2739</td><td class="line">    free_until_pos[i] = LifetimePosition::MaxPosition();</td></tr>
<tr><td class="num" id="LN2740">2740</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2741">2741</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2742">2742</td><td class="line">  <span class='keyword'>for</span> (LiveRange* cur_active : active_live_ranges()) {</td></tr>
<tr><td class="num" id="LN2743">2743</td><td class="line">    free_until_pos[cur_active-&gt;assigned_register()] =</td></tr>
<tr><td class="num" id="LN2744">2744</td><td class="line">        LifetimePosition::GapFromInstructionIndex(0);</td></tr>
<tr><td class="num" id="LN2745">2745</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Register %s is free until pos %d (1)\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Register %s is free until pos %d (1)\n"<br>, RegisterName(cur_active-&gt;assigned_register()), LifetimePosition<br>::GapFromInstructionIndex(0).value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2746">2746</td><td class="line">          <span class='macro'>RegisterName(cur_active-&gt;assigned_register()),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Register %s is free until pos %d (1)\n"<br>, RegisterName(cur_active-&gt;assigned_register()), LifetimePosition<br>::GapFromInstructionIndex(0).value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2747">2747</td><td class="line">          <span class='macro'>LifetimePosition::GapFromInstructionIndex(0).value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Register %s is free until pos %d (1)\n"<br>, RegisterName(cur_active-&gt;assigned_register()), LifetimePosition<br>::GapFromInstructionIndex(0).value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2748">2748</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2749">2749</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2750">2750</td><td class="line">  <span class='keyword'>for</span> (LiveRange* cur_inactive : inactive_live_ranges()) {</td></tr>
<tr><td class="num" id="LN2751">2751</td><td class="line">    <span class='macro'>DCHECK(cur_inactive-&gt;End() &gt; current-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(cur_inactive-&gt;End() &gt; current<br>-&gt;Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2751, "Check failed: %s.", "cur_inactive-&gt;End() &gt; current-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2752">2752</td><td class="line">    LifetimePosition next_intersection =</td></tr>
<tr><td class="num" id="LN2753">2753</td><td class="line">        cur_inactive-&gt;FirstIntersection(current);</td></tr>
<tr><td class="num" id="LN2754">2754</td><td class="line">    <span class='keyword'>if</span> (!next_intersection.IsValid()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2755">2755</td><td class="line">    <span class='keyword'>int</span> cur_reg = cur_inactive-&gt;assigned_register();</td></tr>
<tr><td class="num" id="LN2756">2756</td><td class="line">    free_until_pos[cur_reg] = Min(free_until_pos[cur_reg], next_intersection);</td></tr>
<tr><td class="num" id="LN2757">2757</td><td class="line">    <span class='macro'>TRACE(<span class='string_literal'>"Register %s is free until pos %d (2)\n"</span>, RegisterName(cur_reg),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Register %s is free until pos %d (2)\n"<br>, RegisterName(cur_reg), Min(free_until_pos[cur_reg], next_intersection<br>).value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2758">2758</td><td class="line">          <span class='macro'>Min(free_until_pos[cur_reg], next_intersection).value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Register %s is free until pos %d (2)\n"<br>, RegisterName(cur_reg), Min(free_until_pos[cur_reg], next_intersection<br>).value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2759">2759</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2760">2760</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2761">2761</td><td class="line">  <span class='keyword'>int</span> hint_register;</td></tr>
<tr><td class="num" id="LN2762">2762</td><td class="line">  <span class='keyword'>if</span> (current-&gt;FirstHintPosition(&amp;hint_register) != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2763">2763</td><td class="line">    <span class='macro'>TRACE(<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"<br>, RegisterName(hint_register), free_until_pos[hint_register].<br>value(), current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id<br>(), current-&gt;End().value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2764">2764</td><td class="line">        <span class='string_literal'><span class='macro'>"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"<br>, RegisterName(hint_register), free_until_pos[hint_register].<br>value(), current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id<br>(), current-&gt;End().value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2765">2765</td><td class="line">        <span class='macro'>RegisterName(hint_register), free_until_pos[hint_register].value(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"<br>, RegisterName(hint_register), free_until_pos[hint_register].<br>value(), current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id<br>(), current-&gt;End().value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2766">2766</td><td class="line">        <span class='macro'>current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"<br>, RegisterName(hint_register), free_until_pos[hint_register].<br>value(), current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id<br>(), current-&gt;End().value()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2767">2767</td><td class="line">        <span class='macro'>current-&gt;End().value())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\n"<br>, RegisterName(hint_register), free_until_pos[hint_register].<br>value(), current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id<br>(), current-&gt;End().value()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2768">2768</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2769">2769</td><td class="line">    <span class='comment'>// The desired register is free until the end of the current live range.</span></td></tr>
<tr><td class="num" id="LN2770">2770</td><td class="line">    <span class='keyword'>if</span> (free_until_pos[hint_register] &gt;= current-&gt;End()) {</td></tr>
<tr><td class="num" id="LN2771">2771</td><td class="line">      <span class='macro'>TRACE(<span class='string_literal'>"Assigning preferred reg %s to live range %d:%d\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning preferred reg %s to live range %d:%d\n"<br>, RegisterName(hint_register), current-&gt;TopLevel()-&gt;vreg<br>(), current-&gt;relative_id()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2772">2772</td><td class="line">            <span class='macro'>RegisterName(hint_register), current-&gt;TopLevel()-&gt;vreg(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning preferred reg %s to live range %d:%d\n"<br>, RegisterName(hint_register), current-&gt;TopLevel()-&gt;vreg<br>(), current-&gt;relative_id()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2773">2773</td><td class="line">            <span class='macro'>current-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning preferred reg %s to live range %d:%d\n"<br>, RegisterName(hint_register), current-&gt;TopLevel()-&gt;vreg<br>(), current-&gt;relative_id()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2774">2774</td><td class="line">      SetLiveRangeAssignedRegister(current, hint_register);</td></tr>
<tr><td class="num" id="LN2775">2775</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2776">2776</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2777">2777</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2778">2778</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2779">2779</td><td class="line">  <span class='comment'>// Find the register which stays free for the longest time.</span></td></tr>
<tr><td class="num" id="LN2780">2780</td><td class="line">  <span class='keyword'>int</span> reg = allocatable_register_code(0);</td></tr>
<tr><td class="num" id="LN2781">2781</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 1; i &lt; num_allocatable_registers(); ++i) {</td></tr>
<tr><td class="num" id="LN2782">2782</td><td class="line">    <span class='keyword'>int</span> code = allocatable_register_code(i);</td></tr>
<tr><td class="num" id="LN2783">2783</td><td class="line">    <span class='keyword'>if</span> (free_until_pos[code] &gt; free_until_pos[reg]) {</td></tr>
<tr><td class="num" id="LN2784">2784</td><td class="line">      reg = code;</td></tr>
<tr><td class="num" id="LN2785">2785</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2786">2786</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2787">2787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2788">2788</td><td class="line">  LifetimePosition pos = free_until_pos[reg];</td></tr>
<tr><td class="num" id="LN2789">2789</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2790">2790</td><td class="line">  <span class='keyword'>if</span> (pos &lt;= current-&gt;Start()) {</td></tr>
<tr><td class="num" id="LN2791">2791</td><td class="line">    <span class='comment'>// All registers are blocked.</span></td></tr>
<tr><td class="num" id="LN2792">2792</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2793">2793</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2794">2794</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2795">2795</td><td class="line">  <span class='keyword'>if</span> (pos &lt; current-&gt;End()) {</td></tr>
<tr><td class="num" id="LN2796">2796</td><td class="line">    <span class='comment'>// Register reg is available at the range start but becomes blocked before</span></td></tr>
<tr><td class="num" id="LN2797">2797</td><td class="line">    <span class='comment'>// the range end. Split current at position where it becomes blocked.</span></td></tr>
<tr><td class="num" id="LN2798">2798</td><td class="line">    LiveRange* tail = SplitRangeAt(current, pos);</td></tr>
<tr><td class="num" id="LN2799">2799</td><td class="line">    AddToUnhandledSorted(tail);</td></tr>
<tr><td class="num" id="LN2800">2800</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2801">2801</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2802">2802</td><td class="line">  <span class='comment'>// Register reg is available at the range start and is free until</span></td></tr>
<tr><td class="num" id="LN2803">2803</td><td class="line">  <span class='comment'>// the range end.</span></td></tr>
<tr><td class="num" id="LN2804">2804</td><td class="line">  <span class='macro'>DCHECK(pos &gt;= current-&gt;End())<span class='expansion'>do { if ((__builtin_expect(!!(!(pos &gt;= current-&gt;End()))<br>, 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2804<br>, "Check failed: %s.", "pos &gt;= current-&gt;End()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2805">2805</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Assigning free reg %s to live range %d:%d\n"</span>, RegisterName(reg),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning free reg %s to live range %d:%d\n"<br>, RegisterName(reg), current-&gt;TopLevel()-&gt;vreg(), current<br>-&gt;relative_id()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2806">2806</td><td class="line">        <span class='macro'>current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning free reg %s to live range %d:%d\n"<br>, RegisterName(reg), current-&gt;TopLevel()-&gt;vreg(), current<br>-&gt;relative_id()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2807">2807</td><td class="line">  SetLiveRangeAssignedRegister(current, reg);</td></tr>
<tr><td class="num" id="LN2808">2808</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2809">2809</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2810">2810</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2811">2811</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2812">2812</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2813">2813</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::AllocateBlockedReg(LiveRange* current) {</td></tr>
<tr><td class="num" id="LN2814">2814</td><td class="line">  UsePosition* register_use = current-&gt;NextRegisterPosition(current-&gt;Start());</td></tr>
<tr><td class="num" id="LN2815">2815</td><td class="line">  <span class='keyword'>if</span> (register_use == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2816">2816</td><td class="line">    <span class='comment'>// There is no use in the current live range that requires a register.</span></td></tr>
<tr><td class="num" id="LN2817">2817</td><td class="line">    <span class='comment'>// We can just spill it.</span></td></tr>
<tr><td class="num" id="LN2818">2818</td><td class="line">    Spill(current);</td></tr>
<tr><td class="num" id="LN2819">2819</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2820">2820</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2821">2821</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2822">2822</td><td class="line">  LifetimePosition use_pos[RegisterConfiguration::kMaxDoubleRegisters];</td></tr>
<tr><td class="num" id="LN2823">2823</td><td class="line">  LifetimePosition block_pos[RegisterConfiguration::kMaxDoubleRegisters];</td></tr>
<tr><td class="num" id="LN2824">2824</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2825">2825</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; num_registers(); i++) {</td></tr>
<tr><td class="num" id="LN2826">2826</td><td class="line">    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();</td></tr>
<tr><td class="num" id="LN2827">2827</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2828">2828</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2829">2829</td><td class="line">  <span class='keyword'>for</span> (LiveRange* range : active_live_ranges()) {</td></tr>
<tr><td class="num" id="LN2830">2830</td><td class="line">    <span class='keyword'>int</span> cur_reg = range-&gt;assigned_register();</td></tr>
<tr><td class="num" id="LN2831">2831</td><td class="line">    <span class='keyword'>if</span> (range-&gt;TopLevel()-&gt;IsFixed() ||</td></tr>
<tr><td class="num" id="LN2832">2832</td><td class="line">        !range-&gt;CanBeSpilled(current-&gt;Start())) {</td></tr>
<tr><td class="num" id="LN2833">2833</td><td class="line">      block_pos[cur_reg] = use_pos[cur_reg] =</td></tr>
<tr><td class="num" id="LN2834">2834</td><td class="line">          LifetimePosition::GapFromInstructionIndex(0);</td></tr>
<tr><td class="num" id="LN2835">2835</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2836">2836</td><td class="line">      UsePosition* next_use =</td></tr>
<tr><td class="num" id="LN2837">2837</td><td class="line">          range-&gt;NextUsePositionRegisterIsBeneficial(current-&gt;Start());</td></tr>
<tr><td class="num" id="LN2838">2838</td><td class="line">      <span class='keyword'>if</span> (next_use == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2839">2839</td><td class="line">        use_pos[cur_reg] = range-&gt;End();</td></tr>
<tr><td class="num" id="LN2840">2840</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2841">2841</td><td class="line">        use_pos[cur_reg] = next_use-&gt;pos();</td></tr>
<tr><td class="num" id="LN2842">2842</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2843">2843</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2844">2844</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2845">2845</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2846">2846</td><td class="line">  <span class='keyword'>for</span> (LiveRange* range : inactive_live_ranges()) {</td></tr>
<tr><td class="num" id="LN2847">2847</td><td class="line">    <span class='macro'>DCHECK(range-&gt;End() &gt; current-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(range-&gt;End() &gt; current-&gt;<br>Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2847, "Check failed: %s.", "range-&gt;End() &gt; current-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2848">2848</td><td class="line">    LifetimePosition next_intersection = range-&gt;FirstIntersection(current);</td></tr>
<tr><td class="num" id="LN2849">2849</td><td class="line">    <span class='keyword'>if</span> (!next_intersection.IsValid()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2850">2850</td><td class="line">    <span class='keyword'>int</span> cur_reg = range-&gt;assigned_register();</td></tr>
<tr><td class="num" id="LN2851">2851</td><td class="line">    <span class='keyword'>if</span> (range-&gt;TopLevel()-&gt;IsFixed()) {</td></tr>
<tr><td class="num" id="LN2852">2852</td><td class="line">      block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);</td></tr>
<tr><td class="num" id="LN2853">2853</td><td class="line">      use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);</td></tr>
<tr><td class="num" id="LN2854">2854</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2855">2855</td><td class="line">      use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);</td></tr>
<tr><td class="num" id="LN2856">2856</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2857">2857</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2858">2858</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2859">2859</td><td class="line">  <span class='keyword'>int</span> reg = allocatable_register_code(0);</td></tr>
<tr><td class="num" id="LN2860">2860</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 1; i &lt; num_allocatable_registers(); ++i) {</td></tr>
<tr><td class="num" id="LN2861">2861</td><td class="line">    <span class='keyword'>int</span> code = allocatable_register_code(i);</td></tr>
<tr><td class="num" id="LN2862">2862</td><td class="line">    <span class='keyword'>if</span> (use_pos[code] &gt; use_pos[reg]) {</td></tr>
<tr><td class="num" id="LN2863">2863</td><td class="line">      reg = code;</td></tr>
<tr><td class="num" id="LN2864">2864</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2865">2865</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2866">2866</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2867">2867</td><td class="line">  LifetimePosition pos = use_pos[reg];</td></tr>
<tr><td class="num" id="LN2868">2868</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2869">2869</td><td class="line">  <span class='keyword'>if</span> (pos &lt; register_use-&gt;pos()) {</td></tr>
<tr><td class="num" id="LN2870">2870</td><td class="line">    <span class='comment'>// All registers are blocked before the first use that requires a register.</span></td></tr>
<tr><td class="num" id="LN2871">2871</td><td class="line">    <span class='comment'>// Spill starting part of live range up to that use.</span></td></tr>
<tr><td class="num" id="LN2872">2872</td><td class="line">    SpillBetween(current, current-&gt;Start(), register_use-&gt;pos());</td></tr>
<tr><td class="num" id="LN2873">2873</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2874">2874</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2875">2875</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2876">2876</td><td class="line">  <span class='keyword'>if</span> (block_pos[reg] &lt; current-&gt;End()) {</td></tr>
<tr><td class="num" id="LN2877">2877</td><td class="line">    <span class='comment'>// Register becomes blocked before the current range end. Split before that</span></td></tr>
<tr><td class="num" id="LN2878">2878</td><td class="line">    <span class='comment'>// position.</span></td></tr>
<tr><td class="num" id="LN2879">2879</td><td class="line">    LiveRange* tail =</td></tr>
<tr><td class="num" id="LN2880">2880</td><td class="line">        SplitBetween(current, current-&gt;Start(), block_pos[reg].Start());</td></tr>
<tr><td class="num" id="LN2881">2881</td><td class="line">    AddToUnhandledSorted(tail);</td></tr>
<tr><td class="num" id="LN2882">2882</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2883">2883</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2884">2884</td><td class="line">  <span class='comment'>// Register reg is not blocked for the whole range.</span></td></tr>
<tr><td class="num" id="LN2885">2885</td><td class="line">  <span class='macro'>DCHECK(block_pos[reg] &gt;= current-&gt;End())<span class='expansion'>do { if ((__builtin_expect(!!(!(block_pos[reg] &gt;= current-&gt;<br>End())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2885, "Check failed: %s.", "block_pos[reg] &gt;= current-&gt;End()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2886">2886</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Assigning blocked reg %s to live range %d:%d\n"</span>, RegisterName(reg),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning blocked reg %s to live range %d:%d\n"<br>, RegisterName(reg), current-&gt;TopLevel()-&gt;vreg(), current<br>-&gt;relative_id()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN2887">2887</td><td class="line">        <span class='macro'>current-&gt;TopLevel()-&gt;vreg(), current-&gt;relative_id())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Assigning blocked reg %s to live range %d:%d\n"<br>, RegisterName(reg), current-&gt;TopLevel()-&gt;vreg(), current<br>-&gt;relative_id()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN2888">2888</td><td class="line">  SetLiveRangeAssignedRegister(current, reg);</td></tr>
<tr><td class="num" id="LN2889">2889</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2890">2890</td><td class="line">  <span class='comment'>// This register was not free. Thus we need to find and spill</span></td></tr>
<tr><td class="num" id="LN2891">2891</td><td class="line">  <span class='comment'>// parts of active and inactive live regions that use the same register</span></td></tr>
<tr><td class="num" id="LN2892">2892</td><td class="line">  <span class='comment'>// at the same lifetime positions as current.</span></td></tr>
<tr><td class="num" id="LN2893">2893</td><td class="line">  SplitAndSpillIntersecting(current);</td></tr>
<tr><td class="num" id="LN2894">2894</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2895">2895</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2896">2896</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2897">2897</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SplitAndSpillIntersecting(LiveRange* current) {</td></tr>
<tr><td class="num" id="LN2898">2898</td><td class="line">  <span class='macro'>DCHECK(current-&gt;HasRegisterAssigned())<span class='expansion'>do { if ((__builtin_expect(!!(!(current-&gt;HasRegisterAssigned<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2898, "Check failed: %s.", "current-&gt;HasRegisterAssigned()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2899">2899</td><td class="line">  <span class='keyword'>int</span> reg = current-&gt;assigned_register();</td></tr>
<tr><td class="num" id="LN2900">2900</td><td class="line">  LifetimePosition split_pos = current-&gt;Start();</td></tr>
<tr><td class="num" id="LN2901">2901</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; active_live_ranges().size(); ++i) {</td></tr>
<tr><td class="num" id="LN2902">2902</td><td class="line">    LiveRange* range = active_live_ranges()[i];</td></tr>
<tr><td class="num" id="LN2903">2903</td><td class="line">    <span class='keyword'>if</span> (range-&gt;assigned_register() == reg) {</td></tr>
<tr><td class="num" id="LN2904">2904</td><td class="line">      UsePosition* next_pos = range-&gt;NextRegisterPosition(current-&gt;Start());</td></tr>
<tr><td class="num" id="LN2905">2905</td><td class="line">      LifetimePosition spill_pos = FindOptimalSpillingPos(range, split_pos);</td></tr>
<tr><td class="num" id="LN2906">2906</td><td class="line">      <span class='keyword'>if</span> (next_pos == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2907">2907</td><td class="line">        SpillAfter(range, spill_pos);</td></tr>
<tr><td class="num" id="LN2908">2908</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2909">2909</td><td class="line">        <span class='comment'>// When spilling between spill_pos and next_pos ensure that the range</span></td></tr>
<tr><td class="num" id="LN2910">2910</td><td class="line">        <span class='comment'>// remains spilled at least until the start of the current live range.</span></td></tr>
<tr><td class="num" id="LN2911">2911</td><td class="line">        <span class='comment'>// This guarantees that we will not introduce new unhandled ranges that</span></td></tr>
<tr><td class="num" id="LN2912">2912</td><td class="line">        <span class='comment'>// start before the current range as this violates allocation invariant</span></td></tr>
<tr><td class="num" id="LN2913">2913</td><td class="line">        <span class='comment'>// and will lead to an inconsistent state of active and inactive</span></td></tr>
<tr><td class="num" id="LN2914">2914</td><td class="line">        <span class='comment'>// live-ranges: ranges are allocated in order of their start positions,</span></td></tr>
<tr><td class="num" id="LN2915">2915</td><td class="line">        <span class='comment'>// ranges are retired from active/inactive when the start of the</span></td></tr>
<tr><td class="num" id="LN2916">2916</td><td class="line">        <span class='comment'>// current live-range is larger than their end.</span></td></tr>
<tr><td class="num" id="LN2917">2917</td><td class="line">        SpillBetweenUntil(range, spill_pos, current-&gt;Start(), next_pos-&gt;pos());</td></tr>
<tr><td class="num" id="LN2918">2918</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2919">2919</td><td class="line">      ActiveToHandled(range);</td></tr>
<tr><td class="num" id="LN2920">2920</td><td class="line">      --i;</td></tr>
<tr><td class="num" id="LN2921">2921</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2922">2922</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2923">2923</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2924">2924</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; inactive_live_ranges().size(); ++i) {</td></tr>
<tr><td class="num" id="LN2925">2925</td><td class="line">    LiveRange* range = inactive_live_ranges()[i];</td></tr>
<tr><td class="num" id="LN2926">2926</td><td class="line">    <span class='macro'>DCHECK(range-&gt;End() &gt; current-&gt;Start())<span class='expansion'>do { if ((__builtin_expect(!!(!(range-&gt;End() &gt; current-&gt;<br>Start())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 2926, "Check failed: %s.", "range-&gt;End() &gt; current-&gt;Start()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2927">2927</td><td class="line">    <span class='keyword'>if</span> (range-&gt;assigned_register() == reg &amp;&amp; !range-&gt;TopLevel()-&gt;IsFixed()) {</td></tr>
<tr><td class="num" id="LN2928">2928</td><td class="line">      LifetimePosition next_intersection = range-&gt;FirstIntersection(current);</td></tr>
<tr><td class="num" id="LN2929">2929</td><td class="line">      <span class='keyword'>if</span> (next_intersection.IsValid()) {</td></tr>
<tr><td class="num" id="LN2930">2930</td><td class="line">        UsePosition* next_pos = range-&gt;NextRegisterPosition(current-&gt;Start());</td></tr>
<tr><td class="num" id="LN2931">2931</td><td class="line">        <span class='keyword'>if</span> (next_pos == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2932">2932</td><td class="line">          SpillAfter(range, split_pos);</td></tr>
<tr><td class="num" id="LN2933">2933</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2934">2934</td><td class="line">          next_intersection = Min(next_intersection, next_pos-&gt;pos());</td></tr>
<tr><td class="num" id="LN2935">2935</td><td class="line">          SpillBetween(range, split_pos, next_intersection);</td></tr>
<tr><td class="num" id="LN2936">2936</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2937">2937</td><td class="line">        InactiveToHandled(range);</td></tr>
<tr><td class="num" id="LN2938">2938</td><td class="line">        --i;</td></tr>
<tr><td class="num" id="LN2939">2939</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2940">2940</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2941">2941</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2942">2942</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2943">2943</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2944">2944</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2945">2945</td><td class="line"><span class='keyword'>bool</span> LinearScanAllocator::TryReuseSpillForPhi(TopLevelLiveRange* range) {</td></tr>
<tr><td class="num" id="LN2946">2946</td><td class="line">  <span class='keyword'>if</span> (!range-&gt;is_phi()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2947">2947</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2948">2948</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;HasSpillOperand())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;HasSpillOperand())<br>), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 2948<br>, "Check failed: %s.", "!range-&gt;HasSpillOperand()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2949">2949</td><td class="line">  RegisterAllocationData::PhiMapValue* phi_map_value =</td></tr>
<tr><td class="num" id="LN2950">2950</td><td class="line">      data()-&gt;GetPhiMapValueFor(range);</td></tr>
<tr><td class="num" id="LN2951">2951</td><td class="line">  <span class='keyword'>const</span> PhiInstruction* phi = phi_map_value-&gt;phi();</td></tr>
<tr><td class="num" id="LN2952">2952</td><td class="line">  <span class='keyword'>const</span> InstructionBlock* block = phi_map_value-&gt;block();</td></tr>
<tr><td class="num" id="LN2953">2953</td><td class="line">  <span class='comment'>// Count the number of spilled operands.</span></td></tr>
<tr><td class="num" id="LN2954">2954</td><td class="line">  size_t spilled_count = 0;</td></tr>
<tr><td class="num" id="LN2955">2955</td><td class="line">  LiveRange* first_op = <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN2956">2956</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; phi-&gt;operands().size(); i++) {</td></tr>
<tr><td class="num" id="LN2957">2957</td><td class="line">    <span class='keyword'>int</span> op = phi-&gt;operands()[i];</td></tr>
<tr><td class="num" id="LN2958">2958</td><td class="line">    LiveRange* op_range = data()-&gt;GetOrCreateLiveRangeFor(op);</td></tr>
<tr><td class="num" id="LN2959">2959</td><td class="line">    <span class='keyword'>if</span> (!op_range-&gt;TopLevel()-&gt;HasSpillRange()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2960">2960</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* pred =</td></tr>
<tr><td class="num" id="LN2961">2961</td><td class="line">        code()-&gt;InstructionBlockAt(block-&gt;predecessors()[i]);</td></tr>
<tr><td class="num" id="LN2962">2962</td><td class="line">    LifetimePosition pred_end =</td></tr>
<tr><td class="num" id="LN2963">2963</td><td class="line">        LifetimePosition::InstructionFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN2964">2964</td><td class="line">            pred-&gt;last_instruction_index());</td></tr>
<tr><td class="num" id="LN2965">2965</td><td class="line">    <span class='keyword'>while</span> (op_range != <span class='keyword'>nullptr</span> &amp;&amp; !op_range-&gt;CanCover(pred_end)) {</td></tr>
<tr><td class="num" id="LN2966">2966</td><td class="line">      op_range = op_range-&gt;next();</td></tr>
<tr><td class="num" id="LN2967">2967</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2968">2968</td><td class="line">    <span class='keyword'>if</span> (op_range != <span class='keyword'>nullptr</span> &amp;&amp; op_range-&gt;spilled()) {</td></tr>
<tr><td class="num" id="LN2969">2969</td><td class="line">      spilled_count++;</td></tr>
<tr><td class="num" id="LN2970">2970</td><td class="line">      <span class='keyword'>if</span> (first_op == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN2971">2971</td><td class="line">        first_op = op_range-&gt;TopLevel();</td></tr>
<tr><td class="num" id="LN2972">2972</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2973">2973</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2974">2974</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2975">2975</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2976">2976</td><td class="line">  <span class='comment'>// Only continue if more than half of the operands are spilled.</span></td></tr>
<tr><td class="num" id="LN2977">2977</td><td class="line">  <span class='keyword'>if</span> (spilled_count * 2 &lt;= phi-&gt;operands().size()) {</td></tr>
<tr><td class="num" id="LN2978">2978</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2979">2979</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2980">2980</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2981">2981</td><td class="line">  <span class='comment'>// Try to merge the spilled operands and count the number of merged spilled</span></td></tr>
<tr><td class="num" id="LN2982">2982</td><td class="line">  <span class='comment'>// operands.</span></td></tr>
<tr><td class="num" id="LN2983">2983</td><td class="line">  <span class='macro'>DCHECK(first_op != <span class='keyword'>nullptr</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(first_op != nullptr)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 2983, "Check failed: %s."<br>, "first_op != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2984">2984</td><td class="line">  SpillRange* first_op_spill = first_op-&gt;TopLevel()-&gt;GetSpillRange();</td></tr>
<tr><td class="num" id="LN2985">2985</td><td class="line">  size_t num_merged = 1;</td></tr>
<tr><td class="num" id="LN2986">2986</td><td class="line">  <span class='keyword'>for</span> (size_t i = 1; i &lt; phi-&gt;operands().size(); i++) {</td></tr>
<tr><td class="num" id="LN2987">2987</td><td class="line">    <span class='keyword'>int</span> op = phi-&gt;operands()[i];</td></tr>
<tr><td class="num" id="LN2988">2988</td><td class="line">    TopLevelLiveRange* op_range = data()-&gt;live_ranges()[op];</td></tr>
<tr><td class="num" id="LN2989">2989</td><td class="line">    <span class='keyword'>if</span> (!op_range-&gt;HasSpillRange()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN2990">2990</td><td class="line">    SpillRange* op_spill = op_range-&gt;GetSpillRange();</td></tr>
<tr><td class="num" id="LN2991">2991</td><td class="line">    <span class='keyword'>if</span> (op_spill == first_op_spill || first_op_spill-&gt;TryMerge(op_spill)) {</td></tr>
<tr><td class="num" id="LN2992">2992</td><td class="line">      num_merged++;</td></tr>
<tr><td class="num" id="LN2993">2993</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2994">2994</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2995">2995</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2996">2996</td><td class="line">  <span class='comment'>// Only continue if enough operands could be merged to the</span></td></tr>
<tr><td class="num" id="LN2997">2997</td><td class="line">  <span class='comment'>// same spill slot.</span></td></tr>
<tr><td class="num" id="LN2998">2998</td><td class="line">  <span class='keyword'>if</span> (num_merged * 2 &lt;= phi-&gt;operands().size() ||</td></tr>
<tr><td class="num" id="LN2999">2999</td><td class="line">      AreUseIntervalsIntersecting(first_op_spill-&gt;interval(),</td></tr>
<tr><td class="num" id="LN3000">3000</td><td class="line">                                  range-&gt;first_interval())) {</td></tr>
<tr><td class="num" id="LN3001">3001</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3002">3002</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3003">3003</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3004">3004</td><td class="line">  <span class='comment'>// If the range does not need register soon, spill it to the merged</span></td></tr>
<tr><td class="num" id="LN3005">3005</td><td class="line">  <span class='comment'>// spill range.</span></td></tr>
<tr><td class="num" id="LN3006">3006</td><td class="line">  LifetimePosition next_pos = range-&gt;Start();</td></tr>
<tr><td class="num" id="LN3007">3007</td><td class="line">  <span class='keyword'>if</span> (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();</td></tr>
<tr><td class="num" id="LN3008">3008</td><td class="line">  UsePosition* pos = range-&gt;NextUsePositionRegisterIsBeneficial(next_pos);</td></tr>
<tr><td class="num" id="LN3009">3009</td><td class="line">  <span class='keyword'>if</span> (pos == <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN3010">3010</td><td class="line">    SpillRange* spill_range =</td></tr>
<tr><td class="num" id="LN3011">3011</td><td class="line">        range-&gt;TopLevel()-&gt;HasSpillRange()</td></tr>
<tr><td class="num" id="LN3012">3012</td><td class="line">            ? range-&gt;TopLevel()-&gt;GetSpillRange()</td></tr>
<tr><td class="num" id="LN3013">3013</td><td class="line">            : data()-&gt;AssignSpillRangeToLiveRange(range-&gt;TopLevel());</td></tr>
<tr><td class="num" id="LN3014">3014</td><td class="line">    <span class='keyword'>bool</span> merged = first_op_spill-&gt;TryMerge(spill_range);</td></tr>
<tr><td class="num" id="LN3015">3015</td><td class="line">    <span class='macro'>CHECK(merged)<span class='expansion'>do { if ((__builtin_expect(!!(!(merged)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3015, "Check failed: %s.", "merged"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3016">3016</td><td class="line">    Spill(range);</td></tr>
<tr><td class="num" id="LN3017">3017</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3018">3018</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (pos-&gt;pos() &gt; range-&gt;Start().NextStart()) {</td></tr>
<tr><td class="num" id="LN3019">3019</td><td class="line">    SpillRange* spill_range =</td></tr>
<tr><td class="num" id="LN3020">3020</td><td class="line">        range-&gt;TopLevel()-&gt;HasSpillRange()</td></tr>
<tr><td class="num" id="LN3021">3021</td><td class="line">            ? range-&gt;TopLevel()-&gt;GetSpillRange()</td></tr>
<tr><td class="num" id="LN3022">3022</td><td class="line">            : data()-&gt;AssignSpillRangeToLiveRange(range-&gt;TopLevel());</td></tr>
<tr><td class="num" id="LN3023">3023</td><td class="line">    <span class='keyword'>bool</span> merged = first_op_spill-&gt;TryMerge(spill_range);</td></tr>
<tr><td class="num" id="LN3024">3024</td><td class="line">    <span class='macro'>CHECK(merged)<span class='expansion'>do { if ((__builtin_expect(!!(!(merged)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3024, "Check failed: %s.", "merged"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3025">3025</td><td class="line">    SpillBetween(range, range-&gt;Start(), pos-&gt;pos());</td></tr>
<tr><td class="num" id="LN3026">3026</td><td class="line">    <span class='macro'>DCHECK(UnhandledIsSorted())<span class='expansion'>do { if ((__builtin_expect(!!(!(UnhandledIsSorted())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 3026, "Check failed: %s."<br>, "UnhandledIsSorted()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3027">3027</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3028">3028</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3029">3029</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3030">3030</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3031">3031</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3032">3032</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3033">3033</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SpillAfter(LiveRange* range, LifetimePosition pos) {</td></tr>
<tr><td class="num" id="LN3034">3034</td><td class="line">  LiveRange* second_part = SplitRangeAt(range, pos);</td></tr>
<tr><td class="num" id="LN3035">3035</td><td class="line">  Spill(second_part);</td></tr>
<tr><td class="num" id="LN3036">3036</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3037">3037</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3038">3038</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3039">3039</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SpillBetween(LiveRange* range, LifetimePosition start,</td></tr>
<tr><td class="num" id="LN3040">3040</td><td class="line">                                       LifetimePosition end) {</td></tr>
<tr><td class="num" id="LN3041">3041</td><td class="line">  SpillBetweenUntil(range, start, start, end);</td></tr>
<tr><td class="num" id="LN3042">3042</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3043">3043</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3044">3044</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3045">3045</td><td class="line"><span class='keyword'>void</span> LinearScanAllocator::SpillBetweenUntil(LiveRange* range,</td></tr>
<tr><td class="num" id="LN3046">3046</td><td class="line">                                            LifetimePosition start,</td></tr>
<tr><td class="num" id="LN3047">3047</td><td class="line">                                            LifetimePosition until,</td></tr>
<tr><td class="num" id="LN3048">3048</td><td class="line">                                            LifetimePosition end) {</td></tr>
<tr><td class="num" id="LN3049">3049</td><td class="line">  <span class='macro'>CHECK(start &lt; end)<span class='expansion'>do { if ((__builtin_expect(!!(!(start &lt; end)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 3049, "Check failed: %s."<br>, "start &lt; end"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3050">3050</td><td class="line">  LiveRange* second_part = SplitRangeAt(range, start);</td></tr>
<tr><td class="num" id="LN3051">3051</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3052">3052</td><td class="line">  <span class='keyword'>if</span> (second_part-&gt;Start() &lt; end) {</td></tr>
<tr><td class="num" id="LN3053">3053</td><td class="line">    <span class='comment'>// The split result intersects with [start, end[.</span></td></tr>
<tr><td class="num" id="LN3054">3054</td><td class="line">    <span class='comment'>// Split it at position between ]start+1, end[, spill the middle part</span></td></tr>
<tr><td class="num" id="LN3055">3055</td><td class="line">    <span class='comment'>// and put the rest to unhandled.</span></td></tr>
<tr><td class="num" id="LN3056">3056</td><td class="line">    LifetimePosition third_part_end = end.PrevStart().End();</td></tr>
<tr><td class="num" id="LN3057">3057</td><td class="line">    <span class='keyword'>if</span> (data()-&gt;IsBlockBoundary(end.Start())) {</td></tr>
<tr><td class="num" id="LN3058">3058</td><td class="line">      third_part_end = end.Start();</td></tr>
<tr><td class="num" id="LN3059">3059</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3060">3060</td><td class="line">    LiveRange* third_part = SplitBetween(</td></tr>
<tr><td class="num" id="LN3061">3061</td><td class="line">        second_part, Max(second_part-&gt;Start().End(), until), third_part_end);</td></tr>
<tr><td class="num" id="LN3062">3062</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3063">3063</td><td class="line">    <span class='macro'>DCHECK(third_part != second_part)<span class='expansion'>do { if ((__builtin_expect(!!(!(third_part != second_part)), 0<br>))) { V8_Fatal("../src/compiler/register-allocator.cc", 3063,<br> "Check failed: %s.", "third_part != second_part"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3064">3064</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3065">3065</td><td class="line">    Spill(second_part);</td></tr>
<tr><td class="num" id="LN3066">3066</td><td class="line">    AddToUnhandledSorted(third_part);</td></tr>
<tr><td class="num" id="LN3067">3067</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3068">3068</td><td class="line">    <span class='comment'>// The split result does not intersect with [start, end[.</span></td></tr>
<tr><td class="num" id="LN3069">3069</td><td class="line">    <span class='comment'>// Nothing to spill. Just put it to unhandled as whole.</span></td></tr>
<tr><td class="num" id="LN3070">3070</td><td class="line">    AddToUnhandledSorted(second_part);</td></tr>
<tr><td class="num" id="LN3071">3071</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3072">3072</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3073">3073</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3074">3074</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3075">3075</td><td class="line">SpillSlotLocator::SpillSlotLocator(RegisterAllocationData* data)</td></tr>
<tr><td class="num" id="LN3076">3076</td><td class="line">    : data_(data) {}</td></tr>
<tr><td class="num" id="LN3077">3077</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3078">3078</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3079">3079</td><td class="line"><span class='keyword'>void</span> SpillSlotLocator::LocateSpillSlots() {</td></tr>
<tr><td class="num" id="LN3080">3080</td><td class="line">  <span class='keyword'>const</span> InstructionSequence* code = data()-&gt;code();</td></tr>
<tr><td class="num" id="LN3081">3081</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN3082">3082</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span> || range-&gt;IsEmpty()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3083">3083</td><td class="line">    <span class='comment'>// We care only about ranges which spill in the frame.</span></td></tr>
<tr><td class="num" id="LN3084">3084</td><td class="line">    <span class='keyword'>if</span> (!range-&gt;HasSpillRange()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3085">3085</td><td class="line">    <span class='keyword'>if</span> (range-&gt;IsSpilledOnlyInDeferredBlocks()) {</td></tr>
<tr><td class="num" id="LN3086">3086</td><td class="line">      <span class='keyword'>for</span> (LiveRange* child = range; child != <span class='keyword'>nullptr</span>; child = child-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3087">3087</td><td class="line">        <span class='keyword'>if</span> (child-&gt;spilled()) {</td></tr>
<tr><td class="num" id="LN3088">3088</td><td class="line">          code-&gt;GetInstructionBlock(child-&gt;Start().ToInstructionIndex())</td></tr>
<tr><td class="num" id="LN3089">3089</td><td class="line">              -&gt;mark_needs_frame();</td></tr>
<tr><td class="num" id="LN3090">3090</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3091">3091</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3092">3092</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3093">3093</td><td class="line">      TopLevelLiveRange::SpillMoveInsertionList* spills =</td></tr>
<tr><td class="num" id="LN3094">3094</td><td class="line">          range-&gt;GetSpillMoveInsertionLocations();</td></tr>
<tr><td class="num" id="LN3095">3095</td><td class="line">      <span class='macro'>DCHECK_NOT_NULL(spills)<span class='expansion'>do { if ((__builtin_expect(!!(!((spills) != nullptr)), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 3095, "Check failed: %s."<br>, "(spills) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3096">3096</td><td class="line">      <span class='keyword'>for</span> (; spills != <span class='keyword'>nullptr</span>; spills = spills-&gt;next) {</td></tr>
<tr><td class="num" id="LN3097">3097</td><td class="line">        code-&gt;GetInstructionBlock(spills-&gt;gap_index)-&gt;mark_needs_frame();</td></tr>
<tr><td class="num" id="LN3098">3098</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3099">3099</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3100">3100</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3101">3101</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3102">3102</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3103">3103</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3104">3104</td><td class="line">OperandAssigner::OperandAssigner(RegisterAllocationData* data) : data_(data) {}</td></tr>
<tr><td class="num" id="LN3105">3105</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3106">3106</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3107">3107</td><td class="line"><span class='keyword'>void</span> OperandAssigner::AssignSpillSlots() {</td></tr>
<tr><td class="num" id="LN3108">3108</td><td class="line">  ZoneVector&lt;SpillRange*&gt;&amp; spill_ranges = data()-&gt;spill_ranges();</td></tr>
<tr><td class="num" id="LN3109">3109</td><td class="line">  <span class='comment'>// Merge disjoint spill ranges</span></td></tr>
<tr><td class="num" id="LN3110">3110</td><td class="line">  <span class='keyword'>for</span> (size_t i = 0; i &lt; spill_ranges.size(); ++i) {</td></tr>
<tr><td class="num" id="LN3111">3111</td><td class="line">    SpillRange* range = spill_ranges[i];</td></tr>
<tr><td class="num" id="LN3112">3112</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span>) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3113">3113</td><td class="line">    <span class='keyword'>if</span> (range-&gt;IsEmpty()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3114">3114</td><td class="line">    <span class='keyword'>for</span> (size_t j = i + 1; j &lt; spill_ranges.size(); ++j) {</td></tr>
<tr><td class="num" id="LN3115">3115</td><td class="line">      SpillRange* other = spill_ranges[j];</td></tr>
<tr><td class="num" id="LN3116">3116</td><td class="line">      <span class='keyword'>if</span> (other != <span class='keyword'>nullptr</span> &amp;&amp; !other-&gt;IsEmpty()) {</td></tr>
<tr><td class="num" id="LN3117">3117</td><td class="line">        range-&gt;TryMerge(other);</td></tr>
<tr><td class="num" id="LN3118">3118</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3119">3119</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3120">3120</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3121">3121</td><td class="line">  <span class='comment'>// Allocate slots for the merged spill ranges.</span></td></tr>
<tr><td class="num" id="LN3122">3122</td><td class="line">  <span class='keyword'>for</span> (SpillRange* range : spill_ranges) {</td></tr>
<tr><td class="num" id="LN3123">3123</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span> || range-&gt;IsEmpty()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3124">3124</td><td class="line">    <span class='comment'>// Allocate a new operand referring to the spill slot.</span></td></tr>
<tr><td class="num" id="LN3125">3125</td><td class="line">    <span class='keyword'>if</span> (!range-&gt;HasSlot()) {</td></tr>
<tr><td class="num" id="LN3126">3126</td><td class="line">      <span class='keyword'>int</span> byte_width = range-&gt;ByteWidth();</td></tr>
<tr><td class="num" id="LN3127">3127</td><td class="line">      <span class='keyword'>int</span> index = data()-&gt;frame()-&gt;AllocateSpillSlot(byte_width);</td></tr>
<tr><td class="num" id="LN3128">3128</td><td class="line">      range-&gt;set_assigned_slot(index);</td></tr>
<tr><td class="num" id="LN3129">3129</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3130">3130</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3131">3131</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3132">3132</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3133">3133</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3134">3134</td><td class="line"><span class='keyword'>void</span> OperandAssigner::CommitAssignment() {</td></tr>
<tr><td class="num" id="LN3135">3135</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* top_range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN3136">3136</td><td class="line">    <span class='keyword'>if</span> (top_range == <span class='keyword'>nullptr</span> || top_range-&gt;IsEmpty()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3137">3137</td><td class="line">    InstructionOperand spill_operand;</td></tr>
<tr><td class="num" id="LN3138">3138</td><td class="line">    <span class='keyword'>if</span> (top_range-&gt;HasSpillOperand()) {</td></tr>
<tr><td class="num" id="LN3139">3139</td><td class="line">      spill_operand = *top_range-&gt;TopLevel()-&gt;GetSpillOperand();</td></tr>
<tr><td class="num" id="LN3140">3140</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (top_range-&gt;TopLevel()-&gt;HasSpillRange()) {</td></tr>
<tr><td class="num" id="LN3141">3141</td><td class="line">      spill_operand = top_range-&gt;TopLevel()-&gt;GetSpillRangeOperand();</td></tr>
<tr><td class="num" id="LN3142">3142</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3143">3143</td><td class="line">    <span class='keyword'>if</span> (top_range-&gt;is_phi()) {</td></tr>
<tr><td class="num" id="LN3144">3144</td><td class="line">      data()-&gt;GetPhiMapValueFor(top_range)-&gt;CommitAssignment(</td></tr>
<tr><td class="num" id="LN3145">3145</td><td class="line">          top_range-&gt;GetAssignedOperand());</td></tr>
<tr><td class="num" id="LN3146">3146</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3147">3147</td><td class="line">    <span class='keyword'>for</span> (LiveRange* range = top_range; range != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN3148">3148</td><td class="line">         range = range-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3149">3149</td><td class="line">      InstructionOperand assigned = range-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3150">3150</td><td class="line">      range-&gt;ConvertUsesToOperand(assigned, spill_operand);</td></tr>
<tr><td class="num" id="LN3151">3151</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3152">3152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3153">3153</td><td class="line">    <span class='keyword'>if</span> (!spill_operand.IsInvalid()) {</td></tr>
<tr><td class="num" id="LN3154">3154</td><td class="line">      <span class='comment'>// If this top level range has a child spilled in a deferred block, we use</span></td></tr>
<tr><td class="num" id="LN3155">3155</td><td class="line">      <span class='comment'>// the range and control flow connection mechanism instead of spilling at</span></td></tr>
<tr><td class="num" id="LN3156">3156</td><td class="line">      <span class='comment'>// definition. Refer to the ConnectLiveRanges and ResolveControlFlow</span></td></tr>
<tr><td class="num" id="LN3157">3157</td><td class="line">      <span class='comment'>// phases. Normally, when we spill at definition, we do not insert a</span></td></tr>
<tr><td class="num" id="LN3158">3158</td><td class="line">      <span class='comment'>// connecting move when a successor child range is spilled - because the</span></td></tr>
<tr><td class="num" id="LN3159">3159</td><td class="line">      <span class='comment'>// spilled range picks up its value from the slot which was assigned at</span></td></tr>
<tr><td class="num" id="LN3160">3160</td><td class="line">      <span class='comment'>// definition. For ranges that are determined to spill only in deferred</span></td></tr>
<tr><td class="num" id="LN3161">3161</td><td class="line">      <span class='comment'>// blocks, we let ConnectLiveRanges and ResolveControlFlow find the blocks</span></td></tr>
<tr><td class="num" id="LN3162">3162</td><td class="line">      <span class='comment'>// where a spill operand is expected, and then finalize by inserting the</span></td></tr>
<tr><td class="num" id="LN3163">3163</td><td class="line">      <span class='comment'>// spills in the deferred blocks dominators.</span></td></tr>
<tr><td class="num" id="LN3164">3164</td><td class="line">      <span class='keyword'>if</span> (!top_range-&gt;IsSpilledOnlyInDeferredBlocks()) {</td></tr>
<tr><td class="num" id="LN3165">3165</td><td class="line">        <span class='comment'>// Spill at definition if the range isn't spilled only in deferred</span></td></tr>
<tr><td class="num" id="LN3166">3166</td><td class="line">        <span class='comment'>// blocks.</span></td></tr>
<tr><td class="num" id="LN3167">3167</td><td class="line">        top_range-&gt;CommitSpillMoves(</td></tr>
<tr><td class="num" id="LN3168">3168</td><td class="line">            data()-&gt;code(), spill_operand,</td></tr>
<tr><td class="num" id="LN3169">3169</td><td class="line">            top_range-&gt;has_slot_use() || top_range-&gt;spilled());</td></tr>
<tr><td class="num" id="LN3170">3170</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3171">3171</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3172">3172</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3173">3173</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3174">3174</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3175">3175</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3176">3176</td><td class="line">ReferenceMapPopulator::ReferenceMapPopulator(RegisterAllocationData* data)</td></tr>
<tr><td class="num" id="LN3177">3177</td><td class="line">    : data_(data) {}</td></tr>
<tr><td class="num" id="LN3178">3178</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3179">3179</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3180">3180</td><td class="line"><span class='keyword'>bool</span> ReferenceMapPopulator::SafePointsAreInOrder() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN3181">3181</td><td class="line">  <span class='keyword'>int</span> safe_point = 0;</td></tr>
<tr><td class="num" id="LN3182">3182</td><td class="line">  <span class='keyword'>for</span> (ReferenceMap* map : *data()-&gt;code()-&gt;reference_maps()) {</td></tr>
<tr><td class="num" id="LN3183">3183</td><td class="line">    <span class='keyword'>if</span> (safe_point &gt; map-&gt;instruction_position()) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3184">3184</td><td class="line">    safe_point = map-&gt;instruction_position();</td></tr>
<tr><td class="num" id="LN3185">3185</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3186">3186</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3187">3187</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3188">3188</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3189">3189</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3190">3190</td><td class="line"><span class='keyword'>void</span> ReferenceMapPopulator::PopulateReferenceMaps() {</td></tr>
<tr><td class="num" id="LN3191">3191</td><td class="line">  <span class='macro'>DCHECK(SafePointsAreInOrder())<span class='expansion'>do { if ((__builtin_expect(!!(!(SafePointsAreInOrder())), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 3191, "Check failed: %s."<br>, "SafePointsAreInOrder()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3192">3192</td><td class="line">  <span class='comment'>// Map all delayed references.</span></td></tr>
<tr><td class="num" id="LN3193">3193</td><td class="line">  <span class='keyword'>for</span> (RegisterAllocationData::DelayedReference&amp; delayed_reference :</td></tr>
<tr><td class="num" id="LN3194">3194</td><td class="line">       data()-&gt;delayed_references()) {</td></tr>
<tr><td class="num" id="LN3195">3195</td><td class="line">    delayed_reference.map-&gt;RecordReference(</td></tr>
<tr><td class="num" id="LN3196">3196</td><td class="line">        AllocatedOperand::cast(*delayed_reference.operand));</td></tr>
<tr><td class="num" id="LN3197">3197</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3198">3198</td><td class="line">  <span class='comment'>// Iterate over all safe point positions and record a pointer</span></td></tr>
<tr><td class="num" id="LN3199">3199</td><td class="line">  <span class='comment'>// for all spilled live ranges at this point.</span></td></tr>
<tr><td class="num" id="LN3200">3200</td><td class="line">  <span class='keyword'>int</span> last_range_start = 0;</td></tr>
<tr><td class="num" id="LN3201">3201</td><td class="line">  <span class='keyword'>const</span> ReferenceMapDeque* reference_maps = data()-&gt;code()-&gt;reference_maps();</td></tr>
<tr><td class="num" id="LN3202">3202</td><td class="line">  ReferenceMapDeque::const_iterator first_it = reference_maps-&gt;begin();</td></tr>
<tr><td class="num" id="LN3203">3203</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN3204">3204</td><td class="line">    <span class='keyword'>if</span> (range == <span class='keyword'>nullptr</span>) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3205">3205</td><td class="line">    <span class='comment'>// Skip non-reference values.</span></td></tr>
<tr><td class="num" id="LN3206">3206</td><td class="line">    <span class='keyword'>if</span> (!data()-&gt;IsReference(range)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3207">3207</td><td class="line">    <span class='comment'>// Skip empty live ranges.</span></td></tr>
<tr><td class="num" id="LN3208">3208</td><td class="line">    <span class='keyword'>if</span> (range-&gt;IsEmpty()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3209">3209</td><td class="line">    <span class='keyword'>if</span> (range-&gt;has_preassigned_slot()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3210">3210</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3211">3211</td><td class="line">    <span class='comment'>// Find the extent of the range and its children.</span></td></tr>
<tr><td class="num" id="LN3212">3212</td><td class="line">    <span class='keyword'>int</span> start = range-&gt;Start().ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN3213">3213</td><td class="line">    <span class='keyword'>int</span> end = 0;</td></tr>
<tr><td class="num" id="LN3214">3214</td><td class="line">    <span class='keyword'>for</span> (LiveRange* cur = range; cur != <span class='keyword'>nullptr</span>; cur = cur-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3215">3215</td><td class="line">      LifetimePosition this_end = cur-&gt;End();</td></tr>
<tr><td class="num" id="LN3216">3216</td><td class="line">      <span class='keyword'>if</span> (this_end.ToInstructionIndex() &gt; end)</td></tr>
<tr><td class="num" id="LN3217">3217</td><td class="line">        end = this_end.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN3218">3218</td><td class="line">      <span class='macro'>DCHECK(cur-&gt;Start().ToInstructionIndex() &gt;= start)<span class='expansion'>do { if ((__builtin_expect(!!(!(cur-&gt;Start().ToInstructionIndex<br>() &gt;= start)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3218, "Check failed: %s.", "cur-&gt;Start().ToInstructionIndex() &gt;= start"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3219">3219</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3220">3220</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3221">3221</td><td class="line">    <span class='comment'>// Most of the ranges are in order, but not all.  Keep an eye on when they</span></td></tr>
<tr><td class="num" id="LN3222">3222</td><td class="line">    <span class='comment'>// step backwards and reset the first_it so we don't miss any safe points.</span></td></tr>
<tr><td class="num" id="LN3223">3223</td><td class="line">    <span class='keyword'>if</span> (start &lt; last_range_start) first_it = reference_maps-&gt;begin();</td></tr>
<tr><td class="num" id="LN3224">3224</td><td class="line">    last_range_start = start;</td></tr>
<tr><td class="num" id="LN3225">3225</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3226">3226</td><td class="line">    <span class='comment'>// Step across all the safe points that are before the start of this range,</span></td></tr>
<tr><td class="num" id="LN3227">3227</td><td class="line">    <span class='comment'>// recording how far we step in order to save doing this for the next range.</span></td></tr>
<tr><td class="num" id="LN3228">3228</td><td class="line">    <span class='keyword'>for</span> (; first_it != reference_maps-&gt;end(); ++first_it) {</td></tr>
<tr><td class="num" id="LN3229">3229</td><td class="line">      ReferenceMap* map = *first_it;</td></tr>
<tr><td class="num" id="LN3230">3230</td><td class="line">      <span class='keyword'>if</span> (map-&gt;instruction_position() &gt;= start) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3231">3231</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3232">3232</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3233">3233</td><td class="line">    InstructionOperand spill_operand;</td></tr>
<tr><td class="num" id="LN3234">3234</td><td class="line">    <span class='keyword'>if</span> (((range-&gt;HasSpillOperand() &amp;&amp;</td></tr>
<tr><td class="num" id="LN3235">3235</td><td class="line">          !range-&gt;GetSpillOperand()-&gt;IsConstant()) ||</td></tr>
<tr><td class="num" id="LN3236">3236</td><td class="line">         range-&gt;HasSpillRange())) {</td></tr>
<tr><td class="num" id="LN3237">3237</td><td class="line">      <span class='keyword'>if</span> (range-&gt;HasSpillOperand()) {</td></tr>
<tr><td class="num" id="LN3238">3238</td><td class="line">        spill_operand = *range-&gt;GetSpillOperand();</td></tr>
<tr><td class="num" id="LN3239">3239</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3240">3240</td><td class="line">        spill_operand = range-&gt;GetSpillRangeOperand();</td></tr>
<tr><td class="num" id="LN3241">3241</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3242">3242</td><td class="line">      <span class='macro'>DCHECK(spill_operand.IsStackSlot())<span class='expansion'>do { if ((__builtin_expect(!!(!(spill_operand.IsStackSlot()))<br>, 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 3242<br>, "Check failed: %s.", "spill_operand.IsStackSlot()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3243">3243</td><td class="line">      <span class='macro'>DCHECK_EQ(MachineRepresentation::kTagged,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (MachineRepresentation<br>::kTagged), (AllocatedOperand::cast(spill_operand).representation<br>()), "MachineRepresentation::kTagged" " " "==" " " "AllocatedOperand::cast(spill_operand).representation()"<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 3244, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3244">3244</td><td class="line">                <span class='macro'>AllocatedOperand::cast(spill_operand).representation())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (MachineRepresentation<br>::kTagged), (AllocatedOperand::cast(spill_operand).representation<br>()), "MachineRepresentation::kTagged" " " "==" " " "AllocatedOperand::cast(spill_operand).representation()"<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 3244, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3245">3245</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3246">3246</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3247">3247</td><td class="line">    LiveRange* cur = range;</td></tr>
<tr><td class="num" id="LN3248">3248</td><td class="line">    <span class='comment'>// Step through the safe points to see whether they are in the range.</span></td></tr>
<tr><td class="num" id="LN3249">3249</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>auto</span> it = first_it; it != reference_maps-&gt;end(); ++it) {</td></tr>
<tr><td class="num" id="LN3250">3250</td><td class="line">      ReferenceMap* map = *it;</td></tr>
<tr><td class="num" id="LN3251">3251</td><td class="line">      <span class='keyword'>int</span> safe_point = map-&gt;instruction_position();</td></tr>
<tr><td class="num" id="LN3252">3252</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3253">3253</td><td class="line">      <span class='comment'>// The safe points are sorted so we can stop searching here.</span></td></tr>
<tr><td class="num" id="LN3254">3254</td><td class="line">      <span class='keyword'>if</span> (safe_point - 1 &gt; end) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3255">3255</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3256">3256</td><td class="line">      <span class='comment'>// Advance to the next active range that covers the current</span></td></tr>
<tr><td class="num" id="LN3257">3257</td><td class="line">      <span class='comment'>// safe point position.</span></td></tr>
<tr><td class="num" id="LN3258">3258</td><td class="line">      LifetimePosition safe_point_pos =</td></tr>
<tr><td class="num" id="LN3259">3259</td><td class="line">          LifetimePosition::InstructionFromInstructionIndex(safe_point);</td></tr>
<tr><td class="num" id="LN3260">3260</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3261">3261</td><td class="line">      <span class='comment'>// Search for the child range (cur) that covers safe_point_pos. If we</span></td></tr>
<tr><td class="num" id="LN3262">3262</td><td class="line">      <span class='comment'>// don't find it before the children pass safe_point_pos, keep cur at</span></td></tr>
<tr><td class="num" id="LN3263">3263</td><td class="line">      <span class='comment'>// the last child, because the next safe_point_pos may be covered by cur.</span></td></tr>
<tr><td class="num" id="LN3264">3264</td><td class="line">      <span class='comment'>// This may happen if cur has more than one interval, and the current</span></td></tr>
<tr><td class="num" id="LN3265">3265</td><td class="line">      <span class='comment'>// safe_point_pos is in between intervals.</span></td></tr>
<tr><td class="num" id="LN3266">3266</td><td class="line">      <span class='comment'>// For that reason, cur may be at most the last child.</span></td></tr>
<tr><td class="num" id="LN3267">3267</td><td class="line">      <span class='macro'>DCHECK_NOT_NULL(cur)<span class='expansion'>do { if ((__builtin_expect(!!(!((cur) != nullptr)), 0))) { V8_Fatal<br>("../src/compiler/register-allocator.cc", 3267, "Check failed: %s."<br>, "(cur) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3268">3268</td><td class="line">      <span class='macro'>DCHECK(safe_point_pos &gt;= cur-&gt;Start() || range == cur)<span class='expansion'>do { if ((__builtin_expect(!!(!(safe_point_pos &gt;= cur-&gt;<br>Start() || range == cur)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3268, "Check failed: %s.", "safe_point_pos &gt;= cur-&gt;Start() || range == cur"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3269">3269</td><td class="line">      <span class='keyword'>bool</span> found = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3270">3270</td><td class="line">      <span class='keyword'>while</span> (!found) {</td></tr>
<tr><td class="num" id="LN3271">3271</td><td class="line">        <span class='keyword'>if</span> (cur-&gt;Covers(safe_point_pos)) {</td></tr>
<tr><td class="num" id="LN3272">3272</td><td class="line">          found = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3273">3273</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3274">3274</td><td class="line">          LiveRange* next = cur-&gt;next();</td></tr>
<tr><td class="num" id="LN3275">3275</td><td class="line">          <span class='keyword'>if</span> (next == <span class='keyword'>nullptr</span> || next-&gt;Start() &gt; safe_point_pos) {</td></tr>
<tr><td class="num" id="LN3276">3276</td><td class="line">            <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3277">3277</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3278">3278</td><td class="line">          cur = next;</td></tr>
<tr><td class="num" id="LN3279">3279</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3280">3280</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3281">3281</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3282">3282</td><td class="line">      <span class='keyword'>if</span> (!found) {</td></tr>
<tr><td class="num" id="LN3283">3283</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3284">3284</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3285">3285</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3286">3286</td><td class="line">      <span class='comment'>// Check if the live range is spilled and the safe point is after</span></td></tr>
<tr><td class="num" id="LN3287">3287</td><td class="line">      <span class='comment'>// the spill position.</span></td></tr>
<tr><td class="num" id="LN3288">3288</td><td class="line">      <span class='keyword'>int</span> spill_index = range-&gt;IsSpilledOnlyInDeferredBlocks()</td></tr>
<tr><td class="num" id="LN3289">3289</td><td class="line">                            ? cur-&gt;Start().ToInstructionIndex()</td></tr>
<tr><td class="num" id="LN3290">3290</td><td class="line">                            : range-&gt;spill_start_index();</td></tr>
<tr><td class="num" id="LN3291">3291</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3292">3292</td><td class="line">      <span class='keyword'>if</span> (!spill_operand.IsInvalid() &amp;&amp; safe_point &gt;= spill_index) {</td></tr>
<tr><td class="num" id="LN3293">3293</td><td class="line">        <span class='macro'>TRACE(<span class='string_literal'>"Pointer for range %d (spilled at %d) at safe point %d\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer for range %d (spilled at %d) at safe point %d\n"<br>, range-&gt;vreg(), spill_index, safe_point); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN3294">3294</td><td class="line">              <span class='macro'>range-&gt;vreg(), spill_index, safe_point)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer for range %d (spilled at %d) at safe point %d\n"<br>, range-&gt;vreg(), spill_index, safe_point); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN3295">3295</td><td class="line">        map-&gt;RecordReference(AllocatedOperand::cast(spill_operand));</td></tr>
<tr><td class="num" id="LN3296">3296</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3297">3297</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3298">3298</td><td class="line">      <span class='keyword'>if</span> (!cur-&gt;spilled()) {</td></tr>
<tr><td class="num" id="LN3299">3299</td><td class="line">        <span class='macro'>TRACE(<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer in register for range %d:%d (start at %d) "<br> "at safe point %d\n", range-&gt;vreg(), cur-&gt;relative_id(<br>), cur-&gt;Start().value(), safe_point); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN3300">3300</td><td class="line">            <span class='string_literal'><span class='macro'>"Pointer in register for range %d:%d (start at %d) "<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer in register for range %d:%d (start at %d) "<br> "at safe point %d\n", range-&gt;vreg(), cur-&gt;relative_id(<br>), cur-&gt;Start().value(), safe_point); } while (false)</span></span></span></td></tr>
<tr><td class="num" id="LN3301">3301</td><td class="line">            <span class='string_literal'><span class='macro'>"at safe point %d\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer in register for range %d:%d (start at %d) "<br> "at safe point %d\n", range-&gt;vreg(), cur-&gt;relative_id(<br>), cur-&gt;Start().value(), safe_point); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN3302">3302</td><td class="line">            <span class='macro'>range-&gt;vreg(), cur-&gt;relative_id(), cur-&gt;Start().value(),<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer in register for range %d:%d (start at %d) "<br> "at safe point %d\n", range-&gt;vreg(), cur-&gt;relative_id(<br>), cur-&gt;Start().value(), safe_point); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN3303">3303</td><td class="line">            <span class='macro'>safe_point)<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Pointer in register for range %d:%d (start at %d) "<br> "at safe point %d\n", range-&gt;vreg(), cur-&gt;relative_id(<br>), cur-&gt;Start().value(), safe_point); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN3304">3304</td><td class="line">        InstructionOperand operand = cur-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3305">3305</td><td class="line">        <span class='macro'>DCHECK(!operand.IsStackSlot())<span class='expansion'>do { if ((__builtin_expect(!!(!(!operand.IsStackSlot())), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 3305, "Check failed: %s."<br>, "!operand.IsStackSlot()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3306">3306</td><td class="line">        <span class='macro'>DCHECK_EQ(MachineRepresentation::kTagged,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (MachineRepresentation<br>::kTagged), (AllocatedOperand::cast(operand).representation()<br>), "MachineRepresentation::kTagged" " " "==" " " "AllocatedOperand::cast(operand).representation()"<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 3307, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3307">3307</td><td class="line">                  <span class='macro'>AllocatedOperand::cast(operand).representation())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (MachineRepresentation<br>::kTagged), (AllocatedOperand::cast(operand).representation()<br>), "MachineRepresentation::kTagged" " " "==" " " "AllocatedOperand::cast(operand).representation()"<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 3307, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3308">3308</td><td class="line">        map-&gt;RecordReference(AllocatedOperand::cast(operand));</td></tr>
<tr><td class="num" id="LN3309">3309</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3310">3310</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3311">3311</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3312">3312</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3313">3313</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3314">3314</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3315">3315</td><td class="line">LiveRangeConnector::LiveRangeConnector(RegisterAllocationData* data)</td></tr>
<tr><td class="num" id="LN3316">3316</td><td class="line">    : data_(data) {}</td></tr>
<tr><td class="num" id="LN3317">3317</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3318">3318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3319">3319</td><td class="line"><span class='keyword'>bool</span> LiveRangeConnector::CanEagerlyResolveControlFlow(</td></tr>
<tr><td class="num" id="LN3320">3320</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* block) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN3321">3321</td><td class="line">  <span class='keyword'>if</span> (block-&gt;PredecessorCount() != 1) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3322">3322</td><td class="line">  <span class='keyword'>return</span> block-&gt;predecessors()[0].IsNext(block-&gt;rpo_number());</td></tr>
<tr><td class="num" id="LN3323">3323</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3324">3324</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3325">3325</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3326">3326</td><td class="line"><span class='keyword'>void</span> LiveRangeConnector::ResolveControlFlow(Zone* local_zone) {</td></tr>
<tr><td class="num" id="LN3327">3327</td><td class="line">  <span class='comment'>// Lazily linearize live ranges in memory for fast lookup.</span></td></tr>
<tr><td class="num" id="LN3328">3328</td><td class="line">  LiveRangeFinder finder(data(), local_zone);</td></tr>
<tr><td class="num" id="LN3329">3329</td><td class="line">  ZoneVector&lt;BitVector*&gt;&amp; live_in_sets = data()-&gt;live_in_sets();</td></tr>
<tr><td class="num" id="LN3330">3330</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> InstructionBlock* block : code()-&gt;instruction_blocks()) {</td></tr>
<tr><td class="num" id="LN3331">3331</td><td class="line">    <span class='keyword'>if</span> (CanEagerlyResolveControlFlow(block)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3332">3332</td><td class="line">    BitVector* live = live_in_sets[block-&gt;rpo_number().ToInt()];</td></tr>
<tr><td class="num" id="LN3333">3333</td><td class="line">    BitVector::Iterator iterator(live);</td></tr>
<tr><td class="num" id="LN3334">3334</td><td class="line">    <span class='keyword'>while</span> (!iterator.Done()) {</td></tr>
<tr><td class="num" id="LN3335">3335</td><td class="line">      LiveRangeBoundArray* array = finder.ArrayFor(iterator.Current());</td></tr>
<tr><td class="num" id="LN3336">3336</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>const</span> RpoNumber&amp; pred : block-&gt;predecessors()) {</td></tr>
<tr><td class="num" id="LN3337">3337</td><td class="line">        FindResult result;</td></tr>
<tr><td class="num" id="LN3338">3338</td><td class="line">        <span class='keyword'>const</span> InstructionBlock* pred_block = code()-&gt;InstructionBlockAt(pred);</td></tr>
<tr><td class="num" id="LN3339">3339</td><td class="line">        <span class='keyword'>if</span> (!array-&gt;FindConnectableSubranges(block, pred_block, &amp;result)) {</td></tr>
<tr><td class="num" id="LN3340">3340</td><td class="line">          <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3341">3341</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3342">3342</td><td class="line">        InstructionOperand pred_op = result.pred_cover_-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3343">3343</td><td class="line">        InstructionOperand cur_op = result.cur_cover_-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3344">3344</td><td class="line">        <span class='keyword'>if</span> (pred_op.Equals(cur_op)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3345">3345</td><td class="line">        <span class='keyword'>if</span> (!pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister()) {</td></tr>
<tr><td class="num" id="LN3346">3346</td><td class="line">          <span class='comment'>// We're doing a reload.</span></td></tr>
<tr><td class="num" id="LN3347">3347</td><td class="line">          <span class='comment'>// We don't need to, if:</span></td></tr>
<tr><td class="num" id="LN3348">3348</td><td class="line">          <span class='comment'>// 1) there's no register use in this block, and</span></td></tr>
<tr><td class="num" id="LN3349">3349</td><td class="line">          <span class='comment'>// 2) the range ends before the block does, and</span></td></tr>
<tr><td class="num" id="LN3350">3350</td><td class="line">          <span class='comment'>// 3) we don't have a successor, or the successor is spilled.</span></td></tr>
<tr><td class="num" id="LN3351">3351</td><td class="line">          LifetimePosition block_start =</td></tr>
<tr><td class="num" id="LN3352">3352</td><td class="line">              LifetimePosition::GapFromInstructionIndex(block-&gt;code_start());</td></tr>
<tr><td class="num" id="LN3353">3353</td><td class="line">          LifetimePosition block_end =</td></tr>
<tr><td class="num" id="LN3354">3354</td><td class="line">              LifetimePosition::GapFromInstructionIndex(block-&gt;code_end());</td></tr>
<tr><td class="num" id="LN3355">3355</td><td class="line">          <span class='keyword'>const</span> LiveRange* current = result.cur_cover_;</td></tr>
<tr><td class="num" id="LN3356">3356</td><td class="line">          <span class='keyword'>const</span> LiveRange* successor = current-&gt;next();</td></tr>
<tr><td class="num" id="LN3357">3357</td><td class="line">          <span class='keyword'>if</span> (current-&gt;End() &lt; block_end &amp;&amp;</td></tr>
<tr><td class="num" id="LN3358">3358</td><td class="line">              (successor == <span class='keyword'>nullptr</span> || successor-&gt;spilled())) {</td></tr>
<tr><td class="num" id="LN3359">3359</td><td class="line">            <span class='comment'>// verify point 1: no register use. We can go to the end of the</span></td></tr>
<tr><td class="num" id="LN3360">3360</td><td class="line">            <span class='comment'>// range, since it's all within the block.</span></td></tr>
<tr><td class="num" id="LN3361">3361</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3362">3362</td><td class="line">            <span class='keyword'>bool</span> uses_reg = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3363">3363</td><td class="line">            <span class='keyword'>for</span> (<span class='keyword'>const</span> UsePosition* use = current-&gt;NextUsePosition(block_start);</td></tr>
<tr><td class="num" id="LN3364">3364</td><td class="line">                 use != <span class='keyword'>nullptr</span>; use = use-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3365">3365</td><td class="line">              <span class='keyword'>if</span> (use-&gt;operand()-&gt;IsAnyRegister()) {</td></tr>
<tr><td class="num" id="LN3366">3366</td><td class="line">                uses_reg = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3367">3367</td><td class="line">                <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3368">3368</td><td class="line">              }</td></tr>
<tr><td class="num" id="LN3369">3369</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN3370">3370</td><td class="line">            <span class='keyword'>if</span> (!uses_reg) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3371">3371</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3372">3372</td><td class="line">          <span class='keyword'>if</span> (current-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp;</td></tr>
<tr><td class="num" id="LN3373">3373</td><td class="line">              pred_block-&gt;IsDeferred()) {</td></tr>
<tr><td class="num" id="LN3374">3374</td><td class="line">            <span class='comment'>// The spill location should be defined in pred_block, so add</span></td></tr>
<tr><td class="num" id="LN3375">3375</td><td class="line">            <span class='comment'>// pred_block to the list of blocks requiring a spill operand.</span></td></tr>
<tr><td class="num" id="LN3376">3376</td><td class="line">            current-&gt;TopLevel()-&gt;GetListOfBlocksRequiringSpillOperands()-&gt;Add(</td></tr>
<tr><td class="num" id="LN3377">3377</td><td class="line">                pred_block-&gt;rpo_number().ToInt());</td></tr>
<tr><td class="num" id="LN3378">3378</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN3379">3379</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3380">3380</td><td class="line">        <span class='keyword'>int</span> move_loc = ResolveControlFlow(block, cur_op, pred_block, pred_op);</td></tr>
<tr><td class="num" id="LN3381">3381</td><td class="line">        USE(move_loc);</td></tr>
<tr><td class="num" id="LN3382">3382</td><td class="line">        <span class='macro'>DCHECK_IMPLIES(<span class='expansion'>do { if ((__builtin_expect(!!(!(!(result.cur_cover_-&gt;TopLevel<br>()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister<br>() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock<br>(move_loc)-&gt;IsDeferred()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3385, "Check failed: %s.", "!(result.cur_cover_-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(move_loc)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3383">3383</td><td class="line">            <span class='macro'>result.cur_cover_-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp;<span class='expansion'>do { if ((__builtin_expect(!!(!(!(result.cur_cover_-&gt;TopLevel<br>()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister<br>() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock<br>(move_loc)-&gt;IsDeferred()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3385, "Check failed: %s.", "!(result.cur_cover_-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(move_loc)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3384">3384</td><td class="line">                <span class='macro'>!(pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister()),<span class='expansion'>do { if ((__builtin_expect(!!(!(!(result.cur_cover_-&gt;TopLevel<br>()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister<br>() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock<br>(move_loc)-&gt;IsDeferred()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3385, "Check failed: %s.", "!(result.cur_cover_-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(move_loc)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3385">3385</td><td class="line">            <span class='macro'>code()-&gt;GetInstructionBlock(move_loc)-&gt;IsDeferred())<span class='expansion'>do { if ((__builtin_expect(!!(!(!(result.cur_cover_-&gt;TopLevel<br>()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister<br>() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock<br>(move_loc)-&gt;IsDeferred()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3385, "Check failed: %s.", "!(result.cur_cover_-&gt;TopLevel()-&gt;IsSpilledOnlyInDeferredBlocks() &amp;&amp; !(pred_op.IsAnyRegister() &amp;&amp; cur_op.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(move_loc)-&gt;IsDeferred())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3386">3386</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3387">3387</td><td class="line">      iterator.Advance();</td></tr>
<tr><td class="num" id="LN3388">3388</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3389">3389</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3390">3390</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3391">3391</td><td class="line">  <span class='comment'>// At this stage, we collected blocks needing a spill operand from</span></td></tr>
<tr><td class="num" id="LN3392">3392</td><td class="line">  <span class='comment'>// ConnectRanges and from ResolveControlFlow. Time to commit the spills for</span></td></tr>
<tr><td class="num" id="LN3393">3393</td><td class="line">  <span class='comment'>// deferred blocks.</span></td></tr>
<tr><td class="num" id="LN3394">3394</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* top : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN3395">3395</td><td class="line">    <span class='keyword'>if</span> (top == <span class='keyword'>nullptr</span> || top-&gt;IsEmpty() ||</td></tr>
<tr><td class="num" id="LN3396">3396</td><td class="line">        !top-&gt;IsSpilledOnlyInDeferredBlocks())</td></tr>
<tr><td class="num" id="LN3397">3397</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3398">3398</td><td class="line">    CommitSpillsInDeferredBlocks(top, finder.ArrayFor(top-&gt;vreg()), local_zone);</td></tr>
<tr><td class="num" id="LN3399">3399</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3400">3400</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3401">3401</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3402">3402</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3403">3403</td><td class="line"><span class='keyword'>int</span> LiveRangeConnector::ResolveControlFlow(<span class='keyword'>const</span> InstructionBlock* block,</td></tr>
<tr><td class="num" id="LN3404">3404</td><td class="line">                                           <span class='keyword'>const</span> InstructionOperand&amp; cur_op,</td></tr>
<tr><td class="num" id="LN3405">3405</td><td class="line">                                           <span class='keyword'>const</span> InstructionBlock* pred,</td></tr>
<tr><td class="num" id="LN3406">3406</td><td class="line">                                           <span class='keyword'>const</span> InstructionOperand&amp; pred_op) {</td></tr>
<tr><td class="num" id="LN3407">3407</td><td class="line">  <span class='macro'>DCHECK(!pred_op.Equals(cur_op))<span class='expansion'>do { if ((__builtin_expect(!!(!(!pred_op.Equals(cur_op))), 0)<br>)) { V8_Fatal("../src/compiler/register-allocator.cc", 3407, "Check failed: %s."<br>, "!pred_op.Equals(cur_op)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3408">3408</td><td class="line">  <span class='keyword'>int</span> gap_index;</td></tr>
<tr><td class="num" id="LN3409">3409</td><td class="line">  Instruction::GapPosition position;</td></tr>
<tr><td class="num" id="LN3410">3410</td><td class="line">  <span class='keyword'>if</span> (block-&gt;PredecessorCount() == 1) {</td></tr>
<tr><td class="num" id="LN3411">3411</td><td class="line">    gap_index = block-&gt;first_instruction_index();</td></tr>
<tr><td class="num" id="LN3412">3412</td><td class="line">    position = Instruction::START;</td></tr>
<tr><td class="num" id="LN3413">3413</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3414">3414</td><td class="line">    <span class='macro'>DCHECK(pred-&gt;SuccessorCount() == 1)<span class='expansion'>do { if ((__builtin_expect(!!(!(pred-&gt;SuccessorCount() == 1<br>)), 0))) { V8_Fatal("../src/compiler/register-allocator.cc", 3414<br>, "Check failed: %s.", "pred-&gt;SuccessorCount() == 1"); } }<br> while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3415">3415</td><td class="line">    <span class='macro'>DCHECK(!code()<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(pred<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 3417, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(pred-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3416">3416</td><td class="line">                <span class='macro'>-&gt;InstructionAt(pred-&gt;last_instruction_index())<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(pred<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 3417, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(pred-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3417">3417</td><td class="line">                <span class='macro'>-&gt;HasReferenceMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(!code() -&gt;InstructionAt(pred<br>-&gt;last_instruction_index()) -&gt;HasReferenceMap())), 0)))<br> { V8_Fatal("../src/compiler/register-allocator.cc", 3417, "Check failed: %s."<br>, "!code() -&gt;InstructionAt(pred-&gt;last_instruction_index()) -&gt;HasReferenceMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3418">3418</td><td class="line">    gap_index = pred-&gt;last_instruction_index();</td></tr>
<tr><td class="num" id="LN3419">3419</td><td class="line">    position = Instruction::END;</td></tr>
<tr><td class="num" id="LN3420">3420</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3421">3421</td><td class="line">  data()-&gt;AddGapMove(gap_index, position, pred_op, cur_op);</td></tr>
<tr><td class="num" id="LN3422">3422</td><td class="line">  <span class='keyword'>return</span> gap_index;</td></tr>
<tr><td class="num" id="LN3423">3423</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3424">3424</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3425">3425</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3426">3426</td><td class="line"><span class='keyword'>void</span> LiveRangeConnector::ConnectRanges(Zone* local_zone) {</td></tr>
<tr><td class="num" id="LN3427">3427</td><td class="line">  DelayedInsertionMap delayed_insertion_map(local_zone);</td></tr>
<tr><td class="num" id="LN3428">3428</td><td class="line">  <span class='keyword'>for</span> (TopLevelLiveRange* top_range : data()-&gt;live_ranges()) {</td></tr>
<tr><td class="num" id="LN3429">3429</td><td class="line">    <span class='keyword'>if</span> (top_range == <span class='keyword'>nullptr</span>) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3430">3430</td><td class="line">    <span class='keyword'>bool</span> connect_spilled = top_range-&gt;IsSpilledOnlyInDeferredBlocks();</td></tr>
<tr><td class="num" id="LN3431">3431</td><td class="line">    LiveRange* first_range = top_range;</td></tr>
<tr><td class="num" id="LN3432">3432</td><td class="line">    <span class='keyword'>for</span> (LiveRange *second_range = first_range-&gt;next(); second_range != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN3433">3433</td><td class="line">         first_range = second_range, second_range = second_range-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3434">3434</td><td class="line">      LifetimePosition pos = second_range-&gt;Start();</td></tr>
<tr><td class="num" id="LN3435">3435</td><td class="line">      <span class='comment'>// Add gap move if the two live ranges touch and there is no block</span></td></tr>
<tr><td class="num" id="LN3436">3436</td><td class="line">      <span class='comment'>// boundary.</span></td></tr>
<tr><td class="num" id="LN3437">3437</td><td class="line">      <span class='keyword'>if</span> (second_range-&gt;spilled()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3438">3438</td><td class="line">      <span class='keyword'>if</span> (first_range-&gt;End() != pos) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3439">3439</td><td class="line">      <span class='keyword'>if</span> (data()-&gt;IsBlockBoundary(pos) &amp;&amp;</td></tr>
<tr><td class="num" id="LN3440">3440</td><td class="line">          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {</td></tr>
<tr><td class="num" id="LN3441">3441</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3442">3442</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3443">3443</td><td class="line">      InstructionOperand prev_operand = first_range-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3444">3444</td><td class="line">      InstructionOperand cur_operand = second_range-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3445">3445</td><td class="line">      <span class='keyword'>if</span> (prev_operand.Equals(cur_operand)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3446">3446</td><td class="line">      <span class='keyword'>bool</span> delay_insertion = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN3447">3447</td><td class="line">      Instruction::GapPosition gap_pos;</td></tr>
<tr><td class="num" id="LN3448">3448</td><td class="line">      <span class='keyword'>int</span> gap_index = pos.ToInstructionIndex();</td></tr>
<tr><td class="num" id="LN3449">3449</td><td class="line">      <span class='keyword'>if</span> (connect_spilled &amp;&amp; !prev_operand.IsAnyRegister() &amp;&amp;</td></tr>
<tr><td class="num" id="LN3450">3450</td><td class="line">          cur_operand.IsAnyRegister()) {</td></tr>
<tr><td class="num" id="LN3451">3451</td><td class="line">        <span class='keyword'>const</span> InstructionBlock* block = code()-&gt;GetInstructionBlock(gap_index);</td></tr>
<tr><td class="num" id="LN3452">3452</td><td class="line">        <span class='macro'>DCHECK(block-&gt;IsDeferred())<span class='expansion'>do { if ((__builtin_expect(!!(!(block-&gt;IsDeferred())), 0))<br>) { V8_Fatal("../src/compiler/register-allocator.cc", 3452, "Check failed: %s."<br>, "block-&gt;IsDeferred()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3453">3453</td><td class="line">        <span class='comment'>// Performing a reload in this block, meaning the spill operand must</span></td></tr>
<tr><td class="num" id="LN3454">3454</td><td class="line">        <span class='comment'>// be defined here.</span></td></tr>
<tr><td class="num" id="LN3455">3455</td><td class="line">        top_range-&gt;GetListOfBlocksRequiringSpillOperands()-&gt;Add(</td></tr>
<tr><td class="num" id="LN3456">3456</td><td class="line">            block-&gt;rpo_number().ToInt());</td></tr>
<tr><td class="num" id="LN3457">3457</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3458">3458</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3459">3459</td><td class="line">      <span class='keyword'>if</span> (pos.IsGapPosition()) {</td></tr>
<tr><td class="num" id="LN3460">3460</td><td class="line">        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;</td></tr>
<tr><td class="num" id="LN3461">3461</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3462">3462</td><td class="line">        <span class='keyword'>if</span> (pos.IsStart()) {</td></tr>
<tr><td class="num" id="LN3463">3463</td><td class="line">          delay_insertion = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN3464">3464</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3465">3465</td><td class="line">          gap_index++;</td></tr>
<tr><td class="num" id="LN3466">3466</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN3467">3467</td><td class="line">        gap_pos = delay_insertion ? Instruction::END : Instruction::START;</td></tr>
<tr><td class="num" id="LN3468">3468</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3469">3469</td><td class="line">      <span class='comment'>// Reloads or spills for spilled in deferred blocks ranges must happen</span></td></tr>
<tr><td class="num" id="LN3470">3470</td><td class="line">      <span class='comment'>// only in deferred blocks.</span></td></tr>
<tr><td class="num" id="LN3471">3471</td><td class="line">      <span class='macro'>DCHECK_IMPLIES(<span class='expansion'>do { if ((__builtin_expect(!!(!(!(connect_spilled &amp;&amp; !<br>(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister<br>())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred<br>()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3474, "Check failed: %s.", "!(connect_spilled &amp;&amp; !(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3472">3472</td><td class="line">          <span class='macro'>connect_spilled &amp;&amp;<span class='expansion'>do { if ((__builtin_expect(!!(!(!(connect_spilled &amp;&amp; !<br>(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister<br>())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred<br>()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3474, "Check failed: %s.", "!(connect_spilled &amp;&amp; !(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3473">3473</td><td class="line">              <span class='macro'>!(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister()),<span class='expansion'>do { if ((__builtin_expect(!!(!(!(connect_spilled &amp;&amp; !<br>(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister<br>())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred<br>()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3474, "Check failed: %s.", "!(connect_spilled &amp;&amp; !(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred())"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN3474">3474</td><td class="line">          <span class='macro'>code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred())<span class='expansion'>do { if ((__builtin_expect(!!(!(!(connect_spilled &amp;&amp; !<br>(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister<br>())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred<br>()))), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3474, "Check failed: %s.", "!(connect_spilled &amp;&amp; !(prev_operand.IsAnyRegister() &amp;&amp; cur_operand.IsAnyRegister())) || (code()-&gt;GetInstructionBlock(gap_index)-&gt;IsDeferred())"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3475">3475</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3476">3476</td><td class="line">      ParallelMove* move =</td></tr>
<tr><td class="num" id="LN3477">3477</td><td class="line">          code()-&gt;InstructionAt(gap_index)-&gt;GetOrCreateParallelMove(</td></tr>
<tr><td class="num" id="LN3478">3478</td><td class="line">              gap_pos, code_zone());</td></tr>
<tr><td class="num" id="LN3479">3479</td><td class="line">      <span class='keyword'>if</span> (!delay_insertion) {</td></tr>
<tr><td class="num" id="LN3480">3480</td><td class="line">        move-&gt;AddMove(prev_operand, cur_operand);</td></tr>
<tr><td class="num" id="LN3481">3481</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3482">3482</td><td class="line">        delayed_insertion_map.insert(</td></tr>
<tr><td class="num" id="LN3483">3483</td><td class="line">            std::make_pair(std::make_pair(move, prev_operand), cur_operand));</td></tr>
<tr><td class="num" id="LN3484">3484</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3485">3485</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3486">3486</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3487">3487</td><td class="line">  <span class='keyword'>if</span> (delayed_insertion_map.empty()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN3488">3488</td><td class="line">  <span class='comment'>// Insert all the moves which should occur after the stored move.</span></td></tr>
<tr><td class="num" id="LN3489">3489</td><td class="line">  ZoneVector&lt;MoveOperands*&gt; to_insert(local_zone);</td></tr>
<tr><td class="num" id="LN3490">3490</td><td class="line">  ZoneVector&lt;MoveOperands*&gt; to_eliminate(local_zone);</td></tr>
<tr><td class="num" id="LN3491">3491</td><td class="line">  to_insert.reserve(4);</td></tr>
<tr><td class="num" id="LN3492">3492</td><td class="line">  to_eliminate.reserve(4);</td></tr>
<tr><td class="num" id="LN3493">3493</td><td class="line">  ParallelMove* moves = delayed_insertion_map.begin()-&gt;first.first;</td></tr>
<tr><td class="num" id="LN3494">3494</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>auto</span> it = delayed_insertion_map.begin();; ++it) {</td></tr>
<tr><td class="num" id="LN3495">3495</td><td class="line">    <span class='keyword'>bool</span> done = it == delayed_insertion_map.end();</td></tr>
<tr><td class="num" id="LN3496">3496</td><td class="line">    <span class='keyword'>if</span> (done || it-&gt;first.first != moves) {</td></tr>
<tr><td class="num" id="LN3497">3497</td><td class="line">      <span class='comment'>// Commit the MoveOperands for current ParallelMove.</span></td></tr>
<tr><td class="num" id="LN3498">3498</td><td class="line">      <span class='keyword'>for</span> (MoveOperands* move : to_eliminate) {</td></tr>
<tr><td class="num" id="LN3499">3499</td><td class="line">        move-&gt;Eliminate();</td></tr>
<tr><td class="num" id="LN3500">3500</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3501">3501</td><td class="line">      <span class='keyword'>for</span> (MoveOperands* move : to_insert) {</td></tr>
<tr><td class="num" id="LN3502">3502</td><td class="line">        moves-&gt;push_back(move);</td></tr>
<tr><td class="num" id="LN3503">3503</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3504">3504</td><td class="line">      <span class='keyword'>if</span> (done) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN3505">3505</td><td class="line">      <span class='comment'>// Reset state.</span></td></tr>
<tr><td class="num" id="LN3506">3506</td><td class="line">      to_eliminate.clear();</td></tr>
<tr><td class="num" id="LN3507">3507</td><td class="line">      to_insert.clear();</td></tr>
<tr><td class="num" id="LN3508">3508</td><td class="line">      moves = it-&gt;first.first;</td></tr>
<tr><td class="num" id="LN3509">3509</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3510">3510</td><td class="line">    <span class='comment'>// Gather all MoveOperands for a single ParallelMove.</span></td></tr>
<tr><td class="num" id="LN3511">3511</td><td class="line">    MoveOperands* move =</td></tr>
<tr><td class="num" id="LN3512">3512</td><td class="line">        <span class='keyword'>new</span> (code_zone()) MoveOperands(it-&gt;first.second, it-&gt;second);</td></tr>
<tr><td class="num" id="LN3513">3513</td><td class="line">    MoveOperands* eliminate = moves-&gt;PrepareInsertAfter(move);</td></tr>
<tr><td class="num" id="LN3514">3514</td><td class="line">    to_insert.push_back(move);</td></tr>
<tr><td class="num" id="LN3515">3515</td><td class="line">    <span class='keyword'>if</span> (eliminate != <span class='keyword'>nullptr</span>) to_eliminate.push_back(eliminate);</td></tr>
<tr><td class="num" id="LN3516">3516</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3517">3517</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3518">3518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3519">3519</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3520">3520</td><td class="line"><span class='keyword'>void</span> LiveRangeConnector::CommitSpillsInDeferredBlocks(</td></tr>
<tr><td class="num" id="LN3521">3521</td><td class="line">    TopLevelLiveRange* range, LiveRangeBoundArray* array, Zone* temp_zone) {</td></tr>
<tr><td class="num" id="LN3522">3522</td><td class="line">  <span class='macro'>DCHECK(range-&gt;IsSpilledOnlyInDeferredBlocks())<span class='expansion'>do { if ((__builtin_expect(!!(!(range-&gt;IsSpilledOnlyInDeferredBlocks<br>())), 0))) { V8_Fatal("../src/compiler/register-allocator.cc"<br>, 3522, "Check failed: %s.", "range-&gt;IsSpilledOnlyInDeferredBlocks()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3523">3523</td><td class="line">  <span class='macro'>DCHECK(!range-&gt;spilled())<span class='expansion'>do { if ((__builtin_expect(!!(!(!range-&gt;spilled())), 0))) {<br> V8_Fatal("../src/compiler/register-allocator.cc", 3523, "Check failed: %s."<br>, "!range-&gt;spilled()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN3524">3524</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3525">3525</td><td class="line">  InstructionSequence* code = data()-&gt;code();</td></tr>
<tr><td class="num" id="LN3526">3526</td><td class="line">  InstructionOperand spill_operand = range-&gt;GetSpillRangeOperand();</td></tr>
<tr><td class="num" id="LN3527">3527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3528">3528</td><td class="line">  <span class='macro'>TRACE(<span class='string_literal'>"Live Range %d will be spilled only in deferred blocks.\n"</span>,<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Live Range %d will be spilled only in deferred blocks.\n"<br>, range-&gt;vreg()); } while (false)</span></span></td></tr>
<tr><td class="num" id="LN3529">3529</td><td class="line">        <span class='macro'>range-&gt;vreg())<span class='expansion'>do { if (FLAG_trace_alloc) PrintF("Live Range %d will be spilled only in deferred blocks.\n"<br>, range-&gt;vreg()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN3530">3530</td><td class="line">  <span class='comment'>// If we have ranges that aren't spilled but require the operand on the stack,</span></td></tr>
<tr><td class="num" id="LN3531">3531</td><td class="line">  <span class='comment'>// make sure we insert the spill.</span></td></tr>
<tr><td class="num" id="LN3532">3532</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>const</span> LiveRange* child = range; child != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN3533">3533</td><td class="line">       child = child-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3534">3534</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> UsePosition* pos = child-&gt;first_pos(); pos != <span class='keyword'>nullptr</span>;</td></tr>
<tr><td class="num" id="LN3535">3535</td><td class="line">         pos = pos-&gt;next()) {</td></tr>
<tr><td class="num" id="LN3536">3536</td><td class="line">      <span class='keyword'>if</span> (pos-&gt;type() != UsePositionType::kRequiresSlot &amp;&amp; !child-&gt;spilled())</td></tr>
<tr><td class="num" id="LN3537">3537</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3538">3538</td><td class="line">      range-&gt;AddBlockRequiringSpillOperand(</td></tr>
<tr><td class="num" id="LN3539">3539</td><td class="line">          code-&gt;GetInstructionBlock(pos-&gt;pos().ToInstructionIndex())</td></tr>
<tr><td class="num" id="LN3540">3540</td><td class="line">              -&gt;rpo_number());</td></tr>
<tr><td class="num" id="LN3541">3541</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3542">3542</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3543">3543</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3544">3544</td><td class="line">  ZoneQueue&lt;<span class='keyword'>int</span>&gt; worklist(temp_zone);</td></tr>
<tr><td class="num" id="LN3545">3545</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3546">3546</td><td class="line">  <span class='keyword'>for</span> (BitVector::Iterator iterator(</td></tr>
<tr><td class="num" id="LN3547">3547</td><td class="line">           range-&gt;GetListOfBlocksRequiringSpillOperands());</td></tr>
<tr><td class="num" id="LN3548">3548</td><td class="line">       !iterator.Done(); iterator.Advance()) {</td></tr>
<tr><td class="num" id="LN3549">3549</td><td class="line">    worklist.push(iterator.Current());</td></tr>
<tr><td class="num" id="LN3550">3550</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3551">3551</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3552">3552</td><td class="line">  <span class='comment'>// Seek the deferred blocks that dominate locations requiring spill operands,</span></td></tr>
<tr><td class="num" id="LN3553">3553</td><td class="line">  <span class='comment'>// and spill there. We only need to spill at the start of such blocks.</span></td></tr>
<tr><td class="num" id="LN3554">3554</td><td class="line">  BitVector done_blocks(</td></tr>
<tr><td class="num" id="LN3555">3555</td><td class="line">      range-&gt;GetListOfBlocksRequiringSpillOperands()-&gt;length(), temp_zone);</td></tr>
<tr><td class="num" id="LN3556">3556</td><td class="line">  <span class='keyword'>while</span> (!worklist.empty()) {</td></tr>
<tr><td class="num" id="LN3557">3557</td><td class="line">    <span class='keyword'>int</span> block_id = worklist.front();</td></tr>
<tr><td class="num" id="LN3558">3558</td><td class="line">    worklist.pop();</td></tr>
<tr><td class="num" id="LN3559">3559</td><td class="line">    <span class='keyword'>if</span> (done_blocks.Contains(block_id)) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN3560">3560</td><td class="line">    done_blocks.Add(block_id);</td></tr>
<tr><td class="num" id="LN3561">3561</td><td class="line">    <span class='keyword'>const</span> InstructionBlock* spill_block =</td></tr>
<tr><td class="num" id="LN3562">3562</td><td class="line">        code-&gt;InstructionBlockAt(RpoNumber::FromInt(block_id));</td></tr>
<tr><td class="num" id="LN3563">3563</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3564">3564</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>const</span> RpoNumber&amp; pred : spill_block-&gt;predecessors()) {</td></tr>
<tr><td class="num" id="LN3565">3565</td><td class="line">      <span class='keyword'>const</span> InstructionBlock* pred_block = code-&gt;InstructionBlockAt(pred);</td></tr>
<tr><td class="num" id="LN3566">3566</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3567">3567</td><td class="line">      <span class='keyword'>if</span> (pred_block-&gt;IsDeferred()) {</td></tr>
<tr><td class="num" id="LN3568">3568</td><td class="line">        worklist.push(pred_block-&gt;rpo_number().ToInt());</td></tr>
<tr><td class="num" id="LN3569">3569</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN3570">3570</td><td class="line">        LifetimePosition pred_end =</td></tr>
<tr><td class="num" id="LN3571">3571</td><td class="line">            LifetimePosition::InstructionFromInstructionIndex(</td></tr>
<tr><td class="num" id="LN3572">3572</td><td class="line">                pred_block-&gt;last_instruction_index());</td></tr>
<tr><td class="num" id="LN3573">3573</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3574">3574</td><td class="line">        LiveRangeBound* bound = array-&gt;Find(pred_end);</td></tr>
<tr><td class="num" id="LN3575">3575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3576">3576</td><td class="line">        InstructionOperand pred_op = bound-&gt;range_-&gt;GetAssignedOperand();</td></tr>
<tr><td class="num" id="LN3577">3577</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3578">3578</td><td class="line">        data()-&gt;AddGapMove(spill_block-&gt;first_instruction_index(),</td></tr>
<tr><td class="num" id="LN3579">3579</td><td class="line">                           Instruction::GapPosition::START, pred_op,</td></tr>
<tr><td class="num" id="LN3580">3580</td><td class="line">                           spill_operand);</td></tr>
<tr><td class="num" id="LN3581">3581</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN3582">3582</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN3583">3583</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN3584">3584</td><td class="line">}</td></tr>
<tr><td class="num" id="LN3585">3585</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3586">3586</td><td class="line"> </td></tr>
<tr><td class="num" id="LN3587">3587</td><td class="line">}  <span class='comment'>// namespace compiler</span></td></tr>
<tr><td class="num" id="LN3588">3588</td><td class="line">}  <span class='comment'>// namespace internal</span></td></tr>
<tr><td class="num" id="LN3589">3589</td><td class="line">}  <span class='comment'>// namespace v8</span></td></tr>
</table></body></html>

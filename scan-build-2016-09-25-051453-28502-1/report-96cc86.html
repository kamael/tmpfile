<!doctype html>
<html>
<head>
<title>../src/snapshot/serialize.cc</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000;   border-radius:5px;  box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndex { border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Value stored to 'current' is never read -->

<!-- BUGTYPE Dead assignment -->

<!-- BUGCATEGORY Dead store -->

<!-- BUGFILE /home/haha/code/v8_5_0/v8/out/../src/snapshot/serialize.cc -->

<!-- FILENAME serialize.cc -->

<!-- FUNCTIONNAME ReadData -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 2a1199a6b48acab03f100b1585b75977 -->

<!-- BUGLINE 1177 -->

<!-- BUGCOLUMN 9 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>out/../src/snapshot/serialize.cc</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 1177, column 9</a></td></tr>
<tr><td class="rowname">Description:</td><td>Value stored to 'current' is never read</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>// Copyright 2012 the V8 project authors. All rights reserved.</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"><span class='comment'>// Use of this source code is governed by a BSD-style license that can be</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"><span class='comment'>// found in the LICENSE file.</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"> </td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"><span class='directive'>#include "src/snapshot/serialize.h"</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"><span class='directive'>#include "src/accessors.h"</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"><span class='directive'>#include "src/api.h"</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"><span class='directive'>#include "src/base/platform/platform.h"</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"><span class='directive'>#include "src/bootstrapper.h"</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"><span class='directive'>#include "src/code-stubs.h"</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"><span class='directive'>#include "src/deoptimizer.h"</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"><span class='directive'>#include "src/execution.h"</span></td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#include "src/global-handles.h"</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#include "src/ic/ic.h"</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#include "src/ic/stub-cache.h"</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#include "src/objects.h"</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"><span class='directive'>#include "src/parsing/parser.h"</span></td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"><span class='directive'>#include "src/profiler/cpu-profiler.h"</span></td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='directive'>#include "src/runtime/runtime.h"</span></td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"><span class='directive'>#include "src/snapshot/natives.h"</span></td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='directive'>#include "src/snapshot/snapshot.h"</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"><span class='directive'>#include "src/snapshot/snapshot-source-sink.h"</span></td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#include "src/v8.h"</span></td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#include "src/v8threads.h"</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#include "src/version.h"</span></td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"> </td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"><span class='keyword'>namespace</span> v8 {</td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='keyword'>namespace</span> internal {</td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"> </td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='comment'>// -----------------------------------------------------------------------------</span></td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"><span class='comment'>// Coding of external references.</span></td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"> </td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"> </td></tr>
<tr><td class="num" id="LN36">36</td><td class="line">ExternalReferenceTable* ExternalReferenceTable::instance(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN37">37</td><td class="line">  ExternalReferenceTable* external_reference_table =</td></tr>
<tr><td class="num" id="LN38">38</td><td class="line">      isolate-&gt;external_reference_table();</td></tr>
<tr><td class="num" id="LN39">39</td><td class="line">  <span class='keyword'>if</span> (external_reference_table == <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN40">40</td><td class="line">    external_reference_table = <span class='keyword'>new</span> ExternalReferenceTable(isolate);</td></tr>
<tr><td class="num" id="LN41">41</td><td class="line">    isolate-&gt;set_external_reference_table(external_reference_table);</td></tr>
<tr><td class="num" id="LN42">42</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN43">43</td><td class="line">  <span class='keyword'>return</span> external_reference_table;</td></tr>
<tr><td class="num" id="LN44">44</td><td class="line">}</td></tr>
<tr><td class="num" id="LN45">45</td><td class="line"> </td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"> </td></tr>
<tr><td class="num" id="LN47">47</td><td class="line">ExternalReferenceTable::ExternalReferenceTable(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN48">48</td><td class="line">  <span class='comment'>// Miscellaneous</span></td></tr>
<tr><td class="num" id="LN49">49</td><td class="line">  Add(ExternalReference::roots_array_start(isolate).address(),</td></tr>
<tr><td class="num" id="LN50">50</td><td class="line">      <span class='string_literal'>"Heap::roots_array_start()"</span>);</td></tr>
<tr><td class="num" id="LN51">51</td><td class="line">  Add(ExternalReference::address_of_stack_limit(isolate).address(),</td></tr>
<tr><td class="num" id="LN52">52</td><td class="line">      <span class='string_literal'>"StackGuard::address_of_jslimit()"</span>);</td></tr>
<tr><td class="num" id="LN53">53</td><td class="line">  Add(ExternalReference::address_of_real_stack_limit(isolate).address(),</td></tr>
<tr><td class="num" id="LN54">54</td><td class="line">      <span class='string_literal'>"StackGuard::address_of_real_jslimit()"</span>);</td></tr>
<tr><td class="num" id="LN55">55</td><td class="line">  Add(ExternalReference::new_space_start(isolate).address(),</td></tr>
<tr><td class="num" id="LN56">56</td><td class="line">      <span class='string_literal'>"Heap::NewSpaceStart()"</span>);</td></tr>
<tr><td class="num" id="LN57">57</td><td class="line">  Add(ExternalReference::new_space_allocation_limit_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN58">58</td><td class="line">      <span class='string_literal'>"Heap::NewSpaceAllocationLimitAddress()"</span>);</td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">  Add(ExternalReference::new_space_allocation_top_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN60">60</td><td class="line">      <span class='string_literal'>"Heap::NewSpaceAllocationTopAddress()"</span>);</td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">  Add(ExternalReference::mod_two_doubles_operation(isolate).address(),</td></tr>
<tr><td class="num" id="LN62">62</td><td class="line">      <span class='string_literal'>"mod_two_doubles"</span>);</td></tr>
<tr><td class="num" id="LN63">63</td><td class="line">  <span class='comment'>// Keyed lookup cache.</span></td></tr>
<tr><td class="num" id="LN64">64</td><td class="line">  Add(ExternalReference::keyed_lookup_cache_keys(isolate).address(),</td></tr>
<tr><td class="num" id="LN65">65</td><td class="line">      <span class='string_literal'>"KeyedLookupCache::keys()"</span>);</td></tr>
<tr><td class="num" id="LN66">66</td><td class="line">  Add(ExternalReference::keyed_lookup_cache_field_offsets(isolate).address(),</td></tr>
<tr><td class="num" id="LN67">67</td><td class="line">      <span class='string_literal'>"KeyedLookupCache::field_offsets()"</span>);</td></tr>
<tr><td class="num" id="LN68">68</td><td class="line">  Add(ExternalReference::handle_scope_next_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN69">69</td><td class="line">      <span class='string_literal'>"HandleScope::next"</span>);</td></tr>
<tr><td class="num" id="LN70">70</td><td class="line">  Add(ExternalReference::handle_scope_limit_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN71">71</td><td class="line">      <span class='string_literal'>"HandleScope::limit"</span>);</td></tr>
<tr><td class="num" id="LN72">72</td><td class="line">  Add(ExternalReference::handle_scope_level_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">      <span class='string_literal'>"HandleScope::level"</span>);</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">  Add(ExternalReference::new_deoptimizer_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line">      <span class='string_literal'>"Deoptimizer::New()"</span>);</td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">  Add(ExternalReference::compute_output_frames_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line">      <span class='string_literal'>"Deoptimizer::ComputeOutputFrames()"</span>);</td></tr>
<tr><td class="num" id="LN78">78</td><td class="line">  Add(ExternalReference::address_of_min_int().address(),</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line">      <span class='string_literal'>"LDoubleConstant::min_int"</span>);</td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">  Add(ExternalReference::address_of_one_half().address(),</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">      <span class='string_literal'>"LDoubleConstant::one_half"</span>);</td></tr>
<tr><td class="num" id="LN82">82</td><td class="line">  Add(ExternalReference::isolate_address(isolate).address(), <span class='string_literal'>"isolate"</span>);</td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">  Add(ExternalReference::interpreter_dispatch_table_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">      <span class='string_literal'>"Interpreter::dispatch_table_address"</span>);</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">  Add(ExternalReference::address_of_negative_infinity().address(),</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">      <span class='string_literal'>"LDoubleConstant::negative_infinity"</span>);</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">  Add(ExternalReference::power_double_double_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">      <span class='string_literal'>"power_double_double_function"</span>);</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">  Add(ExternalReference::power_double_int_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">      <span class='string_literal'>"power_double_int_function"</span>);</td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">  Add(ExternalReference::math_log_double_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">      <span class='string_literal'>"std::log"</span>);</td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">  Add(ExternalReference::store_buffer_top(isolate).address(),</td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">      <span class='string_literal'>"store_buffer_top"</span>);</td></tr>
<tr><td class="num" id="LN95">95</td><td class="line">  Add(ExternalReference::address_of_the_hole_nan().address(), <span class='string_literal'>"the_hole_nan"</span>);</td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">  Add(ExternalReference::get_date_field_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">      <span class='string_literal'>"JSDate::GetField"</span>);</td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">  Add(ExternalReference::date_cache_stamp(isolate).address(),</td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">      <span class='string_literal'>"date_cache_stamp"</span>);</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">  Add(ExternalReference::address_of_pending_message_obj(isolate).address(),</td></tr>
<tr><td class="num" id="LN101">101</td><td class="line">      <span class='string_literal'>"address_of_pending_message_obj"</span>);</td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">  Add(ExternalReference::get_make_code_young_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">      <span class='string_literal'>"Code::MakeCodeYoung"</span>);</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line">  Add(ExternalReference::cpu_features().address(), <span class='string_literal'>"cpu_features"</span>);</td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">  Add(ExternalReference::old_space_allocation_top_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">      <span class='string_literal'>"Heap::OldSpaceAllocationTopAddress"</span>);</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">  Add(ExternalReference::old_space_allocation_limit_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">      <span class='string_literal'>"Heap::OldSpaceAllocationLimitAddress"</span>);</td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">  Add(ExternalReference::allocation_sites_list_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line">      <span class='string_literal'>"Heap::allocation_sites_list_address()"</span>);</td></tr>
<tr><td class="num" id="LN111">111</td><td class="line">  Add(ExternalReference::address_of_uint32_bias().address(), <span class='string_literal'>"uint32_bias"</span>);</td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">  Add(ExternalReference::get_mark_code_as_executed_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">      <span class='string_literal'>"Code::MarkCodeAsExecuted"</span>);</td></tr>
<tr><td class="num" id="LN114">114</td><td class="line">  Add(ExternalReference::is_profiling_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN115">115</td><td class="line">      <span class='string_literal'>"CpuProfiler::is_profiling"</span>);</td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">  Add(ExternalReference::scheduled_exception_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN117">117</td><td class="line">      <span class='string_literal'>"Isolate::scheduled_exception"</span>);</td></tr>
<tr><td class="num" id="LN118">118</td><td class="line">  Add(ExternalReference::invoke_function_callback(isolate).address(),</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line">      <span class='string_literal'>"InvokeFunctionCallback"</span>);</td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">  Add(ExternalReference::invoke_accessor_getter_callback(isolate).address(),</td></tr>
<tr><td class="num" id="LN121">121</td><td class="line">      <span class='string_literal'>"InvokeAccessorGetterCallback"</span>);</td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">  Add(ExternalReference::f32_trunc_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line">      <span class='string_literal'>"f32_trunc_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN124">124</td><td class="line">  Add(ExternalReference::f32_floor_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">      <span class='string_literal'>"f32_floor_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line">  Add(ExternalReference::f32_ceil_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">      <span class='string_literal'>"f32_ceil_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line">  Add(ExternalReference::f32_nearest_int_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">      <span class='string_literal'>"f32_nearest_int_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">  Add(ExternalReference::f64_trunc_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">      <span class='string_literal'>"f64_trunc_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">  Add(ExternalReference::f64_floor_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">      <span class='string_literal'>"f64_floor_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN134">134</td><td class="line">  Add(ExternalReference::f64_ceil_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">      <span class='string_literal'>"f64_ceil_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">  Add(ExternalReference::f64_nearest_int_wrapper_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">      <span class='string_literal'>"f64_nearest_int_wrapper"</span>);</td></tr>
<tr><td class="num" id="LN138">138</td><td class="line">  Add(ExternalReference::log_enter_external_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">      <span class='string_literal'>"Logger::EnterExternal"</span>);</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">  Add(ExternalReference::log_leave_external_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">      <span class='string_literal'>"Logger::LeaveExternal"</span>);</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">  Add(ExternalReference::address_of_minus_one_half().address(),</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line">      <span class='string_literal'>"double_constants.minus_one_half"</span>);</td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">  Add(ExternalReference::stress_deopt_count(isolate).address(),</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">      <span class='string_literal'>"Isolate::stress_deopt_count_address()"</span>);</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line">  Add(ExternalReference::virtual_handler_register(isolate).address(),</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">      <span class='string_literal'>"Isolate::virtual_handler_register()"</span>);</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line">  Add(ExternalReference::virtual_slot_register(isolate).address(),</td></tr>
<tr><td class="num" id="LN149">149</td><td class="line">      <span class='string_literal'>"Isolate::virtual_slot_register()"</span>);</td></tr>
<tr><td class="num" id="LN150">150</td><td class="line">  Add(ExternalReference::runtime_function_table_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN151">151</td><td class="line">      <span class='string_literal'>"Runtime::runtime_function_table_address()"</span>);</td></tr>
<tr><td class="num" id="LN152">152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN153">153</td><td class="line">  <span class='comment'>// Debug addresses</span></td></tr>
<tr><td class="num" id="LN154">154</td><td class="line">  Add(ExternalReference::debug_after_break_target_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line">      <span class='string_literal'>"Debug::after_break_target_address()"</span>);</td></tr>
<tr><td class="num" id="LN156">156</td><td class="line">  Add(ExternalReference::debug_is_active_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN157">157</td><td class="line">      <span class='string_literal'>"Debug::is_active_address()"</span>);</td></tr>
<tr><td class="num" id="LN158">158</td><td class="line">  Add(ExternalReference::debug_step_in_enabled_address(isolate).address(),</td></tr>
<tr><td class="num" id="LN159">159</td><td class="line">      <span class='string_literal'>"Debug::step_in_enabled_address()"</span>);</td></tr>
<tr><td class="num" id="LN160">160</td><td class="line"> </td></tr>
<tr><td class="num" id="LN161">161</td><td class="line"><span class='directive'>#ifndef V8_INTERPRETED_REGEXP</span></td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">  Add(ExternalReference::re_case_insensitive_compare_uc16(isolate).address(),</td></tr>
<tr><td class="num" id="LN163">163</td><td class="line">      <span class='string_literal'>"NativeRegExpMacroAssembler::CaseInsensitiveCompareUC16()"</span>);</td></tr>
<tr><td class="num" id="LN164">164</td><td class="line">  Add(ExternalReference::re_check_stack_guard_state(isolate).address(),</td></tr>
<tr><td class="num" id="LN165">165</td><td class="line">      <span class='string_literal'>"RegExpMacroAssembler*::CheckStackGuardState()"</span>);</td></tr>
<tr><td class="num" id="LN166">166</td><td class="line">  Add(ExternalReference::re_grow_stack(isolate).address(),</td></tr>
<tr><td class="num" id="LN167">167</td><td class="line">      <span class='string_literal'>"NativeRegExpMacroAssembler::GrowStack()"</span>);</td></tr>
<tr><td class="num" id="LN168">168</td><td class="line">  Add(ExternalReference::re_word_character_map().address(),</td></tr>
<tr><td class="num" id="LN169">169</td><td class="line">      <span class='string_literal'>"NativeRegExpMacroAssembler::word_character_map"</span>);</td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">  Add(ExternalReference::address_of_regexp_stack_limit(isolate).address(),</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line">      <span class='string_literal'>"RegExpStack::limit_address()"</span>);</td></tr>
<tr><td class="num" id="LN172">172</td><td class="line">  Add(ExternalReference::address_of_regexp_stack_memory_address(isolate)</td></tr>
<tr><td class="num" id="LN173">173</td><td class="line">          .address(),</td></tr>
<tr><td class="num" id="LN174">174</td><td class="line">      <span class='string_literal'>"RegExpStack::memory_address()"</span>);</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line">  Add(ExternalReference::address_of_regexp_stack_memory_size(isolate).address(),</td></tr>
<tr><td class="num" id="LN176">176</td><td class="line">      <span class='string_literal'>"RegExpStack::memory_size()"</span>);</td></tr>
<tr><td class="num" id="LN177">177</td><td class="line">  Add(ExternalReference::address_of_static_offsets_vector(isolate).address(),</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">      <span class='string_literal'>"OffsetsVector::static_offsets_vector"</span>);</td></tr>
<tr><td class="num" id="LN179">179</td><td class="line"><span class='directive'>#endif  // V8_INTERPRETED_REGEXP</span></td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"> </td></tr>
<tr><td class="num" id="LN181">181</td><td class="line">  <span class='comment'>// The following populates all of the different type of external references</span></td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">  <span class='comment'>// into the ExternalReferenceTable.</span></td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">  <span class='comment'>//</span></td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">  <span class='comment'>// NOTE: This function was originally 100k of code.  It has since been</span></td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">  <span class='comment'>// rewritten to be mostly table driven, as the callback macro style tends to</span></td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">  <span class='comment'>// very easily cause code bloat.  Please be careful in the future when adding</span></td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">  <span class='comment'>// new references.</span></td></tr>
<tr><td class="num" id="LN188">188</td><td class="line"> </td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">  <span class='keyword'>struct</span> RefTableEntry {</td></tr>
<tr><td class="num" id="LN190">190</td><td class="line">    uint16_t id;</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* name;</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN194">194</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> RefTableEntry c_builtins[] = {</td></tr>
<tr><td class="num" id="LN195">195</td><td class="line"><span class='directive'>#define DEF_ENTRY_C(name, ignored)           \</span></td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">  <span class='directive'>{ Builtins::c_##name, "Builtins::" #name } \</span></td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">      <span class='macro'>BUILTIN_LIST_C(DEF_ENTRY_C)<span class='expansion'>DEF_ENTRY_C(Illegal, kNone) DEF_ENTRY_C(EmptyFunction, kNone)<br> DEF_ENTRY_C(ArrayConcat, kNone) DEF_ENTRY_C(ArrayIsArray, kNone<br>) DEF_ENTRY_C(ArrayPop, kNone) DEF_ENTRY_C(ArrayPush, kNone) DEF_ENTRY_C<br>(ArrayShift, kNone) DEF_ENTRY_C(ArraySlice, kNone) DEF_ENTRY_C<br>(ArraySplice, kNone) DEF_ENTRY_C(ArrayUnshift, kNone) DEF_ENTRY_C<br>(ArrayBufferConstructor, kTarget) DEF_ENTRY_C(ArrayBufferConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(ArrayBufferIsView, kNone) DEF_ENTRY_C<br>(BooleanConstructor, kNone) DEF_ENTRY_C(BooleanConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(BooleanPrototypeToString, kNone<br>) DEF_ENTRY_C(BooleanPrototypeValueOf, kNone) DEF_ENTRY_C(DataViewConstructor<br>, kNone) DEF_ENTRY_C(DataViewConstructor_ConstructStub, kTargetAndNewTarget<br>) DEF_ENTRY_C(DateConstructor, kNone) DEF_ENTRY_C(DateConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(DateNow, kNone) DEF_ENTRY_C<br>(DateParse, kNone) DEF_ENTRY_C(DateUTC, kNone) DEF_ENTRY_C(DatePrototypeSetDate<br>, kNone) DEF_ENTRY_C(DatePrototypeSetFullYear, kNone) DEF_ENTRY_C<br>(DatePrototypeSetHours, kNone) DEF_ENTRY_C(DatePrototypeSetMilliseconds<br>, kNone) DEF_ENTRY_C(DatePrototypeSetMinutes, kNone) DEF_ENTRY_C<br>(DatePrototypeSetMonth, kNone) DEF_ENTRY_C(DatePrototypeSetSeconds<br>, kNone) DEF_ENTRY_C(DatePrototypeSetTime, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCDate, kNone) DEF_ENTRY_C(DatePrototypeSetUTCFullYear<br>, kNone) DEF_ENTRY_C(DatePrototypeSetUTCHours, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCMilliseconds, kNone) DEF_ENTRY_C(DatePrototypeSetUTCMinutes<br>, kNone) DEF_ENTRY_C(DatePrototypeSetUTCMonth, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCSeconds, kNone) DEF_ENTRY_C(DatePrototypeToDateString<br>, kNone) DEF_ENTRY_C(DatePrototypeToISOString, kNone) DEF_ENTRY_C<br>(DatePrototypeToPrimitive, kNone) DEF_ENTRY_C(DatePrototypeToUTCString<br>, kNone) DEF_ENTRY_C(DatePrototypeToString, kNone) DEF_ENTRY_C<br>(DatePrototypeToTimeString, kNone) DEF_ENTRY_C(DatePrototypeValueOf<br>, kNone) DEF_ENTRY_C(DatePrototypeGetYear, kNone) DEF_ENTRY_C<br>(DatePrototypeSetYear, kNone) DEF_ENTRY_C(FunctionConstructor<br>, kTargetAndNewTarget) DEF_ENTRY_C(FunctionPrototypeBind, kNone<br>) DEF_ENTRY_C(FunctionPrototypeToString, kNone) DEF_ENTRY_C(FunctionHasInstance<br>, kNone) DEF_ENTRY_C(GeneratorFunctionConstructor, kTargetAndNewTarget<br>) DEF_ENTRY_C(GlobalEval, kTarget) DEF_ENTRY_C(ObjectAssign, kNone<br>) DEF_ENTRY_C(ObjectCreate, kNone) DEF_ENTRY_C(ObjectFreeze, kNone<br>) DEF_ENTRY_C(ObjectGetOwnPropertyDescriptor, kNone) DEF_ENTRY_C<br>(ObjectGetOwnPropertyNames, kNone) DEF_ENTRY_C(ObjectGetOwnPropertySymbols<br>, kNone) DEF_ENTRY_C(ObjectIs, kNone) DEF_ENTRY_C(ObjectIsExtensible<br>, kNone) DEF_ENTRY_C(ObjectIsFrozen, kNone) DEF_ENTRY_C(ObjectIsSealed<br>, kNone) DEF_ENTRY_C(ObjectKeys, kNone) DEF_ENTRY_C(ObjectValues<br>, kNone) DEF_ENTRY_C(ObjectEntries, kNone) DEF_ENTRY_C(ObjectGetOwnPropertyDescriptors<br>, kNone) DEF_ENTRY_C(ObjectPreventExtensions, kNone) DEF_ENTRY_C<br>(ObjectSeal, kNone) DEF_ENTRY_C(ObjectProtoToString, kNone) DEF_ENTRY_C<br>(ProxyConstructor, kNone) DEF_ENTRY_C(ProxyConstructor_ConstructStub<br>, kTarget) DEF_ENTRY_C(ReflectDefineProperty, kNone) DEF_ENTRY_C<br>(ReflectDeleteProperty, kNone) DEF_ENTRY_C(ReflectGet, kNone)<br> DEF_ENTRY_C(ReflectGetOwnPropertyDescriptor, kNone) DEF_ENTRY_C<br>(ReflectGetPrototypeOf, kNone) DEF_ENTRY_C(ReflectHas, kNone)<br> DEF_ENTRY_C(ReflectIsExtensible, kNone) DEF_ENTRY_C(ReflectOwnKeys<br>, kNone) DEF_ENTRY_C(ReflectPreventExtensions, kNone) DEF_ENTRY_C<br>(ReflectSet, kNone) DEF_ENTRY_C(ReflectSetPrototypeOf, kNone)<br> DEF_ENTRY_C(StringFromCharCode, kNone) DEF_ENTRY_C(SymbolConstructor<br>, kNone) DEF_ENTRY_C(SymbolConstructor_ConstructStub, kTarget<br>) DEF_ENTRY_C(HandleApiCall, kTarget) DEF_ENTRY_C(HandleApiCallConstruct<br>, kTarget) DEF_ENTRY_C(HandleApiCallAsFunction, kNone) DEF_ENTRY_C<br>(HandleApiCallAsConstructor, kNone) DEF_ENTRY_C(RestrictedFunctionPropertiesThrower<br>, kNone) DEF_ENTRY_C(RestrictedStrictArgumentsPropertiesThrower<br>, kNone)</span></span></td></tr>
<tr><td class="num" id="LN199">199</td><td class="line"><span class='directive'>#undef DEF_ENTRY_C</span></td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line"> </td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='macro'>arraysize(c_builtins)<span class='expansion'>(sizeof(ArraySizeHelper(c_builtins)))</span></span>; ++i) {</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">    ExternalReference ref(<span class='keyword'>static_cast</span>&lt;Builtins::CFunctionId&gt;(c_builtins[i].id),</td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">                          isolate);</td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">    Add(ref.address(), c_builtins[i].name);</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> RefTableEntry builtins[] = {</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line"><span class='directive'>#define DEF_ENTRY_C(name, ignored)          \</span></td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">  <span class='directive'>{ Builtins::k##name, "Builtins::" #name } \</span></td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN212">212</td><td class="line"><span class='directive'>#define DEF_ENTRY_A(name, i1, i2, i3)       \</span></td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">  <span class='directive'>{ Builtins::k##name, "Builtins::" #name } \</span></td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">      <span class='macro'>BUILTIN_LIST_C(DEF_ENTRY_C)<span class='expansion'>DEF_ENTRY_C(Illegal, kNone) DEF_ENTRY_C(EmptyFunction, kNone)<br> DEF_ENTRY_C(ArrayConcat, kNone) DEF_ENTRY_C(ArrayIsArray, kNone<br>) DEF_ENTRY_C(ArrayPop, kNone) DEF_ENTRY_C(ArrayPush, kNone) DEF_ENTRY_C<br>(ArrayShift, kNone) DEF_ENTRY_C(ArraySlice, kNone) DEF_ENTRY_C<br>(ArraySplice, kNone) DEF_ENTRY_C(ArrayUnshift, kNone) DEF_ENTRY_C<br>(ArrayBufferConstructor, kTarget) DEF_ENTRY_C(ArrayBufferConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(ArrayBufferIsView, kNone) DEF_ENTRY_C<br>(BooleanConstructor, kNone) DEF_ENTRY_C(BooleanConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(BooleanPrototypeToString, kNone<br>) DEF_ENTRY_C(BooleanPrototypeValueOf, kNone) DEF_ENTRY_C(DataViewConstructor<br>, kNone) DEF_ENTRY_C(DataViewConstructor_ConstructStub, kTargetAndNewTarget<br>) DEF_ENTRY_C(DateConstructor, kNone) DEF_ENTRY_C(DateConstructor_ConstructStub<br>, kTargetAndNewTarget) DEF_ENTRY_C(DateNow, kNone) DEF_ENTRY_C<br>(DateParse, kNone) DEF_ENTRY_C(DateUTC, kNone) DEF_ENTRY_C(DatePrototypeSetDate<br>, kNone) DEF_ENTRY_C(DatePrototypeSetFullYear, kNone) DEF_ENTRY_C<br>(DatePrototypeSetHours, kNone) DEF_ENTRY_C(DatePrototypeSetMilliseconds<br>, kNone) DEF_ENTRY_C(DatePrototypeSetMinutes, kNone) DEF_ENTRY_C<br>(DatePrototypeSetMonth, kNone) DEF_ENTRY_C(DatePrototypeSetSeconds<br>, kNone) DEF_ENTRY_C(DatePrototypeSetTime, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCDate, kNone) DEF_ENTRY_C(DatePrototypeSetUTCFullYear<br>, kNone) DEF_ENTRY_C(DatePrototypeSetUTCHours, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCMilliseconds, kNone) DEF_ENTRY_C(DatePrototypeSetUTCMinutes<br>, kNone) DEF_ENTRY_C(DatePrototypeSetUTCMonth, kNone) DEF_ENTRY_C<br>(DatePrototypeSetUTCSeconds, kNone) DEF_ENTRY_C(DatePrototypeToDateString<br>, kNone) DEF_ENTRY_C(DatePrototypeToISOString, kNone) DEF_ENTRY_C<br>(DatePrototypeToPrimitive, kNone) DEF_ENTRY_C(DatePrototypeToUTCString<br>, kNone) DEF_ENTRY_C(DatePrototypeToString, kNone) DEF_ENTRY_C<br>(DatePrototypeToTimeString, kNone) DEF_ENTRY_C(DatePrototypeValueOf<br>, kNone) DEF_ENTRY_C(DatePrototypeGetYear, kNone) DEF_ENTRY_C<br>(DatePrototypeSetYear, kNone) DEF_ENTRY_C(FunctionConstructor<br>, kTargetAndNewTarget) DEF_ENTRY_C(FunctionPrototypeBind, kNone<br>) DEF_ENTRY_C(FunctionPrototypeToString, kNone) DEF_ENTRY_C(FunctionHasInstance<br>, kNone) DEF_ENTRY_C(GeneratorFunctionConstructor, kTargetAndNewTarget<br>) DEF_ENTRY_C(GlobalEval, kTarget) DEF_ENTRY_C(ObjectAssign, kNone<br>) DEF_ENTRY_C(ObjectCreate, kNone) DEF_ENTRY_C(ObjectFreeze, kNone<br>) DEF_ENTRY_C(ObjectGetOwnPropertyDescriptor, kNone) DEF_ENTRY_C<br>(ObjectGetOwnPropertyNames, kNone) DEF_ENTRY_C(ObjectGetOwnPropertySymbols<br>, kNone) DEF_ENTRY_C(ObjectIs, kNone) DEF_ENTRY_C(ObjectIsExtensible<br>, kNone) DEF_ENTRY_C(ObjectIsFrozen, kNone) DEF_ENTRY_C(ObjectIsSealed<br>, kNone) DEF_ENTRY_C(ObjectKeys, kNone) DEF_ENTRY_C(ObjectValues<br>, kNone) DEF_ENTRY_C(ObjectEntries, kNone) DEF_ENTRY_C(ObjectGetOwnPropertyDescriptors<br>, kNone) DEF_ENTRY_C(ObjectPreventExtensions, kNone) DEF_ENTRY_C<br>(ObjectSeal, kNone) DEF_ENTRY_C(ObjectProtoToString, kNone) DEF_ENTRY_C<br>(ProxyConstructor, kNone) DEF_ENTRY_C(ProxyConstructor_ConstructStub<br>, kTarget) DEF_ENTRY_C(ReflectDefineProperty, kNone) DEF_ENTRY_C<br>(ReflectDeleteProperty, kNone) DEF_ENTRY_C(ReflectGet, kNone)<br> DEF_ENTRY_C(ReflectGetOwnPropertyDescriptor, kNone) DEF_ENTRY_C<br>(ReflectGetPrototypeOf, kNone) DEF_ENTRY_C(ReflectHas, kNone)<br> DEF_ENTRY_C(ReflectIsExtensible, kNone) DEF_ENTRY_C(ReflectOwnKeys<br>, kNone) DEF_ENTRY_C(ReflectPreventExtensions, kNone) DEF_ENTRY_C<br>(ReflectSet, kNone) DEF_ENTRY_C(ReflectSetPrototypeOf, kNone)<br> DEF_ENTRY_C(StringFromCharCode, kNone) DEF_ENTRY_C(SymbolConstructor<br>, kNone) DEF_ENTRY_C(SymbolConstructor_ConstructStub, kTarget<br>) DEF_ENTRY_C(HandleApiCall, kTarget) DEF_ENTRY_C(HandleApiCallConstruct<br>, kTarget) DEF_ENTRY_C(HandleApiCallAsFunction, kNone) DEF_ENTRY_C<br>(HandleApiCallAsConstructor, kNone) DEF_ENTRY_C(RestrictedFunctionPropertiesThrower<br>, kNone) DEF_ENTRY_C(RestrictedStrictArgumentsPropertiesThrower<br>, kNone)</span></span> <span class='macro'>BUILTIN_LIST_A(DEF_ENTRY_A)<span class='expansion'>DEF_ENTRY_A(ArgumentsAdaptorTrampoline, BUILTIN, UNINITIALIZED<br>, kNoExtraICState) DEF_ENTRY_A(ConstructedNonConstructable, BUILTIN<br>, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CallFunction_ReceiverIsNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CallFunction_ReceiverIsNotNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CallFunction_ReceiverIsAny<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCallFunction_ReceiverIsNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCallFunction_ReceiverIsNotNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCallFunction_ReceiverIsAny<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CallBoundFunction<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCallBoundFunction<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(Call_ReceiverIsNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(Call_ReceiverIsNotNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(Call_ReceiverIsAny<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCall_ReceiverIsNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCall_ReceiverIsNotNullOrUndefined<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(TailCall_ReceiverIsAny<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ConstructFunction<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ConstructBoundFunction<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ConstructProxy<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(Construct<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(Apply,<br> BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(HandleFastApiCall<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InOptimizationQueue<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSConstructStubGeneric<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSBuiltinsConstructStub<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSBuiltinsConstructStubForDerived<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSConstructStubApi<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSEntryTrampoline<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(JSConstructEntryTrampoline<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CompileLazy<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CompileOptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(CompileOptimizedConcurrent<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NotifyDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NotifySoftDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NotifyLazyDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NotifyStubFailure<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NotifyStubFailureSaveDoubles<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterEntryTrampoline<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterExitTrampoline<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterPushArgsAndCall<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterPushArgsAndTailCall<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterPushArgsAndConstruct<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterNotifyDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterNotifySoftDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterNotifyLazyDeoptimized<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterpreterEnterBytecodeDispatch<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(LoadIC_Miss<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(KeyedLoadIC_Miss<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(StoreIC_Miss<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(KeyedStoreIC_Miss<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(LoadIC_Getter_ForDeopt<br>, LOAD_IC, MONOMORPHIC, kNoExtraICState) DEF_ENTRY_A(KeyedLoadIC_Megamorphic<br>, KEYED_LOAD_IC, MEGAMORPHIC, kNoExtraICState) DEF_ENTRY_A(StoreIC_Setter_ForDeopt<br>, STORE_IC, MONOMORPHIC, StoreICState::kStrictModeState) DEF_ENTRY_A<br>(KeyedStoreIC_Initialize, KEYED_STORE_IC, UNINITIALIZED, kNoExtraICState<br>) DEF_ENTRY_A(KeyedStoreIC_PreMonomorphic, KEYED_STORE_IC, PREMONOMORPHIC<br>, kNoExtraICState) DEF_ENTRY_A(KeyedStoreIC_Megamorphic, KEYED_STORE_IC<br>, MEGAMORPHIC, kNoExtraICState) DEF_ENTRY_A(KeyedStoreIC_Initialize_Strict<br>, KEYED_STORE_IC, UNINITIALIZED, StoreICState::kStrictModeState<br>) DEF_ENTRY_A(KeyedStoreIC_PreMonomorphic_Strict, KEYED_STORE_IC<br>, PREMONOMORPHIC, StoreICState::kStrictModeState) DEF_ENTRY_A<br>(KeyedStoreIC_Megamorphic_Strict, KEYED_STORE_IC, MEGAMORPHIC<br>, StoreICState::kStrictModeState) DEF_ENTRY_A(DatePrototypeGetDate<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetDay<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetFullYear<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetHours<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetMilliseconds<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetMinutes<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetMonth<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetSeconds<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetTime<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetTimezoneOffset<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCDate<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCDay<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCFullYear<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCHours<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCMilliseconds<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCMinutes<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCMonth<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(DatePrototypeGetUTCSeconds<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(FunctionPrototypeApply<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(FunctionPrototypeCall<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ReflectApply<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ReflectConstruct<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InternalArrayCode<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(ArrayCode<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MathMax<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MathMin<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NumberConstructor<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(NumberConstructor_ConstructStub<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(StringConstructor<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(StringConstructor_ConstructStub<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(OnStackReplacement<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(InterruptCheck<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(OsrAfterStackCheck<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(StackCheck<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MarkCodeAsToBeExecutedOnce<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MarkCodeAsExecutedOnce<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MarkCodeAsExecutedTwice<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeQuadragenarianCodeYoungAgainOddMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeQuadragenarianCodeYoungAgainEvenMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeQuinquagenarianCodeYoungAgainOddMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeQuinquagenarianCodeYoungAgainEvenMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeSexagenarianCodeYoungAgainOddMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeSexagenarianCodeYoungAgainEvenMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeSeptuagenarianCodeYoungAgainOddMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeSeptuagenarianCodeYoungAgainEvenMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeOctogenarianCodeYoungAgainOddMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState) DEF_ENTRY_A(MakeOctogenarianCodeYoungAgainEvenMarking<br>, BUILTIN, UNINITIALIZED, kNoExtraICState)</span></span></td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">          <span class='macro'>BUILTIN_LIST_DEBUG_A(DEF_ENTRY_A)<span class='expansion'>DEF_ENTRY_A(Return_DebugBreak, BUILTIN, DEBUG_STUB, kNoExtraICState<br>) DEF_ENTRY_A(Slot_DebugBreak, BUILTIN, DEBUG_STUB, kNoExtraICState<br>) DEF_ENTRY_A(FrameDropper_LiveEdit, BUILTIN, DEBUG_STUB, kNoExtraICState<br>)</span></span></td></tr>
<tr><td class="num" id="LN217">217</td><td class="line"><span class='directive'>#undef DEF_ENTRY_C</span></td></tr>
<tr><td class="num" id="LN218">218</td><td class="line"><span class='directive'>#undef DEF_ENTRY_A</span></td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line"> </td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='macro'>arraysize(builtins)<span class='expansion'>(sizeof(ArraySizeHelper(builtins)))</span></span>; ++i) {</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">    ExternalReference ref(<span class='keyword'>static_cast</span>&lt;Builtins::Name&gt;(builtins[i].id), isolate);</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">    Add(ref.address(), builtins[i].name);</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line"> </td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> RefTableEntry runtime_functions[] = {</td></tr>
<tr><td class="num" id="LN227">227</td><td class="line"><span class='directive'>#define RUNTIME_ENTRY(name, i1, i2)       \</span></td></tr>
<tr><td class="num" id="LN228">228</td><td class="line">  <span class='directive'>{ Runtime::k##name, "Runtime::" #name } \</span></td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">      <span class='macro'>FOR_EACH_INTRINSIC(RUNTIME_ENTRY)<span class='expansion'>RUNTIME_ENTRY(ForInPrepare, 1, 3) RUNTIME_ENTRY(LoadLookupSlotForCall<br>, 1, 2) RUNTIME_ENTRY(BinaryOpIC_Miss, 2, 1) RUNTIME_ENTRY(BinaryOpIC_MissWithAllocationSite<br>, 3, 1) RUNTIME_ENTRY(CallIC_Miss, 3, 1) RUNTIME_ENTRY(CompareIC_Miss<br>, 3, 1) RUNTIME_ENTRY(CompareNilIC_Miss, 1, 1) RUNTIME_ENTRY(<br>ElementsTransitionAndStoreIC_Miss, 5, 1) RUNTIME_ENTRY(KeyedLoadIC_Miss<br>, 4, 1) RUNTIME_ENTRY(KeyedLoadIC_MissFromStubFailure, 4, 1) RUNTIME_ENTRY<br>(KeyedStoreIC_Miss, 5, 1) RUNTIME_ENTRY(KeyedStoreIC_MissFromStubFailure<br>, 5, 1) RUNTIME_ENTRY(KeyedStoreIC_Slow, 5, 1) RUNTIME_ENTRY(<br>LoadElementWithInterceptor, 2, 1) RUNTIME_ENTRY(LoadIC_Miss, 4<br>, 1) RUNTIME_ENTRY(LoadIC_MissFromStubFailure, 4, 1) RUNTIME_ENTRY<br>(LoadPropertyWithInterceptor, 3, 1) RUNTIME_ENTRY(LoadPropertyWithInterceptorOnly<br>, 3, 1) RUNTIME_ENTRY(StoreCallbackProperty, 6, 1) RUNTIME_ENTRY<br>(StoreIC_Miss, 5, 1) RUNTIME_ENTRY(StoreIC_MissFromStubFailure<br>, 5, 1) RUNTIME_ENTRY(StoreIC_Slow, 5, 1) RUNTIME_ENTRY(StorePropertyWithInterceptor<br>, 3, 1) RUNTIME_ENTRY(ToBooleanIC_Miss, 1, 1) RUNTIME_ENTRY(Unreachable<br>, 0, 1) RUNTIME_ENTRY(FinishArrayPrototypeSetup, 1, 1) RUNTIME_ENTRY<br>(SpecialArrayFunctions, 0, 1) RUNTIME_ENTRY(TransitionElementsKind<br>, 2, 1) RUNTIME_ENTRY(PushIfAbsent, 2, 1) RUNTIME_ENTRY(RemoveArrayHoles<br>, 2, 1) RUNTIME_ENTRY(MoveArrayContents, 2, 1) RUNTIME_ENTRY(<br>EstimateNumberOfElements, 1, 1) RUNTIME_ENTRY(GetArrayKeys, 2<br>, 1) RUNTIME_ENTRY(ArrayConstructor, -1, 1) RUNTIME_ENTRY(NewArray<br>, -1 , 1) RUNTIME_ENTRY(InternalArrayConstructor, -1, 1) RUNTIME_ENTRY<br>(NormalizeElements, 1, 1) RUNTIME_ENTRY(GrowArrayElements, 2,<br> 1) RUNTIME_ENTRY(HasComplexElements, 1, 1) RUNTIME_ENTRY(IsArray<br>, 1, 1) RUNTIME_ENTRY(HasCachedArrayIndex, 1, 1) RUNTIME_ENTRY<br>(GetCachedArrayIndex, 1, 1) RUNTIME_ENTRY(FixedArrayGet, 2, 1<br>) RUNTIME_ENTRY(FixedArraySet, 3, 1) RUNTIME_ENTRY(ArraySpeciesConstructor<br>, 1, 1) RUNTIME_ENTRY(AtomicsCompareExchange, 4, 1) RUNTIME_ENTRY<br>(AtomicsLoad, 2, 1) RUNTIME_ENTRY(AtomicsStore, 3, 1) RUNTIME_ENTRY<br>(AtomicsAdd, 3, 1) RUNTIME_ENTRY(AtomicsSub, 3, 1) RUNTIME_ENTRY<br>(AtomicsAnd, 3, 1) RUNTIME_ENTRY(AtomicsOr, 3, 1) RUNTIME_ENTRY<br>(AtomicsXor, 3, 1) RUNTIME_ENTRY(AtomicsExchange, 3, 1) RUNTIME_ENTRY<br>(AtomicsIsLockFree, 1, 1) RUNTIME_ENTRY(ThrowNonMethodError, 0<br>, 1) RUNTIME_ENTRY(ThrowUnsupportedSuperError, 0, 1) RUNTIME_ENTRY<br>(ThrowConstructorNonCallableError, 1, 1) RUNTIME_ENTRY(ThrowArrayNotSubclassableError<br>, 0, 1) RUNTIME_ENTRY(ThrowStaticPrototypeError, 0, 1) RUNTIME_ENTRY<br>(ThrowIfStaticPrototype, 1, 1) RUNTIME_ENTRY(HomeObjectSymbol<br>, 0, 1) RUNTIME_ENTRY(DefineClass, 4, 1) RUNTIME_ENTRY(FinalizeClassDefinition<br>, 2, 1) RUNTIME_ENTRY(LoadFromSuper, 3, 1) RUNTIME_ENTRY(LoadKeyedFromSuper<br>, 3, 1) RUNTIME_ENTRY(StoreToSuper_Strict, 4, 1) RUNTIME_ENTRY<br>(StoreToSuper_Sloppy, 4, 1) RUNTIME_ENTRY(StoreKeyedToSuper_Strict<br>, 4, 1) RUNTIME_ENTRY(StoreKeyedToSuper_Sloppy, 4, 1) RUNTIME_ENTRY<br>(GetSuperConstructor, 1, 1) RUNTIME_ENTRY(StringGetRawHashField<br>, 1, 1) RUNTIME_ENTRY(TheHole, 0, 1) RUNTIME_ENTRY(JSCollectionGetTable<br>, 1, 1) RUNTIME_ENTRY(GenericHash, 1, 1) RUNTIME_ENTRY(SetInitialize<br>, 1, 1) RUNTIME_ENTRY(SetGrow, 1, 1) RUNTIME_ENTRY(SetShrink,<br> 1, 1) RUNTIME_ENTRY(SetClear, 1, 1) RUNTIME_ENTRY(SetIteratorInitialize<br>, 3, 1) RUNTIME_ENTRY(SetIteratorClone, 1, 1) RUNTIME_ENTRY(SetIteratorNext<br>, 2, 1) RUNTIME_ENTRY(SetIteratorDetails, 1, 1) RUNTIME_ENTRY<br>(MapInitialize, 1, 1) RUNTIME_ENTRY(MapShrink, 1, 1) RUNTIME_ENTRY<br>(MapClear, 1, 1) RUNTIME_ENTRY(MapGrow, 1, 1) RUNTIME_ENTRY(MapIteratorInitialize<br>, 3, 1) RUNTIME_ENTRY(MapIteratorClone, 1, 1) RUNTIME_ENTRY(MapIteratorDetails<br>, 1, 1) RUNTIME_ENTRY(GetWeakMapEntries, 2, 1) RUNTIME_ENTRY(<br>MapIteratorNext, 2, 1) RUNTIME_ENTRY(WeakCollectionInitialize<br>, 1, 1) RUNTIME_ENTRY(WeakCollectionGet, 3, 1) RUNTIME_ENTRY(<br>WeakCollectionHas, 3, 1) RUNTIME_ENTRY(WeakCollectionDelete, 3<br>, 1) RUNTIME_ENTRY(WeakCollectionSet, 4, 1) RUNTIME_ENTRY(GetWeakSetValues<br>, 2, 1) RUNTIME_ENTRY(ObservationWeakMapCreate, 0, 1) RUNTIME_ENTRY<br>(CompileLazy, 1, 1) RUNTIME_ENTRY(CompileOptimized_Concurrent<br>, 1, 1) RUNTIME_ENTRY(CompileOptimized_NotConcurrent, 1, 1) RUNTIME_ENTRY<br>(NotifyStubFailure, 0, 1) RUNTIME_ENTRY(NotifyDeoptimized, 1,<br> 1) RUNTIME_ENTRY(CompileForOnStackReplacement, 1, 1) RUNTIME_ENTRY<br>(TryInstallOptimizedCode, 1, 1) RUNTIME_ENTRY(ResolvePossiblyDirectEval<br>, 5, 1) RUNTIME_ENTRY(IsDate, 1, 1) RUNTIME_ENTRY(DateCurrentTime<br>, 0, 1) RUNTIME_ENTRY(ThrowNotDateError, 0, 1) RUNTIME_ENTRY(<br>HandleDebuggerStatement, 0, 1) RUNTIME_ENTRY(DebugBreak, 0, 1<br>) RUNTIME_ENTRY(SetDebugEventListener, 2, 1) RUNTIME_ENTRY(ScheduleBreak<br>, 0, 1) RUNTIME_ENTRY(DebugGetInternalProperties, 1, 1) RUNTIME_ENTRY<br>(DebugGetPropertyDetails, 2, 1) RUNTIME_ENTRY(DebugGetProperty<br>, 2, 1) RUNTIME_ENTRY(DebugPropertyTypeFromDetails, 1, 1) RUNTIME_ENTRY<br>(DebugPropertyAttributesFromDetails, 1, 1) RUNTIME_ENTRY(DebugPropertyIndexFromDetails<br>, 1, 1) RUNTIME_ENTRY(DebugNamedInterceptorPropertyValue, 2, 1<br>) RUNTIME_ENTRY(DebugIndexedInterceptorElementValue, 2, 1) RUNTIME_ENTRY<br>(CheckExecutionState, 1, 1) RUNTIME_ENTRY(GetFrameCount, 1, 1<br>) RUNTIME_ENTRY(GetFrameDetails, 2, 1) RUNTIME_ENTRY(GetScopeCount<br>, 2, 1) RUNTIME_ENTRY(GetStepInPositions, 2, 1) RUNTIME_ENTRY<br>(GetScopeDetails, 4, 1) RUNTIME_ENTRY(GetAllScopesDetails, 4,<br> 1) RUNTIME_ENTRY(GetFunctionScopeCount, 1, 1) RUNTIME_ENTRY(<br>GetFunctionScopeDetails, 2, 1) RUNTIME_ENTRY(SetScopeVariableValue<br>, 6, 1) RUNTIME_ENTRY(DebugPrintScopes, 0, 1) RUNTIME_ENTRY(GetThreadCount<br>, 1, 1) RUNTIME_ENTRY(GetThreadDetails, 2, 1) RUNTIME_ENTRY(SetBreakPointsActive<br>, 1, 1) RUNTIME_ENTRY(GetBreakLocations, 2, 1) RUNTIME_ENTRY(<br>SetFunctionBreakPoint, 3, 1) RUNTIME_ENTRY(SetScriptBreakPoint<br>, 4, 1) RUNTIME_ENTRY(ClearBreakPoint, 1, 1) RUNTIME_ENTRY(ChangeBreakOnException<br>, 2, 1) RUNTIME_ENTRY(IsBreakOnException, 1, 1) RUNTIME_ENTRY<br>(PrepareStep, 2, 1) RUNTIME_ENTRY(ClearStepping, 0, 1) RUNTIME_ENTRY<br>(DebugEvaluate, 6, 1) RUNTIME_ENTRY(DebugEvaluateGlobal, 4, 1<br>) RUNTIME_ENTRY(DebugGetLoadedScripts, 0, 1) RUNTIME_ENTRY(DebugReferencedBy<br>, 3, 1) RUNTIME_ENTRY(DebugConstructedBy, 2, 1) RUNTIME_ENTRY<br>(DebugGetPrototype, 1, 1) RUNTIME_ENTRY(DebugSetScriptSource,<br> 2, 1) RUNTIME_ENTRY(FunctionGetInferredName, 1, 1) RUNTIME_ENTRY<br>(FunctionGetDebugName, 1, 1) RUNTIME_ENTRY(GetFunctionCodePositionFromSource<br>, 2, 1) RUNTIME_ENTRY(ExecuteInDebugContext, 1, 1) RUNTIME_ENTRY<br>(GetDebugContext, 0, 1) RUNTIME_ENTRY(CollectGarbage, 1, 1) RUNTIME_ENTRY<br>(GetHeapUsage, 0, 1) RUNTIME_ENTRY(GetScript, 1, 1) RUNTIME_ENTRY<br>(DebugPrepareStepInIfStepping, 1, 1) RUNTIME_ENTRY(DebugPushPromise<br>, 2, 1) RUNTIME_ENTRY(DebugPopPromise, 0, 1) RUNTIME_ENTRY(DebugPromiseEvent<br>, 1, 1) RUNTIME_ENTRY(DebugAsyncTaskEvent, 1, 1) RUNTIME_ENTRY<br>(DebugIsActive, 0, 1) RUNTIME_ENTRY(DebugBreakInOptimizedCode<br>, 0, 1) RUNTIME_ENTRY(ForInDone, 2, 1) RUNTIME_ENTRY(ForInEnumerate<br>, 1, 1) RUNTIME_ENTRY(ForInFilter, 2, 1) RUNTIME_ENTRY(ForInNext<br>, 4, 1) RUNTIME_ENTRY(ForInStep, 1, 1) RUNTIME_ENTRY(InterpreterToBoolean<br>, 1, 1) RUNTIME_ENTRY(InterpreterLogicalNot, 1, 1) RUNTIME_ENTRY<br>(InterpreterTypeOf, 1, 1) RUNTIME_ENTRY(InterpreterNewClosure<br>, 2, 1) RUNTIME_ENTRY(InterpreterTraceBytecodeEntry, 3, 1) RUNTIME_ENTRY<br>(InterpreterTraceBytecodeExit, 3, 1) RUNTIME_ENTRY(InterpreterClearPendingMessage<br>, 0, 1) RUNTIME_ENTRY(InterpreterSetPendingMessage, 1, 1) RUNTIME_ENTRY<br>(FunctionGetName, 1, 1) RUNTIME_ENTRY(FunctionSetName, 2, 1) RUNTIME_ENTRY<br>(FunctionRemovePrototype, 1, 1) RUNTIME_ENTRY(FunctionGetScript<br>, 1, 1) RUNTIME_ENTRY(FunctionGetSourceCode, 1, 1) RUNTIME_ENTRY<br>(FunctionGetScriptSourcePosition, 1, 1) RUNTIME_ENTRY(FunctionGetPositionForOffset<br>, 2, 1) RUNTIME_ENTRY(FunctionSetInstanceClassName, 2, 1) RUNTIME_ENTRY<br>(FunctionSetLength, 2, 1) RUNTIME_ENTRY(FunctionSetPrototype,<br> 2, 1) RUNTIME_ENTRY(FunctionIsAPIFunction, 1, 1) RUNTIME_ENTRY<br>(SetCode, 2, 1) RUNTIME_ENTRY(SetNativeFlag, 1, 1) RUNTIME_ENTRY<br>(ThrowStrongModeTooFewArguments, 0, 1) RUNTIME_ENTRY(IsConstructor<br>, 1, 1) RUNTIME_ENTRY(SetForceInlineFlag, 1, 1) RUNTIME_ENTRY<br>(Call, -1 , 1) RUNTIME_ENTRY(TailCall, -1 , 1) RUNTIME_ENTRY(<br>Apply, 5, 1) RUNTIME_ENTRY(ConvertReceiver, 1, 1) RUNTIME_ENTRY<br>(IsFunction, 1, 1) RUNTIME_ENTRY(FunctionToString, 1, 1) RUNTIME_ENTRY<br>(AtomicsFutexWait, 4, 1) RUNTIME_ENTRY(AtomicsFutexWake, 3, 1<br>) RUNTIME_ENTRY(AtomicsFutexWakeOrRequeue, 5, 1) RUNTIME_ENTRY<br>(AtomicsFutexNumWaitersForTesting, 2, 1) RUNTIME_ENTRY(CreateJSGeneratorObject<br>, 0, 1) RUNTIME_ENTRY(SuspendJSGeneratorObject, 1, 1) RUNTIME_ENTRY<br>(ResumeJSGeneratorObject, 3, 1) RUNTIME_ENTRY(GeneratorClose,<br> 1, 1) RUNTIME_ENTRY(GeneratorGetFunction, 1, 1) RUNTIME_ENTRY<br>(GeneratorGetContext, 1, 1) RUNTIME_ENTRY(GeneratorGetReceiver<br>, 1, 1) RUNTIME_ENTRY(GeneratorGetInput, 1, 1) RUNTIME_ENTRY(<br>GeneratorGetContinuation, 1, 1) RUNTIME_ENTRY(GeneratorGetSourcePosition<br>, 1, 1) RUNTIME_ENTRY(GeneratorNext, 2, 1) RUNTIME_ENTRY(GeneratorReturn<br>, 2, 1) RUNTIME_ENTRY(GeneratorThrow, 2, 1) RUNTIME_ENTRY(CanonicalizeLanguageTag<br>, 1, 1) RUNTIME_ENTRY(AvailableLocalesOf, 1, 1) RUNTIME_ENTRY<br>(GetDefaultICULocale, 0, 1) RUNTIME_ENTRY(GetLanguageTagVariants<br>, 1, 1) RUNTIME_ENTRY(IsInitializedIntlObject, 1, 1) RUNTIME_ENTRY<br>(IsInitializedIntlObjectOfType, 2, 1) RUNTIME_ENTRY(MarkAsInitializedIntlObjectOfType<br>, 3, 1) RUNTIME_ENTRY(GetImplFromInitializedIntlObject, 1, 1)<br> RUNTIME_ENTRY(CreateDateTimeFormat, 3, 1) RUNTIME_ENTRY(InternalDateFormat<br>, 2, 1) RUNTIME_ENTRY(InternalDateParse, 2, 1) RUNTIME_ENTRY(<br>CreateNumberFormat, 3, 1) RUNTIME_ENTRY(InternalNumberFormat,<br> 2, 1) RUNTIME_ENTRY(InternalNumberParse, 2, 1) RUNTIME_ENTRY<br>(CreateCollator, 3, 1) RUNTIME_ENTRY(InternalCompare, 3, 1) RUNTIME_ENTRY<br>(StringNormalize, 2, 1) RUNTIME_ENTRY(CreateBreakIterator, 3,<br> 1) RUNTIME_ENTRY(BreakIteratorAdoptText, 2, 1) RUNTIME_ENTRY<br>(BreakIteratorFirst, 1, 1) RUNTIME_ENTRY(BreakIteratorNext, 1<br>, 1) RUNTIME_ENTRY(BreakIteratorCurrent, 1, 1) RUNTIME_ENTRY(<br>BreakIteratorBreakType, 1, 1) RUNTIME_ENTRY(CheckIsBootstrapping<br>, 0, 1) RUNTIME_ENTRY(ExportFromRuntime, 1, 1) RUNTIME_ENTRY(<br>ExportExperimentalFromRuntime, 1, 1) RUNTIME_ENTRY(InstallToContext<br>, 1, 1) RUNTIME_ENTRY(Throw, 1, 1) RUNTIME_ENTRY(ReThrow, 1, 1<br>) RUNTIME_ENTRY(UnwindAndFindExceptionHandler, 0, 1) RUNTIME_ENTRY<br>(PromoteScheduledException, 0, 1) RUNTIME_ENTRY(ThrowReferenceError<br>, 1, 1) RUNTIME_ENTRY(ThrowApplyNonFunction, 1, 1) RUNTIME_ENTRY<br>(NewTypeError, 2, 1) RUNTIME_ENTRY(NewSyntaxError, 2, 1) RUNTIME_ENTRY<br>(NewReferenceError, 2, 1) RUNTIME_ENTRY(ThrowIllegalInvocation<br>, 0, 1) RUNTIME_ENTRY(ThrowIteratorResultNotAnObject, 1, 1) RUNTIME_ENTRY<br>(ThrowStackOverflow, 0, 1) RUNTIME_ENTRY(ThrowStrongModeImplicitConversion<br>, 0, 1) RUNTIME_ENTRY(PromiseRejectEvent, 3, 1) RUNTIME_ENTRY<br>(PromiseRevokeReject, 1, 1) RUNTIME_ENTRY(StackGuard, 0, 1) RUNTIME_ENTRY<br>(Interrupt, 0, 1) RUNTIME_ENTRY(AllocateInNewSpace, 1, 1) RUNTIME_ENTRY<br>(AllocateInTargetSpace, 2, 1) RUNTIME_ENTRY(CollectStackTrace<br>, 2, 1) RUNTIME_ENTRY(MessageGetStartPosition, 1, 1) RUNTIME_ENTRY<br>(MessageGetScript, 1, 1) RUNTIME_ENTRY(FormatMessageString, 4<br>, 1) RUNTIME_ENTRY(CallSiteGetFileNameRT, 1, 1) RUNTIME_ENTRY<br>(CallSiteGetFunctionNameRT, 1, 1) RUNTIME_ENTRY(CallSiteGetScriptNameOrSourceUrlRT<br>, 1, 1) RUNTIME_ENTRY(CallSiteGetMethodNameRT, 1, 1) RUNTIME_ENTRY<br>(CallSiteGetLineNumberRT, 1, 1) RUNTIME_ENTRY(CallSiteGetColumnNumberRT<br>, 1, 1) RUNTIME_ENTRY(CallSiteIsNativeRT, 1, 1) RUNTIME_ENTRY<br>(CallSiteIsToplevelRT, 1, 1) RUNTIME_ENTRY(CallSiteIsEvalRT, 1<br>, 1) RUNTIME_ENTRY(CallSiteIsConstructorRT, 1, 1) RUNTIME_ENTRY<br>(IS_VAR, 1, 1) RUNTIME_ENTRY(IncrementStatsCounter, 1, 1) RUNTIME_ENTRY<br>(ThrowConstructedNonConstructable, 1, 1) RUNTIME_ENTRY(ThrowDerivedConstructorReturnedNonObject<br>, 0, 1) RUNTIME_ENTRY(ThrowCalledNonCallable, 1, 1) RUNTIME_ENTRY<br>(CreateListFromArrayLike, 1, 1) RUNTIME_ENTRY(IncrementUseCounter<br>, 1, 1) RUNTIME_ENTRY(GetAndResetRuntimeCallStats, 0, 1) RUNTIME_ENTRY<br>(QuoteJSONString, 1, 1) RUNTIME_ENTRY(BasicJSONStringify, 1, 1<br>) RUNTIME_ENTRY(ParseJson, 1, 1) RUNTIME_ENTRY(CreateRegExpLiteral<br>, 4, 1) RUNTIME_ENTRY(CreateObjectLiteral, 4, 1) RUNTIME_ENTRY<br>(CreateArrayLiteral, 4, 1) RUNTIME_ENTRY(CreateArrayLiteralStubBailout<br>, 3, 1) RUNTIME_ENTRY(LiveEditFindSharedFunctionInfosForScript<br>, 1, 1) RUNTIME_ENTRY(LiveEditGatherCompileInfo, 2, 1) RUNTIME_ENTRY<br>(LiveEditReplaceScript, 3, 1) RUNTIME_ENTRY(LiveEditFunctionSourceUpdated<br>, 1, 1) RUNTIME_ENTRY(LiveEditReplaceFunctionCode, 2, 1) RUNTIME_ENTRY<br>(LiveEditFunctionSetScript, 2, 1) RUNTIME_ENTRY(LiveEditReplaceRefToNestedFunction<br>, 3, 1) RUNTIME_ENTRY(LiveEditPatchFunctionPositions, 2, 1) RUNTIME_ENTRY<br>(LiveEditCheckAndDropActivations, 3, 1) RUNTIME_ENTRY(LiveEditCompareStrings<br>, 2, 1) RUNTIME_ENTRY(LiveEditRestartFrame, 2, 1) RUNTIME_ENTRY<br>(MathAcos, 1, 1) RUNTIME_ENTRY(MathAsin, 1, 1) RUNTIME_ENTRY(<br>MathAtan, 1, 1) RUNTIME_ENTRY(MathLogRT, 1, 1) RUNTIME_ENTRY(<br>DoubleHi, 1, 1) RUNTIME_ENTRY(DoubleLo, 1, 1) RUNTIME_ENTRY(ConstructDouble<br>, 2, 1) RUNTIME_ENTRY(RemPiO2, 2, 1) RUNTIME_ENTRY(MathAtan2,<br> 2, 1) RUNTIME_ENTRY(MathExpRT, 1, 1) RUNTIME_ENTRY(MathClz32<br>, 1, 1) RUNTIME_ENTRY(MathFloor, 1, 1) RUNTIME_ENTRY(MathPow,<br> 2, 1) RUNTIME_ENTRY(MathPowRT, 2, 1) RUNTIME_ENTRY(RoundNumber<br>, 1, 1) RUNTIME_ENTRY(MathSqrt, 1, 1) RUNTIME_ENTRY(MathFround<br>, 1, 1) RUNTIME_ENTRY(GenerateRandomNumbers, 1, 1) RUNTIME_ENTRY<br>(NumberToRadixString, 2, 1) RUNTIME_ENTRY(NumberToFixed, 2, 1<br>) RUNTIME_ENTRY(NumberToExponential, 2, 1) RUNTIME_ENTRY(NumberToPrecision<br>, 2, 1) RUNTIME_ENTRY(IsValidSmi, 1, 1) RUNTIME_ENTRY(StringToNumber<br>, 1, 1) RUNTIME_ENTRY(StringParseInt, 2, 1) RUNTIME_ENTRY(StringParseFloat<br>, 1, 1) RUNTIME_ENTRY(NumberToString, 1, 1) RUNTIME_ENTRY(NumberToStringSkipCache<br>, 1, 1) RUNTIME_ENTRY(NumberToIntegerMapMinusZero, 1, 1) RUNTIME_ENTRY<br>(NumberToSmi, 1, 1) RUNTIME_ENTRY(NumberImul, 2, 1) RUNTIME_ENTRY<br>(SmiLexicographicCompare, 2, 1) RUNTIME_ENTRY(MaxSmi, 0, 1) RUNTIME_ENTRY<br>(IsSmi, 1, 1) RUNTIME_ENTRY(GetRootNaN, 0, 1) RUNTIME_ENTRY(GetHoleNaNUpper<br>, 0, 1) RUNTIME_ENTRY(GetHoleNaNLower, 0, 1) RUNTIME_ENTRY(GetPrototype<br>, 1, 1) RUNTIME_ENTRY(InternalSetPrototype, 2, 1) RUNTIME_ENTRY<br>(SetPrototype, 2, 1) RUNTIME_ENTRY(GetOwnProperty_Legacy, 2, 1<br>) RUNTIME_ENTRY(OptimizeObjectForAddingMultipleProperties, 2,<br> 1) RUNTIME_ENTRY(GetProperty, 2, 1) RUNTIME_ENTRY(KeyedGetProperty<br>, 2, 1) RUNTIME_ENTRY(LoadGlobalViaContext, 1, 1) RUNTIME_ENTRY<br>(StoreGlobalViaContext_Sloppy, 2, 1) RUNTIME_ENTRY(StoreGlobalViaContext_Strict<br>, 2, 1) RUNTIME_ENTRY(AddNamedProperty, 4, 1) RUNTIME_ENTRY(SetProperty<br>, 4, 1) RUNTIME_ENTRY(AddElement, 3, 1) RUNTIME_ENTRY(AppendElement<br>, 2, 1) RUNTIME_ENTRY(DeleteProperty_Sloppy, 2, 1) RUNTIME_ENTRY<br>(DeleteProperty_Strict, 2, 1) RUNTIME_ENTRY(HasOwnProperty, 2<br>, 1) RUNTIME_ENTRY(HasProperty, 2, 1) RUNTIME_ENTRY(PropertyIsEnumerable<br>, 2, 1) RUNTIME_ENTRY(GetOwnPropertyKeys, 2, 1) RUNTIME_ENTRY<br>(GetInterceptorInfo, 1, 1) RUNTIME_ENTRY(ToFastProperties, 1,<br> 1) RUNTIME_ENTRY(AllocateHeapNumber, 0, 1) RUNTIME_ENTRY(NewObject<br>, 2, 1) RUNTIME_ENTRY(FinalizeInstanceSize, 1, 1) RUNTIME_ENTRY<br>(GlobalProxy, 1, 1) RUNTIME_ENTRY(LookupAccessor, 3, 1) RUNTIME_ENTRY<br>(LoadMutableDouble, 2, 1) RUNTIME_ENTRY(TryMigrateInstance, 1<br>, 1) RUNTIME_ENTRY(IsJSGlobalProxy, 1, 1) RUNTIME_ENTRY(DefineAccessorPropertyUnchecked<br>, 5, 1) RUNTIME_ENTRY(DefineDataPropertyUnchecked, 4, 1) RUNTIME_ENTRY<br>(DefineDataPropertyInLiteral, 5, 1) RUNTIME_ENTRY(GetDataProperty<br>, 2, 1) RUNTIME_ENTRY(HasFastPackedElements, 1, 1) RUNTIME_ENTRY<br>(ValueOf, 1, 1) RUNTIME_ENTRY(IsJSReceiver, 1, 1) RUNTIME_ENTRY<br>(IsStrong, 1, 1) RUNTIME_ENTRY(ClassOf, 1, 1) RUNTIME_ENTRY(DefineGetterPropertyUnchecked<br>, 4, 1) RUNTIME_ENTRY(DefineSetterPropertyUnchecked, 4, 1) RUNTIME_ENTRY<br>(ToObject, 1, 1) RUNTIME_ENTRY(ToPrimitive, 1, 1) RUNTIME_ENTRY<br>(ToPrimitive_Number, 1, 1) RUNTIME_ENTRY(ToPrimitive_String, 1<br>, 1) RUNTIME_ENTRY(ToNumber, 1, 1) RUNTIME_ENTRY(ToInteger, 1<br>, 1) RUNTIME_ENTRY(ToLength, 1, 1) RUNTIME_ENTRY(ToString, 1,<br> 1) RUNTIME_ENTRY(ToName, 1, 1) RUNTIME_ENTRY(SameValue, 2, 1<br>) RUNTIME_ENTRY(SameValueZero, 2, 1) RUNTIME_ENTRY(Compare, 3<br>, 1) RUNTIME_ENTRY(InstanceOf, 2, 1) RUNTIME_ENTRY(HasInPrototypeChain<br>, 2, 1) RUNTIME_ENTRY(CreateIterResultObject, 2, 1) RUNTIME_ENTRY<br>(IsAccessCheckNeeded, 1, 1) RUNTIME_ENTRY(ObjectDefineProperties<br>, 2, 1) RUNTIME_ENTRY(ObjectDefineProperty, 3, 1) RUNTIME_ENTRY<br>(IsObserved, 1, 1) RUNTIME_ENTRY(SetIsObserved, 1, 1) RUNTIME_ENTRY<br>(EnqueueMicrotask, 1, 1) RUNTIME_ENTRY(RunMicrotasks, 0, 1) RUNTIME_ENTRY<br>(DeliverObservationChangeRecords, 2, 1) RUNTIME_ENTRY(GetObservationState<br>, 0, 1) RUNTIME_ENTRY(ObserverObjectAndRecordHaveSameOrigin, 3<br>, 1) RUNTIME_ENTRY(ObjectWasCreatedInCurrentOrigin, 1, 1) RUNTIME_ENTRY<br>(GetObjectContextObjectObserve, 1, 1) RUNTIME_ENTRY(GetObjectContextObjectGetNotifier<br>, 1, 1) RUNTIME_ENTRY(GetObjectContextNotifierPerformChange, 1<br>, 1) RUNTIME_ENTRY(Multiply, 2, 1) RUNTIME_ENTRY(Divide, 2, 1<br>) RUNTIME_ENTRY(Modulus, 2, 1) RUNTIME_ENTRY(Add, 2, 1) RUNTIME_ENTRY<br>(Subtract, 2, 1) RUNTIME_ENTRY(ShiftLeft, 2, 1) RUNTIME_ENTRY<br>(ShiftRight, 2, 1) RUNTIME_ENTRY(ShiftRightLogical, 2, 1) RUNTIME_ENTRY<br>(BitwiseAnd, 2, 1) RUNTIME_ENTRY(BitwiseOr, 2, 1) RUNTIME_ENTRY<br>(BitwiseXor, 2, 1) RUNTIME_ENTRY(Equal, 2, 1) RUNTIME_ENTRY(NotEqual<br>, 2, 1) RUNTIME_ENTRY(StrictEqual, 2, 1) RUNTIME_ENTRY(StrictNotEqual<br>, 2, 1) RUNTIME_ENTRY(LessThan, 2, 1) RUNTIME_ENTRY(GreaterThan<br>, 2, 1) RUNTIME_ENTRY(LessThanOrEqual, 2, 1) RUNTIME_ENTRY(GreaterThanOrEqual<br>, 2, 1) RUNTIME_ENTRY(IsJSProxy, 1, 1) RUNTIME_ENTRY(JSProxyCall<br>, -1 , 1) RUNTIME_ENTRY(JSProxyConstruct, -1 , 1) RUNTIME_ENTRY<br>(JSProxyGetTarget, 1, 1) RUNTIME_ENTRY(JSProxyGetHandler, 1, 1<br>) RUNTIME_ENTRY(JSProxyRevoke, 1, 1) RUNTIME_ENTRY(StringReplaceGlobalRegExpWithString<br>, 4, 1) RUNTIME_ENTRY(StringSplit, 3, 1) RUNTIME_ENTRY(RegExpExec<br>, 4, 1) RUNTIME_ENTRY(RegExpFlags, 1, 1) RUNTIME_ENTRY(RegExpSource<br>, 1, 1) RUNTIME_ENTRY(RegExpConstructResult, 3, 1) RUNTIME_ENTRY<br>(RegExpInitializeAndCompile, 3, 1) RUNTIME_ENTRY(RegExpExecMultiple<br>, 4, 1) RUNTIME_ENTRY(RegExpExecReThrow, 4, 1) RUNTIME_ENTRY(<br>IsRegExp, 1, 1) RUNTIME_ENTRY(ThrowConstAssignError, 0, 1) RUNTIME_ENTRY<br>(DeclareGlobals, 2, 1) RUNTIME_ENTRY(InitializeVarGlobal, 3, 1<br>) RUNTIME_ENTRY(InitializeConstGlobal, 2, 1) RUNTIME_ENTRY(DeclareLookupSlot<br>, 3, 1) RUNTIME_ENTRY(InitializeLegacyConstLookupSlot, 3, 1) RUNTIME_ENTRY<br>(NewSloppyArguments_Generic, 1, 1) RUNTIME_ENTRY(NewStrictArguments<br>, 1, 1) RUNTIME_ENTRY(NewRestParameter, 1, 1) RUNTIME_ENTRY(NewSloppyArguments<br>, 3, 1) RUNTIME_ENTRY(NewClosure, 1, 1) RUNTIME_ENTRY(NewClosure_Tenured<br>, 1, 1) RUNTIME_ENTRY(NewScriptContext, 2, 1) RUNTIME_ENTRY(NewFunctionContext<br>, 1, 1) RUNTIME_ENTRY(PushWithContext, 2, 1) RUNTIME_ENTRY(PushCatchContext<br>, 3, 1) RUNTIME_ENTRY(PushBlockContext, 2, 1) RUNTIME_ENTRY(IsJSModule<br>, 1, 1) RUNTIME_ENTRY(PushModuleContext, 2, 1) RUNTIME_ENTRY(<br>DeclareModules, 1, 1) RUNTIME_ENTRY(DeleteLookupSlot, 1, 1) RUNTIME_ENTRY<br>(LoadLookupSlot, 1, 1) RUNTIME_ENTRY(LoadLookupSlotInsideTypeof<br>, 1, 1) RUNTIME_ENTRY(StoreLookupSlot_Sloppy, 2, 1) RUNTIME_ENTRY<br>(StoreLookupSlot_Strict, 2, 1) RUNTIME_ENTRY(IsSimdValue, 1, 1<br>) RUNTIME_ENTRY(CreateFloat32x4, 4, 1) RUNTIME_ENTRY(CreateInt32x4<br>, 4, 1) RUNTIME_ENTRY(CreateUint32x4, 4, 1) RUNTIME_ENTRY(CreateBool32x4<br>, 4, 1) RUNTIME_ENTRY(CreateInt16x8, 8, 1) RUNTIME_ENTRY(CreateUint16x8<br>, 8, 1) RUNTIME_ENTRY(CreateBool16x8, 8, 1) RUNTIME_ENTRY(CreateInt8x16<br>, 16, 1) RUNTIME_ENTRY(CreateUint8x16, 16, 1) RUNTIME_ENTRY(CreateBool8x16<br>, 16, 1) RUNTIME_ENTRY(Float32x4Check, 1, 1) RUNTIME_ENTRY(Float32x4ExtractLane<br>, 2, 1) RUNTIME_ENTRY(Float32x4ReplaceLane, 3, 1) RUNTIME_ENTRY<br>(Float32x4Abs, 1, 1) RUNTIME_ENTRY(Float32x4Neg, 1, 1) RUNTIME_ENTRY<br>(Float32x4Sqrt, 1, 1) RUNTIME_ENTRY(Float32x4RecipApprox, 1, 1<br>) RUNTIME_ENTRY(Float32x4RecipSqrtApprox, 1, 1) RUNTIME_ENTRY<br>(Float32x4Add, 2, 1) RUNTIME_ENTRY(Float32x4Sub, 2, 1) RUNTIME_ENTRY<br>(Float32x4Mul, 2, 1) RUNTIME_ENTRY(Float32x4Div, 2, 1) RUNTIME_ENTRY<br>(Float32x4Min, 2, 1) RUNTIME_ENTRY(Float32x4Max, 2, 1) RUNTIME_ENTRY<br>(Float32x4MinNum, 2, 1) RUNTIME_ENTRY(Float32x4MaxNum, 2, 1) RUNTIME_ENTRY<br>(Float32x4Equal, 2, 1) RUNTIME_ENTRY(Float32x4NotEqual, 2, 1)<br> RUNTIME_ENTRY(Float32x4LessThan, 2, 1) RUNTIME_ENTRY(Float32x4LessThanOrEqual<br>, 2, 1) RUNTIME_ENTRY(Float32x4GreaterThan, 2, 1) RUNTIME_ENTRY<br>(Float32x4GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Float32x4Select<br>, 3, 1) RUNTIME_ENTRY(Float32x4Swizzle, 5, 1) RUNTIME_ENTRY(Float32x4Shuffle<br>, 6, 1) RUNTIME_ENTRY(Float32x4FromInt32x4, 1, 1) RUNTIME_ENTRY<br>(Float32x4FromUint32x4, 1, 1) RUNTIME_ENTRY(Float32x4FromInt32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Float32x4FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Float32x4FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Float32x4FromUint16x8Bits<br>, 1, 1) RUNTIME_ENTRY(Float32x4FromInt8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Float32x4FromUint8x16Bits, 1, 1) RUNTIME_ENTRY(Float32x4Load<br>, 2, 1) RUNTIME_ENTRY(Float32x4Load1, 2, 1) RUNTIME_ENTRY(Float32x4Load2<br>, 2, 1) RUNTIME_ENTRY(Float32x4Load3, 2, 1) RUNTIME_ENTRY(Float32x4Store<br>, 3, 1) RUNTIME_ENTRY(Float32x4Store1, 3, 1) RUNTIME_ENTRY(Float32x4Store2<br>, 3, 1) RUNTIME_ENTRY(Float32x4Store3, 3, 1) RUNTIME_ENTRY(Int32x4Check<br>, 1, 1) RUNTIME_ENTRY(Int32x4ExtractLane, 2, 1) RUNTIME_ENTRY<br>(Int32x4ReplaceLane, 3, 1) RUNTIME_ENTRY(Int32x4Neg, 1, 1) RUNTIME_ENTRY<br>(Int32x4Add, 2, 1) RUNTIME_ENTRY(Int32x4Sub, 2, 1) RUNTIME_ENTRY<br>(Int32x4Mul, 2, 1) RUNTIME_ENTRY(Int32x4Min, 2, 1) RUNTIME_ENTRY<br>(Int32x4Max, 2, 1) RUNTIME_ENTRY(Int32x4And, 2, 1) RUNTIME_ENTRY<br>(Int32x4Or, 2, 1) RUNTIME_ENTRY(Int32x4Xor, 2, 1) RUNTIME_ENTRY<br>(Int32x4Not, 1, 1) RUNTIME_ENTRY(Int32x4ShiftLeftByScalar, 2,<br> 1) RUNTIME_ENTRY(Int32x4ShiftRightByScalar, 2, 1) RUNTIME_ENTRY<br>(Int32x4Equal, 2, 1) RUNTIME_ENTRY(Int32x4NotEqual, 2, 1) RUNTIME_ENTRY<br>(Int32x4LessThan, 2, 1) RUNTIME_ENTRY(Int32x4LessThanOrEqual,<br> 2, 1) RUNTIME_ENTRY(Int32x4GreaterThan, 2, 1) RUNTIME_ENTRY(<br>Int32x4GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Int32x4Select,<br> 3, 1) RUNTIME_ENTRY(Int32x4Swizzle, 5, 1) RUNTIME_ENTRY(Int32x4Shuffle<br>, 6, 1) RUNTIME_ENTRY(Int32x4FromFloat32x4, 1, 1) RUNTIME_ENTRY<br>(Int32x4FromUint32x4, 1, 1) RUNTIME_ENTRY(Int32x4FromFloat32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Int32x4FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Int32x4FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Int32x4FromUint16x8Bits<br>, 1, 1) RUNTIME_ENTRY(Int32x4FromInt8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Int32x4FromUint8x16Bits, 1, 1) RUNTIME_ENTRY(Int32x4Load, 2,<br> 1) RUNTIME_ENTRY(Int32x4Load1, 2, 1) RUNTIME_ENTRY(Int32x4Load2<br>, 2, 1) RUNTIME_ENTRY(Int32x4Load3, 2, 1) RUNTIME_ENTRY(Int32x4Store<br>, 3, 1) RUNTIME_ENTRY(Int32x4Store1, 3, 1) RUNTIME_ENTRY(Int32x4Store2<br>, 3, 1) RUNTIME_ENTRY(Int32x4Store3, 3, 1) RUNTIME_ENTRY(Uint32x4Check<br>, 1, 1) RUNTIME_ENTRY(Uint32x4ExtractLane, 2, 1) RUNTIME_ENTRY<br>(Uint32x4ReplaceLane, 3, 1) RUNTIME_ENTRY(Uint32x4Add, 2, 1) RUNTIME_ENTRY<br>(Uint32x4Sub, 2, 1) RUNTIME_ENTRY(Uint32x4Mul, 2, 1) RUNTIME_ENTRY<br>(Uint32x4Min, 2, 1) RUNTIME_ENTRY(Uint32x4Max, 2, 1) RUNTIME_ENTRY<br>(Uint32x4And, 2, 1) RUNTIME_ENTRY(Uint32x4Or, 2, 1) RUNTIME_ENTRY<br>(Uint32x4Xor, 2, 1) RUNTIME_ENTRY(Uint32x4Not, 1, 1) RUNTIME_ENTRY<br>(Uint32x4ShiftLeftByScalar, 2, 1) RUNTIME_ENTRY(Uint32x4ShiftRightByScalar<br>, 2, 1) RUNTIME_ENTRY(Uint32x4Equal, 2, 1) RUNTIME_ENTRY(Uint32x4NotEqual<br>, 2, 1) RUNTIME_ENTRY(Uint32x4LessThan, 2, 1) RUNTIME_ENTRY(Uint32x4LessThanOrEqual<br>, 2, 1) RUNTIME_ENTRY(Uint32x4GreaterThan, 2, 1) RUNTIME_ENTRY<br>(Uint32x4GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Uint32x4Select<br>, 3, 1) RUNTIME_ENTRY(Uint32x4Swizzle, 5, 1) RUNTIME_ENTRY(Uint32x4Shuffle<br>, 6, 1) RUNTIME_ENTRY(Uint32x4FromFloat32x4, 1, 1) RUNTIME_ENTRY<br>(Uint32x4FromInt32x4, 1, 1) RUNTIME_ENTRY(Uint32x4FromFloat32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Uint32x4FromInt32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Uint32x4FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Uint32x4FromUint16x8Bits<br>, 1, 1) RUNTIME_ENTRY(Uint32x4FromInt8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Uint32x4FromUint8x16Bits, 1, 1) RUNTIME_ENTRY(Uint32x4Load, 2<br>, 1) RUNTIME_ENTRY(Uint32x4Load1, 2, 1) RUNTIME_ENTRY(Uint32x4Load2<br>, 2, 1) RUNTIME_ENTRY(Uint32x4Load3, 2, 1) RUNTIME_ENTRY(Uint32x4Store<br>, 3, 1) RUNTIME_ENTRY(Uint32x4Store1, 3, 1) RUNTIME_ENTRY(Uint32x4Store2<br>, 3, 1) RUNTIME_ENTRY(Uint32x4Store3, 3, 1) RUNTIME_ENTRY(Bool32x4Check<br>, 1, 1) RUNTIME_ENTRY(Bool32x4ExtractLane, 2, 1) RUNTIME_ENTRY<br>(Bool32x4ReplaceLane, 3, 1) RUNTIME_ENTRY(Bool32x4And, 2, 1) RUNTIME_ENTRY<br>(Bool32x4Or, 2, 1) RUNTIME_ENTRY(Bool32x4Xor, 2, 1) RUNTIME_ENTRY<br>(Bool32x4Not, 1, 1) RUNTIME_ENTRY(Bool32x4AnyTrue, 1, 1) RUNTIME_ENTRY<br>(Bool32x4AllTrue, 1, 1) RUNTIME_ENTRY(Bool32x4Swizzle, 5, 1) RUNTIME_ENTRY<br>(Bool32x4Shuffle, 6, 1) RUNTIME_ENTRY(Bool32x4Equal, 2, 1) RUNTIME_ENTRY<br>(Bool32x4NotEqual, 2, 1) RUNTIME_ENTRY(Int16x8Check, 1, 1) RUNTIME_ENTRY<br>(Int16x8ExtractLane, 2, 1) RUNTIME_ENTRY(Int16x8ReplaceLane, 3<br>, 1) RUNTIME_ENTRY(Int16x8Neg, 1, 1) RUNTIME_ENTRY(Int16x8Add<br>, 2, 1) RUNTIME_ENTRY(Int16x8AddSaturate, 2, 1) RUNTIME_ENTRY<br>(Int16x8Sub, 2, 1) RUNTIME_ENTRY(Int16x8SubSaturate, 2, 1) RUNTIME_ENTRY<br>(Int16x8Mul, 2, 1) RUNTIME_ENTRY(Int16x8Min, 2, 1) RUNTIME_ENTRY<br>(Int16x8Max, 2, 1) RUNTIME_ENTRY(Int16x8And, 2, 1) RUNTIME_ENTRY<br>(Int16x8Or, 2, 1) RUNTIME_ENTRY(Int16x8Xor, 2, 1) RUNTIME_ENTRY<br>(Int16x8Not, 1, 1) RUNTIME_ENTRY(Int16x8ShiftLeftByScalar, 2,<br> 1) RUNTIME_ENTRY(Int16x8ShiftRightByScalar, 2, 1) RUNTIME_ENTRY<br>(Int16x8Equal, 2, 1) RUNTIME_ENTRY(Int16x8NotEqual, 2, 1) RUNTIME_ENTRY<br>(Int16x8LessThan, 2, 1) RUNTIME_ENTRY(Int16x8LessThanOrEqual,<br> 2, 1) RUNTIME_ENTRY(Int16x8GreaterThan, 2, 1) RUNTIME_ENTRY(<br>Int16x8GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Int16x8Select,<br> 3, 1) RUNTIME_ENTRY(Int16x8Swizzle, 9, 1) RUNTIME_ENTRY(Int16x8Shuffle<br>, 10, 1) RUNTIME_ENTRY(Int16x8FromUint16x8, 1, 1) RUNTIME_ENTRY<br>(Int16x8FromFloat32x4Bits, 1, 1) RUNTIME_ENTRY(Int16x8FromInt32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Int16x8FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Int16x8FromUint16x8Bits, 1, 1) RUNTIME_ENTRY(Int16x8FromInt8x16Bits<br>, 1, 1) RUNTIME_ENTRY(Int16x8FromUint8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Int16x8Load, 2, 1) RUNTIME_ENTRY(Int16x8Store, 3, 1) RUNTIME_ENTRY<br>(Uint16x8Check, 1, 1) RUNTIME_ENTRY(Uint16x8ExtractLane, 2, 1<br>) RUNTIME_ENTRY(Uint16x8ReplaceLane, 3, 1) RUNTIME_ENTRY(Uint16x8Add<br>, 2, 1) RUNTIME_ENTRY(Uint16x8AddSaturate, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Sub, 2, 1) RUNTIME_ENTRY(Uint16x8SubSaturate, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Mul, 2, 1) RUNTIME_ENTRY(Uint16x8Min, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Max, 2, 1) RUNTIME_ENTRY(Uint16x8And, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Or, 2, 1) RUNTIME_ENTRY(Uint16x8Xor, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Not, 1, 1) RUNTIME_ENTRY(Uint16x8ShiftLeftByScalar, 2<br>, 1) RUNTIME_ENTRY(Uint16x8ShiftRightByScalar, 2, 1) RUNTIME_ENTRY<br>(Uint16x8Equal, 2, 1) RUNTIME_ENTRY(Uint16x8NotEqual, 2, 1) RUNTIME_ENTRY<br>(Uint16x8LessThan, 2, 1) RUNTIME_ENTRY(Uint16x8LessThanOrEqual<br>, 2, 1) RUNTIME_ENTRY(Uint16x8GreaterThan, 2, 1) RUNTIME_ENTRY<br>(Uint16x8GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Uint16x8Select<br>, 3, 1) RUNTIME_ENTRY(Uint16x8Swizzle, 9, 1) RUNTIME_ENTRY(Uint16x8Shuffle<br>, 10, 1) RUNTIME_ENTRY(Uint16x8FromInt16x8, 1, 1) RUNTIME_ENTRY<br>(Uint16x8FromFloat32x4Bits, 1, 1) RUNTIME_ENTRY(Uint16x8FromInt32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Uint16x8FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Uint16x8FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Uint16x8FromInt8x16Bits<br>, 1, 1) RUNTIME_ENTRY(Uint16x8FromUint8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Uint16x8Load, 2, 1) RUNTIME_ENTRY(Uint16x8Store, 3, 1) RUNTIME_ENTRY<br>(Bool16x8Check, 1, 1) RUNTIME_ENTRY(Bool16x8ExtractLane, 2, 1<br>) RUNTIME_ENTRY(Bool16x8ReplaceLane, 3, 1) RUNTIME_ENTRY(Bool16x8And<br>, 2, 1) RUNTIME_ENTRY(Bool16x8Or, 2, 1) RUNTIME_ENTRY(Bool16x8Xor<br>, 2, 1) RUNTIME_ENTRY(Bool16x8Not, 1, 1) RUNTIME_ENTRY(Bool16x8AnyTrue<br>, 1, 1) RUNTIME_ENTRY(Bool16x8AllTrue, 1, 1) RUNTIME_ENTRY(Bool16x8Swizzle<br>, 9, 1) RUNTIME_ENTRY(Bool16x8Shuffle, 10, 1) RUNTIME_ENTRY(Bool16x8Equal<br>, 2, 1) RUNTIME_ENTRY(Bool16x8NotEqual, 2, 1) RUNTIME_ENTRY(Int8x16Check<br>, 1, 1) RUNTIME_ENTRY(Int8x16ExtractLane, 2, 1) RUNTIME_ENTRY<br>(Int8x16ReplaceLane, 3, 1) RUNTIME_ENTRY(Int8x16Neg, 1, 1) RUNTIME_ENTRY<br>(Int8x16Add, 2, 1) RUNTIME_ENTRY(Int8x16AddSaturate, 2, 1) RUNTIME_ENTRY<br>(Int8x16Sub, 2, 1) RUNTIME_ENTRY(Int8x16SubSaturate, 2, 1) RUNTIME_ENTRY<br>(Int8x16Mul, 2, 1) RUNTIME_ENTRY(Int8x16Min, 2, 1) RUNTIME_ENTRY<br>(Int8x16Max, 2, 1) RUNTIME_ENTRY(Int8x16And, 2, 1) RUNTIME_ENTRY<br>(Int8x16Or, 2, 1) RUNTIME_ENTRY(Int8x16Xor, 2, 1) RUNTIME_ENTRY<br>(Int8x16Not, 1, 1) RUNTIME_ENTRY(Int8x16ShiftLeftByScalar, 2,<br> 1) RUNTIME_ENTRY(Int8x16ShiftRightByScalar, 2, 1) RUNTIME_ENTRY<br>(Int8x16Equal, 2, 1) RUNTIME_ENTRY(Int8x16NotEqual, 2, 1) RUNTIME_ENTRY<br>(Int8x16LessThan, 2, 1) RUNTIME_ENTRY(Int8x16LessThanOrEqual,<br> 2, 1) RUNTIME_ENTRY(Int8x16GreaterThan, 2, 1) RUNTIME_ENTRY(<br>Int8x16GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Int8x16Select,<br> 3, 1) RUNTIME_ENTRY(Int8x16Swizzle, 17, 1) RUNTIME_ENTRY(Int8x16Shuffle<br>, 18, 1) RUNTIME_ENTRY(Int8x16FromUint8x16, 1, 1) RUNTIME_ENTRY<br>(Int8x16FromFloat32x4Bits, 1, 1) RUNTIME_ENTRY(Int8x16FromInt32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Int8x16FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Int8x16FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Int8x16FromUint16x8Bits<br>, 1, 1) RUNTIME_ENTRY(Int8x16FromUint8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Int8x16Load, 2, 1) RUNTIME_ENTRY(Int8x16Store, 3, 1) RUNTIME_ENTRY<br>(Uint8x16Check, 1, 1) RUNTIME_ENTRY(Uint8x16ExtractLane, 2, 1<br>) RUNTIME_ENTRY(Uint8x16ReplaceLane, 3, 1) RUNTIME_ENTRY(Uint8x16Add<br>, 2, 1) RUNTIME_ENTRY(Uint8x16AddSaturate, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Sub, 2, 1) RUNTIME_ENTRY(Uint8x16SubSaturate, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Mul, 2, 1) RUNTIME_ENTRY(Uint8x16Min, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Max, 2, 1) RUNTIME_ENTRY(Uint8x16And, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Or, 2, 1) RUNTIME_ENTRY(Uint8x16Xor, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Not, 1, 1) RUNTIME_ENTRY(Uint8x16ShiftLeftByScalar, 2<br>, 1) RUNTIME_ENTRY(Uint8x16ShiftRightByScalar, 2, 1) RUNTIME_ENTRY<br>(Uint8x16Equal, 2, 1) RUNTIME_ENTRY(Uint8x16NotEqual, 2, 1) RUNTIME_ENTRY<br>(Uint8x16LessThan, 2, 1) RUNTIME_ENTRY(Uint8x16LessThanOrEqual<br>, 2, 1) RUNTIME_ENTRY(Uint8x16GreaterThan, 2, 1) RUNTIME_ENTRY<br>(Uint8x16GreaterThanOrEqual, 2, 1) RUNTIME_ENTRY(Uint8x16Select<br>, 3, 1) RUNTIME_ENTRY(Uint8x16Swizzle, 17, 1) RUNTIME_ENTRY(Uint8x16Shuffle<br>, 18, 1) RUNTIME_ENTRY(Uint8x16FromInt8x16, 1, 1) RUNTIME_ENTRY<br>(Uint8x16FromFloat32x4Bits, 1, 1) RUNTIME_ENTRY(Uint8x16FromInt32x4Bits<br>, 1, 1) RUNTIME_ENTRY(Uint8x16FromUint32x4Bits, 1, 1) RUNTIME_ENTRY<br>(Uint8x16FromInt16x8Bits, 1, 1) RUNTIME_ENTRY(Uint8x16FromUint16x8Bits<br>, 1, 1) RUNTIME_ENTRY(Uint8x16FromInt8x16Bits, 1, 1) RUNTIME_ENTRY<br>(Uint8x16Load, 2, 1) RUNTIME_ENTRY(Uint8x16Store, 3, 1) RUNTIME_ENTRY<br>(Bool8x16Check, 1, 1) RUNTIME_ENTRY(Bool8x16ExtractLane, 2, 1<br>) RUNTIME_ENTRY(Bool8x16ReplaceLane, 3, 1) RUNTIME_ENTRY(Bool8x16And<br>, 2, 1) RUNTIME_ENTRY(Bool8x16Or, 2, 1) RUNTIME_ENTRY(Bool8x16Xor<br>, 2, 1) RUNTIME_ENTRY(Bool8x16Not, 1, 1) RUNTIME_ENTRY(Bool8x16AnyTrue<br>, 1, 1) RUNTIME_ENTRY(Bool8x16AllTrue, 1, 1) RUNTIME_ENTRY(Bool8x16Swizzle<br>, 17, 1) RUNTIME_ENTRY(Bool8x16Shuffle, 18, 1) RUNTIME_ENTRY(<br>Bool8x16Equal, 2, 1) RUNTIME_ENTRY(Bool8x16NotEqual, 2, 1) RUNTIME_ENTRY<br>(StringReplaceOneCharWithString, 3, 1) RUNTIME_ENTRY(StringIndexOf<br>, 3, 1) RUNTIME_ENTRY(StringLastIndexOf, 3, 1) RUNTIME_ENTRY(<br>StringLocaleCompare, 2, 1) RUNTIME_ENTRY(SubString, 3, 1) RUNTIME_ENTRY<br>(StringAdd, 2, 1) RUNTIME_ENTRY(InternalizeString, 1, 1) RUNTIME_ENTRY<br>(StringMatch, 3, 1) RUNTIME_ENTRY(StringCharCodeAtRT, 2, 1) RUNTIME_ENTRY<br>(StringCompare, 2, 1) RUNTIME_ENTRY(StringBuilderConcat, 3, 1<br>) RUNTIME_ENTRY(StringBuilderJoin, 3, 1) RUNTIME_ENTRY(SparseJoinWithSeparator<br>, 3, 1) RUNTIME_ENTRY(StringToArray, 2, 1) RUNTIME_ENTRY(StringToLowerCase<br>, 1, 1) RUNTIME_ENTRY(StringToUpperCase, 1, 1) RUNTIME_ENTRY(<br>StringTrim, 3, 1) RUNTIME_ENTRY(TruncateString, 2, 1) RUNTIME_ENTRY<br>(NewString, 2, 1) RUNTIME_ENTRY(StringEquals, 2, 1) RUNTIME_ENTRY<br>(FlattenString, 1, 1) RUNTIME_ENTRY(StringCharFromCode, 1, 1)<br> RUNTIME_ENTRY(StringCharAt, 2, 1) RUNTIME_ENTRY(OneByteSeqStringGetChar<br>, 2, 1) RUNTIME_ENTRY(OneByteSeqStringSetChar, 3, 1) RUNTIME_ENTRY<br>(TwoByteSeqStringGetChar, 2, 1) RUNTIME_ENTRY(TwoByteSeqStringSetChar<br>, 3, 1) RUNTIME_ENTRY(StringCharCodeAt, 2, 1) RUNTIME_ENTRY(CreateSymbol<br>, 1, 1) RUNTIME_ENTRY(CreatePrivateSymbol, 1, 1) RUNTIME_ENTRY<br>(SymbolDescription, 1, 1) RUNTIME_ENTRY(SymbolDescriptiveString<br>, 1, 1) RUNTIME_ENTRY(SymbolRegistry, 0, 1) RUNTIME_ENTRY(SymbolIsPrivate<br>, 1, 1) RUNTIME_ENTRY(DeoptimizeFunction, 1, 1) RUNTIME_ENTRY<br>(DeoptimizeNow, 0, 1) RUNTIME_ENTRY(RunningInSimulator, 0, 1)<br> RUNTIME_ENTRY(IsConcurrentRecompilationSupported, 0, 1) RUNTIME_ENTRY<br>(OptimizeFunctionOnNextCall, -1, 1) RUNTIME_ENTRY(OptimizeOsr<br>, -1, 1) RUNTIME_ENTRY(NeverOptimizeFunction, 1, 1) RUNTIME_ENTRY<br>(GetOptimizationStatus, -1, 1) RUNTIME_ENTRY(UnblockConcurrentRecompilation<br>, 0, 1) RUNTIME_ENTRY(GetOptimizationCount, 1, 1) RUNTIME_ENTRY<br>(GetUndetectable, 0, 1) RUNTIME_ENTRY(ClearFunctionTypeFeedback<br>, 1, 1) RUNTIME_ENTRY(NotifyContextDisposed, 0, 1) RUNTIME_ENTRY<br>(SetAllocationTimeout, -1 , 1) RUNTIME_ENTRY(DebugPrint, 1, 1<br>) RUNTIME_ENTRY(DebugTrace, 0, 1) RUNTIME_ENTRY(GlobalPrint, 1<br>, 1) RUNTIME_ENTRY(SystemBreak, 0, 1) RUNTIME_ENTRY(SetFlags,<br> 1, 1) RUNTIME_ENTRY(Abort, 1, 1) RUNTIME_ENTRY(AbortJS, 1, 1<br>) RUNTIME_ENTRY(NativeScriptsCount, 0, 1) RUNTIME_ENTRY(GetV8Version<br>, 0, 1) RUNTIME_ENTRY(DisassembleFunction, 1, 1) RUNTIME_ENTRY<br>(TraceEnter, 0, 1) RUNTIME_ENTRY(TraceExit, 1, 1) RUNTIME_ENTRY<br>(TraceTailCall, 0, 1) RUNTIME_ENTRY(HaveSameMap, 2, 1) RUNTIME_ENTRY<br>(InNewSpace, 1, 1) RUNTIME_ENTRY(HasFastSmiElements, 1, 1) RUNTIME_ENTRY<br>(HasFastObjectElements, 1, 1) RUNTIME_ENTRY(HasFastSmiOrObjectElements<br>, 1, 1) RUNTIME_ENTRY(HasFastDoubleElements, 1, 1) RUNTIME_ENTRY<br>(HasFastHoleyElements, 1, 1) RUNTIME_ENTRY(HasDictionaryElements<br>, 1, 1) RUNTIME_ENTRY(HasSloppyArgumentsElements, 1, 1) RUNTIME_ENTRY<br>(HasFixedTypedArrayElements, 1, 1) RUNTIME_ENTRY(HasFastProperties<br>, 1, 1) RUNTIME_ENTRY(HasFixedUint8Elements, 1, 1) RUNTIME_ENTRY<br>(HasFixedInt8Elements, 1, 1) RUNTIME_ENTRY(HasFixedUint16Elements<br>, 1, 1) RUNTIME_ENTRY(HasFixedInt16Elements, 1, 1) RUNTIME_ENTRY<br>(HasFixedUint32Elements, 1, 1) RUNTIME_ENTRY(HasFixedInt32Elements<br>, 1, 1) RUNTIME_ENTRY(HasFixedFloat32Elements, 1, 1) RUNTIME_ENTRY<br>(HasFixedFloat64Elements, 1, 1) RUNTIME_ENTRY(HasFixedUint8ClampedElements<br>, 1, 1) RUNTIME_ENTRY(ArrayBufferGetByteLength, 1, 1) RUNTIME_ENTRY<br>(ArrayBufferSliceImpl, 4, 1) RUNTIME_ENTRY(ArrayBufferNeuter,<br> 1, 1) RUNTIME_ENTRY(TypedArrayInitialize, 6, 1) RUNTIME_ENTRY<br>(TypedArrayInitializeFromArrayLike, 4, 1) RUNTIME_ENTRY(ArrayBufferViewGetByteLength<br>, 1, 1) RUNTIME_ENTRY(ArrayBufferViewGetByteOffset, 1, 1) RUNTIME_ENTRY<br>(TypedArrayGetLength, 1, 1) RUNTIME_ENTRY(DataViewGetBuffer, 1<br>, 1) RUNTIME_ENTRY(TypedArrayGetBuffer, 1, 1) RUNTIME_ENTRY(TypedArraySetFastCases<br>, 3, 1) RUNTIME_ENTRY(TypedArrayMaxSizeInHeap, 0, 1) RUNTIME_ENTRY<br>(IsTypedArray, 1, 1) RUNTIME_ENTRY(IsSharedTypedArray, 1, 1) RUNTIME_ENTRY<br>(IsSharedIntegerTypedArray, 1, 1) RUNTIME_ENTRY(IsSharedInteger32TypedArray<br>, 1, 1) RUNTIME_ENTRY(DataViewGetUint8, 3, 1) RUNTIME_ENTRY(DataViewGetInt8<br>, 3, 1) RUNTIME_ENTRY(DataViewGetUint16, 3, 1) RUNTIME_ENTRY(<br>DataViewGetInt16, 3, 1) RUNTIME_ENTRY(DataViewGetUint32, 3, 1<br>) RUNTIME_ENTRY(DataViewGetInt32, 3, 1) RUNTIME_ENTRY(DataViewGetFloat32<br>, 3, 1) RUNTIME_ENTRY(DataViewGetFloat64, 3, 1) RUNTIME_ENTRY<br>(DataViewSetUint8, 4, 1) RUNTIME_ENTRY(DataViewSetInt8, 4, 1)<br> RUNTIME_ENTRY(DataViewSetUint16, 4, 1) RUNTIME_ENTRY(DataViewSetInt16<br>, 4, 1) RUNTIME_ENTRY(DataViewSetUint32, 4, 1) RUNTIME_ENTRY(<br>DataViewSetInt32, 4, 1) RUNTIME_ENTRY(DataViewSetFloat32, 4, 1<br>) RUNTIME_ENTRY(DataViewSetFloat64, 4, 1) RUNTIME_ENTRY(URIEscape<br>, 1, 1) RUNTIME_ENTRY(URIUnescape, 1, 1)</span></span></td></tr>
<tr><td class="num" id="LN231">231</td><td class="line"><span class='directive'>#undef RUNTIME_ENTRY</span></td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line"> </td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='macro'>arraysize(runtime_functions)<span class='expansion'>(sizeof(ArraySizeHelper(runtime_functions)))</span></span>; ++i) {</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">    ExternalReference ref(</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">        <span class='keyword'>static_cast</span>&lt;Runtime::FunctionId&gt;(runtime_functions[i].id), isolate);</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">    Add(ref.address(), runtime_functions[i].name);</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line"> </td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">  <span class='comment'>// Stat counters</span></td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">  <span class='keyword'>struct</span> StatsRefTableEntry {</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">    StatsCounter* (Counters::*counter)();</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* name;</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line"> </td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> StatsRefTableEntry stats_ref_table[] = {</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line"><span class='directive'>#define COUNTER_ENTRY(name, caption)      \</span></td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">  <span class='directive'>{ &amp;Counters::name, "Counters::" #name } \</span></td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">      <span class='macro'>STATS_COUNTER_LIST_1(COUNTER_ENTRY)<span class='expansion'>COUNTER_ENTRY(global_handles, V8.GlobalHandles) COUNTER_ENTRY<br>(memory_allocated, V8.OsMemoryAllocated) COUNTER_ENTRY(maps_normalized<br>, V8.MapsNormalized) COUNTER_ENTRY(maps_created, V8.MapsCreated<br>) COUNTER_ENTRY(elements_transitions, V8.ObjectElementsTransitions<br>) COUNTER_ENTRY(props_to_dictionary, V8.ObjectPropertiesToDictionary<br>) COUNTER_ENTRY(elements_to_dictionary, V8.ObjectElementsToDictionary<br>) COUNTER_ENTRY(alive_after_last_gc, V8.AliveAfterLastGC) COUNTER_ENTRY<br>(objs_since_last_young, V8.ObjsSinceLastYoung) COUNTER_ENTRY(<br>objs_since_last_full, V8.ObjsSinceLastFull) COUNTER_ENTRY(string_table_capacity<br>, V8.StringTableCapacity) COUNTER_ENTRY(number_of_symbols, V8<br>.NumberOfSymbols) COUNTER_ENTRY(script_wrappers, V8.ScriptWrappers<br>) COUNTER_ENTRY(inlined_copied_elements, V8.InlinedCopiedElements<br>) COUNTER_ENTRY(arguments_adaptors, V8.ArgumentsAdaptors) COUNTER_ENTRY<br>(compilation_cache_hits, V8.CompilationCacheHits) COUNTER_ENTRY<br>(compilation_cache_misses, V8.CompilationCacheMisses) COUNTER_ENTRY<br>(total_eval_size, V8.TotalEvalSize) COUNTER_ENTRY(total_load_size<br>, V8.TotalLoadSize) COUNTER_ENTRY(total_parse_size, V8.TotalParseSize<br>) COUNTER_ENTRY(total_preparse_skipped, V8.TotalPreparseSkipped<br>) COUNTER_ENTRY(total_compile_size, V8.TotalCompileSize) COUNTER_ENTRY<br>(total_full_codegen_source_size, V8.TotalFullCodegenSourceSize<br>) COUNTER_ENTRY(contexts_created_from_scratch, V8.ContextsCreatedFromScratch<br>) COUNTER_ENTRY(contexts_created_by_snapshot, V8.ContextsCreatedBySnapshot<br>) COUNTER_ENTRY(pc_to_code, V8.PcToCode) COUNTER_ENTRY(pc_to_code_cached<br>, V8.PcToCodeCached) COUNTER_ENTRY(store_buffer_overflows, V8<br>.StoreBufferOverflows)</span></span> <span class='macro'>STATS_COUNTER_LIST_2(COUNTER_ENTRY)<span class='expansion'>COUNTER_ENTRY(code_stubs, V8.CodeStubs) COUNTER_ENTRY(total_stubs_code_size<br>, V8.TotalStubsCodeSize) COUNTER_ENTRY(total_compiled_code_size<br>, V8.TotalCompiledCodeSize) COUNTER_ENTRY(gc_compactor_caused_by_request<br>, V8.GCCompactorCausedByRequest) COUNTER_ENTRY(gc_compactor_caused_by_promoted_data<br>, V8.GCCompactorCausedByPromotedData) COUNTER_ENTRY(gc_compactor_caused_by_oldspace_exhaustion<br>, V8.GCCompactorCausedByOldspaceExhaustion) COUNTER_ENTRY(gc_last_resort_from_js<br>, V8.GCLastResortFromJS) COUNTER_ENTRY(gc_last_resort_from_handles<br>, V8.GCLastResortFromHandles) COUNTER_ENTRY(ic_keyed_load_generic_smi<br>, V8.ICKeyedLoadGenericSmi) COUNTER_ENTRY(ic_keyed_load_generic_symbol<br>, V8.ICKeyedLoadGenericSymbol) COUNTER_ENTRY(ic_keyed_load_generic_slow<br>, V8.ICKeyedLoadGenericSlow) COUNTER_ENTRY(ic_named_load_global_stub<br>, V8.ICNamedLoadGlobalStub) COUNTER_ENTRY(ic_store_normal_miss<br>, V8.ICStoreNormalMiss) COUNTER_ENTRY(ic_store_normal_hit, V8<br>.ICStoreNormalHit) COUNTER_ENTRY(ic_binary_op_miss, V8.ICBinaryOpMiss<br>) COUNTER_ENTRY(ic_compare_miss, V8.ICCompareMiss) COUNTER_ENTRY<br>(ic_call_miss, V8.ICCallMiss) COUNTER_ENTRY(ic_keyed_call_miss<br>, V8.ICKeyedCallMiss) COUNTER_ENTRY(ic_load_miss, V8.ICLoadMiss<br>) COUNTER_ENTRY(ic_keyed_load_miss, V8.ICKeyedLoadMiss) COUNTER_ENTRY<br>(ic_store_miss, V8.ICStoreMiss) COUNTER_ENTRY(ic_keyed_store_miss<br>, V8.ICKeyedStoreMiss) COUNTER_ENTRY(cow_arrays_created_runtime<br>, V8.COWArraysCreatedRuntime) COUNTER_ENTRY(cow_arrays_converted<br>, V8.COWArraysConverted) COUNTER_ENTRY(constructed_objects, V8<br>.ConstructedObjects) COUNTER_ENTRY(constructed_objects_runtime<br>, V8.ConstructedObjectsRuntime) COUNTER_ENTRY(negative_lookups<br>, V8.NegativeLookups) COUNTER_ENTRY(negative_lookups_miss, V8<br>.NegativeLookupsMiss) COUNTER_ENTRY(megamorphic_stub_cache_probes<br>, V8.MegamorphicStubCacheProbes) COUNTER_ENTRY(megamorphic_stub_cache_misses<br>, V8.MegamorphicStubCacheMisses) COUNTER_ENTRY(megamorphic_stub_cache_updates<br>, V8.MegamorphicStubCacheUpdates) COUNTER_ENTRY(enum_cache_hits<br>, V8.EnumCacheHits) COUNTER_ENTRY(enum_cache_misses, V8.EnumCacheMisses<br>) COUNTER_ENTRY(fast_new_closure_total, V8.FastNewClosureTotal<br>) COUNTER_ENTRY(fast_new_closure_try_optimized, V8.FastNewClosureTryOptimized<br>) COUNTER_ENTRY(fast_new_closure_install_optimized, V8.FastNewClosureInstallOptimized<br>) COUNTER_ENTRY(string_add_runtime, V8.StringAddRuntime) COUNTER_ENTRY<br>(string_add_native, V8.StringAddNative) COUNTER_ENTRY(string_add_runtime_ext_to_one_byte<br>, V8.StringAddRuntimeExtToOneByte) COUNTER_ENTRY(sub_string_runtime<br>, V8.SubStringRuntime) COUNTER_ENTRY(sub_string_native, V8.SubStringNative<br>) COUNTER_ENTRY(string_compare_native, V8.StringCompareNative<br>) COUNTER_ENTRY(string_compare_runtime, V8.StringCompareRuntime<br>) COUNTER_ENTRY(regexp_entry_runtime, V8.RegExpEntryRuntime) COUNTER_ENTRY<br>(regexp_entry_native, V8.RegExpEntryNative) COUNTER_ENTRY(number_to_string_native<br>, V8.NumberToStringNative) COUNTER_ENTRY(number_to_string_runtime<br>, V8.NumberToStringRuntime) COUNTER_ENTRY(math_acos_runtime, V8<br>.MathAcosRuntime) COUNTER_ENTRY(math_asin_runtime, V8.MathAsinRuntime<br>) COUNTER_ENTRY(math_atan_runtime, V8.MathAtanRuntime) COUNTER_ENTRY<br>(math_atan2_runtime, V8.MathAtan2Runtime) COUNTER_ENTRY(math_clz32_runtime<br>, V8.MathClz32Runtime) COUNTER_ENTRY(math_exp_runtime, V8.MathExpRuntime<br>) COUNTER_ENTRY(math_floor_runtime, V8.MathFloorRuntime) COUNTER_ENTRY<br>(math_log_runtime, V8.MathLogRuntime) COUNTER_ENTRY(math_pow_runtime<br>, V8.MathPowRuntime) COUNTER_ENTRY(math_round_runtime, V8.MathRoundRuntime<br>) COUNTER_ENTRY(math_sqrt_runtime, V8.MathSqrtRuntime) COUNTER_ENTRY<br>(stack_interrupts, V8.StackInterrupts) COUNTER_ENTRY(runtime_profiler_ticks<br>, V8.RuntimeProfilerTicks) COUNTER_ENTRY(runtime_calls, V8.RuntimeCalls<br>) COUNTER_ENTRY(bounds_checks_eliminated, V8.BoundsChecksEliminated<br>) COUNTER_ENTRY(bounds_checks_hoisted, V8.BoundsChecksHoisted<br>) COUNTER_ENTRY(soft_deopts_requested, V8.SoftDeoptsRequested<br>) COUNTER_ENTRY(soft_deopts_inserted, V8.SoftDeoptsInserted) COUNTER_ENTRY<br>(soft_deopts_executed, V8.SoftDeoptsExecuted) COUNTER_ENTRY(write_barriers_dynamic<br>, V8.WriteBarriersDynamic) COUNTER_ENTRY(write_barriers_static<br>, V8.WriteBarriersStatic) COUNTER_ENTRY(new_space_bytes_available<br>, V8.MemoryNewSpaceBytesAvailable) COUNTER_ENTRY(new_space_bytes_committed<br>, V8.MemoryNewSpaceBytesCommitted) COUNTER_ENTRY(new_space_bytes_used<br>, V8.MemoryNewSpaceBytesUsed) COUNTER_ENTRY(old_space_bytes_available<br>, V8.MemoryOldSpaceBytesAvailable) COUNTER_ENTRY(old_space_bytes_committed<br>, V8.MemoryOldSpaceBytesCommitted) COUNTER_ENTRY(old_space_bytes_used<br>, V8.MemoryOldSpaceBytesUsed) COUNTER_ENTRY(code_space_bytes_available<br>, V8.MemoryCodeSpaceBytesAvailable) COUNTER_ENTRY(code_space_bytes_committed<br>, V8.MemoryCodeSpaceBytesCommitted) COUNTER_ENTRY(code_space_bytes_used<br>, V8.MemoryCodeSpaceBytesUsed) COUNTER_ENTRY(map_space_bytes_available<br>, V8.MemoryMapSpaceBytesAvailable) COUNTER_ENTRY(map_space_bytes_committed<br>, V8.MemoryMapSpaceBytesCommitted) COUNTER_ENTRY(map_space_bytes_used<br>, V8.MemoryMapSpaceBytesUsed) COUNTER_ENTRY(lo_space_bytes_available<br>, V8.MemoryLoSpaceBytesAvailable) COUNTER_ENTRY(lo_space_bytes_committed<br>, V8.MemoryLoSpaceBytesCommitted) COUNTER_ENTRY(lo_space_bytes_used<br>, V8.MemoryLoSpaceBytesUsed) COUNTER_ENTRY(turbo_escape_allocs_replaced<br>, V8.TurboEscapeAllocsReplaced) COUNTER_ENTRY(crankshaft_escape_allocs_replaced<br>, V8.CrankshaftEscapeAllocsReplaced) COUNTER_ENTRY(turbo_escape_loads_replaced<br>, V8.TurboEscapeLoadsReplaced) COUNTER_ENTRY(crankshaft_escape_loads_replaced<br>, V8.CrankshaftEscapeLoadsReplaced) COUNTER_ENTRY(total_baseline_code_size<br>, V8.TotalBaselineCodeSize) COUNTER_ENTRY(total_baseline_compile_count<br>, V8.TotalBaselineCompileCount)</span></span></td></tr>
<tr><td class="num" id="LN251">251</td><td class="line"><span class='directive'>#undef COUNTER_ENTRY</span></td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">  Counters* counters = isolate-&gt;counters();</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='macro'>arraysize(stats_ref_table)<span class='expansion'>(sizeof(ArraySizeHelper(stats_ref_table)))</span></span>; ++i) {</td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">    <span class='comment'>// To make sure the indices are not dependent on whether counters are</span></td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">    <span class='comment'>// enabled, use a dummy address as filler.</span></td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">    Address address = NotAvailable();</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">    StatsCounter* counter = (counters-&gt;*(stats_ref_table[i].counter))();</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">    <span class='keyword'>if</span> (counter-&gt;Enabled()) {</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">      address = <span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(counter-&gt;GetInternalPointer());</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN263">263</td><td class="line">    Add(address, stats_ref_table[i].name);</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line"> </td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">  <span class='comment'>// Top addresses</span></td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span>* address_names[] = {</td></tr>
<tr><td class="num" id="LN268">268</td><td class="line"><span class='directive'>#define BUILD_NAME_LITERAL(Name, name) "Isolate::" #name "_address",</span></td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">      <span class='macro'>FOR_EACH_ISOLATE_ADDRESS_NAME(BUILD_NAME_LITERAL)<span class='expansion'>BUILD_NAME_LITERAL(Handler, handler) BUILD_NAME_LITERAL(CEntryFP<br>, c_entry_fp) BUILD_NAME_LITERAL(CFunction, c_function) BUILD_NAME_LITERAL<br>(Context, context) BUILD_NAME_LITERAL(PendingException, pending_exception<br>) BUILD_NAME_LITERAL(PendingHandlerContext, pending_handler_context<br>) BUILD_NAME_LITERAL(PendingHandlerCode, pending_handler_code<br>) BUILD_NAME_LITERAL(PendingHandlerOffset, pending_handler_offset<br>) BUILD_NAME_LITERAL(PendingHandlerFP, pending_handler_fp) BUILD_NAME_LITERAL<br>(PendingHandlerSP, pending_handler_sp) BUILD_NAME_LITERAL(ExternalCaughtException<br>, external_caught_exception) BUILD_NAME_LITERAL(JSEntrySP, js_entry_sp<br>)</span></span> <span class='macro'>NULL<span class='expansion'>__null</span></span></td></tr>
<tr><td class="num" id="LN270">270</td><td class="line"><span class='directive'>#undef BUILD_NAME_LITERAL</span></td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN273">273</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; Isolate::kIsolateAddressCount; ++i) {</td></tr>
<tr><td class="num" id="LN274">274</td><td class="line">    Add(isolate-&gt;get_address_from_id(<span class='keyword'>static_cast</span>&lt;Isolate::AddressId&gt;(i)),</td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">        address_names[i]);</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line"> </td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">  <span class='comment'>// Accessors</span></td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">  <span class='keyword'>struct</span> AccessorRefTable {</td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">    Address address;</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* name;</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN284">284</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> AccessorRefTable accessors[] = {</td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"><span class='directive'>#define ACCESSOR_INFO_DECLARATION(name)                                     \</span></td></tr>
<tr><td class="num" id="LN286">286</td><td class="line">  <span class='directive'>{ <span class='macro'>FUNCTION_ADDR(&amp;Accessors::name##Getter)<span class='expansion'>(reinterpret_cast&lt;v8::internal::Address&gt;(reinterpret_cast<br>&lt;intptr_t&gt;(&amp;Accessors::name##Getter)))</span></span>, "Accessors::" #name "Getter" } \</span></td></tr>
<tr><td class="num" id="LN287">287</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">      <span class='macro'>ACCESSOR_INFO_LIST(ACCESSOR_INFO_DECLARATION)<span class='expansion'>ACCESSOR_INFO_DECLARATION(ArgumentsIterator) ACCESSOR_INFO_DECLARATION<br>(ArrayLength) ACCESSOR_INFO_DECLARATION(FunctionArguments) ACCESSOR_INFO_DECLARATION<br>(FunctionCaller) ACCESSOR_INFO_DECLARATION(FunctionName) ACCESSOR_INFO_DECLARATION<br>(FunctionLength) ACCESSOR_INFO_DECLARATION(FunctionPrototype)<br> ACCESSOR_INFO_DECLARATION(ScriptColumnOffset) ACCESSOR_INFO_DECLARATION<br>(ScriptCompilationType) ACCESSOR_INFO_DECLARATION(ScriptContextData<br>) ACCESSOR_INFO_DECLARATION(ScriptEvalFromScript) ACCESSOR_INFO_DECLARATION<br>(ScriptEvalFromScriptPosition) ACCESSOR_INFO_DECLARATION(ScriptEvalFromFunctionName<br>) ACCESSOR_INFO_DECLARATION(ScriptId) ACCESSOR_INFO_DECLARATION<br>(ScriptLineEnds) ACCESSOR_INFO_DECLARATION(ScriptLineOffset) ACCESSOR_INFO_DECLARATION<br>(ScriptName) ACCESSOR_INFO_DECLARATION(ScriptSource) ACCESSOR_INFO_DECLARATION<br>(ScriptType) ACCESSOR_INFO_DECLARATION(ScriptSourceUrl) ACCESSOR_INFO_DECLARATION<br>(ScriptSourceMappingUrl) ACCESSOR_INFO_DECLARATION(ScriptIsEmbedderDebugScript<br>) ACCESSOR_INFO_DECLARATION(StringLength)</span></span></td></tr>
<tr><td class="num" id="LN289">289</td><td class="line"><span class='directive'>#undef ACCESSOR_INFO_DECLARATION</span></td></tr>
<tr><td class="num" id="LN290">290</td><td class="line"><span class='directive'>#define <span class='macro'>ACCESSOR_SETTER_DECLARATION(name)<span class='expansion'>{ (reinterpret_cast&lt;v8::internal::Address&gt;(reinterpret_cast<br>&lt;intptr_t&gt;(&amp;Accessors::name))), "Accessors::" "name"<br> } ,</span></span>                  \</span></td></tr>
<tr><td class="num" id="LN291">291</td><td class="line">  <span class='directive'>{ <span class='macro'>FUNCTION_ADDR(&amp;Accessors::name)<span class='expansion'>(reinterpret_cast&lt;v8::internal::Address&gt;(reinterpret_cast<br>&lt;intptr_t&gt;(&amp;Accessors::name)))</span></span>, "Accessors::" #name } \</span></td></tr>
<tr><td class="num" id="LN292">292</td><td class="line">  <span class='directive'>,</span></td></tr>
<tr><td class="num" id="LN293">293</td><td class="line">          <span class='macro'>ACCESSOR_SETTER_LIST(ACCESSOR_SETTER_DECLARATION)<span class='expansion'>{ (reinterpret_cast&lt;v8::internal::Address&gt;(reinterpret_cast<br>&lt;intptr_t&gt;(&amp;Accessors::ReconfigureToDataProperty)))<br>, "Accessors::" "ReconfigureToDataProperty" } , { (reinterpret_cast<br>&lt;v8::internal::Address&gt;(reinterpret_cast&lt;intptr_t&gt;<br>(&amp;Accessors::ObservedReconfigureToDataProperty))), "Accessors::"<br> "ObservedReconfigureToDataProperty" } , { (reinterpret_cast&lt;<br>v8::internal::Address&gt;(reinterpret_cast&lt;intptr_t&gt;(&amp;<br>Accessors::ArrayLengthSetter))), "Accessors::" "ArrayLengthSetter"<br> } , { (reinterpret_cast&lt;v8::internal::Address&gt;(reinterpret_cast<br>&lt;intptr_t&gt;(&amp;Accessors::FunctionPrototypeSetter))), "Accessors::"<br> "FunctionPrototypeSetter" } ,</span></span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line"><span class='directive'>#undef ACCESSOR_INFO_DECLARATION</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN296">296</td><td class="line"> </td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='macro'>arraysize(accessors)<span class='expansion'>(sizeof(ArraySizeHelper(accessors)))</span></span>; ++i) {</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">    Add(accessors[i].address, accessors[i].name);</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line"> </td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">  StubCache* stub_cache = isolate-&gt;stub_cache();</td></tr>
<tr><td class="num" id="LN302">302</td><td class="line"> </td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">  <span class='comment'>// Stub cache tables</span></td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">  Add(stub_cache-&gt;key_reference(StubCache::kPrimary).address(),</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">      <span class='string_literal'>"StubCache::primary_-&gt;key"</span>);</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">  Add(stub_cache-&gt;value_reference(StubCache::kPrimary).address(),</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">      <span class='string_literal'>"StubCache::primary_-&gt;value"</span>);</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line">  Add(stub_cache-&gt;map_reference(StubCache::kPrimary).address(),</td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">      <span class='string_literal'>"StubCache::primary_-&gt;map"</span>);</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">  Add(stub_cache-&gt;key_reference(StubCache::kSecondary).address(),</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">      <span class='string_literal'>"StubCache::secondary_-&gt;key"</span>);</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">  Add(stub_cache-&gt;value_reference(StubCache::kSecondary).address(),</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">      <span class='string_literal'>"StubCache::secondary_-&gt;value"</span>);</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">  Add(stub_cache-&gt;map_reference(StubCache::kSecondary).address(),</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">      <span class='string_literal'>"StubCache::secondary_-&gt;map"</span>);</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line"> </td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">  <span class='comment'>// Runtime entries</span></td></tr>
<tr><td class="num" id="LN318">318</td><td class="line">  Add(ExternalReference::delete_handle_scope_extensions(isolate).address(),</td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">      <span class='string_literal'>"HandleScope::DeleteExtensions"</span>);</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">  Add(ExternalReference::incremental_marking_record_write_function(isolate)</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">          .address(),</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">      <span class='string_literal'>"IncrementalMarking::RecordWrite"</span>);</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">  Add(ExternalReference::incremental_marking_record_write_code_entry_function(</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">          isolate)</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">          .address(),</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">      <span class='string_literal'>"IncrementalMarking::RecordWriteOfCodeEntryFromCode"</span>);</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">  Add(ExternalReference::store_buffer_overflow_function(isolate).address(),</td></tr>
<tr><td class="num" id="LN328">328</td><td class="line">      <span class='string_literal'>"StoreBuffer::StoreBufferOverflow"</span>);</td></tr>
<tr><td class="num" id="LN329">329</td><td class="line"> </td></tr>
<tr><td class="num" id="LN330">330</td><td class="line">  <span class='comment'>// Add a small set of deopt entry addresses to encoder without generating the</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line">  <span class='comment'>// deopt table code, which isn't possible at deserialization time.</span></td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">  HandleScope scope(isolate);</td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> entry = 0; entry &lt; kDeoptTableSerializeEntryCount; ++entry) {</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">    Address address = Deoptimizer::GetDeoptimizationEntry(</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">        isolate,</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">        entry,</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">        Deoptimizer::LAZY,</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">        Deoptimizer::CALCULATE_ENTRY_ADDRESS);</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line">    Add(address, <span class='string_literal'>"lazy_deopt"</span>);</td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">}</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line"> </td></tr>
<tr><td class="num" id="LN343">343</td><td class="line"> </td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">ExternalReferenceEncoder::ExternalReferenceEncoder(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">  map_ = isolate-&gt;external_reference_map();</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">  <span class='keyword'>if</span> (map_ != <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">  map_ = <span class='keyword'>new</span> HashMap(HashMap::PointersMatch);</td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">  ExternalReferenceTable* table = ExternalReferenceTable::instance(isolate);</td></tr>
<tr><td class="num" id="LN349">349</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; table-&gt;size(); ++i) {</td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">    Address addr = table-&gt;address(i);</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">    <span class='keyword'>if</span> (addr == ExternalReferenceTable::NotAvailable()) <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN352">352</td><td class="line">    <span class='comment'>// We expect no duplicate external references entries in the table.</span></td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">    <span class='macro'>DCHECK_NULL(map_-&gt;Lookup(addr, Hash(addr)))<span class='expansion'>do { if ((__builtin_expect(!!(!((map_-&gt;Lookup(addr, Hash(addr<br>))) == nullptr)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 353, "Check failed: %s.", "(map_-&gt;Lookup(addr, Hash(addr))) == nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">    map_-&gt;LookupOrInsert(addr, Hash(addr))-&gt;value = <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>void</span>*&gt;(i);</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">  isolate-&gt;set_external_reference_map(map_);</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">}</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line"> </td></tr>
<tr><td class="num" id="LN359">359</td><td class="line"> </td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">uint32_t ExternalReferenceEncoder::Encode(Address address) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">  <span class='macro'>DCHECK_NOT_NULL(address)<span class='expansion'>do { if ((__builtin_expect(!!(!((address) != nullptr)), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 361, "Check failed: %s."<br>, "(address) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">  HashMap::Entry* entry =</td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">      <span class='keyword'>const_cast</span>&lt;HashMap*&gt;(map_)-&gt;Lookup(address, Hash(address));</td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">  <span class='macro'>DCHECK_NOT_NULL(entry)<span class='expansion'>do { if ((__builtin_expect(!!(!((entry) != nullptr)), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 364, "Check failed: %s.", "(entry) != nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(<span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(entry-&gt;value));</td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">}</td></tr>
<tr><td class="num" id="LN367">367</td><td class="line"> </td></tr>
<tr><td class="num" id="LN368">368</td><td class="line"> </td></tr>
<tr><td class="num" id="LN369">369</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>char</span>* ExternalReferenceEncoder::NameOfAddress(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">                                                    Address address) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">  HashMap::Entry* entry =</td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">      <span class='keyword'>const_cast</span>&lt;HashMap*&gt;(map_)-&gt;Lookup(address, Hash(address));</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">  <span class='keyword'>if</span> (entry == <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>return</span> <span class='string_literal'>"&lt;unknown&gt;"</span>;</td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">  uint32_t i = <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(<span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(entry-&gt;value));</td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">  <span class='keyword'>return</span> ExternalReferenceTable::instance(isolate)-&gt;name(i);</td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">}</td></tr>
<tr><td class="num" id="LN377">377</td><td class="line"> </td></tr>
<tr><td class="num" id="LN378">378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN379">379</td><td class="line"><span class='keyword'>class</span> CodeAddressMap: <span class='keyword'>public</span> CodeEventLogger {</td></tr>
<tr><td class="num" id="LN380">380</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">  <span class='keyword'>explicit</span> CodeAddressMap(Isolate* isolate)</td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">      : isolate_(isolate) {</td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">    isolate-&gt;logger()-&gt;addCodeEventListener(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">  ~CodeAddressMap() override {</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">    isolate_-&gt;logger()-&gt;removeCodeEventListener(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line"> </td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">  <span class='keyword'>void</span> CodeMoveEvent(Address from, Address to) override {</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">    address_to_name_map_.Move(from, to);</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line"> </td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">  <span class='keyword'>void</span> CodeDisableOptEvent(Code* code, SharedFunctionInfo* shared) override {}</td></tr>
<tr><td class="num" id="LN395">395</td><td class="line"> </td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">  <span class='keyword'>void</span> CodeDeleteEvent(Address from) override {</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">    address_to_name_map_.Remove(from);</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN399">399</td><td class="line"> </td></tr>
<tr><td class="num" id="LN400">400</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span>* Lookup(Address address) {</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">    <span class='keyword'>return</span> address_to_name_map_.Lookup(address);</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN403">403</td><td class="line"> </td></tr>
<tr><td class="num" id="LN404">404</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">  <span class='keyword'>class</span> NameMap {</td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">   <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">    NameMap() : impl_(HashMap::PointersMatch) {}</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line"> </td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    ~NameMap() {</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">      <span class='keyword'>for</span> (HashMap::Entry* p = impl_.Start(); p != <span class='macro'>NULL<span class='expansion'>__null</span></span>; p = impl_.Next(p)) {</td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">        DeleteArray(<span class='keyword'>static_cast</span>&lt;<span class='keyword'>const</span> <span class='keyword'>char</span>*&gt;(p-&gt;value));</td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN414">414</td><td class="line"> </td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">    <span class='keyword'>void</span> Insert(Address code_address, <span class='keyword'>const</span> <span class='keyword'>char</span>* name, <span class='keyword'>int</span> name_size) {</td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">      HashMap::Entry* entry = FindOrCreateEntry(code_address);</td></tr>
<tr><td class="num" id="LN417">417</td><td class="line">      <span class='keyword'>if</span> (entry-&gt;value == <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">        entry-&gt;value = CopyName(name, name_size);</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line"> </td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* Lookup(Address code_address) {</td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">      HashMap::Entry* entry = FindEntry(code_address);</td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">      <span class='keyword'>return</span> (entry != <span class='macro'>NULL<span class='expansion'>__null</span></span>) ? <span class='keyword'>static_cast</span>&lt;<span class='keyword'>const</span> <span class='keyword'>char</span>*&gt;(entry-&gt;value) : <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN426">426</td><td class="line"> </td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">    <span class='keyword'>void</span> Remove(Address code_address) {</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">      HashMap::Entry* entry = FindEntry(code_address);</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">      <span class='keyword'>if</span> (entry != <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">        DeleteArray(<span class='keyword'>static_cast</span>&lt;<span class='keyword'>char</span>*&gt;(entry-&gt;value));</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">        RemoveEntry(entry);</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line"> </td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">    <span class='keyword'>void</span> Move(Address from, Address to) {</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">      <span class='keyword'>if</span> (from == to) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">      HashMap::Entry* from_entry = FindEntry(from);</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">      <span class='macro'>DCHECK(from_entry != NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(from_entry != __null)), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 438, "Check failed: %s."<br>, "from_entry != __null"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">      <span class='keyword'>void</span>* value = from_entry-&gt;value;</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">      RemoveEntry(from_entry);</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">      HashMap::Entry* to_entry = FindOrCreateEntry(to);</td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">      <span class='macro'>DCHECK(to_entry-&gt;value == NULL)<span class='expansion'>do { if ((__builtin_expect(!!(!(to_entry-&gt;value == __null)<br>), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 442, "Check failed: %s."<br>, "to_entry-&gt;value == __null"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">      to_entry-&gt;value = value;</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN445">445</td><td class="line"> </td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">   <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>char</span>* CopyName(<span class='keyword'>const</span> <span class='keyword'>char</span>* name, <span class='keyword'>int</span> name_size) {</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">      <span class='keyword'>char</span>* result = NewArray&lt;<span class='keyword'>char</span>&gt;(name_size + 1);</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; name_size; ++i) {</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">        <span class='keyword'>char</span> c = name[i];</td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">        <span class='keyword'>if</span> (c == '\0') c = ' ';</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">        result[i] = c;</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">      result[name_size] = '\0';</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">      <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line"> </td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">    HashMap::Entry* FindOrCreateEntry(Address code_address) {</td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">      <span class='keyword'>return</span> impl_.LookupOrInsert(code_address,</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">                                  ComputePointerHash(code_address));</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line"> </td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">    HashMap::Entry* FindEntry(Address code_address) {</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">      <span class='keyword'>return</span> impl_.Lookup(code_address, ComputePointerHash(code_address));</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN466">466</td><td class="line"> </td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">    <span class='keyword'>void</span> RemoveEntry(HashMap::Entry* entry) {</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">      impl_.Remove(entry-&gt;key, entry-&gt;hash);</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN470">470</td><td class="line"> </td></tr>
<tr><td class="num" id="LN471">471</td><td class="line">    HashMap impl_;</td></tr>
<tr><td class="num" id="LN472">472</td><td class="line"> </td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">    <span class='macro'>DISALLOW_COPY_AND_ASSIGN(NameMap)<span class='expansion'>NameMap(const NameMap&amp;) = delete; void operator=(const NameMap<br>&amp;) = delete</span></span>;</td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">  };</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line"> </td></tr>
<tr><td class="num" id="LN476">476</td><td class="line">  <span class='keyword'>void</span> LogRecordedBuffer(Code* code, SharedFunctionInfo*, <span class='keyword'>const</span> <span class='keyword'>char</span>* name,</td></tr>
<tr><td class="num" id="LN477">477</td><td class="line">                         <span class='keyword'>int</span> length) override {</td></tr>
<tr><td class="num" id="LN478">478</td><td class="line">    address_to_name_map_.Insert(code-&gt;address(), name, length);</td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN480">480</td><td class="line"> </td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">  NameMap address_to_name_map_;</td></tr>
<tr><td class="num" id="LN482">482</td><td class="line">  Isolate* isolate_;</td></tr>
<tr><td class="num" id="LN483">483</td><td class="line">};</td></tr>
<tr><td class="num" id="LN484">484</td><td class="line"> </td></tr>
<tr><td class="num" id="LN485">485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN486">486</td><td class="line"><span class='keyword'>void</span> Deserializer::DecodeReservation(</td></tr>
<tr><td class="num" id="LN487">487</td><td class="line">    Vector&lt;<span class='keyword'>const</span> SerializedData::Reservation&gt; res) {</td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">  <span class='macro'>DCHECK_EQ(0, reservations_[NEW_SPACE].length())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (reservations_<br>[NEW_SPACE].length()), "0" " " "==" " " "reservations_[NEW_SPACE].length()"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 488, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">  <span class='macro'>STATIC_ASSERT(NEW_SPACE == 0)<span class='expansion'>static_assert(NEW_SPACE == 0, "NEW_SPACE == 0")</span></span>;</td></tr>
<tr><td class="num" id="LN490">490</td><td class="line">  <span class='keyword'>int</span> current_space = NEW_SPACE;</td></tr>
<tr><td class="num" id="LN491">491</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>auto</span>&amp; r : res) {</td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">    reservations_[current_space].Add({r.chunk_size(), <span class='macro'>NULL<span class='expansion'>__null</span></span>, <span class='macro'>NULL<span class='expansion'>__null</span></span>});</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">    <span class='keyword'>if</span> (r.is_last()) current_space++;</td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line">  <span class='macro'>DCHECK_EQ(kNumberOfSpaces, current_space)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (kNumberOfSpaces<br>), (current_space), "kNumberOfSpaces" " " "==" " " "current_space"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 495, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN496">496</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kNumberOfPreallocatedSpaces; i++) current_chunk_[i] = 0;</td></tr>
<tr><td class="num" id="LN497">497</td><td class="line">}</td></tr>
<tr><td class="num" id="LN498">498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN499">499</td><td class="line"> </td></tr>
<tr><td class="num" id="LN500">500</td><td class="line"><span class='keyword'>void</span> Deserializer::FlushICacheForNewIsolate() {</td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">  <span class='macro'>DCHECK(!deserializing_user_code_)<span class='expansion'>do { if ((__builtin_expect(!!(!(!deserializing_user_code_)), 0<br>))) { V8_Fatal("../src/snapshot/serialize.cc", 501, "Check failed: %s."<br>, "!deserializing_user_code_"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">  <span class='comment'>// The entire isolate is newly deserialized. Simply flush all code pages.</span></td></tr>
<tr><td class="num" id="LN503">503</td><td class="line">  PageIterator it(isolate_-&gt;heap()-&gt;code_space());</td></tr>
<tr><td class="num" id="LN504">504</td><td class="line">  <span class='keyword'>while</span> (it.has_next()) {</td></tr>
<tr><td class="num" id="LN505">505</td><td class="line">    Page* p = it.next();</td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">    Assembler::FlushICache(isolate_, p-&gt;area_start(),</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line">                           p-&gt;area_end() - p-&gt;area_start());</td></tr>
<tr><td class="num" id="LN508">508</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN509">509</td><td class="line">}</td></tr>
<tr><td class="num" id="LN510">510</td><td class="line"> </td></tr>
<tr><td class="num" id="LN511">511</td><td class="line"> </td></tr>
<tr><td class="num" id="LN512">512</td><td class="line"><span class='keyword'>void</span> Deserializer::FlushICacheForNewCodeObjects() {</td></tr>
<tr><td class="num" id="LN513">513</td><td class="line">  <span class='macro'>DCHECK(deserializing_user_code_)<span class='expansion'>do { if ((__builtin_expect(!!(!(deserializing_user_code_)), 0<br>))) { V8_Fatal("../src/snapshot/serialize.cc", 513, "Check failed: %s."<br>, "deserializing_user_code_"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN514">514</td><td class="line">  <span class='keyword'>for</span> (Code* code : new_code_objects_) {</td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">    Assembler::FlushICache(isolate_, code-&gt;instruction_start(),</td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">                           code-&gt;instruction_size());</td></tr>
<tr><td class="num" id="LN517">517</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN518">518</td><td class="line">}</td></tr>
<tr><td class="num" id="LN519">519</td><td class="line"> </td></tr>
<tr><td class="num" id="LN520">520</td><td class="line"> </td></tr>
<tr><td class="num" id="LN521">521</td><td class="line"><span class='keyword'>bool</span> Deserializer::ReserveSpace() {</td></tr>
<tr><td class="num" id="LN522">522</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = NEW_SPACE; i &lt; kNumberOfSpaces; ++i) {</td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">    <span class='macro'>CHECK(reservations_[i].length() &gt; 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(reservations_[i].length() &gt;<br> 0)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 524, "Check failed: %s."<br>, "reservations_[i].length() &gt; 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line"><span class='directive'>#endif  // DEBUG</span></td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">  <span class='keyword'>if</span> (!isolate_-&gt;heap()-&gt;ReserveSpace(reservations_)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kNumberOfPreallocatedSpaces; i++) {</td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">    high_water_[i] = reservations_[i][0].start;</td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">}</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN534">534</td><td class="line"> </td></tr>
<tr><td class="num" id="LN535">535</td><td class="line"><span class='keyword'>void</span> Deserializer::Initialize(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">  <span class='macro'>DCHECK_NULL(isolate_)<span class='expansion'>do { if ((__builtin_expect(!!(!((isolate_) == nullptr)), 0)))<br> { V8_Fatal("../src/snapshot/serialize.cc", 536, "Check failed: %s."<br>, "(isolate_) == nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">  <span class='macro'>DCHECK_NOT_NULL(isolate)<span class='expansion'>do { if ((__builtin_expect(!!(!((isolate) != nullptr)), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 537, "Check failed: %s."<br>, "(isolate) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">  isolate_ = isolate;</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">  <span class='macro'>DCHECK_NULL(external_reference_table_)<span class='expansion'>do { if ((__builtin_expect(!!(!((external_reference_table_) ==<br> nullptr)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 539<br>, "Check failed: %s.", "(external_reference_table_) == nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">  external_reference_table_ = ExternalReferenceTable::instance(isolate);</td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">  <span class='macro'>CHECK_EQ(magic_number_,<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (magic_number_<br>), (SerializedData::ComputeMagicNumber(external_reference_table_<br>)), "magic_number_" " " "==" " " "SerializedData::ComputeMagicNumber(external_reference_table_)"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 542, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">           <span class='macro'>SerializedData::ComputeMagicNumber(external_reference_table_))<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (magic_number_<br>), (SerializedData::ComputeMagicNumber(external_reference_table_<br>)), "magic_number_" " " "==" " " "SerializedData::ComputeMagicNumber(external_reference_table_)"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 542, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">}</td></tr>
<tr><td class="num" id="LN544">544</td><td class="line"> </td></tr>
<tr><td class="num" id="LN545">545</td><td class="line"> </td></tr>
<tr><td class="num" id="LN546">546</td><td class="line"><span class='keyword'>void</span> Deserializer::Deserialize(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">  Initialize(isolate);</td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">  <span class='keyword'>if</span> (!ReserveSpace()) V8::FatalProcessOutOfMemory(<span class='string_literal'>"deserializing context"</span>);</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">  <span class='comment'>// No active threads.</span></td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">  <span class='macro'>DCHECK_NULL(isolate_-&gt;thread_manager()-&gt;FirstThreadStateInUse())<span class='expansion'>do { if ((__builtin_expect(!!(!((isolate_-&gt;thread_manager(<br>)-&gt;FirstThreadStateInUse()) == nullptr)), 0))) { V8_Fatal(<br>"../src/snapshot/serialize.cc", 550, "Check failed: %s.", "(isolate_-&gt;thread_manager()-&gt;FirstThreadStateInUse()) == nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">  <span class='comment'>// No active handles.</span></td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">  <span class='macro'>DCHECK(isolate_-&gt;handle_scope_implementer()-&gt;blocks()-&gt;is_empty())<span class='expansion'>do { if ((__builtin_expect(!!(!(isolate_-&gt;handle_scope_implementer<br>()-&gt;blocks()-&gt;is_empty())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 552, "Check failed: %s.", "isolate_-&gt;handle_scope_implementer()-&gt;blocks()-&gt;is_empty()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line"> </td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">  {</td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">    DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">    isolate_-&gt;heap()-&gt;IterateSmiRoots(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">    isolate_-&gt;heap()-&gt;IterateStrongRoots(<span class='keyword'>this</span>, VISIT_ONLY_STRONG);</td></tr>
<tr><td class="num" id="LN558">558</td><td class="line">    isolate_-&gt;heap()-&gt;RepairFreeListsAfterDeserialization();</td></tr>
<tr><td class="num" id="LN559">559</td><td class="line">    isolate_-&gt;heap()-&gt;IterateWeakRoots(<span class='keyword'>this</span>, VISIT_ALL);</td></tr>
<tr><td class="num" id="LN560">560</td><td class="line">    DeserializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">    FlushICacheForNewIsolate();</td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN563">563</td><td class="line"> </td></tr>
<tr><td class="num" id="LN564">564</td><td class="line">  isolate_-&gt;heap()-&gt;set_native_contexts_list(</td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">      isolate_-&gt;heap()-&gt;undefined_value());</td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">  <span class='comment'>// The allocation site list is build during root iteration, but if no sites</span></td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">  <span class='comment'>// were encountered then it needs to be initialized to undefined.</span></td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">  <span class='keyword'>if</span> (isolate_-&gt;heap()-&gt;allocation_sites_list() == Smi::FromInt(0)) {</td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">    isolate_-&gt;heap()-&gt;set_allocation_sites_list(</td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">        isolate_-&gt;heap()-&gt;undefined_value());</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line"> </td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">  <span class='comment'>// Update data pointers to the external strings containing natives sources.</span></td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">  Natives::UpdateSourceCache(isolate_-&gt;heap());</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">  ExtraNatives::UpdateSourceCache(isolate_-&gt;heap());</td></tr>
<tr><td class="num" id="LN576">576</td><td class="line"> </td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">  <span class='comment'>// Issue code events for newly deserialized code objects.</span></td></tr>
<tr><td class="num" id="LN578">578</td><td class="line">  <span class='macro'>LOG_CODE_EVENT(isolate_, LogCodeObjects())<span class='expansion'>do { v8::internal::Logger* logger = (isolate_)-&gt;logger(); if<br> (logger-&gt;is_logging_code_events()) logger-&gt;LogCodeObjects<br>(); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">  <span class='macro'>LOG_CODE_EVENT(isolate_, LogCompiledFunctions())<span class='expansion'>do { v8::internal::Logger* logger = (isolate_)-&gt;logger(); if<br> (logger-&gt;is_logging_code_events()) logger-&gt;LogCompiledFunctions<br>(); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">}</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line"> </td></tr>
<tr><td class="num" id="LN582">582</td><td class="line"> </td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">MaybeHandle&lt;Object&gt; Deserializer::DeserializePartial(</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">    Isolate* isolate, Handle&lt;JSGlobalProxy&gt; global_proxy) {</td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">  Initialize(isolate);</td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">  <span class='keyword'>if</span> (!ReserveSpace()) {</td></tr>
<tr><td class="num" id="LN587">587</td><td class="line">    V8::FatalProcessOutOfMemory(<span class='string_literal'>"deserialize context"</span>);</td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">    <span class='keyword'>return</span> MaybeHandle&lt;Object&gt;();</td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN590">590</td><td class="line"> </td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">  Vector&lt;Handle&lt;Object&gt; &gt; attached_objects = Vector&lt;Handle&lt;Object&gt; &gt;::New(1);</td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">  attached_objects[kGlobalProxyReference] = global_proxy;</td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">  SetAttachedObjects(attached_objects);</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">  <span class='comment'>// Keep track of the code space start and end pointers in case new</span></td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">  <span class='comment'>// code objects were unserialized</span></td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">  OldSpace* code_space = isolate_-&gt;heap()-&gt;code_space();</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">  Address start_address = code_space-&gt;top();</td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">  Object* root;</td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">  VisitPointer(&amp;root);</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">  DeserializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN603">603</td><td class="line"> </td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">  <span class='comment'>// There's no code deserialized here. If this assert fires then that's</span></td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">  <span class='comment'>// changed and logging should be added to notify the profiler et al of the</span></td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">  <span class='comment'>// new code, which also has to be flushed from instruction cache.</span></td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">  <span class='macro'>CHECK_EQ(start_address, code_space-&gt;top())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (start_address<br>), (code_space-&gt;top()), "start_address" " " "==" " " "code_space-&gt;top()"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 607, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">  <span class='keyword'>return</span> Handle&lt;Object&gt;(root, isolate);</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">}</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN611">611</td><td class="line"> </td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">MaybeHandle&lt;SharedFunctionInfo&gt; Deserializer::DeserializeCode(</td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">    Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">  Initialize(isolate);</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">  <span class='keyword'>if</span> (!ReserveSpace()) {</td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">    <span class='keyword'>return</span> Handle&lt;SharedFunctionInfo&gt;();</td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">    deserializing_user_code_ = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">    HandleScope scope(isolate);</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">    Handle&lt;SharedFunctionInfo&gt; result;</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">    {</td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">      DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line">      Object* root;</td></tr>
<tr><td class="num" id="LN624">624</td><td class="line">      VisitPointer(&amp;root);</td></tr>
<tr><td class="num" id="LN625">625</td><td class="line">      DeserializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">      FlushICacheForNewCodeObjects();</td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">      result = Handle&lt;SharedFunctionInfo&gt;(SharedFunctionInfo::cast(root));</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">    CommitPostProcessedObjects(isolate);</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">    <span class='keyword'>return</span> scope.CloseAndEscape(result);</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">}</td></tr>
<tr><td class="num" id="LN633">633</td><td class="line"> </td></tr>
<tr><td class="num" id="LN634">634</td><td class="line"> </td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">Deserializer::~Deserializer() {</td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">  <span class='comment'>// TODO(svenpanne) Re-enable this assertion when v8 initialization is fixed.</span></td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">  <span class='comment'>// DCHECK(source_.AtEOF());</span></td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">  attached_objects_.Dispose();</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">}</td></tr>
<tr><td class="num" id="LN640">640</td><td class="line"> </td></tr>
<tr><td class="num" id="LN641">641</td><td class="line"> </td></tr>
<tr><td class="num" id="LN642">642</td><td class="line"><span class='comment'>// This is called on the roots.  It is the driver of the deserialization</span></td></tr>
<tr><td class="num" id="LN643">643</td><td class="line"><span class='comment'>// process.  It is also called on the body of each function.</span></td></tr>
<tr><td class="num" id="LN644">644</td><td class="line"><span class='keyword'>void</span> Deserializer::VisitPointers(Object** start, Object** end) {</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line">  <span class='comment'>// The space must be new space.  Any other space would cause ReadChunk to try</span></td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">  <span class='comment'>// to update the remembered using NULL as the address.</span></td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">  ReadData(start, end, NEW_SPACE, <span class='macro'>NULL<span class='expansion'>__null</span></span>);</td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">}</td></tr>
<tr><td class="num" id="LN649">649</td><td class="line"> </td></tr>
<tr><td class="num" id="LN650">650</td><td class="line"><span class='keyword'>void</span> Deserializer::Synchronize(VisitorSynchronization::SyncTag tag) {</td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> byte expected = kSynchronize;</td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">  <span class='macro'>CHECK_EQ(expected, source_.Get())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (expected<br>), (source_.Get()), "expected" " " "==" " " "source_.Get()"))<br> { V8_Fatal("../src/snapshot/serialize.cc", 652, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">}</td></tr>
<tr><td class="num" id="LN654">654</td><td class="line"> </td></tr>
<tr><td class="num" id="LN655">655</td><td class="line"><span class='keyword'>void</span> Deserializer::DeserializeDeferredObjects() {</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> code = source_.Get(); code != kSynchronize; code = source_.Get()) {</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">    <span class='keyword'>switch</span> (code) {</td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix:</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix + 1:</td></tr>
<tr><td class="num" id="LN660">660</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix + 2:</td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">        SetAlignment(code);</td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">      <span class='keyword'>default</span>: {</td></tr>
<tr><td class="num" id="LN664">664</td><td class="line">        <span class='keyword'>int</span> space = code &amp; kSpaceMask;</td></tr>
<tr><td class="num" id="LN665">665</td><td class="line">        <span class='macro'>DCHECK(space &lt;= kNumberOfSpaces)<span class='expansion'>do { if ((__builtin_expect(!!(!(space &lt;= kNumberOfSpaces))<br>, 0))) { V8_Fatal("../src/snapshot/serialize.cc", 665, "Check failed: %s."<br>, "space &lt;= kNumberOfSpaces"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN666">666</td><td class="line">        <span class='macro'>DCHECK(code - space == kNewObject)<span class='expansion'>do { if ((__builtin_expect(!!(!(code - space == kNewObject)),<br> 0))) { V8_Fatal("../src/snapshot/serialize.cc", 666, "Check failed: %s."<br>, "code - space == kNewObject"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN667">667</td><td class="line">        HeapObject* object = GetBackReferencedObject(space);</td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">        <span class='keyword'>int</span> size = source_.GetInt() &lt;&lt; kPointerSizeLog2;</td></tr>
<tr><td class="num" id="LN669">669</td><td class="line">        Address obj_address = object-&gt;address();</td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">        Object** start = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(obj_address + kPointerSize);</td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">        Object** end = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(obj_address + size);</td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">        <span class='keyword'>bool</span> filled = ReadData(start, end, space, obj_address);</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">        <span class='macro'>CHECK(filled)<span class='expansion'>do { if ((__builtin_expect(!!(!(filled)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 673, "Check failed: %s.", "filled"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">        <span class='macro'>DCHECK(CanBeDeferred(object))<span class='expansion'>do { if ((__builtin_expect(!!(!(CanBeDeferred(object))), 0)))<br> { V8_Fatal("../src/snapshot/serialize.cc", 674, "Check failed: %s."<br>, "CanBeDeferred(object)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">        PostProcessNewObject(object, space);</td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">}</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line"> </td></tr>
<tr><td class="num" id="LN681">681</td><td class="line"> </td></tr>
<tr><td class="num" id="LN682">682</td><td class="line"><span class='comment'>// Used to insert a deserialized internalized string into the string table.</span></td></tr>
<tr><td class="num" id="LN683">683</td><td class="line"><span class='keyword'>class</span> StringTableInsertionKey : <span class='keyword'>public</span> HashTableKey {</td></tr>
<tr><td class="num" id="LN684">684</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">  <span class='keyword'>explicit</span> StringTableInsertionKey(String* string)</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">      : string_(string), hash_(HashForObject(string)) {</td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">    <span class='macro'>DCHECK(string-&gt;IsInternalizedString())<span class='expansion'>do { if ((__builtin_expect(!!(!(string-&gt;IsInternalizedString<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 687, "Check failed: %s."<br>, "string-&gt;IsInternalizedString()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line"> </td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">  <span class='keyword'>bool</span> IsMatch(Object* string) override {</td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">    <span class='comment'>// We know that all entries in a hash table had their hash keys created.</span></td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">    <span class='comment'>// Use that knowledge to have fast failure.</span></td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">    <span class='keyword'>if</span> (hash_ != HashForObject(string)) <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">    <span class='comment'>// We want to compare the content of two internalized strings here.</span></td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">    <span class='keyword'>return</span> string_-&gt;SlowEquals(String::cast(string));</td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN697">697</td><td class="line"> </td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">  uint32_t Hash() override { <span class='keyword'>return</span> hash_; }</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line"> </td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">  uint32_t HashForObject(Object* key) override {</td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">    <span class='keyword'>return</span> String::cast(key)-&gt;Hash();</td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN703">703</td><td class="line"> </td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">  <span class='macro'>MUST_USE_RESULT<span class='expansion'>__attribute__((warn_unused_result))</span></span> Handle&lt;Object&gt; AsHandle(Isolate* isolate) override {</td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">    <span class='keyword'>return</span> handle(string_, isolate);</td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN707">707</td><td class="line"> </td></tr>
<tr><td class="num" id="LN708">708</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">  String* string_;</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">  uint32_t hash_;</td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">};</td></tr>
<tr><td class="num" id="LN713">713</td><td class="line"> </td></tr>
<tr><td class="num" id="LN714">714</td><td class="line"> </td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">HeapObject* Deserializer::PostProcessNewObject(HeapObject* obj, <span class='keyword'>int</span> space) {</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line">  <span class='keyword'>if</span> (deserializing_user_code()) {</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">    <span class='keyword'>if</span> (obj-&gt;IsString()) {</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">      String* string = String::cast(obj);</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">      <span class='comment'>// Uninitialize hash field as the hash seed may have changed.</span></td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">      string-&gt;set_hash_field(String::kEmptyHashField);</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">      <span class='keyword'>if</span> (string-&gt;IsInternalizedString()) {</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">        <span class='comment'>// Canonicalize the internalized string. If it already exists in the</span></td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">        <span class='comment'>// string table, set it to forward to the existing one.</span></td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">        StringTableInsertionKey key(string);</td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">        String* canonical = StringTable::LookupKeyIfExists(isolate_, &amp;key);</td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">        <span class='keyword'>if</span> (canonical == <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">          new_internalized_strings_.Add(handle(string));</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">          <span class='keyword'>return</span> string;</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">          string-&gt;SetForwardedInternalizedString(canonical);</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">          <span class='keyword'>return</span> canonical;</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (obj-&gt;IsScript()) {</td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">      new_scripts_.Add(handle(Script::cast(obj)));</td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">      <span class='macro'>DCHECK(CanBeDeferred(obj))<span class='expansion'>do { if ((__builtin_expect(!!(!(CanBeDeferred(obj))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 737, "Check failed: %s.", "CanBeDeferred(obj)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsAllocationSite()) {</td></tr>
<tr><td class="num" id="LN741">741</td><td class="line">    <span class='macro'>DCHECK(obj-&gt;IsAllocationSite())<span class='expansion'>do { if ((__builtin_expect(!!(!(obj-&gt;IsAllocationSite())),<br> 0))) { V8_Fatal("../src/snapshot/serialize.cc", 741, "Check failed: %s."<br>, "obj-&gt;IsAllocationSite()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">    <span class='comment'>// Allocation sites are present in the snapshot, and must be linked into</span></td></tr>
<tr><td class="num" id="LN743">743</td><td class="line">    <span class='comment'>// a list at deserialization time.</span></td></tr>
<tr><td class="num" id="LN744">744</td><td class="line">    AllocationSite* site = AllocationSite::cast(obj);</td></tr>
<tr><td class="num" id="LN745">745</td><td class="line">    <span class='comment'>// TODO(mvstanton): consider treating the heap()-&gt;allocation_sites_list()</span></td></tr>
<tr><td class="num" id="LN746">746</td><td class="line">    <span class='comment'>// as a (weak) root. If this root is relocated correctly, this becomes</span></td></tr>
<tr><td class="num" id="LN747">747</td><td class="line">    <span class='comment'>// unnecessary.</span></td></tr>
<tr><td class="num" id="LN748">748</td><td class="line">    <span class='keyword'>if</span> (isolate_-&gt;heap()-&gt;allocation_sites_list() == Smi::FromInt(0)) {</td></tr>
<tr><td class="num" id="LN749">749</td><td class="line">      site-&gt;set_weak_next(isolate_-&gt;heap()-&gt;undefined_value());</td></tr>
<tr><td class="num" id="LN750">750</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN751">751</td><td class="line">      site-&gt;set_weak_next(isolate_-&gt;heap()-&gt;allocation_sites_list());</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN753">753</td><td class="line">    isolate_-&gt;heap()-&gt;set_allocation_sites_list(site);</td></tr>
<tr><td class="num" id="LN754">754</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (obj-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN755">755</td><td class="line">    <span class='comment'>// We flush all code pages after deserializing the startup snapshot. In that</span></td></tr>
<tr><td class="num" id="LN756">756</td><td class="line">    <span class='comment'>// case, we only need to remember code objects in the large object space.</span></td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">    <span class='comment'>// When deserializing user code, remember each individual code object.</span></td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">    <span class='keyword'>if</span> (deserializing_user_code() || space == LO_SPACE) {</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">      new_code_objects_.Add(Code::cast(obj));</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">  <span class='comment'>// Check alignment.</span></td></tr>
<tr><td class="num" id="LN763">763</td><td class="line">  <span class='macro'>DCHECK_EQ(0, Heap::GetFillToAlign(obj-&gt;address(), obj-&gt;RequiredAlignment()))<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (Heap<br>::GetFillToAlign(obj-&gt;address(), obj-&gt;RequiredAlignment<br>())), "0" " " "==" " " "Heap::GetFillToAlign(obj-&gt;address(), obj-&gt;RequiredAlignment())"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 763, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN764">764</td><td class="line">  <span class='keyword'>return</span> obj;</td></tr>
<tr><td class="num" id="LN765">765</td><td class="line">}</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line"> </td></tr>
<tr><td class="num" id="LN767">767</td><td class="line"> </td></tr>
<tr><td class="num" id="LN768">768</td><td class="line"><span class='keyword'>void</span> Deserializer::CommitPostProcessedObjects(Isolate* isolate) {</td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">  StringTable::EnsureCapacityForDeserialization(</td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">      isolate, new_internalized_strings_.length());</td></tr>
<tr><td class="num" id="LN771">771</td><td class="line">  <span class='keyword'>for</span> (Handle&lt;String&gt; string : new_internalized_strings_) {</td></tr>
<tr><td class="num" id="LN772">772</td><td class="line">    StringTableInsertionKey key(*string);</td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">    <span class='macro'>DCHECK_NULL(StringTable::LookupKeyIfExists(isolate, &amp;key))<span class='expansion'>do { if ((__builtin_expect(!!(!((StringTable::LookupKeyIfExists<br>(isolate, &amp;key)) == nullptr)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 773, "Check failed: %s.", "(StringTable::LookupKeyIfExists(isolate, &amp;key)) == nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">    StringTable::LookupKey(isolate, &amp;key);</td></tr>
<tr><td class="num" id="LN775">775</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN776">776</td><td class="line"> </td></tr>
<tr><td class="num" id="LN777">777</td><td class="line">  Heap* heap = isolate-&gt;heap();</td></tr>
<tr><td class="num" id="LN778">778</td><td class="line">  Factory* factory = isolate-&gt;factory();</td></tr>
<tr><td class="num" id="LN779">779</td><td class="line">  <span class='keyword'>for</span> (Handle&lt;Script&gt; script : new_scripts_) {</td></tr>
<tr><td class="num" id="LN780">780</td><td class="line">    <span class='comment'>// Assign a new script id to avoid collision.</span></td></tr>
<tr><td class="num" id="LN781">781</td><td class="line">    script-&gt;set_id(isolate_-&gt;heap()-&gt;NextScriptId());</td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">    <span class='comment'>// Add script to list.</span></td></tr>
<tr><td class="num" id="LN783">783</td><td class="line">    Handle&lt;Object&gt; list = WeakFixedArray::Add(factory-&gt;script_list(), script);</td></tr>
<tr><td class="num" id="LN784">784</td><td class="line">    heap-&gt;SetRootScriptList(*list);</td></tr>
<tr><td class="num" id="LN785">785</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN786">786</td><td class="line">}</td></tr>
<tr><td class="num" id="LN787">787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN788">788</td><td class="line"> </td></tr>
<tr><td class="num" id="LN789">789</td><td class="line">HeapObject* Deserializer::GetBackReferencedObject(<span class='keyword'>int</span> space) {</td></tr>
<tr><td class="num" id="LN790">790</td><td class="line">  HeapObject* obj;</td></tr>
<tr><td class="num" id="LN791">791</td><td class="line">  BackReference back_reference(source_.GetInt());</td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">  <span class='keyword'>if</span> (space == LO_SPACE) {</td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">    <span class='macro'>CHECK(back_reference.chunk_index() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(back_reference.chunk_index() ==<br> 0)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 793, "Check failed: %s."<br>, "back_reference.chunk_index() == 0"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">    uint32_t index = back_reference.large_object_index();</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">    obj = deserialized_large_objects_[index];</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">    <span class='macro'>DCHECK(space &lt; kNumberOfPreallocatedSpaces)<span class='expansion'>do { if ((__builtin_expect(!!(!(space &lt; kNumberOfPreallocatedSpaces<br>)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 797, "Check failed: %s."<br>, "space &lt; kNumberOfPreallocatedSpaces"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">    uint32_t chunk_index = back_reference.chunk_index();</td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">    <span class='macro'>DCHECK_LE(chunk_index, current_chunk_[space])<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (chunk_index<br>), (current_chunk_[space]), "chunk_index" " " "&lt;=" " " "current_chunk_[space]"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 799, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">    uint32_t chunk_offset = back_reference.chunk_offset();</td></tr>
<tr><td class="num" id="LN801">801</td><td class="line">    Address address = reservations_[space][chunk_index].start + chunk_offset;</td></tr>
<tr><td class="num" id="LN802">802</td><td class="line">    <span class='keyword'>if</span> (next_alignment_ != kWordAligned) {</td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">      <span class='keyword'>int</span> padding = Heap::GetFillToAlign(address, next_alignment_);</td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">      next_alignment_ = kWordAligned;</td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">      <span class='macro'>DCHECK(padding == 0 || HeapObject::FromAddress(address)-&gt;IsFiller())<span class='expansion'>do { if ((__builtin_expect(!!(!(padding == 0 || HeapObject::FromAddress<br>(address)-&gt;IsFiller())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 805, "Check failed: %s.", "padding == 0 || HeapObject::FromAddress(address)-&gt;IsFiller()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN806">806</td><td class="line">      address += padding;</td></tr>
<tr><td class="num" id="LN807">807</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">    obj = HeapObject::FromAddress(address);</td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">  <span class='keyword'>if</span> (deserializing_user_code() &amp;&amp; obj-&gt;IsInternalizedString()) {</td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">    obj = String::cast(obj)-&gt;GetForwardedInternalizedString();</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">  hot_objects_.Add(obj);</td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">  <span class='keyword'>return</span> obj;</td></tr>
<tr><td class="num" id="LN815">815</td><td class="line">}</td></tr>
<tr><td class="num" id="LN816">816</td><td class="line"> </td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"> </td></tr>
<tr><td class="num" id="LN818">818</td><td class="line"><span class='comment'>// This routine writes the new object into the pointer provided and then</span></td></tr>
<tr><td class="num" id="LN819">819</td><td class="line"><span class='comment'>// returns true if the new object was in young space and false otherwise.</span></td></tr>
<tr><td class="num" id="LN820">820</td><td class="line"><span class='comment'>// The reason for this strange interface is that otherwise the object is</span></td></tr>
<tr><td class="num" id="LN821">821</td><td class="line"><span class='comment'>// written very late, which means the FreeSpace map is not set up by the</span></td></tr>
<tr><td class="num" id="LN822">822</td><td class="line"><span class='comment'>// time we need to use it to mark the space at the end of a page free.</span></td></tr>
<tr><td class="num" id="LN823">823</td><td class="line"><span class='keyword'>void</span> Deserializer::ReadObject(<span class='keyword'>int</span> space_number, Object** write_back) {</td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">  Address address;</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line">  HeapObject* obj;</td></tr>
<tr><td class="num" id="LN826">826</td><td class="line">  <span class='keyword'>int</span> size = source_.GetInt() &lt;&lt; kObjectAlignmentBits;</td></tr>
<tr><td class="num" id="LN827">827</td><td class="line"> </td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">  <span class='keyword'>if</span> (next_alignment_ != kWordAligned) {</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">    <span class='keyword'>int</span> reserved = size + Heap::GetMaximumFillToAlign(next_alignment_);</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">    address = Allocate(space_number, reserved);</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">    obj = HeapObject::FromAddress(address);</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">    <span class='comment'>// If one of the following assertions fails, then we are deserializing an</span></td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">    <span class='comment'>// aligned object when the filler maps have not been deserialized yet.</span></td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">    <span class='comment'>// We require filler maps as padding to align the object.</span></td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">    Heap* heap = isolate_-&gt;heap();</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">    <span class='macro'>DCHECK(heap-&gt;free_space_map()-&gt;IsMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(heap-&gt;free_space_map()-&gt;<br>IsMap())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 836<br>, "Check failed: %s.", "heap-&gt;free_space_map()-&gt;IsMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">    <span class='macro'>DCHECK(heap-&gt;one_pointer_filler_map()-&gt;IsMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(heap-&gt;one_pointer_filler_map<br>()-&gt;IsMap())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 837, "Check failed: %s.", "heap-&gt;one_pointer_filler_map()-&gt;IsMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">    <span class='macro'>DCHECK(heap-&gt;two_pointer_filler_map()-&gt;IsMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(heap-&gt;two_pointer_filler_map<br>()-&gt;IsMap())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 838, "Check failed: %s.", "heap-&gt;two_pointer_filler_map()-&gt;IsMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">    obj = heap-&gt;AlignWithFiller(obj, size, reserved, next_alignment_);</td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">    address = obj-&gt;address();</td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">    next_alignment_ = kWordAligned;</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">    address = Allocate(space_number, size);</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">    obj = HeapObject::FromAddress(address);</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line"> </td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">  isolate_-&gt;heap()-&gt;OnAllocationEvent(obj, size);</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">  Object** current = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(address);</td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">  Object** limit = current + (size &gt;&gt; kPointerSizeLog2);</td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">  <span class='keyword'>if</span> (FLAG_log_snapshot_positions) {</td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">    <span class='macro'>LOG(isolate_, SnapshotPositionEvent(address, source_.position()))<span class='expansion'>do { v8::internal::Logger* logger = (isolate_)-&gt;logger(); if<br> (logger-&gt;is_logging()) logger-&gt;SnapshotPositionEvent(address<br>, source_.position()); } while (false)</span></span>;</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line"> </td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">  <span class='keyword'>if</span> (ReadData(current, limit, space_number, address)) {</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">    <span class='comment'>// Only post process if object content has not been deferred.</span></td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">    obj = PostProcessNewObject(obj, space_number);</td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line"> </td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">  Object* write_back_obj = obj;</td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">  UnalignedCopy(write_back, &amp;write_back_obj);</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">    <span class='macro'>DCHECK(space_number == CODE_SPACE || space_number == LO_SPACE)<span class='expansion'>do { if ((__builtin_expect(!!(!(space_number == CODE_SPACE ||<br> space_number == LO_SPACE)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 863, "Check failed: %s.", "space_number == CODE_SPACE || space_number == LO_SPACE"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">    <span class='macro'>DCHECK(space_number != CODE_SPACE)<span class='expansion'>do { if ((__builtin_expect(!!(!(space_number != CODE_SPACE)),<br> 0))) { V8_Fatal("../src/snapshot/serialize.cc", 865, "Check failed: %s."<br>, "space_number != CODE_SPACE"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN867">867</td><td class="line"><span class='directive'>#endif  // DEBUG</span></td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">}</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line"> </td></tr>
<tr><td class="num" id="LN870">870</td><td class="line"> </td></tr>
<tr><td class="num" id="LN871">871</td><td class="line"><span class='comment'>// We know the space requirements before deserialization and can</span></td></tr>
<tr><td class="num" id="LN872">872</td><td class="line"><span class='comment'>// pre-allocate that reserved space. During deserialization, all we need</span></td></tr>
<tr><td class="num" id="LN873">873</td><td class="line"><span class='comment'>// to do is to bump up the pointer for each space in the reserved</span></td></tr>
<tr><td class="num" id="LN874">874</td><td class="line"><span class='comment'>// space. This is also used for fixing back references.</span></td></tr>
<tr><td class="num" id="LN875">875</td><td class="line"><span class='comment'>// We may have to split up the pre-allocation into several chunks</span></td></tr>
<tr><td class="num" id="LN876">876</td><td class="line"><span class='comment'>// because it would not fit onto a single page. We do not have to keep</span></td></tr>
<tr><td class="num" id="LN877">877</td><td class="line"><span class='comment'>// track of when to move to the next chunk. An opcode will signal this.</span></td></tr>
<tr><td class="num" id="LN878">878</td><td class="line"><span class='comment'>// Since multiple large objects cannot be folded into one large object</span></td></tr>
<tr><td class="num" id="LN879">879</td><td class="line"><span class='comment'>// space allocation, we have to do an actual allocation when deserializing</span></td></tr>
<tr><td class="num" id="LN880">880</td><td class="line"><span class='comment'>// each large object. Instead of tracking offset for back references, we</span></td></tr>
<tr><td class="num" id="LN881">881</td><td class="line"><span class='comment'>// reference large objects by index.</span></td></tr>
<tr><td class="num" id="LN882">882</td><td class="line">Address Deserializer::Allocate(<span class='keyword'>int</span> space_index, <span class='keyword'>int</span> size) {</td></tr>
<tr><td class="num" id="LN883">883</td><td class="line">  <span class='keyword'>if</span> (space_index == LO_SPACE) {</td></tr>
<tr><td class="num" id="LN884">884</td><td class="line">    AlwaysAllocateScope scope(isolate_);</td></tr>
<tr><td class="num" id="LN885">885</td><td class="line">    LargeObjectSpace* lo_space = isolate_-&gt;heap()-&gt;lo_space();</td></tr>
<tr><td class="num" id="LN886">886</td><td class="line">    Executability exec = <span class='keyword'>static_cast</span>&lt;Executability&gt;(source_.Get());</td></tr>
<tr><td class="num" id="LN887">887</td><td class="line">    AllocationResult result = lo_space-&gt;AllocateRaw(size, exec);</td></tr>
<tr><td class="num" id="LN888">888</td><td class="line">    HeapObject* obj = HeapObject::cast(result.ToObjectChecked());</td></tr>
<tr><td class="num" id="LN889">889</td><td class="line">    deserialized_large_objects_.Add(obj);</td></tr>
<tr><td class="num" id="LN890">890</td><td class="line">    <span class='keyword'>return</span> obj-&gt;address();</td></tr>
<tr><td class="num" id="LN891">891</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN892">892</td><td class="line">    <span class='macro'>DCHECK(space_index &lt; kNumberOfPreallocatedSpaces)<span class='expansion'>do { if ((__builtin_expect(!!(!(space_index &lt; kNumberOfPreallocatedSpaces<br>)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 892, "Check failed: %s."<br>, "space_index &lt; kNumberOfPreallocatedSpaces"); } } while (<br>0)</span></span>;</td></tr>
<tr><td class="num" id="LN893">893</td><td class="line">    Address address = high_water_[space_index];</td></tr>
<tr><td class="num" id="LN894">894</td><td class="line">    <span class='macro'>DCHECK_NOT_NULL(address)<span class='expansion'>do { if ((__builtin_expect(!!(!((address) != nullptr)), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 894, "Check failed: %s."<br>, "(address) != nullptr"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN895">895</td><td class="line">    high_water_[space_index] += size;</td></tr>
<tr><td class="num" id="LN896">896</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN897">897</td><td class="line">    <span class='comment'>// Assert that the current reserved chunk is still big enough.</span></td></tr>
<tr><td class="num" id="LN898">898</td><td class="line">    <span class='keyword'>const</span> Heap::Reservation&amp; reservation = reservations_[space_index];</td></tr>
<tr><td class="num" id="LN899">899</td><td class="line">    <span class='keyword'>int</span> chunk_index = current_chunk_[space_index];</td></tr>
<tr><td class="num" id="LN900">900</td><td class="line">    <span class='macro'>CHECK_LE(high_water_[space_index], reservation[chunk_index].end)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (high_water_<br>[space_index]), (reservation[chunk_index].end), "high_water_[space_index]"<br> " " "&lt;=" " " "reservation[chunk_index].end")) { V8_Fatal(<br>"../src/snapshot/serialize.cc", 900, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN901">901</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN902">902</td><td class="line">    <span class='keyword'>return</span> address;</td></tr>
<tr><td class="num" id="LN903">903</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN904">904</td><td class="line">}</td></tr>
<tr><td class="num" id="LN905">905</td><td class="line"> </td></tr>
<tr><td class="num" id="LN906">906</td><td class="line"> </td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">Object** Deserializer::CopyInNativesSource(Vector&lt;<span class='keyword'>const</span> <span class='keyword'>char</span>&gt; source_vector,</td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">                                           Object** current) {</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">  <span class='macro'>DCHECK(!isolate_-&gt;heap()-&gt;deserialization_complete())<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate_-&gt;heap()-&gt;deserialization_complete<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 909, "Check failed: %s."<br>, "!isolate_-&gt;heap()-&gt;deserialization_complete()"); } }<br> while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">  NativesExternalStringResource* resource = <span class='keyword'>new</span> NativesExternalStringResource(</td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">      source_vector.start(), source_vector.length());</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line">  Object* resource_obj = <span class='keyword'>reinterpret_cast</span>&lt;Object*&gt;(resource);</td></tr>
<tr><td class="num" id="LN913">913</td><td class="line">  UnalignedCopy(current++, &amp;resource_obj);</td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">  <span class='keyword'>return</span> current;</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">}</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line"> </td></tr>
<tr><td class="num" id="LN917">917</td><td class="line"> </td></tr>
<tr><td class="num" id="LN918">918</td><td class="line"><span class='keyword'>bool</span> Deserializer::ReadData(Object** current, Object** limit, <span class='keyword'>int</span> source_space,</td></tr>
<tr><td class="num" id="LN919">919</td><td class="line">                            Address current_object_address) {</td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">  Isolate* <span class='keyword'>const</span> isolate = isolate_;</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line">  <span class='comment'>// Write barrier support costs around 1% in startup time.  In fact there</span></td></tr>
<tr><td class="num" id="LN922">922</td><td class="line">  <span class='comment'>// are no new space objects in current boot snapshots, so it's not needed,</span></td></tr>
<tr><td class="num" id="LN923">923</td><td class="line">  <span class='comment'>// but that may change.</span></td></tr>
<tr><td class="num" id="LN924">924</td><td class="line">  <span class='keyword'>bool</span> write_barrier_needed =</td></tr>
<tr><td class="num" id="LN925">925</td><td class="line">      (current_object_address != <span class='macro'>NULL<span class='expansion'>__null</span></span> &amp;&amp; source_space != NEW_SPACE &amp;&amp;</td></tr>
<tr><td class="num" id="LN926">926</td><td class="line">       source_space != CODE_SPACE);</td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">  <span class='keyword'>while</span> (current &lt; limit) {</td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">    byte data = source_.Get();</td></tr>
<tr><td class="num" id="LN929">929</td><td class="line">    <span class='keyword'>switch</span> (data) {</td></tr>
<tr><td class="num" id="LN930">930</td><td class="line"><span class='directive'>#define CASE_STATEMENT(where, how, within, space_number) \</span></td></tr>
<tr><td class="num" id="LN931">931</td><td class="line">  <span class='directive'>case where + how + within + space_number:              \</span></td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">    <span class='directive'><span class='macro'>STATIC_ASSERT((where &amp; ~kWhereMask) == 0)<span class='expansion'>static_assert((where &amp; ~kWhereMask) == 0, "(where &amp; ~kWhereMask) == 0"<br>)</span></span>;           \</span></td></tr>
<tr><td class="num" id="LN933">933</td><td class="line">    <span class='directive'><span class='macro'>STATIC_ASSERT((how &amp; ~kHowToCodeMask) == 0)<span class='expansion'>static_assert((how &amp; ~kHowToCodeMask) == 0, "(how &amp; ~kHowToCodeMask) == 0"<br>)</span></span>;         \</span></td></tr>
<tr><td class="num" id="LN934">934</td><td class="line">    <span class='directive'><span class='macro'>STATIC_ASSERT((within &amp; ~kWhereToPointMask) == 0)<span class='expansion'>static_assert((within &amp; ~kWhereToPointMask) == 0, "(within &amp; ~kWhereToPointMask) == 0"<br>)</span></span>;   \</span></td></tr>
<tr><td class="num" id="LN935">935</td><td class="line">    <span class='directive'><span class='macro'>STATIC_ASSERT((space_number &amp; ~kSpaceMask) == 0)<span class='expansion'>static_assert((space_number &amp; ~kSpaceMask) == 0, "(space_number &amp; ~kSpaceMask) == 0"<br>)</span></span>;</span></td></tr>
<tr><td class="num" id="LN936">936</td><td class="line"> </td></tr>
<tr><td class="num" id="LN937">937</td><td class="line"><span class='directive'>#define CASE_BODY(where, how, within, space_number_if_any)                     \</span></td></tr>
<tr><td class="num" id="LN938">938</td><td class="line">  <span class='directive'>{                                                                            \</span></td></tr>
<tr><td class="num" id="LN939">939</td><td class="line">    <span class='directive'>bool emit_write_barrier = false;                                           \</span></td></tr>
<tr><td class="num" id="LN940">940</td><td class="line">    <span class='directive'>bool current_was_incremented = false;                                      \</span></td></tr>
<tr><td class="num" id="LN941">941</td><td class="line">    <span class='directive'>int space_number = space_number_if_any == kAnyOldSpace                     \</span></td></tr>
<tr><td class="num" id="LN942">942</td><td class="line">                           <span class='directive'>? (data &amp; kSpaceMask)                               \</span></td></tr>
<tr><td class="num" id="LN943">943</td><td class="line">                           <span class='directive'>: space_number_if_any;                              \</span></td></tr>
<tr><td class="num" id="LN944">944</td><td class="line">    <span class='directive'>if (where == kNewObject &amp;&amp; how == kPlain &amp;&amp; within == kStartOfObject) {    \</span></td></tr>
<tr><td class="num" id="LN945">945</td><td class="line">      <span class='directive'>ReadObject(space_number, current);                                       \</span></td></tr>
<tr><td class="num" id="LN946">946</td><td class="line">      <span class='directive'>emit_write_barrier = (space_number == NEW_SPACE);                        \</span></td></tr>
<tr><td class="num" id="LN947">947</td><td class="line">    <span class='directive'>} else {                                                                   \</span></td></tr>
<tr><td class="num" id="LN948">948</td><td class="line">      <span class='directive'>Object* new_object = <span class='macro'>NULL<span class='expansion'>__null</span></span>; /* May not be a real Object pointer. */       \</span></td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">      <span class='directive'>if (where == kNewObject) {                                               \</span></td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">        <span class='directive'>ReadObject(space_number, &amp;new_object);                                 \</span></td></tr>
<tr><td class="num" id="LN951">951</td><td class="line">      <span class='directive'>} else if (where == kBackref) {                                          \</span></td></tr>
<tr><td class="num" id="LN952">952</td><td class="line">        <span class='directive'>emit_write_barrier = (space_number == NEW_SPACE);                      \</span></td></tr>
<tr><td class="num" id="LN953">953</td><td class="line">        <span class='directive'>new_object = GetBackReferencedObject(data &amp; kSpaceMask);               \</span></td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">      <span class='directive'>} else if (where == kBackrefWithSkip) {                                  \</span></td></tr>
<tr><td class="num" id="LN955">955</td><td class="line">        <span class='directive'>int skip = source_.GetInt();                                           \</span></td></tr>
<tr><td class="num" id="LN956">956</td><td class="line">        <span class='directive'>current = reinterpret_cast&lt;Object**&gt;(                                  \</span></td></tr>
<tr><td class="num" id="LN957">957</td><td class="line">            <span class='directive'>reinterpret_cast&lt;Address&gt;(current) + skip);                        \</span></td></tr>
<tr><td class="num" id="LN958">958</td><td class="line">        <span class='directive'>emit_write_barrier = (space_number == NEW_SPACE);                      \</span></td></tr>
<tr><td class="num" id="LN959">959</td><td class="line">        <span class='directive'>new_object = GetBackReferencedObject(data &amp; kSpaceMask);               \</span></td></tr>
<tr><td class="num" id="LN960">960</td><td class="line">      <span class='directive'>} else if (where == kRootArray) {                                        \</span></td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">        <span class='directive'>int id = source_.GetInt();                                             \</span></td></tr>
<tr><td class="num" id="LN962">962</td><td class="line">        <span class='directive'>Heap::RootListIndex root_index = static_cast&lt;Heap::RootListIndex&gt;(id); \</span></td></tr>
<tr><td class="num" id="LN963">963</td><td class="line">        <span class='directive'>new_object = isolate-&gt;heap()-&gt;root(root_index);                        \</span></td></tr>
<tr><td class="num" id="LN964">964</td><td class="line">        <span class='directive'>emit_write_barrier = isolate-&gt;heap()-&gt;InNewSpace(new_object);          \</span></td></tr>
<tr><td class="num" id="LN965">965</td><td class="line">      <span class='directive'>} else if (where == kPartialSnapshotCache) {                             \</span></td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">        <span class='directive'>int cache_index = source_.GetInt();                                    \</span></td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">        <span class='directive'>new_object = isolate-&gt;partial_snapshot_cache()-&gt;at(cache_index);       \</span></td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">        <span class='directive'>emit_write_barrier = isolate-&gt;heap()-&gt;InNewSpace(new_object);          \</span></td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">      <span class='directive'>} else if (where == kExternalReference) {                                \</span></td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">        <span class='directive'>int skip = source_.GetInt();                                           \</span></td></tr>
<tr><td class="num" id="LN971">971</td><td class="line">        <span class='directive'>current = reinterpret_cast&lt;Object**&gt;(                                  \</span></td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">            <span class='directive'>reinterpret_cast&lt;Address&gt;(current) + skip);                        \</span></td></tr>
<tr><td class="num" id="LN973">973</td><td class="line">        <span class='directive'>int reference_id = source_.GetInt();                                   \</span></td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">        <span class='directive'>Address address = external_reference_table_-&gt;address(reference_id);    \</span></td></tr>
<tr><td class="num" id="LN975">975</td><td class="line">        <span class='directive'>new_object = reinterpret_cast&lt;Object*&gt;(address);                       \</span></td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">      <span class='directive'>} else if (where == kAttachedReference) {                                \</span></td></tr>
<tr><td class="num" id="LN977">977</td><td class="line">        <span class='directive'>int index = source_.GetInt();                                          \</span></td></tr>
<tr><td class="num" id="LN978">978</td><td class="line">        <span class='directive'><span class='macro'>DCHECK(deserializing_user_code() || index == kGlobalProxyReference)<span class='expansion'>do { if ((__builtin_expect(!!(!(deserializing_user_code() || index<br> == kGlobalProxyReference)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 978, "Check failed: %s.", "deserializing_user_code() || index == kGlobalProxyReference"<br>); } } while (0)</span></span>;   \</span></td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">        <span class='directive'>new_object = *attached_objects_[index];                                \</span></td></tr>
<tr><td class="num" id="LN980">980</td><td class="line">        <span class='directive'>emit_write_barrier = isolate-&gt;heap()-&gt;InNewSpace(new_object);          \</span></td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">      <span class='directive'>} else {                                                                 \</span></td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">        <span class='directive'><span class='macro'>DCHECK(where == kBuiltin)<span class='expansion'>do { if ((__builtin_expect(!!(!(where == kBuiltin)), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 982, "Check failed: %s.", "where == kBuiltin"<br>); } } while (0)</span></span>;                                             \</span></td></tr>
<tr><td class="num" id="LN983">983</td><td class="line">        <span class='directive'><span class='macro'>DCHECK(deserializing_user_code())<span class='expansion'>do { if ((__builtin_expect(!!(!(deserializing_user_code())), 0<br>))) { V8_Fatal("../src/snapshot/serialize.cc", 983, "Check failed: %s."<br>, "deserializing_user_code()"); } } while (0)</span></span>;                                     \</span></td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">        <span class='directive'>int builtin_id = source_.GetInt();                                     \</span></td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">        <span class='directive'><span class='macro'>DCHECK_LE(0, builtin_id)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (0), (builtin_id<br>), "0" " " "&lt;=" " " "builtin_id")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 985, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;                                              \</span></td></tr>
<tr><td class="num" id="LN986">986</td><td class="line">        <span class='directive'><span class='macro'>DCHECK_LT(builtin_id, Builtins::builtin_count)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLTImpl( (builtin_id<br>), (Builtins::builtin_count), "builtin_id" " " "&lt;" " " "Builtins::builtin_count"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 986, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;                        \</span></td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">        <span class='directive'>Builtins::Name name = static_cast&lt;Builtins::Name&gt;(builtin_id);         \</span></td></tr>
<tr><td class="num" id="LN988">988</td><td class="line">        <span class='directive'>new_object = isolate-&gt;builtins()-&gt;builtin(name);                       \</span></td></tr>
<tr><td class="num" id="LN989">989</td><td class="line">        <span class='directive'>emit_write_barrier = false;                                            \</span></td></tr>
<tr><td class="num" id="LN990">990</td><td class="line">      <span class='directive'>}                                                                        \</span></td></tr>
<tr><td class="num" id="LN991">991</td><td class="line">      <span class='directive'>if (within == kInnerPointer) {                                           \</span></td></tr>
<tr><td class="num" id="LN992">992</td><td class="line">        <span class='directive'>if (space_number != CODE_SPACE || new_object-&gt;IsCode()) {              \</span></td></tr>
<tr><td class="num" id="LN993">993</td><td class="line">          <span class='directive'>Code* new_code_object = reinterpret_cast&lt;Code*&gt;(new_object);         \</span></td></tr>
<tr><td class="num" id="LN994">994</td><td class="line">          <span class='directive'>new_object =                                                         \</span></td></tr>
<tr><td class="num" id="LN995">995</td><td class="line">              <span class='directive'>reinterpret_cast&lt;Object*&gt;(new_code_object-&gt;instruction_start()); \</span></td></tr>
<tr><td class="num" id="LN996">996</td><td class="line">        <span class='directive'>} else {                                                               \</span></td></tr>
<tr><td class="num" id="LN997">997</td><td class="line">          <span class='directive'><span class='macro'>DCHECK(space_number == CODE_SPACE)<span class='expansion'>do { if ((__builtin_expect(!!(!(space_number == CODE_SPACE)),<br> 0))) { V8_Fatal("../src/snapshot/serialize.cc", 997, "Check failed: %s."<br>, "space_number == CODE_SPACE"); } } while (0)</span></span>;                                  \</span></td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">          <span class='directive'>Cell* cell = Cell::cast(new_object);                                 \</span></td></tr>
<tr><td class="num" id="LN999">999</td><td class="line">          <span class='directive'>new_object = reinterpret_cast&lt;Object*&gt;(cell-&gt;ValueAddress());        \</span></td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line">        <span class='directive'>}                                                                      \</span></td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line">      <span class='directive'>}                                                                        \</span></td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line">      <span class='directive'>if (how == kFromCode) {                                                  \</span></td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line">        <span class='directive'>Address location_of_branch_data = reinterpret_cast&lt;Address&gt;(current);  \</span></td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line">        <span class='directive'>Assembler::deserialization_set_special_target_at(                      \</span></td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line">            <span class='directive'>isolate, location_of_branch_data,                                  \</span></td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line">            <span class='directive'>Code::cast(HeapObject::FromAddress(current_object_address)),       \</span></td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line">            <span class='directive'>reinterpret_cast&lt;Address&gt;(new_object));                            \</span></td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line">        <span class='directive'>location_of_branch_data += Assembler::kSpecialTargetSize;              \</span></td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line">        <span class='directive'>current = reinterpret_cast&lt;Object**&gt;(location_of_branch_data);         \</span></td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line">        <span class='directive'>current_was_incremented = true;                                        \</span></td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line">      <span class='directive'>} else {                                                                 \</span></td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line">        <span class='directive'>UnalignedCopy(current, &amp;new_object);                                   \</span></td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">      <span class='directive'>}                                                                        \</span></td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">    <span class='directive'>}                                                                          \</span></td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">    <span class='directive'>if (emit_write_barrier &amp;&amp; write_barrier_needed) {                          \</span></td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">      <span class='directive'>Address current_address = reinterpret_cast&lt;Address&gt;(current);            \</span></td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line">      <span class='directive'><span class='macro'>SLOW_DCHECK(isolate-&gt;heap()-&gt;ContainsSlow(current_object_address))<span class='expansion'>do { if ((__builtin_expect(!!(!(!v8::internal::FLAG_enable_slow_asserts<br> || (isolate-&gt;heap()-&gt;ContainsSlow(current_object_address<br>)))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1017, "Check failed: %s."<br>, "!v8::internal::FLAG_enable_slow_asserts || (isolate-&gt;heap()-&gt;ContainsSlow(current_object_address))"<br>); } } while (0)</span></span>;      \</span></td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line">      <span class='directive'>isolate-&gt;heap()-&gt;RecordWrite(                                            \</span></td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line">          <span class='directive'>HeapObject::FromAddress(current_object_address),                     \</span></td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">          <span class='directive'>static_cast&lt;int&gt;(current_address - current_object_address),          \</span></td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">          <span class='directive'>*reinterpret_cast&lt;Object**&gt;(current_address));                       \</span></td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line">    <span class='directive'>}                                                                          \</span></td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line">    <span class='directive'>if (!current_was_incremented) {                                            \</span></td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line">      <span class='directive'>current++;                                                               \</span></td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line">    <span class='directive'>}                                                                          \</span></td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line">    <span class='directive'>break;                                                                     \</span></td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line"><span class='comment'>// This generates a case and a body for the new space (which has to do extra</span></td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line"><span class='comment'>// write barrier handling) and handles the other spaces with fall-through cases</span></td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line"><span class='comment'>// and one body.</span></td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line"><span class='directive'>#define ALL_SPACES(where, how, within)           \</span></td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, NEW_SPACE)  \</span></td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line">  <span class='directive'>CASE_BODY(where, how, within, NEW_SPACE)       \</span></td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, OLD_SPACE)  \</span></td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, CODE_SPACE) \</span></td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, MAP_SPACE)  \</span></td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, LO_SPACE)   \</span></td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line">  <span class='directive'>CASE_BODY(where, how, within, kAnyOldSpace)</span></td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line"><span class='directive'>#define FOUR_CASES(byte_code)             \</span></td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line">  <span class='directive'>case byte_code:                         \</span></td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line">  <span class='directive'>case byte_code + 1:                     \</span></td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line">  <span class='directive'>case byte_code + 2:                     \</span></td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line">  <span class='directive'>case byte_code + 3:</span></td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line"><span class='directive'>#define SIXTEEN_CASES(byte_code)          \</span></td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line">  <span class='directive'>FOUR_CASES(byte_code)                   \</span></td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line">  <span class='directive'>FOUR_CASES(byte_code + 4)               \</span></td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line">  <span class='directive'>FOUR_CASES(byte_code + 8)               \</span></td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line">  <span class='directive'>FOUR_CASES(byte_code + 12)</span></td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line"><span class='directive'>#define SINGLE_CASE(where, how, within, space) \</span></td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line">  <span class='directive'>CASE_STATEMENT(where, how, within, space)    \</span></td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line">  <span class='directive'>CASE_BODY(where, how, within, space)</span></td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line">      <span class='comment'>// Deserialize a new object and write a pointer to it to the current</span></td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line">      <span class='comment'>// object.</span></td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line">      ALL_SPACES(kNewObject, kPlain, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line">      <span class='comment'>// Support for direct instruction pointers in functions.  It's an inner</span></td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line">      <span class='comment'>// pointer because it points at the entry point, not at the start of the</span></td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line">      <span class='comment'>// code object.</span></td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line">      SINGLE_CASE(kNewObject, kPlain, kInnerPointer, CODE_SPACE)</td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line">      <span class='comment'>// Deserialize a new code object and write a pointer to its first</span></td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line">      <span class='comment'>// instruction to the current code object.</span></td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line">      ALL_SPACES(kNewObject, kFromCode, kInnerPointer)</td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line">      <span class='comment'>// Find a recently deserialized object using its offset from the current</span></td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line">      <span class='comment'>// allocation point and write a pointer to it to the current object.</span></td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line">      ALL_SPACES(kBackref, kPlain, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line">      ALL_SPACES(kBackrefWithSkip, kPlain, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line"><span class='directive'>#if defined(V8_TARGET_ARCH_MIPS) || defined(V8_TARGET_ARCH_MIPS64) || \</span></td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line">    <span class='directive'>defined(V8_TARGET_ARCH_PPC) || <span class='macro'>V8_EMBEDDED_CONSTANT_POOL<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line">      <span class='comment'>// Deserialize a new object from pointer found in code and write</span></td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line">      <span class='comment'>// a pointer to it to the current object. Required only for MIPS, PPC or</span></td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line">      <span class='comment'>// ARM with embedded constant pool, and omitted on the other architectures</span></td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line">      <span class='comment'>// because it is fully unrolled and would cause bloat.</span></td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line">      ALL_SPACES(kNewObject, kFromCode, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line">      <span class='comment'>// Find a recently deserialized code object using its offset from the</span></td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line">      <span class='comment'>// current allocation point and write a pointer to it to the current</span></td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">      <span class='comment'>// object. Required only for MIPS, PPC or ARM with embedded constant pool.</span></td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line">      ALL_SPACES(kBackref, kFromCode, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">      ALL_SPACES(kBackrefWithSkip, kFromCode, kStartOfObject)</td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">      <span class='comment'>// Find a recently deserialized code object using its offset from the</span></td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">      <span class='comment'>// current allocation point and write a pointer to its first instruction</span></td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line">      <span class='comment'>// to the current code object or the instruction pointer in a function</span></td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">      <span class='comment'>// object.</span></td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line">      ALL_SPACES(kBackref, kFromCode, kInnerPointer)</td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">      ALL_SPACES(kBackrefWithSkip, kFromCode, kInnerPointer)</td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line">      ALL_SPACES(kBackref, kPlain, kInnerPointer)</td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">      ALL_SPACES(kBackrefWithSkip, kPlain, kInnerPointer)</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">      <span class='comment'>// Find an object in the roots array and write a pointer to it to the</span></td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line">      <span class='comment'>// current object.</span></td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line">      SINGLE_CASE(kRootArray, kPlain, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line"><span class='directive'>#if defined(V8_TARGET_ARCH_MIPS) || defined(V8_TARGET_ARCH_MIPS64) || \</span></td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line">    <span class='directive'>defined(V8_TARGET_ARCH_PPC) || <span class='macro'>V8_EMBEDDED_CONSTANT_POOL<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line">      <span class='comment'>// Find an object in the roots array and write a pointer to it to in code.</span></td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line">      SINGLE_CASE(kRootArray, kFromCode, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">      <span class='comment'>// Find an object in the partial snapshots cache and write a pointer to it</span></td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line">      <span class='comment'>// to the current object.</span></td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line">      SINGLE_CASE(kPartialSnapshotCache, kPlain, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line">      <span class='comment'>// Find an code entry in the partial snapshots cache and</span></td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">      <span class='comment'>// write a pointer to it to the current object.</span></td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">      SINGLE_CASE(kPartialSnapshotCache, kPlain, kInnerPointer, 0)</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line">      <span class='comment'>// Find an external reference and write a pointer to it to the current</span></td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line">      <span class='comment'>// object.</span></td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line">      SINGLE_CASE(kExternalReference, kPlain, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line">      <span class='comment'>// Find an external reference and write a pointer to it in the current</span></td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line">      <span class='comment'>// code object.</span></td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line">      SINGLE_CASE(kExternalReference, kFromCode, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line">      <span class='comment'>// Find an object in the attached references and write a pointer to it to</span></td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line">      <span class='comment'>// the current object.</span></td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line">      SINGLE_CASE(kAttachedReference, kPlain, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line">      SINGLE_CASE(kAttachedReference, kPlain, kInnerPointer, 0)</td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line">      SINGLE_CASE(kAttachedReference, kFromCode, kInnerPointer, 0)</td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line">      <span class='comment'>// Find a builtin and write a pointer to it to the current object.</span></td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line">      SINGLE_CASE(kBuiltin, kPlain, kStartOfObject, 0)</td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line">      SINGLE_CASE(kBuiltin, kPlain, kInnerPointer, 0)</td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line">      SINGLE_CASE(kBuiltin, kFromCode, kInnerPointer, 0)</td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line"><span class='directive'>#undef CASE_STATEMENT</span></td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line"><span class='directive'>#undef CASE_BODY</span></td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line"><span class='directive'>#undef ALL_SPACES</span></td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line">      <span class='keyword'>case</span> kSkip: {</td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line">        <span class='keyword'>int</span> size = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line">        current = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(</td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line">            <span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(current) + size);</td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">      <span class='keyword'>case</span> kInternalReferenceEncoded:</td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line">      <span class='keyword'>case</span> kInternalReference: {</td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line">        <span class='comment'>// Internal reference address is not encoded via skip, but by offset</span></td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">        <span class='comment'>// from code entry.</span></td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">        <span class='keyword'>int</span> pc_offset = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">        <span class='keyword'>int</span> target_offset = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line">        Code* code =</td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line">            Code::cast(HeapObject::FromAddress(current_object_address));</td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line">        <span class='macro'>DCHECK(0 &lt;= pc_offset &amp;&amp; pc_offset &lt;= code-&gt;instruction_size())<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= pc_offset &amp;&amp; pc_offset<br> &lt;= code-&gt;instruction_size())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1141, "Check failed: %s.", "0 &lt;= pc_offset &amp;&amp; pc_offset &lt;= code-&gt;instruction_size()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line">        <span class='macro'>DCHECK(0 &lt;= target_offset &amp;&amp; target_offset &lt;= code-&gt;instruction_size())<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= target_offset &amp;&amp;<br> target_offset &lt;= code-&gt;instruction_size())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 1142, "Check failed: %s.", "0 &lt;= target_offset &amp;&amp; target_offset &lt;= code-&gt;instruction_size()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line">        Address pc = code-&gt;entry() + pc_offset;</td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line">        Address target = code-&gt;entry() + target_offset;</td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">        Assembler::deserialization_set_target_internal_reference_at(</td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">            isolate, pc, target, data == kInternalReference</td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">                                     ? RelocInfo::INTERNAL_REFERENCE</td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">                                     : RelocInfo::INTERNAL_REFERENCE_ENCODED);</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line">      <span class='keyword'>case</span> kNop:</td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">      <span class='keyword'>case</span> kNextChunk: {</td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line">        <span class='keyword'>int</span> space = source_.Get();</td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">        <span class='macro'>DCHECK(space &lt; kNumberOfPreallocatedSpaces)<span class='expansion'>do { if ((__builtin_expect(!!(!(space &lt; kNumberOfPreallocatedSpaces<br>)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1157, "Check failed: %s."<br>, "space &lt; kNumberOfPreallocatedSpaces"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line">        <span class='keyword'>int</span> chunk_index = current_chunk_[space];</td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">        <span class='keyword'>const</span> Heap::Reservation&amp; reservation = reservations_[space];</td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line">        <span class='comment'>// Make sure the current chunk is indeed exhausted.</span></td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line">        <span class='macro'>CHECK_EQ(reservation[chunk_index].end, high_water_[space])<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (reservation<br>[chunk_index].end), (high_water_[space]), "reservation[chunk_index].end"<br> " " "==" " " "high_water_[space]")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1161, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line">        <span class='comment'>// Move to next reserved chunk.</span></td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line">        chunk_index = ++current_chunk_[space];</td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line">        <span class='macro'>CHECK_LT(chunk_index, reservation.length())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLTImpl( (chunk_index<br>), (reservation.length()), "chunk_index" " " "&lt;" " " "reservation.length()"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 1164, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line">        high_water_[space] = reservation[chunk_index].start;</td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line">      <span class='keyword'>case</span> kDeferred: {</td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line">        <span class='comment'>// Deferred can only occur right after the heap object header.</span></td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line">        <span class='macro'>DCHECK(current == <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(current_object_address +<span class='expansion'>do { if ((__builtin_expect(!!(!(current == reinterpret_cast&lt;<br>Object**&gt;(current_object_address + kPointerSize))), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 1172, "Check failed: %s."<br>, "current == reinterpret_cast&lt;Object**&gt;(current_object_address + kPointerSize)"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">                                                     <span class='macro'>kPointerSize))<span class='expansion'>do { if ((__builtin_expect(!!(!(current == reinterpret_cast&lt;<br>Object**&gt;(current_object_address + kPointerSize))), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 1172, "Check failed: %s."<br>, "current == reinterpret_cast&lt;Object**&gt;(current_object_address + kPointerSize)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">        HeapObject* obj = HeapObject::FromAddress(current_object_address);</td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">        <span class='comment'>// If the deferred object is a map, its instance type may be used</span></td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">        <span class='comment'>// during deserialization. Initialize it with a temporary value.</span></td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line">        <span class='keyword'>if</span> (obj-&gt;IsMap()) Map::cast(obj)-&gt;set_instance_type(FILLER_TYPE);</td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line">        current = <span class="mrange">limit</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:9ex">Value stored to 'current' is never read</div></td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line">        <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line">      <span class='keyword'>case</span> kSynchronize:</td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line">        <span class='comment'>// If we get here then that indicates that you have a mismatch between</span></td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line">        <span class='comment'>// the number of GC roots when serializing and deserializing.</span></td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line">        <span class='macro'>CHECK(<span class='keyword'>false</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(false)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1184, "Check failed: %s.", "false"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line">      <span class='keyword'>case</span> kNativesStringResource:</td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line">        current = CopyInNativesSource(Natives::GetScriptSource(source_.Get()),</td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line">                                      current);</td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line">      <span class='keyword'>case</span> kExtraNativesStringResource:</td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line">        current = CopyInNativesSource(</td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line">            ExtraNatives::GetScriptSource(source_.Get()), current);</td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line">      <span class='comment'>// Deserialize raw data of variable length.</span></td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line">      <span class='keyword'>case</span> kVariableRawData: {</td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line">        <span class='keyword'>int</span> size_in_bytes = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line">        byte* raw_data_out = <span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(current);</td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line">        source_.CopyRaw(raw_data_out, size_in_bytes);</td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line">      <span class='keyword'>case</span> kVariableRepeat: {</td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line">        <span class='keyword'>int</span> repeats = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line">        Object* object = current[-1];</td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line">        <span class='macro'>DCHECK(!isolate-&gt;heap()-&gt;InNewSpace(object))<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate-&gt;heap()-&gt;InNewSpace<br>(object))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1208<br>, "Check failed: %s.", "!isolate-&gt;heap()-&gt;InNewSpace(object)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line">        <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; repeats; i++) UnalignedCopy(current++, &amp;object);</td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix:</td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix + 1:</td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line">      <span class='keyword'>case</span> kAlignmentPrefix + 2:</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">        SetAlignment(data);</td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line">      <span class='macro'>STATIC_ASSERT(kNumberOfRootArrayConstants == Heap::kOldSpaceRoots)<span class='expansion'>static_assert(kNumberOfRootArrayConstants == Heap::kOldSpaceRoots<br>, "kNumberOfRootArrayConstants == Heap::kOldSpaceRoots")</span></span>;</td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">      <span class='macro'>STATIC_ASSERT(kNumberOfRootArrayConstants == 32)<span class='expansion'>static_assert(kNumberOfRootArrayConstants == 32, "kNumberOfRootArrayConstants == 32"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line">      SIXTEEN_CASES(kRootArrayConstantsWithSkip)</td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line">      SIXTEEN_CASES(kRootArrayConstantsWithSkip + 16) {</td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line">        <span class='keyword'>int</span> skip = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line">        current = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(</td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line">            <span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(current) + skip);</td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line">        <span class='comment'>// Fall through.</span></td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line">      SIXTEEN_CASES(kRootArrayConstants)</td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line">      SIXTEEN_CASES(kRootArrayConstants + 16) {</td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">        <span class='keyword'>int</span> id = data &amp; kRootArrayConstantsMask;</td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line">        Heap::RootListIndex root_index = <span class='keyword'>static_cast</span>&lt;Heap::RootListIndex&gt;(id);</td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line">        Object* object = isolate-&gt;heap()-&gt;root(root_index);</td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line">        <span class='macro'>DCHECK(!isolate-&gt;heap()-&gt;InNewSpace(object))<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate-&gt;heap()-&gt;InNewSpace<br>(object))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1234<br>, "Check failed: %s.", "!isolate-&gt;heap()-&gt;InNewSpace(object)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line">        UnalignedCopy(current++, &amp;object);</td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line">      <span class='macro'>STATIC_ASSERT(kNumberOfHotObjects == 8)<span class='expansion'>static_assert(kNumberOfHotObjects == 8, "kNumberOfHotObjects == 8"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line">      FOUR_CASES(kHotObjectWithSkip)</td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line">      FOUR_CASES(kHotObjectWithSkip + 4) {</td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line">        <span class='keyword'>int</span> skip = source_.GetInt();</td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line">        current = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(</td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line">            <span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(current) + skip);</td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">        <span class='comment'>// Fall through.</span></td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">      FOUR_CASES(kHotObject)</td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">      FOUR_CASES(kHotObject + 4) {</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line">        <span class='keyword'>int</span> index = data &amp; kHotObjectMask;</td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line">        Object* hot_object = hot_objects_.Get(index);</td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">        UnalignedCopy(current, &amp;hot_object);</td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line">        <span class='keyword'>if</span> (write_barrier_needed) {</td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line">          Address current_address = <span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(current);</td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line">          <span class='macro'>SLOW_DCHECK(isolate-&gt;heap()-&gt;ContainsSlow(current_object_address))<span class='expansion'>do { if ((__builtin_expect(!!(!(!v8::internal::FLAG_enable_slow_asserts<br> || (isolate-&gt;heap()-&gt;ContainsSlow(current_object_address<br>)))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1255, "Check failed: %s."<br>, "!v8::internal::FLAG_enable_slow_asserts || (isolate-&gt;heap()-&gt;ContainsSlow(current_object_address))"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line">          isolate-&gt;heap()-&gt;RecordWrite(</td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line">              HeapObject::FromAddress(current_object_address),</td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line">              <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(current_address - current_object_address),</td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line">              hot_object);</td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line">        current++;</td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line">      <span class='comment'>// Deserialize raw data of fixed length from 1 to 32 words.</span></td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line">      <span class='macro'>STATIC_ASSERT(kNumberOfFixedRawData == 32)<span class='expansion'>static_assert(kNumberOfFixedRawData == 32, "kNumberOfFixedRawData == 32"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line">      SIXTEEN_CASES(kFixedRawData)</td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line">      SIXTEEN_CASES(kFixedRawData + 16) {</td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line">        byte* raw_data_out = <span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(current);</td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line">        <span class='keyword'>int</span> size_in_bytes = (data - kFixedRawDataStart) &lt;&lt; kPointerSizeLog2;</td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line">        source_.CopyRaw(raw_data_out, size_in_bytes);</td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line">        current = <span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(raw_data_out + size_in_bytes);</td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line">      <span class='macro'>STATIC_ASSERT(kNumberOfFixedRepeat == 16)<span class='expansion'>static_assert(kNumberOfFixedRepeat == 16, "kNumberOfFixedRepeat == 16"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line">      SIXTEEN_CASES(kFixedRepeat) {</td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line">        <span class='keyword'>int</span> repeats = data - kFixedRepeatStart;</td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line">        Object* object;</td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line">        UnalignedCopy(&amp;object, current - 1);</td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line">        <span class='macro'>DCHECK(!isolate-&gt;heap()-&gt;InNewSpace(object))<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate-&gt;heap()-&gt;InNewSpace<br>(object))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1281<br>, "Check failed: %s.", "!isolate-&gt;heap()-&gt;InNewSpace(object)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line">        <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; repeats; i++) UnalignedCopy(current++, &amp;object);</td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line"><span class='directive'>#undef SIXTEEN_CASES</span></td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line"><span class='directive'>#undef FOUR_CASES</span></td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line"><span class='directive'>#undef SINGLE_CASE</span></td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line">      <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line">        <span class='macro'>CHECK(<span class='keyword'>false</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(false)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1291, "Check failed: %s.", "false"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line">  <span class='macro'>CHECK_EQ(limit, current)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (limit)<br>, (current), "limit" " " "==" " " "current")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1294, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">Serializer::Serializer(Isolate* isolate, SnapshotByteSink* sink)</td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line">    : isolate_(isolate),</td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line">      sink_(sink),</td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line">      external_reference_encoder_(isolate),</td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line">      root_index_map_(isolate),</td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line">      recursion_depth_(0),</td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line">      code_address_map_(<span class='macro'>NULL<span class='expansion'>__null</span></span>),</td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line">      large_objects_total_size_(0),</td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line">      seen_large_objects_index_(0) {</td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line">  <span class='comment'>// The serializer is meant to be used only to generate initial heap images</span></td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line">  <span class='comment'>// from a context in which there is only one isolate.</span></td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kNumberOfPreallocatedSpaces; i++) {</td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line">    pending_chunk_[i] = 0;</td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line">    max_chunk_size_[i] = <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(</td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line">        MemoryAllocator::PageAreaSize(<span class='keyword'>static_cast</span>&lt;AllocationSpace&gt;(i)));</td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line"><span class='directive'>#ifdef <span class='macro'>OBJECT_PRINT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line">  <span class='keyword'>if</span> (FLAG_serialization_statistics) {</td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line">    instance_type_count_ = NewArray&lt;<span class='keyword'>int</span>&gt;(kInstanceTypes);</td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line">    instance_type_size_ = NewArray&lt;size_t&gt;(kInstanceTypes);</td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kInstanceTypes; i++) {</td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line">      instance_type_count_[i] = 0;</td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line">      instance_type_size_[i] = 0;</td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line">    instance_type_count_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line">    instance_type_size_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line"><span class='directive'>#endif  // OBJECT_PRINT</span></td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line">Serializer::~Serializer() {</td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line">  <span class='keyword'>if</span> (code_address_map_ != <span class='macro'>NULL<span class='expansion'>__null</span></span>) <span class='keyword'>delete</span> code_address_map_;</td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line"><span class='directive'>#ifdef <span class='macro'>OBJECT_PRINT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line">  <span class='keyword'>if</span> (instance_type_count_ != <span class='macro'>NULL<span class='expansion'>__null</span></span>) {</td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line">    DeleteArray(instance_type_count_);</td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line">    DeleteArray(instance_type_size_);</td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line"><span class='directive'>#endif  // OBJECT_PRINT</span></td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line"><span class='directive'>#ifdef <span class='macro'>OBJECT_PRINT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line"><span class='keyword'>void</span> Serializer::CountInstanceType(Map* map, <span class='keyword'>int</span> size) {</td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line">  <span class='keyword'>int</span> instance_type = map-&gt;instance_type();</td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line">  instance_type_count_[instance_type]++;</td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line">  instance_type_size_[instance_type] += size;</td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line"><span class='directive'>#endif  // OBJECT_PRINT</span></td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line"><span class='keyword'>void</span> Serializer::OutputStatistics(<span class='keyword'>const</span> <span class='keyword'>char</span>* name) {</td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line">  <span class='keyword'>if</span> (!FLAG_serialization_statistics) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line">  PrintF(<span class='string_literal'>"%s:\n"</span>, name);</td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line">  PrintF(<span class='string_literal'>"  Spaces (bytes):\n"</span>);</td></tr>
<tr><td class="num" id="LN1356">1356</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> space = 0; space &lt; kNumberOfSpaces; space++) {</td></tr>
<tr><td class="num" id="LN1357">1357</td><td class="line">    PrintF(<span class='string_literal'>"%16s"</span>, AllocationSpaceName(<span class='keyword'>static_cast</span>&lt;AllocationSpace&gt;(space)));</td></tr>
<tr><td class="num" id="LN1358">1358</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1359">1359</td><td class="line">  PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1360">1360</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> space = 0; space &lt; kNumberOfPreallocatedSpaces; space++) {</td></tr>
<tr><td class="num" id="LN1361">1361</td><td class="line">    size_t s = pending_chunk_[space];</td></tr>
<tr><td class="num" id="LN1362">1362</td><td class="line">    <span class='keyword'>for</span> (uint32_t chunk_size : completed_chunks_[space]) s += chunk_size;</td></tr>
<tr><td class="num" id="LN1363">1363</td><td class="line">    PrintF(<span class='string_literal'>"%16"</span> <span class='macro'>V8_PTR_PREFIX<span class='expansion'>"l"</span></span> <span class='string_literal'>"d"</span>, s);</td></tr>
<tr><td class="num" id="LN1364">1364</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1365">1365</td><td class="line">  PrintF(<span class='string_literal'>"%16d\n"</span>, large_objects_total_size_);</td></tr>
<tr><td class="num" id="LN1366">1366</td><td class="line"><span class='directive'>#ifdef <span class='macro'>OBJECT_PRINT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1367">1367</td><td class="line">  PrintF(<span class='string_literal'>"  Instance types (count and bytes):\n"</span>);</td></tr>
<tr><td class="num" id="LN1368">1368</td><td class="line"><span class='directive'>#define PRINT_INSTANCE_TYPE(Name)                                          \</span></td></tr>
<tr><td class="num" id="LN1369">1369</td><td class="line">  <span class='directive'>if (instance_type_count_[Name]) {                                        \</span></td></tr>
<tr><td class="num" id="LN1370">1370</td><td class="line">    <span class='directive'>PrintF("%10d %10" <span class='macro'>V8_PTR_PREFIX<span class='expansion'>"l"</span></span> "d  %s\n", instance_type_count_[Name], \</span></td></tr>
<tr><td class="num" id="LN1371">1371</td><td class="line">           <span class='directive'>instance_type_size_[Name], #Name);                              \</span></td></tr>
<tr><td class="num" id="LN1372">1372</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr><td class="num" id="LN1373">1373</td><td class="line">  <span class='macro'>INSTANCE_TYPE_LIST(PRINT_INSTANCE_TYPE)<span class='expansion'>PRINT_INSTANCE_TYPE(STRING_TYPE) PRINT_INSTANCE_TYPE(ONE_BYTE_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(CONS_STRING_TYPE) PRINT_INSTANCE_TYPE(CONS_ONE_BYTE_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(SLICED_STRING_TYPE) PRINT_INSTANCE_TYPE<br>(SLICED_ONE_BYTE_STRING_TYPE) PRINT_INSTANCE_TYPE(EXTERNAL_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(EXTERNAL_ONE_BYTE_STRING_TYPE) PRINT_INSTANCE_TYPE<br>(EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE) PRINT_INSTANCE_TYPE<br>(SHORT_EXTERNAL_STRING_TYPE) PRINT_INSTANCE_TYPE(SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE<br>) PRINT_INSTANCE_TYPE(INTERNALIZED_STRING_TYPE) PRINT_INSTANCE_TYPE<br>(ONE_BYTE_INTERNALIZED_STRING_TYPE) PRINT_INSTANCE_TYPE(EXTERNAL_INTERNALIZED_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE<br>) PRINT_INSTANCE_TYPE(SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE<br>) PRINT_INSTANCE_TYPE(SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE<br>) PRINT_INSTANCE_TYPE(SYMBOL_TYPE) PRINT_INSTANCE_TYPE(SIMD128_VALUE_TYPE<br>) PRINT_INSTANCE_TYPE(MAP_TYPE) PRINT_INSTANCE_TYPE(CODE_TYPE<br>) PRINT_INSTANCE_TYPE(ODDBALL_TYPE) PRINT_INSTANCE_TYPE(CELL_TYPE<br>) PRINT_INSTANCE_TYPE(PROPERTY_CELL_TYPE) PRINT_INSTANCE_TYPE<br>(HEAP_NUMBER_TYPE) PRINT_INSTANCE_TYPE(MUTABLE_HEAP_NUMBER_TYPE<br>) PRINT_INSTANCE_TYPE(FOREIGN_TYPE) PRINT_INSTANCE_TYPE(BYTE_ARRAY_TYPE<br>) PRINT_INSTANCE_TYPE(BYTECODE_ARRAY_TYPE) PRINT_INSTANCE_TYPE<br>(FREE_SPACE_TYPE) PRINT_INSTANCE_TYPE(FIXED_INT8_ARRAY_TYPE) PRINT_INSTANCE_TYPE<br>(FIXED_UINT8_ARRAY_TYPE) PRINT_INSTANCE_TYPE(FIXED_INT16_ARRAY_TYPE<br>) PRINT_INSTANCE_TYPE(FIXED_UINT16_ARRAY_TYPE) PRINT_INSTANCE_TYPE<br>(FIXED_INT32_ARRAY_TYPE) PRINT_INSTANCE_TYPE(FIXED_UINT32_ARRAY_TYPE<br>) PRINT_INSTANCE_TYPE(FIXED_FLOAT32_ARRAY_TYPE) PRINT_INSTANCE_TYPE<br>(FIXED_FLOAT64_ARRAY_TYPE) PRINT_INSTANCE_TYPE(FIXED_UINT8_CLAMPED_ARRAY_TYPE<br>) PRINT_INSTANCE_TYPE(FILLER_TYPE) PRINT_INSTANCE_TYPE(ACCESSOR_INFO_TYPE<br>) PRINT_INSTANCE_TYPE(ACCESSOR_PAIR_TYPE) PRINT_INSTANCE_TYPE<br>(ACCESS_CHECK_INFO_TYPE) PRINT_INSTANCE_TYPE(INTERCEPTOR_INFO_TYPE<br>) PRINT_INSTANCE_TYPE(CALL_HANDLER_INFO_TYPE) PRINT_INSTANCE_TYPE<br>(FUNCTION_TEMPLATE_INFO_TYPE) PRINT_INSTANCE_TYPE(OBJECT_TEMPLATE_INFO_TYPE<br>) PRINT_INSTANCE_TYPE(SIGNATURE_INFO_TYPE) PRINT_INSTANCE_TYPE<br>(TYPE_SWITCH_INFO_TYPE) PRINT_INSTANCE_TYPE(ALLOCATION_MEMENTO_TYPE<br>) PRINT_INSTANCE_TYPE(ALLOCATION_SITE_TYPE) PRINT_INSTANCE_TYPE<br>(SCRIPT_TYPE) PRINT_INSTANCE_TYPE(CODE_CACHE_TYPE) PRINT_INSTANCE_TYPE<br>(POLYMORPHIC_CODE_CACHE_TYPE) PRINT_INSTANCE_TYPE(TYPE_FEEDBACK_INFO_TYPE<br>) PRINT_INSTANCE_TYPE(ALIASED_ARGUMENTS_ENTRY_TYPE) PRINT_INSTANCE_TYPE<br>(BOX_TYPE) PRINT_INSTANCE_TYPE(PROTOTYPE_INFO_TYPE) PRINT_INSTANCE_TYPE<br>(SLOPPY_BLOCK_WITH_EVAL_CONTEXT_EXTENSION_TYPE) PRINT_INSTANCE_TYPE<br>(FIXED_ARRAY_TYPE) PRINT_INSTANCE_TYPE(FIXED_DOUBLE_ARRAY_TYPE<br>) PRINT_INSTANCE_TYPE(SHARED_FUNCTION_INFO_TYPE) PRINT_INSTANCE_TYPE<br>(WEAK_CELL_TYPE) PRINT_INSTANCE_TYPE(TRANSITION_ARRAY_TYPE) PRINT_INSTANCE_TYPE<br>(JS_MESSAGE_OBJECT_TYPE) PRINT_INSTANCE_TYPE(JS_VALUE_TYPE) PRINT_INSTANCE_TYPE<br>(JS_DATE_TYPE) PRINT_INSTANCE_TYPE(JS_OBJECT_TYPE) PRINT_INSTANCE_TYPE<br>(JS_CONTEXT_EXTENSION_OBJECT_TYPE) PRINT_INSTANCE_TYPE(JS_GENERATOR_OBJECT_TYPE<br>) PRINT_INSTANCE_TYPE(JS_MODULE_TYPE) PRINT_INSTANCE_TYPE(JS_GLOBAL_OBJECT_TYPE<br>) PRINT_INSTANCE_TYPE(JS_GLOBAL_PROXY_TYPE) PRINT_INSTANCE_TYPE<br>(JS_ARRAY_TYPE) PRINT_INSTANCE_TYPE(JS_ARRAY_BUFFER_TYPE) PRINT_INSTANCE_TYPE<br>(JS_TYPED_ARRAY_TYPE) PRINT_INSTANCE_TYPE(JS_DATA_VIEW_TYPE) PRINT_INSTANCE_TYPE<br>(JS_PROXY_TYPE) PRINT_INSTANCE_TYPE(JS_SET_TYPE) PRINT_INSTANCE_TYPE<br>(JS_MAP_TYPE) PRINT_INSTANCE_TYPE(JS_SET_ITERATOR_TYPE) PRINT_INSTANCE_TYPE<br>(JS_MAP_ITERATOR_TYPE) PRINT_INSTANCE_TYPE(JS_WEAK_MAP_TYPE) PRINT_INSTANCE_TYPE<br>(JS_WEAK_SET_TYPE) PRINT_INSTANCE_TYPE(JS_PROMISE_TYPE) PRINT_INSTANCE_TYPE<br>(JS_REGEXP_TYPE) PRINT_INSTANCE_TYPE(JS_BOUND_FUNCTION_TYPE) PRINT_INSTANCE_TYPE<br>(JS_FUNCTION_TYPE) PRINT_INSTANCE_TYPE(DEBUG_INFO_TYPE) PRINT_INSTANCE_TYPE<br>(BREAK_POINT_INFO_TYPE)</span></span></td></tr>
<tr><td class="num" id="LN1374">1374</td><td class="line"><span class='directive'>#undef PRINT_INSTANCE_TYPE</span></td></tr>
<tr><td class="num" id="LN1375">1375</td><td class="line">  PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1376">1376</td><td class="line"><span class='directive'>#endif  // OBJECT_PRINT</span></td></tr>
<tr><td class="num" id="LN1377">1377</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1378">1378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1379">1379</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1380">1380</td><td class="line"><span class='keyword'>class</span> Serializer::ObjectSerializer : <span class='keyword'>public</span> ObjectVisitor {</td></tr>
<tr><td class="num" id="LN1381">1381</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN1382">1382</td><td class="line">  ObjectSerializer(Serializer* serializer, Object* o, SnapshotByteSink* sink,</td></tr>
<tr><td class="num" id="LN1383">1383</td><td class="line">                   HowToCode how_to_code, WhereToPoint where_to_point)</td></tr>
<tr><td class="num" id="LN1384">1384</td><td class="line">      : serializer_(serializer),</td></tr>
<tr><td class="num" id="LN1385">1385</td><td class="line">        object_(HeapObject::cast(o)),</td></tr>
<tr><td class="num" id="LN1386">1386</td><td class="line">        sink_(sink),</td></tr>
<tr><td class="num" id="LN1387">1387</td><td class="line">        reference_representation_(how_to_code + where_to_point),</td></tr>
<tr><td class="num" id="LN1388">1388</td><td class="line">        bytes_processed_so_far_(0),</td></tr>
<tr><td class="num" id="LN1389">1389</td><td class="line">        is_code_object_(o-&gt;IsCode()),</td></tr>
<tr><td class="num" id="LN1390">1390</td><td class="line">        code_has_been_output_(<span class='keyword'>false</span>) {}</td></tr>
<tr><td class="num" id="LN1391">1391</td><td class="line">  <span class='keyword'>void</span> Serialize();</td></tr>
<tr><td class="num" id="LN1392">1392</td><td class="line">  <span class='keyword'>void</span> SerializeDeferred();</td></tr>
<tr><td class="num" id="LN1393">1393</td><td class="line">  <span class='keyword'>void</span> VisitPointers(Object** start, Object** end) override;</td></tr>
<tr><td class="num" id="LN1394">1394</td><td class="line">  <span class='keyword'>void</span> VisitEmbeddedPointer(RelocInfo* target) override;</td></tr>
<tr><td class="num" id="LN1395">1395</td><td class="line">  <span class='keyword'>void</span> VisitExternalReference(Address* p) override;</td></tr>
<tr><td class="num" id="LN1396">1396</td><td class="line">  <span class='keyword'>void</span> VisitExternalReference(RelocInfo* rinfo) override;</td></tr>
<tr><td class="num" id="LN1397">1397</td><td class="line">  <span class='keyword'>void</span> VisitInternalReference(RelocInfo* rinfo) override;</td></tr>
<tr><td class="num" id="LN1398">1398</td><td class="line">  <span class='keyword'>void</span> VisitCodeTarget(RelocInfo* target) override;</td></tr>
<tr><td class="num" id="LN1399">1399</td><td class="line">  <span class='keyword'>void</span> VisitCodeEntry(Address entry_address) override;</td></tr>
<tr><td class="num" id="LN1400">1400</td><td class="line">  <span class='keyword'>void</span> VisitCell(RelocInfo* rinfo) override;</td></tr>
<tr><td class="num" id="LN1401">1401</td><td class="line">  <span class='keyword'>void</span> VisitRuntimeEntry(RelocInfo* reloc) override;</td></tr>
<tr><td class="num" id="LN1402">1402</td><td class="line">  <span class='comment'>// Used for seralizing the external strings that hold the natives source.</span></td></tr>
<tr><td class="num" id="LN1403">1403</td><td class="line">  <span class='keyword'>void</span> VisitExternalOneByteString(</td></tr>
<tr><td class="num" id="LN1404">1404</td><td class="line">      v8::String::ExternalOneByteStringResource** resource) override;</td></tr>
<tr><td class="num" id="LN1405">1405</td><td class="line">  <span class='comment'>// We can't serialize a heap with external two byte strings.</span></td></tr>
<tr><td class="num" id="LN1406">1406</td><td class="line">  <span class='keyword'>void</span> VisitExternalTwoByteString(</td></tr>
<tr><td class="num" id="LN1407">1407</td><td class="line">      v8::String::ExternalStringResource** resource) override {</td></tr>
<tr><td class="num" id="LN1408">1408</td><td class="line">    <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/snapshot/serialize.cc", 1408, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1409">1409</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1410">1410</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1411">1411</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN1412">1412</td><td class="line">  <span class='keyword'>void</span> SerializePrologue(AllocationSpace space, <span class='keyword'>int</span> size, Map* map);</td></tr>
<tr><td class="num" id="LN1413">1413</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1414">1414</td><td class="line">  <span class='keyword'>bool</span> SerializeExternalNativeSourceString(</td></tr>
<tr><td class="num" id="LN1415">1415</td><td class="line">      <span class='keyword'>int</span> builtin_count,</td></tr>
<tr><td class="num" id="LN1416">1416</td><td class="line">      v8::String::ExternalOneByteStringResource** resource_pointer,</td></tr>
<tr><td class="num" id="LN1417">1417</td><td class="line">      FixedArray* source_cache, <span class='keyword'>int</span> resource_index);</td></tr>
<tr><td class="num" id="LN1418">1418</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1419">1419</td><td class="line">  <span class='keyword'>enum</span> ReturnSkip { kCanReturnSkipInsteadOfSkipping, kIgnoringReturn };</td></tr>
<tr><td class="num" id="LN1420">1420</td><td class="line">  <span class='comment'>// This function outputs or skips the raw data between the last pointer and</span></td></tr>
<tr><td class="num" id="LN1421">1421</td><td class="line">  <span class='comment'>// up to the current position.  It optionally can just return the number of</span></td></tr>
<tr><td class="num" id="LN1422">1422</td><td class="line">  <span class='comment'>// bytes to skip instead of performing a skip instruction, in case the skip</span></td></tr>
<tr><td class="num" id="LN1423">1423</td><td class="line">  <span class='comment'>// can be merged into the next instruction.</span></td></tr>
<tr><td class="num" id="LN1424">1424</td><td class="line">  <span class='keyword'>int</span> OutputRawData(Address up_to, ReturnSkip return_skip = kIgnoringReturn);</td></tr>
<tr><td class="num" id="LN1425">1425</td><td class="line">  <span class='comment'>// External strings are serialized in a way to resemble sequential strings.</span></td></tr>
<tr><td class="num" id="LN1426">1426</td><td class="line">  <span class='keyword'>void</span> SerializeExternalString();</td></tr>
<tr><td class="num" id="LN1427">1427</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1428">1428</td><td class="line">  Address PrepareCode();</td></tr>
<tr><td class="num" id="LN1429">1429</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1430">1430</td><td class="line">  Serializer* serializer_;</td></tr>
<tr><td class="num" id="LN1431">1431</td><td class="line">  HeapObject* object_;</td></tr>
<tr><td class="num" id="LN1432">1432</td><td class="line">  SnapshotByteSink* sink_;</td></tr>
<tr><td class="num" id="LN1433">1433</td><td class="line">  <span class='keyword'>int</span> reference_representation_;</td></tr>
<tr><td class="num" id="LN1434">1434</td><td class="line">  <span class='keyword'>int</span> bytes_processed_so_far_;</td></tr>
<tr><td class="num" id="LN1435">1435</td><td class="line">  <span class='keyword'>bool</span> is_code_object_;</td></tr>
<tr><td class="num" id="LN1436">1436</td><td class="line">  <span class='keyword'>bool</span> code_has_been_output_;</td></tr>
<tr><td class="num" id="LN1437">1437</td><td class="line">};</td></tr>
<tr><td class="num" id="LN1438">1438</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1439">1439</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1440">1440</td><td class="line"><span class='keyword'>void</span> Serializer::SerializeDeferredObjects() {</td></tr>
<tr><td class="num" id="LN1441">1441</td><td class="line">  <span class='keyword'>while</span> (deferred_objects_.length() &gt; 0) {</td></tr>
<tr><td class="num" id="LN1442">1442</td><td class="line">    HeapObject* obj = deferred_objects_.RemoveLast();</td></tr>
<tr><td class="num" id="LN1443">1443</td><td class="line">    ObjectSerializer obj_serializer(<span class='keyword'>this</span>, obj, sink_, kPlain, kStartOfObject);</td></tr>
<tr><td class="num" id="LN1444">1444</td><td class="line">    obj_serializer.SerializeDeferred();</td></tr>
<tr><td class="num" id="LN1445">1445</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1446">1446</td><td class="line">  sink_-&gt;Put(kSynchronize, <span class='string_literal'>"Finished with deferred objects"</span>);</td></tr>
<tr><td class="num" id="LN1447">1447</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1448">1448</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1449">1449</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1450">1450</td><td class="line"><span class='keyword'>void</span> StartupSerializer::SerializeStrongReferences() {</td></tr>
<tr><td class="num" id="LN1451">1451</td><td class="line">  Isolate* isolate = <span class='keyword'>this</span>-&gt;isolate();</td></tr>
<tr><td class="num" id="LN1452">1452</td><td class="line">  <span class='comment'>// No active threads.</span></td></tr>
<tr><td class="num" id="LN1453">1453</td><td class="line">  <span class='macro'>CHECK_NULL(isolate-&gt;thread_manager()-&gt;FirstThreadStateInUse())<span class='expansion'>do { if ((__builtin_expect(!!(!((isolate-&gt;thread_manager()<br>-&gt;FirstThreadStateInUse()) == nullptr)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1453, "Check failed: %s.", "(isolate-&gt;thread_manager()-&gt;FirstThreadStateInUse()) == nullptr"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1454">1454</td><td class="line">  <span class='comment'>// No active or weak handles.</span></td></tr>
<tr><td class="num" id="LN1455">1455</td><td class="line">  <span class='macro'>CHECK(isolate-&gt;handle_scope_implementer()-&gt;blocks()-&gt;is_empty())<span class='expansion'>do { if ((__builtin_expect(!!(!(isolate-&gt;handle_scope_implementer<br>()-&gt;blocks()-&gt;is_empty())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1455, "Check failed: %s.", "isolate-&gt;handle_scope_implementer()-&gt;blocks()-&gt;is_empty()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1456">1456</td><td class="line">  <span class='macro'>CHECK_EQ(0, isolate-&gt;global_handles()-&gt;NumberOfWeakHandles())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (isolate<br>-&gt;global_handles()-&gt;NumberOfWeakHandles()), "0" " " "=="<br> " " "isolate-&gt;global_handles()-&gt;NumberOfWeakHandles()"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 1456, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1457">1457</td><td class="line">  <span class='macro'>CHECK_EQ(0, isolate-&gt;eternal_handles()-&gt;NumberOfHandles())<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (isolate<br>-&gt;eternal_handles()-&gt;NumberOfHandles()), "0" " " "==" " "<br> "isolate-&gt;eternal_handles()-&gt;NumberOfHandles()")) { V8_Fatal<br>("../src/snapshot/serialize.cc", 1457, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1458">1458</td><td class="line">  <span class='comment'>// We don't support serializing installed extensions.</span></td></tr>
<tr><td class="num" id="LN1459">1459</td><td class="line">  <span class='macro'>CHECK(!isolate-&gt;has_installed_extensions())<span class='expansion'>do { if ((__builtin_expect(!!(!(!isolate-&gt;has_installed_extensions<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1459, "Check failed: %s."<br>, "!isolate-&gt;has_installed_extensions()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1460">1460</td><td class="line">  isolate-&gt;heap()-&gt;IterateSmiRoots(<span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN1461">1461</td><td class="line">  isolate-&gt;heap()-&gt;IterateStrongRoots(<span class='keyword'>this</span>, VISIT_ONLY_STRONG);</td></tr>
<tr><td class="num" id="LN1462">1462</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1463">1463</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1464">1464</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1465">1465</td><td class="line"><span class='keyword'>void</span> StartupSerializer::VisitPointers(Object** start, Object** end) {</td></tr>
<tr><td class="num" id="LN1466">1466</td><td class="line">  <span class='keyword'>for</span> (Object** current = start; current &lt; end; current++) {</td></tr>
<tr><td class="num" id="LN1467">1467</td><td class="line">    <span class='keyword'>if</span> (start == isolate()-&gt;heap()-&gt;roots_array_start()) {</td></tr>
<tr><td class="num" id="LN1468">1468</td><td class="line">      root_index_wave_front_ =</td></tr>
<tr><td class="num" id="LN1469">1469</td><td class="line">          Max(root_index_wave_front_, <span class='keyword'>static_cast</span>&lt;intptr_t&gt;(current - start));</td></tr>
<tr><td class="num" id="LN1470">1470</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1471">1471</td><td class="line">    <span class='keyword'>if</span> (ShouldBeSkipped(current)) {</td></tr>
<tr><td class="num" id="LN1472">1472</td><td class="line">      sink_-&gt;Put(kSkip, <span class='string_literal'>"Skip"</span>);</td></tr>
<tr><td class="num" id="LN1473">1473</td><td class="line">      sink_-&gt;PutInt(kPointerSize, <span class='string_literal'>"SkipOneWord"</span>);</td></tr>
<tr><td class="num" id="LN1474">1474</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> ((*current)-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN1475">1475</td><td class="line">      sink_-&gt;Put(kOnePointerRawData, <span class='string_literal'>"Smi"</span>);</td></tr>
<tr><td class="num" id="LN1476">1476</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kPointerSize; i++) {</td></tr>
<tr><td class="num" id="LN1477">1477</td><td class="line">        sink_-&gt;Put(<span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(current)[i], <span class='string_literal'>"Byte"</span>);</td></tr>
<tr><td class="num" id="LN1478">1478</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1479">1479</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1480">1480</td><td class="line">      SerializeObject(HeapObject::cast(*current), kPlain, kStartOfObject, 0);</td></tr>
<tr><td class="num" id="LN1481">1481</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1482">1482</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1483">1483</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1484">1484</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1485">1485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1486">1486</td><td class="line"><span class='keyword'>void</span> PartialSerializer::Serialize(Object** o) {</td></tr>
<tr><td class="num" id="LN1487">1487</td><td class="line">  <span class='keyword'>if</span> ((*o)-&gt;IsContext()) {</td></tr>
<tr><td class="num" id="LN1488">1488</td><td class="line">    Context* context = Context::cast(*o);</td></tr>
<tr><td class="num" id="LN1489">1489</td><td class="line">    global_object_ = context-&gt;global_object();</td></tr>
<tr><td class="num" id="LN1490">1490</td><td class="line">    back_reference_map()-&gt;AddGlobalProxy(context-&gt;global_proxy());</td></tr>
<tr><td class="num" id="LN1491">1491</td><td class="line">    <span class='comment'>// The bootstrap snapshot has a code-stub context. When serializing the</span></td></tr>
<tr><td class="num" id="LN1492">1492</td><td class="line">    <span class='comment'>// partial snapshot, it is chained into the weak context list on the isolate</span></td></tr>
<tr><td class="num" id="LN1493">1493</td><td class="line">    <span class='comment'>// and it's next context pointer may point to the code-stub context.  Clear</span></td></tr>
<tr><td class="num" id="LN1494">1494</td><td class="line">    <span class='comment'>// it before serializing, it will get re-added to the context list</span></td></tr>
<tr><td class="num" id="LN1495">1495</td><td class="line">    <span class='comment'>// explicitly when it's loaded.</span></td></tr>
<tr><td class="num" id="LN1496">1496</td><td class="line">    <span class='keyword'>if</span> (context-&gt;IsNativeContext()) {</td></tr>
<tr><td class="num" id="LN1497">1497</td><td class="line">      context-&gt;set(Context::NEXT_CONTEXT_LINK,</td></tr>
<tr><td class="num" id="LN1498">1498</td><td class="line">                   isolate_-&gt;heap()-&gt;undefined_value());</td></tr>
<tr><td class="num" id="LN1499">1499</td><td class="line">      <span class='macro'>DCHECK(!context-&gt;global_object()-&gt;IsUndefined())<span class='expansion'>do { if ((__builtin_expect(!!(!(!context-&gt;global_object()-&gt;<br>IsUndefined())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1499, "Check failed: %s.", "!context-&gt;global_object()-&gt;IsUndefined()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1500">1500</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1501">1501</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1502">1502</td><td class="line">  VisitPointer(o);</td></tr>
<tr><td class="num" id="LN1503">1503</td><td class="line">  SerializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN1504">1504</td><td class="line">  Pad();</td></tr>
<tr><td class="num" id="LN1505">1505</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1506">1506</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1507">1507</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1508">1508</td><td class="line"><span class='keyword'>bool</span> Serializer::ShouldBeSkipped(Object** current) {</td></tr>
<tr><td class="num" id="LN1509">1509</td><td class="line">  Object** roots = isolate()-&gt;heap()-&gt;roots_array_start();</td></tr>
<tr><td class="num" id="LN1510">1510</td><td class="line">  <span class='keyword'>return</span> current == &amp;roots[Heap::kStoreBufferTopRootIndex]</td></tr>
<tr><td class="num" id="LN1511">1511</td><td class="line">      || current == &amp;roots[Heap::kStackLimitRootIndex]</td></tr>
<tr><td class="num" id="LN1512">1512</td><td class="line">      || current == &amp;roots[Heap::kRealStackLimitRootIndex];</td></tr>
<tr><td class="num" id="LN1513">1513</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1514">1514</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1515">1515</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1516">1516</td><td class="line"><span class='keyword'>void</span> Serializer::VisitPointers(Object** start, Object** end) {</td></tr>
<tr><td class="num" id="LN1517">1517</td><td class="line">  <span class='keyword'>for</span> (Object** current = start; current &lt; end; current++) {</td></tr>
<tr><td class="num" id="LN1518">1518</td><td class="line">    <span class='keyword'>if</span> ((*current)-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN1519">1519</td><td class="line">      sink_-&gt;Put(kOnePointerRawData, <span class='string_literal'>"Smi"</span>);</td></tr>
<tr><td class="num" id="LN1520">1520</td><td class="line">      <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kPointerSize; i++) {</td></tr>
<tr><td class="num" id="LN1521">1521</td><td class="line">        sink_-&gt;Put(<span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(current)[i], <span class='string_literal'>"Byte"</span>);</td></tr>
<tr><td class="num" id="LN1522">1522</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1523">1523</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1524">1524</td><td class="line">      SerializeObject(HeapObject::cast(*current), kPlain, kStartOfObject, 0);</td></tr>
<tr><td class="num" id="LN1525">1525</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1526">1526</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1527">1527</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1528">1528</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1529">1529</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1530">1530</td><td class="line"><span class='keyword'>void</span> Serializer::EncodeReservations(</td></tr>
<tr><td class="num" id="LN1531">1531</td><td class="line">    List&lt;SerializedData::Reservation&gt;* out) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN1532">1532</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; kNumberOfPreallocatedSpaces; i++) {</td></tr>
<tr><td class="num" id="LN1533">1533</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> j = 0; j &lt; completed_chunks_[i].length(); j++) {</td></tr>
<tr><td class="num" id="LN1534">1534</td><td class="line">      out-&gt;Add(SerializedData::Reservation(completed_chunks_[i][j]));</td></tr>
<tr><td class="num" id="LN1535">1535</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1536">1536</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1537">1537</td><td class="line">    <span class='keyword'>if</span> (pending_chunk_[i] &gt; 0 || completed_chunks_[i].length() == 0) {</td></tr>
<tr><td class="num" id="LN1538">1538</td><td class="line">      out-&gt;Add(SerializedData::Reservation(pending_chunk_[i]));</td></tr>
<tr><td class="num" id="LN1539">1539</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1540">1540</td><td class="line">    out-&gt;last().mark_as_last();</td></tr>
<tr><td class="num" id="LN1541">1541</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1542">1542</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1543">1543</td><td class="line">  out-&gt;Add(SerializedData::Reservation(large_objects_total_size_));</td></tr>
<tr><td class="num" id="LN1544">1544</td><td class="line">  out-&gt;last().mark_as_last();</td></tr>
<tr><td class="num" id="LN1545">1545</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1546">1546</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1547">1547</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1548">1548</td><td class="line"><span class='comment'>// This ensures that the partial snapshot cache keeps things alive during GC and</span></td></tr>
<tr><td class="num" id="LN1549">1549</td><td class="line"><span class='comment'>// tracks their movement.  When it is called during serialization of the startup</span></td></tr>
<tr><td class="num" id="LN1550">1550</td><td class="line"><span class='comment'>// snapshot nothing happens.  When the partial (context) snapshot is created,</span></td></tr>
<tr><td class="num" id="LN1551">1551</td><td class="line"><span class='comment'>// this array is populated with the pointers that the partial snapshot will</span></td></tr>
<tr><td class="num" id="LN1552">1552</td><td class="line"><span class='comment'>// need. As that happens we emit serialized objects to the startup snapshot</span></td></tr>
<tr><td class="num" id="LN1553">1553</td><td class="line"><span class='comment'>// that correspond to the elements of this cache array.  On deserialization we</span></td></tr>
<tr><td class="num" id="LN1554">1554</td><td class="line"><span class='comment'>// therefore need to visit the cache array.  This fills it up with pointers to</span></td></tr>
<tr><td class="num" id="LN1555">1555</td><td class="line"><span class='comment'>// deserialized objects.</span></td></tr>
<tr><td class="num" id="LN1556">1556</td><td class="line"><span class='keyword'>void</span> SerializerDeserializer::Iterate(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN1557">1557</td><td class="line">                                     ObjectVisitor* visitor) {</td></tr>
<tr><td class="num" id="LN1558">1558</td><td class="line">  <span class='keyword'>if</span> (isolate-&gt;serializer_enabled()) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1559">1559</td><td class="line">  List&lt;Object*&gt;* cache = isolate-&gt;partial_snapshot_cache();</td></tr>
<tr><td class="num" id="LN1560">1560</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0;; ++i) {</td></tr>
<tr><td class="num" id="LN1561">1561</td><td class="line">    <span class='comment'>// Extend the array ready to get a value when deserializing.</span></td></tr>
<tr><td class="num" id="LN1562">1562</td><td class="line">    <span class='keyword'>if</span> (cache-&gt;length() &lt;= i) cache-&gt;Add(Smi::FromInt(0));</td></tr>
<tr><td class="num" id="LN1563">1563</td><td class="line">    visitor-&gt;VisitPointer(&amp;cache-&gt;at(i));</td></tr>
<tr><td class="num" id="LN1564">1564</td><td class="line">    <span class='comment'>// Sentinel is the undefined object, which is a root so it will not normally</span></td></tr>
<tr><td class="num" id="LN1565">1565</td><td class="line">    <span class='comment'>// be found in the cache.</span></td></tr>
<tr><td class="num" id="LN1566">1566</td><td class="line">    <span class='keyword'>if</span> (cache-&gt;at(i)-&gt;IsUndefined()) <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN1567">1567</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1568">1568</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1569">1569</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1570">1570</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1571">1571</td><td class="line"><span class='keyword'>bool</span> SerializerDeserializer::CanBeDeferred(HeapObject* o) {</td></tr>
<tr><td class="num" id="LN1572">1572</td><td class="line">  <span class='keyword'>return</span> !o-&gt;IsString() &amp;&amp; !o-&gt;IsScript();</td></tr>
<tr><td class="num" id="LN1573">1573</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1574">1574</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1575">1575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1576">1576</td><td class="line"><span class='keyword'>int</span> PartialSerializer::PartialSnapshotCacheIndex(HeapObject* heap_object) {</td></tr>
<tr><td class="num" id="LN1577">1577</td><td class="line">  Isolate* isolate = <span class='keyword'>this</span>-&gt;isolate();</td></tr>
<tr><td class="num" id="LN1578">1578</td><td class="line">  List&lt;Object*&gt;* cache = isolate-&gt;partial_snapshot_cache();</td></tr>
<tr><td class="num" id="LN1579">1579</td><td class="line">  <span class='keyword'>int</span> new_index = cache-&gt;length();</td></tr>
<tr><td class="num" id="LN1580">1580</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1581">1581</td><td class="line">  <span class='keyword'>int</span> index = partial_cache_index_map_.LookupOrInsert(heap_object, new_index);</td></tr>
<tr><td class="num" id="LN1582">1582</td><td class="line">  <span class='keyword'>if</span> (index == PartialCacheIndexMap::kInvalidIndex) {</td></tr>
<tr><td class="num" id="LN1583">1583</td><td class="line">    <span class='comment'>// We didn't find the object in the cache.  So we add it to the cache and</span></td></tr>
<tr><td class="num" id="LN1584">1584</td><td class="line">    <span class='comment'>// then visit the pointer so that it becomes part of the startup snapshot</span></td></tr>
<tr><td class="num" id="LN1585">1585</td><td class="line">    <span class='comment'>// and we can refer to it from the partial snapshot.</span></td></tr>
<tr><td class="num" id="LN1586">1586</td><td class="line">    cache-&gt;Add(heap_object);</td></tr>
<tr><td class="num" id="LN1587">1587</td><td class="line">    startup_serializer_-&gt;VisitPointer(<span class='keyword'>reinterpret_cast</span>&lt;Object**&gt;(&amp;heap_object));</td></tr>
<tr><td class="num" id="LN1588">1588</td><td class="line">    <span class='comment'>// We don't recurse from the startup snapshot generator into the partial</span></td></tr>
<tr><td class="num" id="LN1589">1589</td><td class="line">    <span class='comment'>// snapshot generator.</span></td></tr>
<tr><td class="num" id="LN1590">1590</td><td class="line">    <span class='keyword'>return</span> new_index;</td></tr>
<tr><td class="num" id="LN1591">1591</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1592">1592</td><td class="line">  <span class='keyword'>return</span> index;</td></tr>
<tr><td class="num" id="LN1593">1593</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1594">1594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1595">1595</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1596">1596</td><td class="line"><span class='keyword'>bool</span> PartialSerializer::ShouldBeInThePartialSnapshotCache(HeapObject* o) {</td></tr>
<tr><td class="num" id="LN1597">1597</td><td class="line">  <span class='comment'>// Scripts should be referred only through shared function infos.  We can't</span></td></tr>
<tr><td class="num" id="LN1598">1598</td><td class="line">  <span class='comment'>// allow them to be part of the partial snapshot because they contain a</span></td></tr>
<tr><td class="num" id="LN1599">1599</td><td class="line">  <span class='comment'>// unique ID, and deserializing several partial snapshots containing script</span></td></tr>
<tr><td class="num" id="LN1600">1600</td><td class="line">  <span class='comment'>// would cause dupes.</span></td></tr>
<tr><td class="num" id="LN1601">1601</td><td class="line">  <span class='macro'>DCHECK(!o-&gt;IsScript())<span class='expansion'>do { if ((__builtin_expect(!!(!(!o-&gt;IsScript())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 1601, "Check failed: %s.", "!o-&gt;IsScript()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1602">1602</td><td class="line">  <span class='keyword'>return</span> o-&gt;IsName() || o-&gt;IsSharedFunctionInfo() || o-&gt;IsHeapNumber() ||</td></tr>
<tr><td class="num" id="LN1603">1603</td><td class="line">         o-&gt;IsCode() || o-&gt;IsScopeInfo() || o-&gt;IsAccessorInfo() ||</td></tr>
<tr><td class="num" id="LN1604">1604</td><td class="line">         o-&gt;map() ==</td></tr>
<tr><td class="num" id="LN1605">1605</td><td class="line">             startup_serializer_-&gt;isolate()-&gt;heap()-&gt;fixed_cow_array_map();</td></tr>
<tr><td class="num" id="LN1606">1606</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1607">1607</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1608">1608</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1609">1609</td><td class="line"><span class='directive'>#ifdef <span class='macro'>DEBUG<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1610">1610</td><td class="line"><span class='keyword'>bool</span> Serializer::BackReferenceIsAlreadyAllocated(BackReference reference) {</td></tr>
<tr><td class="num" id="LN1611">1611</td><td class="line">  <span class='macro'>DCHECK(reference.is_valid())<span class='expansion'>do { if ((__builtin_expect(!!(!(reference.is_valid())), 0))) {<br> V8_Fatal("../src/snapshot/serialize.cc", 1611, "Check failed: %s."<br>, "reference.is_valid()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1612">1612</td><td class="line">  <span class='macro'>DCHECK(!reference.is_source())<span class='expansion'>do { if ((__builtin_expect(!!(!(!reference.is_source())), 0))<br>) { V8_Fatal("../src/snapshot/serialize.cc", 1612, "Check failed: %s."<br>, "!reference.is_source()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1613">1613</td><td class="line">  <span class='macro'>DCHECK(!reference.is_global_proxy())<span class='expansion'>do { if ((__builtin_expect(!!(!(!reference.is_global_proxy())<br>), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1613, "Check failed: %s."<br>, "!reference.is_global_proxy()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1614">1614</td><td class="line">  AllocationSpace space = reference.space();</td></tr>
<tr><td class="num" id="LN1615">1615</td><td class="line">  <span class='keyword'>int</span> chunk_index = reference.chunk_index();</td></tr>
<tr><td class="num" id="LN1616">1616</td><td class="line">  <span class='keyword'>if</span> (space == LO_SPACE) {</td></tr>
<tr><td class="num" id="LN1617">1617</td><td class="line">    <span class='keyword'>return</span> chunk_index == 0 &amp;&amp;</td></tr>
<tr><td class="num" id="LN1618">1618</td><td class="line">           reference.large_object_index() &lt; seen_large_objects_index_;</td></tr>
<tr><td class="num" id="LN1619">1619</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (chunk_index == completed_chunks_[space].length()) {</td></tr>
<tr><td class="num" id="LN1620">1620</td><td class="line">    <span class='keyword'>return</span> reference.chunk_offset() &lt; pending_chunk_[space];</td></tr>
<tr><td class="num" id="LN1621">1621</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1622">1622</td><td class="line">    <span class='keyword'>return</span> chunk_index &lt; completed_chunks_[space].length() &amp;&amp;</td></tr>
<tr><td class="num" id="LN1623">1623</td><td class="line">           reference.chunk_offset() &lt; completed_chunks_[space][chunk_index];</td></tr>
<tr><td class="num" id="LN1624">1624</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1625">1625</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1626">1626</td><td class="line"><span class='directive'>#endif  // DEBUG</span></td></tr>
<tr><td class="num" id="LN1627">1627</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1628">1628</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1629">1629</td><td class="line"><span class='keyword'>bool</span> Serializer::SerializeKnownObject(HeapObject* obj, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN1630">1630</td><td class="line">                                      WhereToPoint where_to_point, <span class='keyword'>int</span> skip) {</td></tr>
<tr><td class="num" id="LN1631">1631</td><td class="line">  <span class='keyword'>if</span> (how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) {</td></tr>
<tr><td class="num" id="LN1632">1632</td><td class="line">    <span class='comment'>// Encode a reference to a hot object by its index in the working set.</span></td></tr>
<tr><td class="num" id="LN1633">1633</td><td class="line">    <span class='keyword'>int</span> index = hot_objects_.Find(obj);</td></tr>
<tr><td class="num" id="LN1634">1634</td><td class="line">    <span class='keyword'>if</span> (index != HotObjectsList::kNotFound) {</td></tr>
<tr><td class="num" id="LN1635">1635</td><td class="line">      <span class='macro'>DCHECK(index &gt;= 0 &amp;&amp; index &lt; kNumberOfHotObjects)<span class='expansion'>do { if ((__builtin_expect(!!(!(index &gt;= 0 &amp;&amp; index<br> &lt; kNumberOfHotObjects)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1635, "Check failed: %s.", "index &gt;= 0 &amp;&amp; index &lt; kNumberOfHotObjects"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1636">1636</td><td class="line">      <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN1637">1637</td><td class="line">        PrintF(<span class='string_literal'>" Encoding hot object %d:"</span>, index);</td></tr>
<tr><td class="num" id="LN1638">1638</td><td class="line">        obj-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN1639">1639</td><td class="line">        PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1640">1640</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1641">1641</td><td class="line">      <span class='keyword'>if</span> (skip != 0) {</td></tr>
<tr><td class="num" id="LN1642">1642</td><td class="line">        sink_-&gt;Put(kHotObjectWithSkip + index, <span class='string_literal'>"HotObjectWithSkip"</span>);</td></tr>
<tr><td class="num" id="LN1643">1643</td><td class="line">        sink_-&gt;PutInt(skip, <span class='string_literal'>"HotObjectSkipDistance"</span>);</td></tr>
<tr><td class="num" id="LN1644">1644</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1645">1645</td><td class="line">        sink_-&gt;Put(kHotObject + index, <span class='string_literal'>"HotObject"</span>);</td></tr>
<tr><td class="num" id="LN1646">1646</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1647">1647</td><td class="line">      <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1648">1648</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1649">1649</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1650">1650</td><td class="line">  BackReference back_reference = back_reference_map_.Lookup(obj);</td></tr>
<tr><td class="num" id="LN1651">1651</td><td class="line">  <span class='keyword'>if</span> (back_reference.is_valid()) {</td></tr>
<tr><td class="num" id="LN1652">1652</td><td class="line">    <span class='comment'>// Encode the location of an already deserialized object in order to write</span></td></tr>
<tr><td class="num" id="LN1653">1653</td><td class="line">    <span class='comment'>// its location into a later object.  We can encode the location as an</span></td></tr>
<tr><td class="num" id="LN1654">1654</td><td class="line">    <span class='comment'>// offset fromthe start of the deserialized objects or as an offset</span></td></tr>
<tr><td class="num" id="LN1655">1655</td><td class="line">    <span class='comment'>// backwards from thecurrent allocation pointer.</span></td></tr>
<tr><td class="num" id="LN1656">1656</td><td class="line">    <span class='keyword'>if</span> (back_reference.is_source()) {</td></tr>
<tr><td class="num" id="LN1657">1657</td><td class="line">      FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1658">1658</td><td class="line">      <span class='keyword'>if</span> (FLAG_trace_serializer) PrintF(<span class='string_literal'>" Encoding source object\n"</span>);</td></tr>
<tr><td class="num" id="LN1659">1659</td><td class="line">      <span class='macro'>DCHECK(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject)<span class='expansion'>do { if ((__builtin_expect(!!(!(how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1659, "Check failed: %s.", "how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1660">1660</td><td class="line">      sink_-&gt;Put(kAttachedReference + kPlain + kStartOfObject, <span class='string_literal'>"Source"</span>);</td></tr>
<tr><td class="num" id="LN1661">1661</td><td class="line">      sink_-&gt;PutInt(kSourceObjectReference, <span class='string_literal'>"kSourceObjectReference"</span>);</td></tr>
<tr><td class="num" id="LN1662">1662</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (back_reference.is_global_proxy()) {</td></tr>
<tr><td class="num" id="LN1663">1663</td><td class="line">      FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1664">1664</td><td class="line">      <span class='keyword'>if</span> (FLAG_trace_serializer) PrintF(<span class='string_literal'>" Encoding global proxy\n"</span>);</td></tr>
<tr><td class="num" id="LN1665">1665</td><td class="line">      <span class='macro'>DCHECK(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject)<span class='expansion'>do { if ((__builtin_expect(!!(!(how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1665, "Check failed: %s.", "how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1666">1666</td><td class="line">      sink_-&gt;Put(kAttachedReference + kPlain + kStartOfObject, <span class='string_literal'>"Global Proxy"</span>);</td></tr>
<tr><td class="num" id="LN1667">1667</td><td class="line">      sink_-&gt;PutInt(kGlobalProxyReference, <span class='string_literal'>"kGlobalProxyReference"</span>);</td></tr>
<tr><td class="num" id="LN1668">1668</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1669">1669</td><td class="line">      <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN1670">1670</td><td class="line">        PrintF(<span class='string_literal'>" Encoding back reference to: "</span>);</td></tr>
<tr><td class="num" id="LN1671">1671</td><td class="line">        obj-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN1672">1672</td><td class="line">        PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1673">1673</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1674">1674</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1675">1675</td><td class="line">      PutAlignmentPrefix(obj);</td></tr>
<tr><td class="num" id="LN1676">1676</td><td class="line">      AllocationSpace space = back_reference.space();</td></tr>
<tr><td class="num" id="LN1677">1677</td><td class="line">      <span class='keyword'>if</span> (skip == 0) {</td></tr>
<tr><td class="num" id="LN1678">1678</td><td class="line">        sink_-&gt;Put(kBackref + how_to_code + where_to_point + space, <span class='string_literal'>"BackRef"</span>);</td></tr>
<tr><td class="num" id="LN1679">1679</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1680">1680</td><td class="line">        sink_-&gt;Put(kBackrefWithSkip + how_to_code + where_to_point + space,</td></tr>
<tr><td class="num" id="LN1681">1681</td><td class="line">                   <span class='string_literal'>"BackRefWithSkip"</span>);</td></tr>
<tr><td class="num" id="LN1682">1682</td><td class="line">        sink_-&gt;PutInt(skip, <span class='string_literal'>"BackRefSkipDistance"</span>);</td></tr>
<tr><td class="num" id="LN1683">1683</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN1684">1684</td><td class="line">      PutBackReference(obj, back_reference);</td></tr>
<tr><td class="num" id="LN1685">1685</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1686">1686</td><td class="line">    <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN1687">1687</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1688">1688</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1689">1689</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1690">1690</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1691">1691</td><td class="line">StartupSerializer::StartupSerializer(Isolate* isolate, SnapshotByteSink* sink)</td></tr>
<tr><td class="num" id="LN1692">1692</td><td class="line">    : Serializer(isolate, sink),</td></tr>
<tr><td class="num" id="LN1693">1693</td><td class="line">      root_index_wave_front_(0),</td></tr>
<tr><td class="num" id="LN1694">1694</td><td class="line">      serializing_builtins_(<span class='keyword'>false</span>) {</td></tr>
<tr><td class="num" id="LN1695">1695</td><td class="line">  <span class='comment'>// Clear the cache of objects used by the partial snapshot.  After the</span></td></tr>
<tr><td class="num" id="LN1696">1696</td><td class="line">  <span class='comment'>// strong roots have been serialized we can create a partial snapshot</span></td></tr>
<tr><td class="num" id="LN1697">1697</td><td class="line">  <span class='comment'>// which will repopulate the cache with objects needed by that partial</span></td></tr>
<tr><td class="num" id="LN1698">1698</td><td class="line">  <span class='comment'>// snapshot.</span></td></tr>
<tr><td class="num" id="LN1699">1699</td><td class="line">  isolate-&gt;partial_snapshot_cache()-&gt;Clear();</td></tr>
<tr><td class="num" id="LN1700">1700</td><td class="line">  InitializeCodeAddressMap();</td></tr>
<tr><td class="num" id="LN1701">1701</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1702">1702</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1703">1703</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1704">1704</td><td class="line"><span class='keyword'>void</span> StartupSerializer::SerializeObject(HeapObject* obj, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN1705">1705</td><td class="line">                                        WhereToPoint where_to_point, <span class='keyword'>int</span> skip) {</td></tr>
<tr><td class="num" id="LN1706">1706</td><td class="line">  <span class='macro'>DCHECK(!obj-&gt;IsJSFunction())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsJSFunction())), 0)<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 1706, "Check failed: %s."<br>, "!obj-&gt;IsJSFunction()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1707">1707</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1708">1708</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN1709">1709</td><td class="line">    Code* code = Code::cast(obj);</td></tr>
<tr><td class="num" id="LN1710">1710</td><td class="line">    <span class='comment'>// If the function code is compiled (either as native code or bytecode),</span></td></tr>
<tr><td class="num" id="LN1711">1711</td><td class="line">    <span class='comment'>// replace it with lazy-compile builtin. Only exception is when we are</span></td></tr>
<tr><td class="num" id="LN1712">1712</td><td class="line">    <span class='comment'>// serializing the canonical interpreter-entry-trampoline builtin.</span></td></tr>
<tr><td class="num" id="LN1713">1713</td><td class="line">    <span class='keyword'>if</span> (code-&gt;kind() == Code::FUNCTION ||</td></tr>
<tr><td class="num" id="LN1714">1714</td><td class="line">        (!serializing_builtins_ &amp;&amp; code-&gt;is_interpreter_entry_trampoline())) {</td></tr>
<tr><td class="num" id="LN1715">1715</td><td class="line">      obj = isolate()-&gt;builtins()-&gt;builtin(Builtins::kCompileLazy);</td></tr>
<tr><td class="num" id="LN1716">1716</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1717">1717</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (obj-&gt;IsBytecodeArray()) {</td></tr>
<tr><td class="num" id="LN1718">1718</td><td class="line">    obj = isolate()-&gt;heap()-&gt;undefined_value();</td></tr>
<tr><td class="num" id="LN1719">1719</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1720">1720</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1721">1721</td><td class="line">  <span class='keyword'>int</span> root_index = root_index_map_.Lookup(obj);</td></tr>
<tr><td class="num" id="LN1722">1722</td><td class="line">  <span class='keyword'>bool</span> is_immortal_immovable_root = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN1723">1723</td><td class="line">  <span class='comment'>// We can only encode roots as such if it has already been serialized.</span></td></tr>
<tr><td class="num" id="LN1724">1724</td><td class="line">  <span class='comment'>// That applies to root indices below the wave front.</span></td></tr>
<tr><td class="num" id="LN1725">1725</td><td class="line">  <span class='keyword'>if</span> (root_index != RootIndexMap::kInvalidRootIndex) {</td></tr>
<tr><td class="num" id="LN1726">1726</td><td class="line">    <span class='keyword'>if</span> (root_index &lt; root_index_wave_front_) {</td></tr>
<tr><td class="num" id="LN1727">1727</td><td class="line">      PutRoot(root_index, obj, how_to_code, where_to_point, skip);</td></tr>
<tr><td class="num" id="LN1728">1728</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1729">1729</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1730">1730</td><td class="line">      is_immortal_immovable_root = Heap::RootIsImmortalImmovable(root_index);</td></tr>
<tr><td class="num" id="LN1731">1731</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1732">1732</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1733">1733</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1734">1734</td><td class="line">  <span class='keyword'>if</span> (SerializeKnownObject(obj, how_to_code, where_to_point, skip)) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1735">1735</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1736">1736</td><td class="line">  FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1737">1737</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1738">1738</td><td class="line">  <span class='comment'>// Object has not yet been serialized.  Serialize it here.</span></td></tr>
<tr><td class="num" id="LN1739">1739</td><td class="line">  ObjectSerializer object_serializer(<span class='keyword'>this</span>, obj, sink_, how_to_code,</td></tr>
<tr><td class="num" id="LN1740">1740</td><td class="line">                                     where_to_point);</td></tr>
<tr><td class="num" id="LN1741">1741</td><td class="line">  object_serializer.Serialize();</td></tr>
<tr><td class="num" id="LN1742">1742</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1743">1743</td><td class="line">  <span class='keyword'>if</span> (is_immortal_immovable_root) {</td></tr>
<tr><td class="num" id="LN1744">1744</td><td class="line">    <span class='comment'>// Make sure that the immortal immovable root has been included in the first</span></td></tr>
<tr><td class="num" id="LN1745">1745</td><td class="line">    <span class='comment'>// chunk of its reserved space , so that it is deserialized onto the first</span></td></tr>
<tr><td class="num" id="LN1746">1746</td><td class="line">    <span class='comment'>// page of its space and stays immortal immovable.</span></td></tr>
<tr><td class="num" id="LN1747">1747</td><td class="line">    BackReference ref = back_reference_map_.Lookup(obj);</td></tr>
<tr><td class="num" id="LN1748">1748</td><td class="line">    <span class='macro'>CHECK(ref.is_valid() &amp;&amp; ref.chunk_index() == 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(ref.is_valid() &amp;&amp; ref<br>.chunk_index() == 0)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1748, "Check failed: %s.", "ref.is_valid() &amp;&amp; ref.chunk_index() == 0"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1749">1749</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1750">1750</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1751">1751</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1752">1752</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1753">1753</td><td class="line"><span class='keyword'>void</span> StartupSerializer::SerializeWeakReferencesAndDeferred() {</td></tr>
<tr><td class="num" id="LN1754">1754</td><td class="line">  <span class='comment'>// This phase comes right after the serialization (of the snapshot).</span></td></tr>
<tr><td class="num" id="LN1755">1755</td><td class="line">  <span class='comment'>// After we have done the partial serialization the partial snapshot cache</span></td></tr>
<tr><td class="num" id="LN1756">1756</td><td class="line">  <span class='comment'>// will contain some references needed to decode the partial snapshot.  We</span></td></tr>
<tr><td class="num" id="LN1757">1757</td><td class="line">  <span class='comment'>// add one entry with 'undefined' which is the sentinel that the deserializer</span></td></tr>
<tr><td class="num" id="LN1758">1758</td><td class="line">  <span class='comment'>// uses to know it is done deserializing the array.</span></td></tr>
<tr><td class="num" id="LN1759">1759</td><td class="line">  Object* undefined = isolate()-&gt;heap()-&gt;undefined_value();</td></tr>
<tr><td class="num" id="LN1760">1760</td><td class="line">  VisitPointer(&amp;undefined);</td></tr>
<tr><td class="num" id="LN1761">1761</td><td class="line">  isolate()-&gt;heap()-&gt;IterateWeakRoots(<span class='keyword'>this</span>, VISIT_ALL);</td></tr>
<tr><td class="num" id="LN1762">1762</td><td class="line">  SerializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN1763">1763</td><td class="line">  Pad();</td></tr>
<tr><td class="num" id="LN1764">1764</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1765">1765</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1766">1766</td><td class="line"><span class='keyword'>void</span> StartupSerializer::Synchronize(VisitorSynchronization::SyncTag tag) {</td></tr>
<tr><td class="num" id="LN1767">1767</td><td class="line">  <span class='comment'>// We expect the builtins tag after builtins have been serialized.</span></td></tr>
<tr><td class="num" id="LN1768">1768</td><td class="line">  <span class='macro'>DCHECK(!serializing_builtins_ || tag == VisitorSynchronization::kBuiltins)<span class='expansion'>do { if ((__builtin_expect(!!(!(!serializing_builtins_ || tag<br> == VisitorSynchronization::kBuiltins)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1768, "Check failed: %s.", "!serializing_builtins_ || tag == VisitorSynchronization::kBuiltins"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1769">1769</td><td class="line">  serializing_builtins_ = (tag == VisitorSynchronization::kHandleScope);</td></tr>
<tr><td class="num" id="LN1770">1770</td><td class="line">  sink_-&gt;Put(kSynchronize, <span class='string_literal'>"Synchronize"</span>);</td></tr>
<tr><td class="num" id="LN1771">1771</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1772">1772</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1773">1773</td><td class="line"><span class='keyword'>void</span> Serializer::PutRoot(<span class='keyword'>int</span> root_index,</td></tr>
<tr><td class="num" id="LN1774">1774</td><td class="line">                         HeapObject* object,</td></tr>
<tr><td class="num" id="LN1775">1775</td><td class="line">                         SerializerDeserializer::HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN1776">1776</td><td class="line">                         SerializerDeserializer::WhereToPoint where_to_point,</td></tr>
<tr><td class="num" id="LN1777">1777</td><td class="line">                         <span class='keyword'>int</span> skip) {</td></tr>
<tr><td class="num" id="LN1778">1778</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN1779">1779</td><td class="line">    PrintF(<span class='string_literal'>" Encoding root %d:"</span>, root_index);</td></tr>
<tr><td class="num" id="LN1780">1780</td><td class="line">    object-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN1781">1781</td><td class="line">    PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN1782">1782</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1783">1783</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1784">1784</td><td class="line">  <span class='keyword'>if</span> (how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject &amp;&amp;</td></tr>
<tr><td class="num" id="LN1785">1785</td><td class="line">      root_index &lt; kNumberOfRootArrayConstants &amp;&amp;</td></tr>
<tr><td class="num" id="LN1786">1786</td><td class="line">      !isolate()-&gt;heap()-&gt;InNewSpace(object)) {</td></tr>
<tr><td class="num" id="LN1787">1787</td><td class="line">    <span class='keyword'>if</span> (skip == 0) {</td></tr>
<tr><td class="num" id="LN1788">1788</td><td class="line">      sink_-&gt;Put(kRootArrayConstants + root_index, <span class='string_literal'>"RootConstant"</span>);</td></tr>
<tr><td class="num" id="LN1789">1789</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1790">1790</td><td class="line">      sink_-&gt;Put(kRootArrayConstantsWithSkip + root_index, <span class='string_literal'>"RootConstant"</span>);</td></tr>
<tr><td class="num" id="LN1791">1791</td><td class="line">      sink_-&gt;PutInt(skip, <span class='string_literal'>"SkipInPutRoot"</span>);</td></tr>
<tr><td class="num" id="LN1792">1792</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1793">1793</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1794">1794</td><td class="line">    FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1795">1795</td><td class="line">    sink_-&gt;Put(kRootArray + how_to_code + where_to_point, <span class='string_literal'>"RootSerialization"</span>);</td></tr>
<tr><td class="num" id="LN1796">1796</td><td class="line">    sink_-&gt;PutInt(root_index, <span class='string_literal'>"root_index"</span>);</td></tr>
<tr><td class="num" id="LN1797">1797</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1798">1798</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1799">1799</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1800">1800</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1801">1801</td><td class="line"><span class='keyword'>void</span> Serializer::PutBackReference(HeapObject* object, BackReference reference) {</td></tr>
<tr><td class="num" id="LN1802">1802</td><td class="line">  <span class='macro'>DCHECK(BackReferenceIsAlreadyAllocated(reference))<span class='expansion'>do { if ((__builtin_expect(!!(!(BackReferenceIsAlreadyAllocated<br>(reference))), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1802, "Check failed: %s.", "BackReferenceIsAlreadyAllocated(reference)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1803">1803</td><td class="line">  sink_-&gt;PutInt(reference.reference(), <span class='string_literal'>"BackRefValue"</span>);</td></tr>
<tr><td class="num" id="LN1804">1804</td><td class="line">  hot_objects_.Add(object);</td></tr>
<tr><td class="num" id="LN1805">1805</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1806">1806</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1807">1807</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1808">1808</td><td class="line"><span class='keyword'>int</span> Serializer::PutAlignmentPrefix(HeapObject* object) {</td></tr>
<tr><td class="num" id="LN1809">1809</td><td class="line">  AllocationAlignment alignment = object-&gt;RequiredAlignment();</td></tr>
<tr><td class="num" id="LN1810">1810</td><td class="line">  <span class='keyword'>if</span> (alignment != kWordAligned) {</td></tr>
<tr><td class="num" id="LN1811">1811</td><td class="line">    <span class='macro'>DCHECK(1 &lt;= alignment &amp;&amp; alignment &lt;= 3)<span class='expansion'>do { if ((__builtin_expect(!!(!(1 &lt;= alignment &amp;&amp; alignment<br> &lt;= 3)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1811<br>, "Check failed: %s.", "1 &lt;= alignment &amp;&amp; alignment &lt;= 3"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1812">1812</td><td class="line">    byte prefix = (kAlignmentPrefix - 1) + alignment;</td></tr>
<tr><td class="num" id="LN1813">1813</td><td class="line">    sink_-&gt;Put(prefix, <span class='string_literal'>"Alignment"</span>);</td></tr>
<tr><td class="num" id="LN1814">1814</td><td class="line">    <span class='keyword'>return</span> Heap::GetMaximumFillToAlign(alignment);</td></tr>
<tr><td class="num" id="LN1815">1815</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1816">1816</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1817">1817</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1818">1818</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1819">1819</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1820">1820</td><td class="line"><span class='keyword'>void</span> PartialSerializer::SerializeObject(HeapObject* obj, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN1821">1821</td><td class="line">                                        WhereToPoint where_to_point, <span class='keyword'>int</span> skip) {</td></tr>
<tr><td class="num" id="LN1822">1822</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsMap()) {</td></tr>
<tr><td class="num" id="LN1823">1823</td><td class="line">    <span class='comment'>// The code-caches link to context-specific code objects, which</span></td></tr>
<tr><td class="num" id="LN1824">1824</td><td class="line">    <span class='comment'>// the startup and context serializes cannot currently handle.</span></td></tr>
<tr><td class="num" id="LN1825">1825</td><td class="line">    <span class='macro'>DCHECK(Map::cast(obj)-&gt;code_cache() == obj-&gt;GetHeap()-&gt;empty_fixed_array())<span class='expansion'>do { if ((__builtin_expect(!!(!(Map::cast(obj)-&gt;code_cache<br>() == obj-&gt;GetHeap()-&gt;empty_fixed_array())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 1825, "Check failed: %s.", "Map::cast(obj)-&gt;code_cache() == obj-&gt;GetHeap()-&gt;empty_fixed_array()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1826">1826</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1827">1827</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1828">1828</td><td class="line">  <span class='comment'>// Replace typed arrays by undefined.</span></td></tr>
<tr><td class="num" id="LN1829">1829</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsJSTypedArray()) obj = isolate_-&gt;heap()-&gt;undefined_value();</td></tr>
<tr><td class="num" id="LN1830">1830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1831">1831</td><td class="line">  <span class='keyword'>int</span> root_index = root_index_map_.Lookup(obj);</td></tr>
<tr><td class="num" id="LN1832">1832</td><td class="line">  <span class='keyword'>if</span> (root_index != RootIndexMap::kInvalidRootIndex) {</td></tr>
<tr><td class="num" id="LN1833">1833</td><td class="line">    PutRoot(root_index, obj, how_to_code, where_to_point, skip);</td></tr>
<tr><td class="num" id="LN1834">1834</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1835">1835</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1836">1836</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1837">1837</td><td class="line">  <span class='keyword'>if</span> (ShouldBeInThePartialSnapshotCache(obj)) {</td></tr>
<tr><td class="num" id="LN1838">1838</td><td class="line">    FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1839">1839</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1840">1840</td><td class="line">    <span class='keyword'>int</span> cache_index = PartialSnapshotCacheIndex(obj);</td></tr>
<tr><td class="num" id="LN1841">1841</td><td class="line">    sink_-&gt;Put(kPartialSnapshotCache + how_to_code + where_to_point,</td></tr>
<tr><td class="num" id="LN1842">1842</td><td class="line">               <span class='string_literal'>"PartialSnapshotCache"</span>);</td></tr>
<tr><td class="num" id="LN1843">1843</td><td class="line">    sink_-&gt;PutInt(cache_index, <span class='string_literal'>"partial_snapshot_cache_index"</span>);</td></tr>
<tr><td class="num" id="LN1844">1844</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1845">1845</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1846">1846</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1847">1847</td><td class="line">  <span class='comment'>// Pointers from the partial snapshot to the objects in the startup snapshot</span></td></tr>
<tr><td class="num" id="LN1848">1848</td><td class="line">  <span class='comment'>// should go through the root array or through the partial snapshot cache.</span></td></tr>
<tr><td class="num" id="LN1849">1849</td><td class="line">  <span class='comment'>// If this is not the case you may have to add something to the root array.</span></td></tr>
<tr><td class="num" id="LN1850">1850</td><td class="line">  <span class='macro'>DCHECK(!startup_serializer_-&gt;back_reference_map()-&gt;Lookup(obj).is_valid())<span class='expansion'>do { if ((__builtin_expect(!!(!(!startup_serializer_-&gt;back_reference_map<br>()-&gt;Lookup(obj).is_valid())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1850, "Check failed: %s.", "!startup_serializer_-&gt;back_reference_map()-&gt;Lookup(obj).is_valid()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1851">1851</td><td class="line">  <span class='comment'>// All the internalized strings that the partial snapshot needs should be</span></td></tr>
<tr><td class="num" id="LN1852">1852</td><td class="line">  <span class='comment'>// either in the root table or in the partial snapshot cache.</span></td></tr>
<tr><td class="num" id="LN1853">1853</td><td class="line">  <span class='macro'>DCHECK(!obj-&gt;IsInternalizedString())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsInternalizedString<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1853, "Check failed: %s."<br>, "!obj-&gt;IsInternalizedString()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1854">1854</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1855">1855</td><td class="line">  <span class='keyword'>if</span> (SerializeKnownObject(obj, how_to_code, where_to_point, skip)) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1856">1856</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1857">1857</td><td class="line">  FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN1858">1858</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1859">1859</td><td class="line">  <span class='comment'>// Clear literal boilerplates.</span></td></tr>
<tr><td class="num" id="LN1860">1860</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsJSFunction()) {</td></tr>
<tr><td class="num" id="LN1861">1861</td><td class="line">    FixedArray* literals = JSFunction::cast(obj)-&gt;literals();</td></tr>
<tr><td class="num" id="LN1862">1862</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; literals-&gt;length(); i++) literals-&gt;set_undefined(i);</td></tr>
<tr><td class="num" id="LN1863">1863</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1864">1864</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1865">1865</td><td class="line">  <span class='comment'>// Object has not yet been serialized.  Serialize it here.</span></td></tr>
<tr><td class="num" id="LN1866">1866</td><td class="line">  ObjectSerializer serializer(<span class='keyword'>this</span>, obj, sink_, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN1867">1867</td><td class="line">  serializer.Serialize();</td></tr>
<tr><td class="num" id="LN1868">1868</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1869">1869</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1870">1870</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1871">1871</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::SerializePrologue(AllocationSpace space,</td></tr>
<tr><td class="num" id="LN1872">1872</td><td class="line">                                                     <span class='keyword'>int</span> size, Map* map) {</td></tr>
<tr><td class="num" id="LN1873">1873</td><td class="line">  <span class='keyword'>if</span> (serializer_-&gt;code_address_map_) {</td></tr>
<tr><td class="num" id="LN1874">1874</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* code_name =</td></tr>
<tr><td class="num" id="LN1875">1875</td><td class="line">        serializer_-&gt;code_address_map_-&gt;Lookup(object_-&gt;address());</td></tr>
<tr><td class="num" id="LN1876">1876</td><td class="line">    <span class='macro'>LOG(serializer_-&gt;isolate_,<span class='expansion'>do { v8::internal::Logger* logger = (serializer_-&gt;isolate_<br>)-&gt;logger(); if (logger-&gt;is_logging()) logger-&gt;CodeNameEvent<br>(object_-&gt;address(), sink_-&gt;Position(), code_name); } while<br> (false)</span></span></td></tr>
<tr><td class="num" id="LN1877">1877</td><td class="line">        <span class='macro'>CodeNameEvent(object_-&gt;address(), sink_-&gt;Position(), code_name))<span class='expansion'>do { v8::internal::Logger* logger = (serializer_-&gt;isolate_<br>)-&gt;logger(); if (logger-&gt;is_logging()) logger-&gt;CodeNameEvent<br>(object_-&gt;address(), sink_-&gt;Position(), code_name); } while<br> (false)</span></span>;</td></tr>
<tr><td class="num" id="LN1878">1878</td><td class="line">    <span class='macro'>LOG(serializer_-&gt;isolate_,<span class='expansion'>do { v8::internal::Logger* logger = (serializer_-&gt;isolate_<br>)-&gt;logger(); if (logger-&gt;is_logging()) logger-&gt;SnapshotPositionEvent<br>(object_-&gt;address(), sink_-&gt;Position()); } while (false<br>)</span></span></td></tr>
<tr><td class="num" id="LN1879">1879</td><td class="line">        <span class='macro'>SnapshotPositionEvent(object_-&gt;address(), sink_-&gt;Position()))<span class='expansion'>do { v8::internal::Logger* logger = (serializer_-&gt;isolate_<br>)-&gt;logger(); if (logger-&gt;is_logging()) logger-&gt;SnapshotPositionEvent<br>(object_-&gt;address(), sink_-&gt;Position()); } while (false<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN1880">1880</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1881">1881</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1882">1882</td><td class="line">  BackReference back_reference;</td></tr>
<tr><td class="num" id="LN1883">1883</td><td class="line">  <span class='keyword'>if</span> (space == LO_SPACE) {</td></tr>
<tr><td class="num" id="LN1884">1884</td><td class="line">    sink_-&gt;Put(kNewObject + reference_representation_ + space,</td></tr>
<tr><td class="num" id="LN1885">1885</td><td class="line">               <span class='string_literal'>"NewLargeObject"</span>);</td></tr>
<tr><td class="num" id="LN1886">1886</td><td class="line">    sink_-&gt;PutInt(size &gt;&gt; kObjectAlignmentBits, <span class='string_literal'>"ObjectSizeInWords"</span>);</td></tr>
<tr><td class="num" id="LN1887">1887</td><td class="line">    <span class='keyword'>if</span> (object_-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN1888">1888</td><td class="line">      sink_-&gt;Put(EXECUTABLE, <span class='string_literal'>"executable large object"</span>);</td></tr>
<tr><td class="num" id="LN1889">1889</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1890">1890</td><td class="line">      sink_-&gt;Put(NOT_EXECUTABLE, <span class='string_literal'>"not executable large object"</span>);</td></tr>
<tr><td class="num" id="LN1891">1891</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1892">1892</td><td class="line">    back_reference = serializer_-&gt;AllocateLargeObject(size);</td></tr>
<tr><td class="num" id="LN1893">1893</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1894">1894</td><td class="line">    <span class='keyword'>int</span> fill = serializer_-&gt;PutAlignmentPrefix(object_);</td></tr>
<tr><td class="num" id="LN1895">1895</td><td class="line">    back_reference = serializer_-&gt;Allocate(space, size + fill);</td></tr>
<tr><td class="num" id="LN1896">1896</td><td class="line">    sink_-&gt;Put(kNewObject + reference_representation_ + space, <span class='string_literal'>"NewObject"</span>);</td></tr>
<tr><td class="num" id="LN1897">1897</td><td class="line">    sink_-&gt;PutInt(size &gt;&gt; kObjectAlignmentBits, <span class='string_literal'>"ObjectSizeInWords"</span>);</td></tr>
<tr><td class="num" id="LN1898">1898</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1899">1899</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1900">1900</td><td class="line"><span class='directive'>#ifdef <span class='macro'>OBJECT_PRINT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN1901">1901</td><td class="line">  <span class='keyword'>if</span> (FLAG_serialization_statistics) {</td></tr>
<tr><td class="num" id="LN1902">1902</td><td class="line">    serializer_-&gt;CountInstanceType(map, size);</td></tr>
<tr><td class="num" id="LN1903">1903</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1904">1904</td><td class="line"><span class='directive'>#endif  // OBJECT_PRINT</span></td></tr>
<tr><td class="num" id="LN1905">1905</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1906">1906</td><td class="line">  <span class='comment'>// Mark this object as already serialized.</span></td></tr>
<tr><td class="num" id="LN1907">1907</td><td class="line">  serializer_-&gt;back_reference_map()-&gt;Add(object_, back_reference);</td></tr>
<tr><td class="num" id="LN1908">1908</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1909">1909</td><td class="line">  <span class='comment'>// Serialize the map (first word of the object).</span></td></tr>
<tr><td class="num" id="LN1910">1910</td><td class="line">  serializer_-&gt;SerializeObject(map, kPlain, kStartOfObject, 0);</td></tr>
<tr><td class="num" id="LN1911">1911</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1912">1912</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1913">1913</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1914">1914</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::SerializeExternalString() {</td></tr>
<tr><td class="num" id="LN1915">1915</td><td class="line">  <span class='comment'>// Instead of serializing this as an external string, we serialize</span></td></tr>
<tr><td class="num" id="LN1916">1916</td><td class="line">  <span class='comment'>// an imaginary sequential string with the same content.</span></td></tr>
<tr><td class="num" id="LN1917">1917</td><td class="line">  Isolate* isolate = serializer_-&gt;isolate();</td></tr>
<tr><td class="num" id="LN1918">1918</td><td class="line">  <span class='macro'>DCHECK(object_-&gt;IsExternalString())<span class='expansion'>do { if ((__builtin_expect(!!(!(object_-&gt;IsExternalString(<br>))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 1918, "Check failed: %s."<br>, "object_-&gt;IsExternalString()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1919">1919</td><td class="line">  <span class='macro'>DCHECK(object_-&gt;map() != isolate-&gt;heap()-&gt;native_source_string_map())<span class='expansion'>do { if ((__builtin_expect(!!(!(object_-&gt;map() != isolate-&gt;<br>heap()-&gt;native_source_string_map())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1919, "Check failed: %s.", "object_-&gt;map() != isolate-&gt;heap()-&gt;native_source_string_map()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1920">1920</td><td class="line">  ExternalString* string = ExternalString::cast(object_);</td></tr>
<tr><td class="num" id="LN1921">1921</td><td class="line">  <span class='keyword'>int</span> length = string-&gt;length();</td></tr>
<tr><td class="num" id="LN1922">1922</td><td class="line">  Map* map;</td></tr>
<tr><td class="num" id="LN1923">1923</td><td class="line">  <span class='keyword'>int</span> content_size;</td></tr>
<tr><td class="num" id="LN1924">1924</td><td class="line">  <span class='keyword'>int</span> allocation_size;</td></tr>
<tr><td class="num" id="LN1925">1925</td><td class="line">  <span class='keyword'>const</span> byte* resource;</td></tr>
<tr><td class="num" id="LN1926">1926</td><td class="line">  <span class='comment'>// Find the map and size for the imaginary sequential string.</span></td></tr>
<tr><td class="num" id="LN1927">1927</td><td class="line">  <span class='keyword'>bool</span> internalized = object_-&gt;IsInternalizedString();</td></tr>
<tr><td class="num" id="LN1928">1928</td><td class="line">  <span class='keyword'>if</span> (object_-&gt;IsExternalOneByteString()) {</td></tr>
<tr><td class="num" id="LN1929">1929</td><td class="line">    map = internalized ? isolate-&gt;heap()-&gt;one_byte_internalized_string_map()</td></tr>
<tr><td class="num" id="LN1930">1930</td><td class="line">                       : isolate-&gt;heap()-&gt;one_byte_string_map();</td></tr>
<tr><td class="num" id="LN1931">1931</td><td class="line">    allocation_size = SeqOneByteString::SizeFor(length);</td></tr>
<tr><td class="num" id="LN1932">1932</td><td class="line">    content_size = length * kCharSize;</td></tr>
<tr><td class="num" id="LN1933">1933</td><td class="line">    resource = <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> byte*&gt;(</td></tr>
<tr><td class="num" id="LN1934">1934</td><td class="line">        ExternalOneByteString::cast(string)-&gt;resource()-&gt;data());</td></tr>
<tr><td class="num" id="LN1935">1935</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1936">1936</td><td class="line">    map = internalized ? isolate-&gt;heap()-&gt;internalized_string_map()</td></tr>
<tr><td class="num" id="LN1937">1937</td><td class="line">                       : isolate-&gt;heap()-&gt;string_map();</td></tr>
<tr><td class="num" id="LN1938">1938</td><td class="line">    allocation_size = SeqTwoByteString::SizeFor(length);</td></tr>
<tr><td class="num" id="LN1939">1939</td><td class="line">    content_size = length * kShortSize;</td></tr>
<tr><td class="num" id="LN1940">1940</td><td class="line">    resource = <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> byte*&gt;(</td></tr>
<tr><td class="num" id="LN1941">1941</td><td class="line">        ExternalTwoByteString::cast(string)-&gt;resource()-&gt;data());</td></tr>
<tr><td class="num" id="LN1942">1942</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1943">1943</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1944">1944</td><td class="line">  AllocationSpace space = (allocation_size &gt; Page::kMaxRegularHeapObjectSize)</td></tr>
<tr><td class="num" id="LN1945">1945</td><td class="line">                              ? LO_SPACE</td></tr>
<tr><td class="num" id="LN1946">1946</td><td class="line">                              : OLD_SPACE;</td></tr>
<tr><td class="num" id="LN1947">1947</td><td class="line">  SerializePrologue(space, allocation_size, map);</td></tr>
<tr><td class="num" id="LN1948">1948</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1949">1949</td><td class="line">  <span class='comment'>// Output the rest of the imaginary string.</span></td></tr>
<tr><td class="num" id="LN1950">1950</td><td class="line">  <span class='keyword'>int</span> bytes_to_output = allocation_size - HeapObject::kHeaderSize;</td></tr>
<tr><td class="num" id="LN1951">1951</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1952">1952</td><td class="line">  <span class='comment'>// Output raw data header. Do not bother with common raw length cases here.</span></td></tr>
<tr><td class="num" id="LN1953">1953</td><td class="line">  sink_-&gt;Put(kVariableRawData, <span class='string_literal'>"RawDataForString"</span>);</td></tr>
<tr><td class="num" id="LN1954">1954</td><td class="line">  sink_-&gt;PutInt(bytes_to_output, <span class='string_literal'>"length"</span>);</td></tr>
<tr><td class="num" id="LN1955">1955</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1956">1956</td><td class="line">  <span class='comment'>// Serialize string header (except for map).</span></td></tr>
<tr><td class="num" id="LN1957">1957</td><td class="line">  Address string_start = string-&gt;address();</td></tr>
<tr><td class="num" id="LN1958">1958</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = HeapObject::kHeaderSize; i &lt; SeqString::kHeaderSize; i++) {</td></tr>
<tr><td class="num" id="LN1959">1959</td><td class="line">    sink_-&gt;PutSection(string_start[i], <span class='string_literal'>"StringHeader"</span>);</td></tr>
<tr><td class="num" id="LN1960">1960</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1961">1961</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1962">1962</td><td class="line">  <span class='comment'>// Serialize string content.</span></td></tr>
<tr><td class="num" id="LN1963">1963</td><td class="line">  sink_-&gt;PutRaw(resource, content_size, <span class='string_literal'>"StringContent"</span>);</td></tr>
<tr><td class="num" id="LN1964">1964</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1965">1965</td><td class="line">  <span class='comment'>// Since the allocation size is rounded up to object alignment, there</span></td></tr>
<tr><td class="num" id="LN1966">1966</td><td class="line">  <span class='comment'>// maybe left-over bytes that need to be padded.</span></td></tr>
<tr><td class="num" id="LN1967">1967</td><td class="line">  <span class='keyword'>int</span> padding_size = allocation_size - SeqString::kHeaderSize - content_size;</td></tr>
<tr><td class="num" id="LN1968">1968</td><td class="line">  <span class='macro'>DCHECK(0 &lt;= padding_size &amp;&amp; padding_size &lt; kObjectAlignment)<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= padding_size &amp;&amp;<br> padding_size &lt; kObjectAlignment)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 1968, "Check failed: %s.", "0 &lt;= padding_size &amp;&amp; padding_size &lt; kObjectAlignment"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1969">1969</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; padding_size; i++) sink_-&gt;PutSection(0, <span class='string_literal'>"StringPadding"</span>);</td></tr>
<tr><td class="num" id="LN1970">1970</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1971">1971</td><td class="line">  sink_-&gt;Put(kSkip, <span class='string_literal'>"SkipAfterString"</span>);</td></tr>
<tr><td class="num" id="LN1972">1972</td><td class="line">  sink_-&gt;PutInt(bytes_to_output, <span class='string_literal'>"SkipDistance"</span>);</td></tr>
<tr><td class="num" id="LN1973">1973</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1974">1974</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1975">1975</td><td class="line"><span class='comment'>// Clear and later restore the next link in the weak cell or allocation site.</span></td></tr>
<tr><td class="num" id="LN1976">1976</td><td class="line"><span class='comment'>// TODO(all): replace this with proper iteration of weak slots in serializer.</span></td></tr>
<tr><td class="num" id="LN1977">1977</td><td class="line"><span class='keyword'>class</span> UnlinkWeakNextScope {</td></tr>
<tr><td class="num" id="LN1978">1978</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN1979">1979</td><td class="line">  <span class='keyword'>explicit</span> UnlinkWeakNextScope(HeapObject* object) : object_(<span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1980">1980</td><td class="line">    <span class='keyword'>if</span> (object-&gt;IsWeakCell()) {</td></tr>
<tr><td class="num" id="LN1981">1981</td><td class="line">      object_ = object;</td></tr>
<tr><td class="num" id="LN1982">1982</td><td class="line">      next_ = WeakCell::cast(object)-&gt;next();</td></tr>
<tr><td class="num" id="LN1983">1983</td><td class="line">      WeakCell::cast(object)-&gt;clear_next(object-&gt;GetHeap()-&gt;the_hole_value());</td></tr>
<tr><td class="num" id="LN1984">1984</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (object-&gt;IsAllocationSite()) {</td></tr>
<tr><td class="num" id="LN1985">1985</td><td class="line">      object_ = object;</td></tr>
<tr><td class="num" id="LN1986">1986</td><td class="line">      next_ = AllocationSite::cast(object)-&gt;weak_next();</td></tr>
<tr><td class="num" id="LN1987">1987</td><td class="line">      AllocationSite::cast(object)</td></tr>
<tr><td class="num" id="LN1988">1988</td><td class="line">          -&gt;set_weak_next(object-&gt;GetHeap()-&gt;undefined_value());</td></tr>
<tr><td class="num" id="LN1989">1989</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1990">1990</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN1991">1991</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1992">1992</td><td class="line">  ~UnlinkWeakNextScope() {</td></tr>
<tr><td class="num" id="LN1993">1993</td><td class="line">    <span class='keyword'>if</span> (object_ != <span class='keyword'>nullptr</span>) {</td></tr>
<tr><td class="num" id="LN1994">1994</td><td class="line">      <span class='keyword'>if</span> (object_-&gt;IsWeakCell()) {</td></tr>
<tr><td class="num" id="LN1995">1995</td><td class="line">        WeakCell::cast(object_)-&gt;set_next(next_, UPDATE_WEAK_WRITE_BARRIER);</td></tr>
<tr><td class="num" id="LN1996">1996</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1997">1997</td><td class="line">        AllocationSite::cast(object_)</td></tr>
<tr><td class="num" id="LN1998">1998</td><td class="line">            -&gt;set_weak_next(next_, UPDATE_WEAK_WRITE_BARRIER);</td></tr>
<tr><td class="num" id="LN1999">1999</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2000">2000</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2001">2001</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2002">2002</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2003">2003</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN2004">2004</td><td class="line">  HeapObject* object_;</td></tr>
<tr><td class="num" id="LN2005">2005</td><td class="line">  Object* next_;</td></tr>
<tr><td class="num" id="LN2006">2006</td><td class="line">  DisallowHeapAllocation no_gc_;</td></tr>
<tr><td class="num" id="LN2007">2007</td><td class="line">};</td></tr>
<tr><td class="num" id="LN2008">2008</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2009">2009</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2010">2010</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::Serialize() {</td></tr>
<tr><td class="num" id="LN2011">2011</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2012">2012</td><td class="line">    PrintF(<span class='string_literal'>" Encoding heap object: "</span>);</td></tr>
<tr><td class="num" id="LN2013">2013</td><td class="line">    object_-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN2014">2014</td><td class="line">    PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN2015">2015</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2016">2016</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2017">2017</td><td class="line">  <span class='comment'>// We cannot serialize typed array objects correctly.</span></td></tr>
<tr><td class="num" id="LN2018">2018</td><td class="line">  <span class='macro'>DCHECK(!object_-&gt;IsJSTypedArray())<span class='expansion'>do { if ((__builtin_expect(!!(!(!object_-&gt;IsJSTypedArray()<br>)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2018, "Check failed: %s."<br>, "!object_-&gt;IsJSTypedArray()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2019">2019</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2020">2020</td><td class="line">  <span class='comment'>// We don't expect fillers.</span></td></tr>
<tr><td class="num" id="LN2021">2021</td><td class="line">  <span class='macro'>DCHECK(!object_-&gt;IsFiller())<span class='expansion'>do { if ((__builtin_expect(!!(!(!object_-&gt;IsFiller())), 0)<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 2021, "Check failed: %s."<br>, "!object_-&gt;IsFiller()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2022">2022</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2023">2023</td><td class="line">  <span class='keyword'>if</span> (object_-&gt;IsScript()) {</td></tr>
<tr><td class="num" id="LN2024">2024</td><td class="line">    <span class='comment'>// Clear cached line ends.</span></td></tr>
<tr><td class="num" id="LN2025">2025</td><td class="line">    Object* undefined = serializer_-&gt;isolate()-&gt;heap()-&gt;undefined_value();</td></tr>
<tr><td class="num" id="LN2026">2026</td><td class="line">    Script::cast(object_)-&gt;set_line_ends(undefined);</td></tr>
<tr><td class="num" id="LN2027">2027</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2028">2028</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2029">2029</td><td class="line">  <span class='keyword'>if</span> (object_-&gt;IsExternalString()) {</td></tr>
<tr><td class="num" id="LN2030">2030</td><td class="line">    Heap* heap = serializer_-&gt;isolate()-&gt;heap();</td></tr>
<tr><td class="num" id="LN2031">2031</td><td class="line">    <span class='keyword'>if</span> (object_-&gt;map() != heap-&gt;native_source_string_map()) {</td></tr>
<tr><td class="num" id="LN2032">2032</td><td class="line">      <span class='comment'>// Usually we cannot recreate resources for external strings. To work</span></td></tr>
<tr><td class="num" id="LN2033">2033</td><td class="line">      <span class='comment'>// around this, external strings are serialized to look like ordinary</span></td></tr>
<tr><td class="num" id="LN2034">2034</td><td class="line">      <span class='comment'>// sequential strings.</span></td></tr>
<tr><td class="num" id="LN2035">2035</td><td class="line">      <span class='comment'>// The exception are native source code strings, since we can recreate</span></td></tr>
<tr><td class="num" id="LN2036">2036</td><td class="line">      <span class='comment'>// their resources. In that case we fall through and leave it to</span></td></tr>
<tr><td class="num" id="LN2037">2037</td><td class="line">      <span class='comment'>// VisitExternalOneByteString further down.</span></td></tr>
<tr><td class="num" id="LN2038">2038</td><td class="line">      SerializeExternalString();</td></tr>
<tr><td class="num" id="LN2039">2039</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2040">2040</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2041">2041</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2042">2042</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2043">2043</td><td class="line">  <span class='keyword'>int</span> size = object_-&gt;Size();</td></tr>
<tr><td class="num" id="LN2044">2044</td><td class="line">  Map* map = object_-&gt;map();</td></tr>
<tr><td class="num" id="LN2045">2045</td><td class="line">  AllocationSpace space =</td></tr>
<tr><td class="num" id="LN2046">2046</td><td class="line">      MemoryChunk::FromAddress(object_-&gt;address())-&gt;owner()-&gt;identity();</td></tr>
<tr><td class="num" id="LN2047">2047</td><td class="line">  SerializePrologue(space, size, map);</td></tr>
<tr><td class="num" id="LN2048">2048</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2049">2049</td><td class="line">  <span class='comment'>// Serialize the rest of the object.</span></td></tr>
<tr><td class="num" id="LN2050">2050</td><td class="line">  <span class='macro'>CHECK_EQ(0, bytes_processed_so_far_)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (bytes_processed_so_far_<br>), "0" " " "==" " " "bytes_processed_so_far_")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2050, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2051">2051</td><td class="line">  bytes_processed_so_far_ = kPointerSize;</td></tr>
<tr><td class="num" id="LN2052">2052</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2053">2053</td><td class="line">  RecursionScope recursion(serializer_);</td></tr>
<tr><td class="num" id="LN2054">2054</td><td class="line">  <span class='comment'>// Objects that are immediately post processed during deserialization</span></td></tr>
<tr><td class="num" id="LN2055">2055</td><td class="line">  <span class='comment'>// cannot be deferred, since post processing requires the object content.</span></td></tr>
<tr><td class="num" id="LN2056">2056</td><td class="line">  <span class='keyword'>if</span> (recursion.ExceedsMaximum() &amp;&amp; CanBeDeferred(object_)) {</td></tr>
<tr><td class="num" id="LN2057">2057</td><td class="line">    serializer_-&gt;QueueDeferredObject(object_);</td></tr>
<tr><td class="num" id="LN2058">2058</td><td class="line">    sink_-&gt;Put(kDeferred, <span class='string_literal'>"Deferring object content"</span>);</td></tr>
<tr><td class="num" id="LN2059">2059</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2060">2060</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2061">2061</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2062">2062</td><td class="line">  UnlinkWeakNextScope unlink_weak_next(object_);</td></tr>
<tr><td class="num" id="LN2063">2063</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2064">2064</td><td class="line">  object_-&gt;IterateBody(map-&gt;instance_type(), size, <span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN2065">2065</td><td class="line">  OutputRawData(object_-&gt;address() + size);</td></tr>
<tr><td class="num" id="LN2066">2066</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2067">2067</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2068">2068</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2069">2069</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::SerializeDeferred() {</td></tr>
<tr><td class="num" id="LN2070">2070</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2071">2071</td><td class="line">    PrintF(<span class='string_literal'>" Encoding deferred heap object: "</span>);</td></tr>
<tr><td class="num" id="LN2072">2072</td><td class="line">    object_-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN2073">2073</td><td class="line">    PrintF(<span class='string_literal'>"\n"</span>);</td></tr>
<tr><td class="num" id="LN2074">2074</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2075">2075</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2076">2076</td><td class="line">  <span class='keyword'>int</span> size = object_-&gt;Size();</td></tr>
<tr><td class="num" id="LN2077">2077</td><td class="line">  Map* map = object_-&gt;map();</td></tr>
<tr><td class="num" id="LN2078">2078</td><td class="line">  BackReference reference = serializer_-&gt;back_reference_map()-&gt;Lookup(object_);</td></tr>
<tr><td class="num" id="LN2079">2079</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2080">2080</td><td class="line">  <span class='comment'>// Serialize the rest of the object.</span></td></tr>
<tr><td class="num" id="LN2081">2081</td><td class="line">  <span class='macro'>CHECK_EQ(0, bytes_processed_so_far_)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (bytes_processed_so_far_<br>), "0" " " "==" " " "bytes_processed_so_far_")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2081, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2082">2082</td><td class="line">  bytes_processed_so_far_ = kPointerSize;</td></tr>
<tr><td class="num" id="LN2083">2083</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2084">2084</td><td class="line">  serializer_-&gt;PutAlignmentPrefix(object_);</td></tr>
<tr><td class="num" id="LN2085">2085</td><td class="line">  sink_-&gt;Put(kNewObject + reference.space(), <span class='string_literal'>"deferred object"</span>);</td></tr>
<tr><td class="num" id="LN2086">2086</td><td class="line">  serializer_-&gt;PutBackReference(object_, reference);</td></tr>
<tr><td class="num" id="LN2087">2087</td><td class="line">  sink_-&gt;PutInt(size &gt;&gt; kPointerSizeLog2, <span class='string_literal'>"deferred object size"</span>);</td></tr>
<tr><td class="num" id="LN2088">2088</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2089">2089</td><td class="line">  UnlinkWeakNextScope unlink_weak_next(object_);</td></tr>
<tr><td class="num" id="LN2090">2090</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2091">2091</td><td class="line">  object_-&gt;IterateBody(map-&gt;instance_type(), size, <span class='keyword'>this</span>);</td></tr>
<tr><td class="num" id="LN2092">2092</td><td class="line">  OutputRawData(object_-&gt;address() + size);</td></tr>
<tr><td class="num" id="LN2093">2093</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2094">2094</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2095">2095</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2096">2096</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitPointers(Object** start,</td></tr>
<tr><td class="num" id="LN2097">2097</td><td class="line">                                                 Object** end) {</td></tr>
<tr><td class="num" id="LN2098">2098</td><td class="line">  Object** current = start;</td></tr>
<tr><td class="num" id="LN2099">2099</td><td class="line">  <span class='keyword'>while</span> (current &lt; end) {</td></tr>
<tr><td class="num" id="LN2100">2100</td><td class="line">    <span class='keyword'>while</span> (current &lt; end &amp;&amp; (*current)-&gt;IsSmi()) current++;</td></tr>
<tr><td class="num" id="LN2101">2101</td><td class="line">    <span class='keyword'>if</span> (current &lt; end) OutputRawData(<span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(current));</td></tr>
<tr><td class="num" id="LN2102">2102</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2103">2103</td><td class="line">    <span class='keyword'>while</span> (current &lt; end &amp;&amp; !(*current)-&gt;IsSmi()) {</td></tr>
<tr><td class="num" id="LN2104">2104</td><td class="line">      HeapObject* current_contents = HeapObject::cast(*current);</td></tr>
<tr><td class="num" id="LN2105">2105</td><td class="line">      <span class='keyword'>int</span> root_index = serializer_-&gt;root_index_map()-&gt;Lookup(current_contents);</td></tr>
<tr><td class="num" id="LN2106">2106</td><td class="line">      <span class='comment'>// Repeats are not subject to the write barrier so we can only use</span></td></tr>
<tr><td class="num" id="LN2107">2107</td><td class="line">      <span class='comment'>// immortal immovable root members. They are never in new space.</span></td></tr>
<tr><td class="num" id="LN2108">2108</td><td class="line">      <span class='keyword'>if</span> (current != start &amp;&amp; root_index != RootIndexMap::kInvalidRootIndex &amp;&amp;</td></tr>
<tr><td class="num" id="LN2109">2109</td><td class="line">          Heap::RootIsImmortalImmovable(root_index) &amp;&amp;</td></tr>
<tr><td class="num" id="LN2110">2110</td><td class="line">          current_contents == current[-1]) {</td></tr>
<tr><td class="num" id="LN2111">2111</td><td class="line">        <span class='macro'>DCHECK(!serializer_-&gt;isolate()-&gt;heap()-&gt;InNewSpace(current_contents))<span class='expansion'>do { if ((__builtin_expect(!!(!(!serializer_-&gt;isolate()-&gt;<br>heap()-&gt;InNewSpace(current_contents))), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2111, "Check failed: %s.", "!serializer_-&gt;isolate()-&gt;heap()-&gt;InNewSpace(current_contents)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2112">2112</td><td class="line">        <span class='keyword'>int</span> repeat_count = 1;</td></tr>
<tr><td class="num" id="LN2113">2113</td><td class="line">        <span class='keyword'>while</span> (&amp;current[repeat_count] &lt; end - 1 &amp;&amp;</td></tr>
<tr><td class="num" id="LN2114">2114</td><td class="line">               current[repeat_count] == current_contents) {</td></tr>
<tr><td class="num" id="LN2115">2115</td><td class="line">          repeat_count++;</td></tr>
<tr><td class="num" id="LN2116">2116</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2117">2117</td><td class="line">        current += repeat_count;</td></tr>
<tr><td class="num" id="LN2118">2118</td><td class="line">        bytes_processed_so_far_ += repeat_count * kPointerSize;</td></tr>
<tr><td class="num" id="LN2119">2119</td><td class="line">        <span class='keyword'>if</span> (repeat_count &gt; kNumberOfFixedRepeat) {</td></tr>
<tr><td class="num" id="LN2120">2120</td><td class="line">          sink_-&gt;Put(kVariableRepeat, <span class='string_literal'>"VariableRepeat"</span>);</td></tr>
<tr><td class="num" id="LN2121">2121</td><td class="line">          sink_-&gt;PutInt(repeat_count, <span class='string_literal'>"repeat count"</span>);</td></tr>
<tr><td class="num" id="LN2122">2122</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2123">2123</td><td class="line">          sink_-&gt;Put(kFixedRepeatStart + repeat_count, <span class='string_literal'>"FixedRepeat"</span>);</td></tr>
<tr><td class="num" id="LN2124">2124</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN2125">2125</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2126">2126</td><td class="line">        serializer_-&gt;SerializeObject(</td></tr>
<tr><td class="num" id="LN2127">2127</td><td class="line">                current_contents, kPlain, kStartOfObject, 0);</td></tr>
<tr><td class="num" id="LN2128">2128</td><td class="line">        bytes_processed_so_far_ += kPointerSize;</td></tr>
<tr><td class="num" id="LN2129">2129</td><td class="line">        current++;</td></tr>
<tr><td class="num" id="LN2130">2130</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2131">2131</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2132">2132</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2133">2133</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2134">2134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2135">2135</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2136">2136</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitEmbeddedPointer(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2137">2137</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(rinfo-&gt;target_address_address(),</td></tr>
<tr><td class="num" id="LN2138">2138</td><td class="line">                           kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2139">2139</td><td class="line">  HowToCode how_to_code = rinfo-&gt;IsCodedSpecially() ? kFromCode : kPlain;</td></tr>
<tr><td class="num" id="LN2140">2140</td><td class="line">  Object* object = rinfo-&gt;target_object();</td></tr>
<tr><td class="num" id="LN2141">2141</td><td class="line">  serializer_-&gt;SerializeObject(HeapObject::cast(object), how_to_code,</td></tr>
<tr><td class="num" id="LN2142">2142</td><td class="line">                               kStartOfObject, skip);</td></tr>
<tr><td class="num" id="LN2143">2143</td><td class="line">  bytes_processed_so_far_ += rinfo-&gt;target_address_size();</td></tr>
<tr><td class="num" id="LN2144">2144</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2145">2145</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2146">2146</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2147">2147</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitExternalReference(Address* p) {</td></tr>
<tr><td class="num" id="LN2148">2148</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(<span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(p),</td></tr>
<tr><td class="num" id="LN2149">2149</td><td class="line">                           kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2150">2150</td><td class="line">  sink_-&gt;Put(kExternalReference + kPlain + kStartOfObject, <span class='string_literal'>"ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2151">2151</td><td class="line">  sink_-&gt;PutInt(skip, <span class='string_literal'>"SkipB4ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2152">2152</td><td class="line">  Address target = *p;</td></tr>
<tr><td class="num" id="LN2153">2153</td><td class="line">  sink_-&gt;PutInt(serializer_-&gt;EncodeExternalReference(target), <span class='string_literal'>"reference id"</span>);</td></tr>
<tr><td class="num" id="LN2154">2154</td><td class="line">  bytes_processed_so_far_ += kPointerSize;</td></tr>
<tr><td class="num" id="LN2155">2155</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2156">2156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2157">2157</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2158">2158</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitExternalReference(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2159">2159</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(rinfo-&gt;target_address_address(),</td></tr>
<tr><td class="num" id="LN2160">2160</td><td class="line">                           kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2161">2161</td><td class="line">  HowToCode how_to_code = rinfo-&gt;IsCodedSpecially() ? kFromCode : kPlain;</td></tr>
<tr><td class="num" id="LN2162">2162</td><td class="line">  sink_-&gt;Put(kExternalReference + how_to_code + kStartOfObject, <span class='string_literal'>"ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2163">2163</td><td class="line">  sink_-&gt;PutInt(skip, <span class='string_literal'>"SkipB4ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2164">2164</td><td class="line">  Address target = rinfo-&gt;target_external_reference();</td></tr>
<tr><td class="num" id="LN2165">2165</td><td class="line">  sink_-&gt;PutInt(serializer_-&gt;EncodeExternalReference(target), <span class='string_literal'>"reference id"</span>);</td></tr>
<tr><td class="num" id="LN2166">2166</td><td class="line">  bytes_processed_so_far_ += rinfo-&gt;target_address_size();</td></tr>
<tr><td class="num" id="LN2167">2167</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2168">2168</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2169">2169</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2170">2170</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitInternalReference(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2171">2171</td><td class="line">  <span class='comment'>// We can only reference to internal references of code that has been output.</span></td></tr>
<tr><td class="num" id="LN2172">2172</td><td class="line">  <span class='macro'>DCHECK(is_code_object_ &amp;&amp; code_has_been_output_)<span class='expansion'>do { if ((__builtin_expect(!!(!(is_code_object_ &amp;&amp; code_has_been_output_<br>)), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2172, "Check failed: %s."<br>, "is_code_object_ &amp;&amp; code_has_been_output_"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2173">2173</td><td class="line">  <span class='comment'>// We do not use skip from last patched pc to find the pc to patch, since</span></td></tr>
<tr><td class="num" id="LN2174">2174</td><td class="line">  <span class='comment'>// target_address_address may not return addresses in ascending order when</span></td></tr>
<tr><td class="num" id="LN2175">2175</td><td class="line">  <span class='comment'>// used for internal references. External references may be stored at the</span></td></tr>
<tr><td class="num" id="LN2176">2176</td><td class="line">  <span class='comment'>// end of the code in the constant pool, whereas internal references are</span></td></tr>
<tr><td class="num" id="LN2177">2177</td><td class="line">  <span class='comment'>// inline. That would cause the skip to be negative. Instead, we store the</span></td></tr>
<tr><td class="num" id="LN2178">2178</td><td class="line">  <span class='comment'>// offset from code entry.</span></td></tr>
<tr><td class="num" id="LN2179">2179</td><td class="line">  Address entry = Code::cast(object_)-&gt;entry();</td></tr>
<tr><td class="num" id="LN2180">2180</td><td class="line">  intptr_t pc_offset = rinfo-&gt;target_internal_reference_address() - entry;</td></tr>
<tr><td class="num" id="LN2181">2181</td><td class="line">  intptr_t target_offset = rinfo-&gt;target_internal_reference() - entry;</td></tr>
<tr><td class="num" id="LN2182">2182</td><td class="line">  <span class='macro'>DCHECK(0 &lt;= pc_offset &amp;&amp;<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= pc_offset &amp;&amp; pc_offset<br> &lt;= Code::cast(object_)-&gt;instruction_size())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2183, "Check failed: %s.", "0 &lt;= pc_offset &amp;&amp; pc_offset &lt;= Code::cast(object_)-&gt;instruction_size()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2183">2183</td><td class="line">         <span class='macro'>pc_offset &lt;= Code::cast(object_)-&gt;instruction_size())<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= pc_offset &amp;&amp; pc_offset<br> &lt;= Code::cast(object_)-&gt;instruction_size())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2183, "Check failed: %s.", "0 &lt;= pc_offset &amp;&amp; pc_offset &lt;= Code::cast(object_)-&gt;instruction_size()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2184">2184</td><td class="line">  <span class='macro'>DCHECK(0 &lt;= target_offset &amp;&amp;<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= target_offset &amp;&amp;<br> target_offset &lt;= Code::cast(object_)-&gt;instruction_size<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2185, "Check failed: %s."<br>, "0 &lt;= target_offset &amp;&amp; target_offset &lt;= Code::cast(object_)-&gt;instruction_size()"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2185">2185</td><td class="line">         <span class='macro'>target_offset &lt;= Code::cast(object_)-&gt;instruction_size())<span class='expansion'>do { if ((__builtin_expect(!!(!(0 &lt;= target_offset &amp;&amp;<br> target_offset &lt;= Code::cast(object_)-&gt;instruction_size<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2185, "Check failed: %s."<br>, "0 &lt;= target_offset &amp;&amp; target_offset &lt;= Code::cast(object_)-&gt;instruction_size()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2186">2186</td><td class="line">  sink_-&gt;Put(rinfo-&gt;rmode() == RelocInfo::INTERNAL_REFERENCE</td></tr>
<tr><td class="num" id="LN2187">2187</td><td class="line">                 ? kInternalReference</td></tr>
<tr><td class="num" id="LN2188">2188</td><td class="line">                 : kInternalReferenceEncoded,</td></tr>
<tr><td class="num" id="LN2189">2189</td><td class="line">             <span class='string_literal'>"InternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2190">2190</td><td class="line">  sink_-&gt;PutInt(<span class='keyword'>static_cast</span>&lt;uintptr_t&gt;(pc_offset), <span class='string_literal'>"internal ref address"</span>);</td></tr>
<tr><td class="num" id="LN2191">2191</td><td class="line">  sink_-&gt;PutInt(<span class='keyword'>static_cast</span>&lt;uintptr_t&gt;(target_offset), <span class='string_literal'>"internal ref value"</span>);</td></tr>
<tr><td class="num" id="LN2192">2192</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2193">2193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2194">2194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2195">2195</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitRuntimeEntry(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2196">2196</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(rinfo-&gt;target_address_address(),</td></tr>
<tr><td class="num" id="LN2197">2197</td><td class="line">                           kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2198">2198</td><td class="line">  HowToCode how_to_code = rinfo-&gt;IsCodedSpecially() ? kFromCode : kPlain;</td></tr>
<tr><td class="num" id="LN2199">2199</td><td class="line">  sink_-&gt;Put(kExternalReference + how_to_code + kStartOfObject, <span class='string_literal'>"ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2200">2200</td><td class="line">  sink_-&gt;PutInt(skip, <span class='string_literal'>"SkipB4ExternalRef"</span>);</td></tr>
<tr><td class="num" id="LN2201">2201</td><td class="line">  Address target = rinfo-&gt;target_address();</td></tr>
<tr><td class="num" id="LN2202">2202</td><td class="line">  sink_-&gt;PutInt(serializer_-&gt;EncodeExternalReference(target), <span class='string_literal'>"reference id"</span>);</td></tr>
<tr><td class="num" id="LN2203">2203</td><td class="line">  bytes_processed_so_far_ += rinfo-&gt;target_address_size();</td></tr>
<tr><td class="num" id="LN2204">2204</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2205">2205</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2206">2206</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2207">2207</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitCodeTarget(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2208">2208</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(rinfo-&gt;target_address_address(),</td></tr>
<tr><td class="num" id="LN2209">2209</td><td class="line">                           kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2210">2210</td><td class="line">  Code* object = Code::GetCodeFromTargetAddress(rinfo-&gt;target_address());</td></tr>
<tr><td class="num" id="LN2211">2211</td><td class="line">  serializer_-&gt;SerializeObject(object, kFromCode, kInnerPointer, skip);</td></tr>
<tr><td class="num" id="LN2212">2212</td><td class="line">  bytes_processed_so_far_ += rinfo-&gt;target_address_size();</td></tr>
<tr><td class="num" id="LN2213">2213</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2214">2214</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2215">2215</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2216">2216</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitCodeEntry(Address entry_address) {</td></tr>
<tr><td class="num" id="LN2217">2217</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(entry_address, kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2218">2218</td><td class="line">  Code* object = Code::cast(Code::GetObjectFromEntryAddress(entry_address));</td></tr>
<tr><td class="num" id="LN2219">2219</td><td class="line">  serializer_-&gt;SerializeObject(object, kPlain, kInnerPointer, skip);</td></tr>
<tr><td class="num" id="LN2220">2220</td><td class="line">  bytes_processed_so_far_ += kPointerSize;</td></tr>
<tr><td class="num" id="LN2221">2221</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2222">2222</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2223">2223</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2224">2224</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitCell(RelocInfo* rinfo) {</td></tr>
<tr><td class="num" id="LN2225">2225</td><td class="line">  <span class='keyword'>int</span> skip = OutputRawData(rinfo-&gt;pc(), kCanReturnSkipInsteadOfSkipping);</td></tr>
<tr><td class="num" id="LN2226">2226</td><td class="line">  Cell* object = Cell::cast(rinfo-&gt;target_cell());</td></tr>
<tr><td class="num" id="LN2227">2227</td><td class="line">  serializer_-&gt;SerializeObject(object, kPlain, kInnerPointer, skip);</td></tr>
<tr><td class="num" id="LN2228">2228</td><td class="line">  bytes_processed_so_far_ += kPointerSize;</td></tr>
<tr><td class="num" id="LN2229">2229</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2230">2230</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2231">2231</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2232">2232</td><td class="line"><span class='keyword'>bool</span> Serializer::ObjectSerializer::SerializeExternalNativeSourceString(</td></tr>
<tr><td class="num" id="LN2233">2233</td><td class="line">    <span class='keyword'>int</span> builtin_count,</td></tr>
<tr><td class="num" id="LN2234">2234</td><td class="line">    v8::String::ExternalOneByteStringResource** resource_pointer,</td></tr>
<tr><td class="num" id="LN2235">2235</td><td class="line">    FixedArray* source_cache, <span class='keyword'>int</span> resource_index) {</td></tr>
<tr><td class="num" id="LN2236">2236</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; builtin_count; i++) {</td></tr>
<tr><td class="num" id="LN2237">2237</td><td class="line">    Object* source = source_cache-&gt;get(i);</td></tr>
<tr><td class="num" id="LN2238">2238</td><td class="line">    <span class='keyword'>if</span> (!source-&gt;IsUndefined()) {</td></tr>
<tr><td class="num" id="LN2239">2239</td><td class="line">      ExternalOneByteString* string = ExternalOneByteString::cast(source);</td></tr>
<tr><td class="num" id="LN2240">2240</td><td class="line">      <span class='keyword'>typedef</span> v8::String::ExternalOneByteStringResource Resource;</td></tr>
<tr><td class="num" id="LN2241">2241</td><td class="line">      <span class='keyword'>const</span> Resource* resource = string-&gt;resource();</td></tr>
<tr><td class="num" id="LN2242">2242</td><td class="line">      <span class='keyword'>if</span> (resource == *resource_pointer) {</td></tr>
<tr><td class="num" id="LN2243">2243</td><td class="line">        sink_-&gt;Put(resource_index, <span class='string_literal'>"NativesStringResource"</span>);</td></tr>
<tr><td class="num" id="LN2244">2244</td><td class="line">        sink_-&gt;PutSection(i, <span class='string_literal'>"NativesStringResourceEnd"</span>);</td></tr>
<tr><td class="num" id="LN2245">2245</td><td class="line">        bytes_processed_so_far_ += <span class='keyword'>sizeof</span>(resource);</td></tr>
<tr><td class="num" id="LN2246">2246</td><td class="line">        <span class='keyword'>return</span> <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2247">2247</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2248">2248</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2249">2249</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2250">2250</td><td class="line">  <span class='keyword'>return</span> <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2251">2251</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2252">2252</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2253">2253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2254">2254</td><td class="line"><span class='keyword'>void</span> Serializer::ObjectSerializer::VisitExternalOneByteString(</td></tr>
<tr><td class="num" id="LN2255">2255</td><td class="line">    v8::String::ExternalOneByteStringResource** resource_pointer) {</td></tr>
<tr><td class="num" id="LN2256">2256</td><td class="line">  Address references_start = <span class='keyword'>reinterpret_cast</span>&lt;Address&gt;(resource_pointer);</td></tr>
<tr><td class="num" id="LN2257">2257</td><td class="line">  OutputRawData(references_start);</td></tr>
<tr><td class="num" id="LN2258">2258</td><td class="line">  <span class='keyword'>if</span> (SerializeExternalNativeSourceString(</td></tr>
<tr><td class="num" id="LN2259">2259</td><td class="line">          Natives::GetBuiltinsCount(), resource_pointer,</td></tr>
<tr><td class="num" id="LN2260">2260</td><td class="line">          Natives::GetSourceCache(serializer_-&gt;isolate()-&gt;heap()),</td></tr>
<tr><td class="num" id="LN2261">2261</td><td class="line">          kNativesStringResource)) {</td></tr>
<tr><td class="num" id="LN2262">2262</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2263">2263</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2264">2264</td><td class="line">  <span class='keyword'>if</span> (SerializeExternalNativeSourceString(</td></tr>
<tr><td class="num" id="LN2265">2265</td><td class="line">          ExtraNatives::GetBuiltinsCount(), resource_pointer,</td></tr>
<tr><td class="num" id="LN2266">2266</td><td class="line">          ExtraNatives::GetSourceCache(serializer_-&gt;isolate()-&gt;heap()),</td></tr>
<tr><td class="num" id="LN2267">2267</td><td class="line">          kExtraNativesStringResource)) {</td></tr>
<tr><td class="num" id="LN2268">2268</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2269">2269</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2270">2270</td><td class="line">  <span class='comment'>// One of the strings in the natives cache should match the resource.  We</span></td></tr>
<tr><td class="num" id="LN2271">2271</td><td class="line">  <span class='comment'>// don't expect any other kinds of external strings here.</span></td></tr>
<tr><td class="num" id="LN2272">2272</td><td class="line">  <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/snapshot/serialize.cc", 2272, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN2273">2273</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2274">2274</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2275">2275</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2276">2276</td><td class="line">Address Serializer::ObjectSerializer::PrepareCode() {</td></tr>
<tr><td class="num" id="LN2277">2277</td><td class="line">  <span class='comment'>// To make snapshots reproducible, we make a copy of the code object</span></td></tr>
<tr><td class="num" id="LN2278">2278</td><td class="line">  <span class='comment'>// and wipe all pointers in the copy, which we then serialize.</span></td></tr>
<tr><td class="num" id="LN2279">2279</td><td class="line">  Code* original = Code::cast(object_);</td></tr>
<tr><td class="num" id="LN2280">2280</td><td class="line">  Code* code = serializer_-&gt;CopyCode(original);</td></tr>
<tr><td class="num" id="LN2281">2281</td><td class="line">  <span class='comment'>// Code age headers are not serializable.</span></td></tr>
<tr><td class="num" id="LN2282">2282</td><td class="line">  code-&gt;MakeYoung(serializer_-&gt;isolate());</td></tr>
<tr><td class="num" id="LN2283">2283</td><td class="line">  <span class='keyword'>int</span> mode_mask = RelocInfo::kCodeTargetMask |</td></tr>
<tr><td class="num" id="LN2284">2284</td><td class="line">                  RelocInfo::ModeMask(RelocInfo::EMBEDDED_OBJECT) |</td></tr>
<tr><td class="num" id="LN2285">2285</td><td class="line">                  RelocInfo::ModeMask(RelocInfo::EXTERNAL_REFERENCE) |</td></tr>
<tr><td class="num" id="LN2286">2286</td><td class="line">                  RelocInfo::ModeMask(RelocInfo::RUNTIME_ENTRY) |</td></tr>
<tr><td class="num" id="LN2287">2287</td><td class="line">                  RelocInfo::ModeMask(RelocInfo::INTERNAL_REFERENCE) |</td></tr>
<tr><td class="num" id="LN2288">2288</td><td class="line">                  RelocInfo::ModeMask(RelocInfo::INTERNAL_REFERENCE_ENCODED);</td></tr>
<tr><td class="num" id="LN2289">2289</td><td class="line">  <span class='keyword'>for</span> (RelocIterator it(code, mode_mask); !it.done(); it.next()) {</td></tr>
<tr><td class="num" id="LN2290">2290</td><td class="line">    RelocInfo* rinfo = it.rinfo();</td></tr>
<tr><td class="num" id="LN2291">2291</td><td class="line">    rinfo-&gt;WipeOut();</td></tr>
<tr><td class="num" id="LN2292">2292</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2293">2293</td><td class="line">  <span class='comment'>// We need to wipe out the header fields *after* wiping out the</span></td></tr>
<tr><td class="num" id="LN2294">2294</td><td class="line">  <span class='comment'>// relocations, because some of these fields are needed for the latter.</span></td></tr>
<tr><td class="num" id="LN2295">2295</td><td class="line">  code-&gt;WipeOutHeader();</td></tr>
<tr><td class="num" id="LN2296">2296</td><td class="line">  <span class='keyword'>return</span> code-&gt;address();</td></tr>
<tr><td class="num" id="LN2297">2297</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2298">2298</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2299">2299</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2300">2300</td><td class="line"><span class='keyword'>int</span> Serializer::ObjectSerializer::OutputRawData(</td></tr>
<tr><td class="num" id="LN2301">2301</td><td class="line">    Address up_to, Serializer::ObjectSerializer::ReturnSkip return_skip) {</td></tr>
<tr><td class="num" id="LN2302">2302</td><td class="line">  Address object_start = object_-&gt;address();</td></tr>
<tr><td class="num" id="LN2303">2303</td><td class="line">  <span class='keyword'>int</span> base = bytes_processed_so_far_;</td></tr>
<tr><td class="num" id="LN2304">2304</td><td class="line">  <span class='keyword'>int</span> up_to_offset = <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(up_to - object_start);</td></tr>
<tr><td class="num" id="LN2305">2305</td><td class="line">  <span class='keyword'>int</span> to_skip = up_to_offset - bytes_processed_so_far_;</td></tr>
<tr><td class="num" id="LN2306">2306</td><td class="line">  <span class='keyword'>int</span> bytes_to_output = to_skip;</td></tr>
<tr><td class="num" id="LN2307">2307</td><td class="line">  bytes_processed_so_far_ += to_skip;</td></tr>
<tr><td class="num" id="LN2308">2308</td><td class="line">  <span class='comment'>// This assert will fail if the reloc info gives us the target_address_address</span></td></tr>
<tr><td class="num" id="LN2309">2309</td><td class="line">  <span class='comment'>// locations in a non-ascending order.  Luckily that doesn't happen.</span></td></tr>
<tr><td class="num" id="LN2310">2310</td><td class="line">  <span class='macro'>DCHECK(to_skip &gt;= 0)<span class='expansion'>do { if ((__builtin_expect(!!(!(to_skip &gt;= 0)), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2310, "Check failed: %s.", "to_skip &gt;= 0"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2311">2311</td><td class="line">  <span class='keyword'>bool</span> outputting_code = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2312">2312</td><td class="line">  <span class='keyword'>if</span> (to_skip != 0 &amp;&amp; is_code_object_ &amp;&amp; !code_has_been_output_) {</td></tr>
<tr><td class="num" id="LN2313">2313</td><td class="line">    <span class='comment'>// Output the code all at once and fix later.</span></td></tr>
<tr><td class="num" id="LN2314">2314</td><td class="line">    bytes_to_output = object_-&gt;Size() + to_skip - bytes_processed_so_far_;</td></tr>
<tr><td class="num" id="LN2315">2315</td><td class="line">    outputting_code = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2316">2316</td><td class="line">    code_has_been_output_ = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2317">2317</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2318">2318</td><td class="line">  <span class='keyword'>if</span> (bytes_to_output != 0 &amp;&amp; (!is_code_object_ || outputting_code)) {</td></tr>
<tr><td class="num" id="LN2319">2319</td><td class="line">    <span class='keyword'>if</span> (!outputting_code &amp;&amp; bytes_to_output == to_skip &amp;&amp;</td></tr>
<tr><td class="num" id="LN2320">2320</td><td class="line">        IsAligned(bytes_to_output, kPointerAlignment) &amp;&amp;</td></tr>
<tr><td class="num" id="LN2321">2321</td><td class="line">        bytes_to_output &lt;= kNumberOfFixedRawData * kPointerSize) {</td></tr>
<tr><td class="num" id="LN2322">2322</td><td class="line">      <span class='keyword'>int</span> size_in_words = bytes_to_output &gt;&gt; kPointerSizeLog2;</td></tr>
<tr><td class="num" id="LN2323">2323</td><td class="line">      sink_-&gt;PutSection(kFixedRawDataStart + size_in_words, <span class='string_literal'>"FixedRawData"</span>);</td></tr>
<tr><td class="num" id="LN2324">2324</td><td class="line">      to_skip = 0;  <span class='comment'>// This instruction includes skip.</span></td></tr>
<tr><td class="num" id="LN2325">2325</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN2326">2326</td><td class="line">      <span class='comment'>// We always end up here if we are outputting the code of a code object.</span></td></tr>
<tr><td class="num" id="LN2327">2327</td><td class="line">      sink_-&gt;Put(kVariableRawData, <span class='string_literal'>"VariableRawData"</span>);</td></tr>
<tr><td class="num" id="LN2328">2328</td><td class="line">      sink_-&gt;PutInt(bytes_to_output, <span class='string_literal'>"length"</span>);</td></tr>
<tr><td class="num" id="LN2329">2329</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2330">2330</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2331">2331</td><td class="line">    <span class='keyword'>if</span> (is_code_object_) object_start = PrepareCode();</td></tr>
<tr><td class="num" id="LN2332">2332</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2333">2333</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* description = is_code_object_ ? <span class='string_literal'>"Code"</span> : <span class='string_literal'>"Byte"</span>;</td></tr>
<tr><td class="num" id="LN2334">2334</td><td class="line">    sink_-&gt;PutRaw(object_start + base, bytes_to_output, description);</td></tr>
<tr><td class="num" id="LN2335">2335</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2336">2336</td><td class="line">  <span class='keyword'>if</span> (to_skip != 0 &amp;&amp; return_skip == kIgnoringReturn) {</td></tr>
<tr><td class="num" id="LN2337">2337</td><td class="line">    sink_-&gt;Put(kSkip, <span class='string_literal'>"Skip"</span>);</td></tr>
<tr><td class="num" id="LN2338">2338</td><td class="line">    sink_-&gt;PutInt(to_skip, <span class='string_literal'>"SkipDistance"</span>);</td></tr>
<tr><td class="num" id="LN2339">2339</td><td class="line">    to_skip = 0;</td></tr>
<tr><td class="num" id="LN2340">2340</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2341">2341</td><td class="line">  <span class='keyword'>return</span> to_skip;</td></tr>
<tr><td class="num" id="LN2342">2342</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2343">2343</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2344">2344</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2345">2345</td><td class="line">BackReference Serializer::AllocateLargeObject(<span class='keyword'>int</span> size) {</td></tr>
<tr><td class="num" id="LN2346">2346</td><td class="line">  <span class='comment'>// Large objects are allocated one-by-one when deserializing. We do not</span></td></tr>
<tr><td class="num" id="LN2347">2347</td><td class="line">  <span class='comment'>// have to keep track of multiple chunks.</span></td></tr>
<tr><td class="num" id="LN2348">2348</td><td class="line">  large_objects_total_size_ += size;</td></tr>
<tr><td class="num" id="LN2349">2349</td><td class="line">  <span class='keyword'>return</span> BackReference::LargeObjectReference(seen_large_objects_index_++);</td></tr>
<tr><td class="num" id="LN2350">2350</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2351">2351</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2352">2352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2353">2353</td><td class="line">BackReference Serializer::Allocate(AllocationSpace space, <span class='keyword'>int</span> size) {</td></tr>
<tr><td class="num" id="LN2354">2354</td><td class="line">  <span class='macro'>DCHECK(space &gt;= 0 &amp;&amp; space &lt; kNumberOfPreallocatedSpaces)<span class='expansion'>do { if ((__builtin_expect(!!(!(space &gt;= 0 &amp;&amp; space<br> &lt; kNumberOfPreallocatedSpaces)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2354, "Check failed: %s.", "space &gt;= 0 &amp;&amp; space &lt; kNumberOfPreallocatedSpaces"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2355">2355</td><td class="line">  <span class='macro'>DCHECK(size &gt; 0 &amp;&amp; size &lt;= <span class='keyword'>static_cast</span>&lt;<span class='keyword'>int</span>&gt;(max_chunk_size(space)))<span class='expansion'>do { if ((__builtin_expect(!!(!(size &gt; 0 &amp;&amp; size &lt;=<br> static_cast&lt;int&gt;(max_chunk_size(space)))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2355, "Check failed: %s.", "size &gt; 0 &amp;&amp; size &lt;= static_cast&lt;int&gt;(max_chunk_size(space))"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2356">2356</td><td class="line">  uint32_t new_chunk_size = pending_chunk_[space] + size;</td></tr>
<tr><td class="num" id="LN2357">2357</td><td class="line">  <span class='keyword'>if</span> (new_chunk_size &gt; max_chunk_size(space)) {</td></tr>
<tr><td class="num" id="LN2358">2358</td><td class="line">    <span class='comment'>// The new chunk size would not fit onto a single page. Complete the</span></td></tr>
<tr><td class="num" id="LN2359">2359</td><td class="line">    <span class='comment'>// current chunk and start a new one.</span></td></tr>
<tr><td class="num" id="LN2360">2360</td><td class="line">    sink_-&gt;Put(kNextChunk, <span class='string_literal'>"NextChunk"</span>);</td></tr>
<tr><td class="num" id="LN2361">2361</td><td class="line">    sink_-&gt;Put(space, <span class='string_literal'>"NextChunkSpace"</span>);</td></tr>
<tr><td class="num" id="LN2362">2362</td><td class="line">    completed_chunks_[space].Add(pending_chunk_[space]);</td></tr>
<tr><td class="num" id="LN2363">2363</td><td class="line">    <span class='macro'>DCHECK_LE(completed_chunks_[space].length(), BackReference::kMaxChunkIndex)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (completed_chunks_<br>[space].length()), (BackReference::kMaxChunkIndex), "completed_chunks_[space].length()"<br> " " "&lt;=" " " "BackReference::kMaxChunkIndex")) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2363, "Check failed: %s.", _msg<br>-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2364">2364</td><td class="line">    pending_chunk_[space] = 0;</td></tr>
<tr><td class="num" id="LN2365">2365</td><td class="line">    new_chunk_size = size;</td></tr>
<tr><td class="num" id="LN2366">2366</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2367">2367</td><td class="line">  uint32_t offset = pending_chunk_[space];</td></tr>
<tr><td class="num" id="LN2368">2368</td><td class="line">  pending_chunk_[space] = new_chunk_size;</td></tr>
<tr><td class="num" id="LN2369">2369</td><td class="line">  <span class='keyword'>return</span> BackReference::Reference(space, completed_chunks_[space].length(),</td></tr>
<tr><td class="num" id="LN2370">2370</td><td class="line">                                  offset);</td></tr>
<tr><td class="num" id="LN2371">2371</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2372">2372</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2373">2373</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2374">2374</td><td class="line"><span class='keyword'>void</span> Serializer::Pad() {</td></tr>
<tr><td class="num" id="LN2375">2375</td><td class="line">  <span class='comment'>// The non-branching GetInt will read up to 3 bytes too far, so we need</span></td></tr>
<tr><td class="num" id="LN2376">2376</td><td class="line">  <span class='comment'>// to pad the snapshot to make sure we don't read over the end.</span></td></tr>
<tr><td class="num" id="LN2377">2377</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>unsigned</span> i = 0; i &lt; <span class='keyword'>sizeof</span>(int32_t) - 1; i++) {</td></tr>
<tr><td class="num" id="LN2378">2378</td><td class="line">    sink_-&gt;Put(kNop, <span class='string_literal'>"Padding"</span>);</td></tr>
<tr><td class="num" id="LN2379">2379</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2380">2380</td><td class="line">  <span class='comment'>// Pad up to pointer size for checksum.</span></td></tr>
<tr><td class="num" id="LN2381">2381</td><td class="line">  <span class='keyword'>while</span> (!IsAligned(sink_-&gt;Position(), kPointerAlignment)) {</td></tr>
<tr><td class="num" id="LN2382">2382</td><td class="line">    sink_-&gt;Put(kNop, <span class='string_literal'>"Padding"</span>);</td></tr>
<tr><td class="num" id="LN2383">2383</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2384">2384</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2385">2385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2386">2386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2387">2387</td><td class="line"><span class='keyword'>void</span> Serializer::InitializeCodeAddressMap() {</td></tr>
<tr><td class="num" id="LN2388">2388</td><td class="line">  isolate_-&gt;InitializeLoggingAndCounters();</td></tr>
<tr><td class="num" id="LN2389">2389</td><td class="line">  code_address_map_ = <span class='keyword'>new</span> CodeAddressMap(isolate_);</td></tr>
<tr><td class="num" id="LN2390">2390</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2391">2391</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2392">2392</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2393">2393</td><td class="line">Code* Serializer::CopyCode(Code* code) {</td></tr>
<tr><td class="num" id="LN2394">2394</td><td class="line">  code_buffer_.Rewind(0);  <span class='comment'>// Clear buffer without deleting backing store.</span></td></tr>
<tr><td class="num" id="LN2395">2395</td><td class="line">  <span class='keyword'>int</span> size = code-&gt;CodeSize();</td></tr>
<tr><td class="num" id="LN2396">2396</td><td class="line">  code_buffer_.AddAll(Vector&lt;byte&gt;(code-&gt;address(), size));</td></tr>
<tr><td class="num" id="LN2397">2397</td><td class="line">  <span class='keyword'>return</span> Code::cast(HeapObject::FromAddress(&amp;code_buffer_.first()));</td></tr>
<tr><td class="num" id="LN2398">2398</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2399">2399</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2400">2400</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2401">2401</td><td class="line">ScriptData* CodeSerializer::Serialize(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN2402">2402</td><td class="line">                                      Handle&lt;SharedFunctionInfo&gt; info,</td></tr>
<tr><td class="num" id="LN2403">2403</td><td class="line">                                      Handle&lt;String&gt; source) {</td></tr>
<tr><td class="num" id="LN2404">2404</td><td class="line">  base::ElapsedTimer timer;</td></tr>
<tr><td class="num" id="LN2405">2405</td><td class="line">  <span class='keyword'>if</span> (FLAG_profile_deserialization) timer.Start();</td></tr>
<tr><td class="num" id="LN2406">2406</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2407">2407</td><td class="line">    PrintF(<span class='string_literal'>"[Serializing from"</span>);</td></tr>
<tr><td class="num" id="LN2408">2408</td><td class="line">    Object* script = info-&gt;script();</td></tr>
<tr><td class="num" id="LN2409">2409</td><td class="line">    <span class='keyword'>if</span> (script-&gt;IsScript()) Script::cast(script)-&gt;name()-&gt;ShortPrint();</td></tr>
<tr><td class="num" id="LN2410">2410</td><td class="line">    PrintF(<span class='string_literal'>"]\n"</span>);</td></tr>
<tr><td class="num" id="LN2411">2411</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2412">2412</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2413">2413</td><td class="line">  <span class='comment'>// Serialize code object.</span></td></tr>
<tr><td class="num" id="LN2414">2414</td><td class="line">  SnapshotByteSink sink(info-&gt;code()-&gt;CodeSize() * 2);</td></tr>
<tr><td class="num" id="LN2415">2415</td><td class="line">  CodeSerializer cs(isolate, &amp;sink, *source);</td></tr>
<tr><td class="num" id="LN2416">2416</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN2417">2417</td><td class="line">  Object** location = Handle&lt;Object&gt;::cast(info).location();</td></tr>
<tr><td class="num" id="LN2418">2418</td><td class="line">  cs.VisitPointer(location);</td></tr>
<tr><td class="num" id="LN2419">2419</td><td class="line">  cs.SerializeDeferredObjects();</td></tr>
<tr><td class="num" id="LN2420">2420</td><td class="line">  cs.Pad();</td></tr>
<tr><td class="num" id="LN2421">2421</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2422">2422</td><td class="line">  SerializedCodeData data(sink.data(), cs);</td></tr>
<tr><td class="num" id="LN2423">2423</td><td class="line">  ScriptData* script_data = data.GetScriptData();</td></tr>
<tr><td class="num" id="LN2424">2424</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2425">2425</td><td class="line">  <span class='keyword'>if</span> (FLAG_profile_deserialization) {</td></tr>
<tr><td class="num" id="LN2426">2426</td><td class="line">    <span class='keyword'>double</span> ms = timer.Elapsed().InMillisecondsF();</td></tr>
<tr><td class="num" id="LN2427">2427</td><td class="line">    <span class='keyword'>int</span> length = script_data-&gt;length();</td></tr>
<tr><td class="num" id="LN2428">2428</td><td class="line">    PrintF(<span class='string_literal'>"[Serializing to %d bytes took %0.3f ms]\n"</span>, length, ms);</td></tr>
<tr><td class="num" id="LN2429">2429</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2430">2430</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2431">2431</td><td class="line">  <span class='keyword'>return</span> script_data;</td></tr>
<tr><td class="num" id="LN2432">2432</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2433">2433</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2434">2434</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2435">2435</td><td class="line"><span class='keyword'>void</span> CodeSerializer::SerializeObject(HeapObject* obj, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN2436">2436</td><td class="line">                                     WhereToPoint where_to_point, <span class='keyword'>int</span> skip) {</td></tr>
<tr><td class="num" id="LN2437">2437</td><td class="line">  <span class='keyword'>int</span> root_index = root_index_map_.Lookup(obj);</td></tr>
<tr><td class="num" id="LN2438">2438</td><td class="line">  <span class='keyword'>if</span> (root_index != RootIndexMap::kInvalidRootIndex) {</td></tr>
<tr><td class="num" id="LN2439">2439</td><td class="line">    PutRoot(root_index, obj, how_to_code, where_to_point, skip);</td></tr>
<tr><td class="num" id="LN2440">2440</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2441">2441</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2442">2442</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2443">2443</td><td class="line">  <span class='keyword'>if</span> (SerializeKnownObject(obj, how_to_code, where_to_point, skip)) <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2444">2444</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2445">2445</td><td class="line">  FlushSkip(skip);</td></tr>
<tr><td class="num" id="LN2446">2446</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2447">2447</td><td class="line">  <span class='keyword'>if</span> (obj-&gt;IsCode()) {</td></tr>
<tr><td class="num" id="LN2448">2448</td><td class="line">    Code* code_object = Code::cast(obj);</td></tr>
<tr><td class="num" id="LN2449">2449</td><td class="line">    <span class='keyword'>switch</span> (code_object-&gt;kind()) {</td></tr>
<tr><td class="num" id="LN2450">2450</td><td class="line">      <span class='keyword'>case</span> Code::OPTIMIZED_FUNCTION:  <span class='comment'>// No optimized code compiled yet.</span></td></tr>
<tr><td class="num" id="LN2451">2451</td><td class="line">      <span class='keyword'>case</span> Code::HANDLER:             <span class='comment'>// No handlers patched in yet.</span></td></tr>
<tr><td class="num" id="LN2452">2452</td><td class="line">      <span class='keyword'>case</span> Code::REGEXP:              <span class='comment'>// No regexp literals initialized yet.</span></td></tr>
<tr><td class="num" id="LN2453">2453</td><td class="line">      <span class='keyword'>case</span> Code::NUMBER_OF_KINDS:     <span class='comment'>// Pseudo enum value.</span></td></tr>
<tr><td class="num" id="LN2454">2454</td><td class="line">        <span class='macro'>CHECK(<span class='keyword'>false</span>)<span class='expansion'>do { if ((__builtin_expect(!!(!(false)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2454, "Check failed: %s.", "false"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2455">2455</td><td class="line">      <span class='keyword'>case</span> Code::BUILTIN:</td></tr>
<tr><td class="num" id="LN2456">2456</td><td class="line">        SerializeBuiltin(code_object-&gt;builtin_index(), how_to_code,</td></tr>
<tr><td class="num" id="LN2457">2457</td><td class="line">                         where_to_point);</td></tr>
<tr><td class="num" id="LN2458">2458</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2459">2459</td><td class="line">      <span class='keyword'>case</span> Code::STUB:</td></tr>
<tr><td class="num" id="LN2460">2460</td><td class="line">        SerializeCodeStub(code_object-&gt;stub_key(), how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2461">2461</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2462">2462</td><td class="line"><span class='directive'>#define IC_KIND_CASE(KIND) case Code::KIND:</span></td></tr>
<tr><td class="num" id="LN2463">2463</td><td class="line">        <span class='macro'>IC_KIND_LIST(IC_KIND_CASE)<span class='expansion'>IC_KIND_CASE(LOAD_IC) IC_KIND_CASE(KEYED_LOAD_IC) IC_KIND_CASE<br>(CALL_IC) IC_KIND_CASE(STORE_IC) IC_KIND_CASE(KEYED_STORE_IC)<br> IC_KIND_CASE(BINARY_OP_IC) IC_KIND_CASE(COMPARE_IC) IC_KIND_CASE<br>(COMPARE_NIL_IC) IC_KIND_CASE(TO_BOOLEAN_IC)</span></span></td></tr>
<tr><td class="num" id="LN2464">2464</td><td class="line"><span class='directive'>#undef IC_KIND_CASE</span></td></tr>
<tr><td class="num" id="LN2465">2465</td><td class="line">        SerializeIC(code_object, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2466">2466</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2467">2467</td><td class="line">      <span class='keyword'>case</span> Code::FUNCTION:</td></tr>
<tr><td class="num" id="LN2468">2468</td><td class="line">        <span class='macro'>DCHECK(code_object-&gt;has_reloc_info_for_serialization())<span class='expansion'>do { if ((__builtin_expect(!!(!(code_object-&gt;has_reloc_info_for_serialization<br>())), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2468, "Check failed: %s."<br>, "code_object-&gt;has_reloc_info_for_serialization()"); } } while<br> (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2469">2469</td><td class="line">        SerializeGeneric(code_object, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2470">2470</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2471">2471</td><td class="line">      <span class='keyword'>case</span> Code::WASM_FUNCTION:</td></tr>
<tr><td class="num" id="LN2472">2472</td><td class="line">        <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/snapshot/serialize.cc", 2472, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN2473">2473</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2474">2474</td><td class="line">    <span class='macro'>UNREACHABLE()<span class='expansion'>V8_Fatal("../src/snapshot/serialize.cc", 2474, "unreachable code"<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN2475">2475</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2476">2476</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2477">2477</td><td class="line">  <span class='comment'>// Past this point we should not see any (context-specific) maps anymore.</span></td></tr>
<tr><td class="num" id="LN2478">2478</td><td class="line">  <span class='macro'>CHECK(!obj-&gt;IsMap())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsMap())), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2478, "Check failed: %s.", "!obj-&gt;IsMap()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2479">2479</td><td class="line">  <span class='comment'>// There should be no references to the global object embedded.</span></td></tr>
<tr><td class="num" id="LN2480">2480</td><td class="line">  <span class='macro'>CHECK(!obj-&gt;IsJSGlobalProxy() &amp;&amp; !obj-&gt;IsJSGlobalObject())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsJSGlobalProxy() &amp;&amp;<br> !obj-&gt;IsJSGlobalObject())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2480, "Check failed: %s.", "!obj-&gt;IsJSGlobalProxy() &amp;&amp; !obj-&gt;IsJSGlobalObject()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2481">2481</td><td class="line">  <span class='comment'>// There should be no hash table embedded. They would require rehashing.</span></td></tr>
<tr><td class="num" id="LN2482">2482</td><td class="line">  <span class='macro'>CHECK(!obj-&gt;IsHashTable())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsHashTable())), 0))<br>) { V8_Fatal("../src/snapshot/serialize.cc", 2482, "Check failed: %s."<br>, "!obj-&gt;IsHashTable()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2483">2483</td><td class="line">  <span class='comment'>// We expect no instantiated function objects or contexts.</span></td></tr>
<tr><td class="num" id="LN2484">2484</td><td class="line">  <span class='macro'>CHECK(!obj-&gt;IsJSFunction() &amp;&amp; !obj-&gt;IsContext())<span class='expansion'>do { if ((__builtin_expect(!!(!(!obj-&gt;IsJSFunction() &amp;&amp;<br> !obj-&gt;IsContext())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2484, "Check failed: %s.", "!obj-&gt;IsJSFunction() &amp;&amp; !obj-&gt;IsContext()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2485">2485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2486">2486</td><td class="line">  SerializeGeneric(obj, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2487">2487</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2488">2488</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2489">2489</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2490">2490</td><td class="line"><span class='keyword'>void</span> CodeSerializer::SerializeGeneric(HeapObject* heap_object,</td></tr>
<tr><td class="num" id="LN2491">2491</td><td class="line">                                      HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN2492">2492</td><td class="line">                                      WhereToPoint where_to_point) {</td></tr>
<tr><td class="num" id="LN2493">2493</td><td class="line">  <span class='comment'>// Object has not yet been serialized.  Serialize it here.</span></td></tr>
<tr><td class="num" id="LN2494">2494</td><td class="line">  ObjectSerializer serializer(<span class='keyword'>this</span>, heap_object, sink_, how_to_code,</td></tr>
<tr><td class="num" id="LN2495">2495</td><td class="line">                              where_to_point);</td></tr>
<tr><td class="num" id="LN2496">2496</td><td class="line">  serializer.Serialize();</td></tr>
<tr><td class="num" id="LN2497">2497</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2498">2498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2499">2499</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2500">2500</td><td class="line"><span class='keyword'>void</span> CodeSerializer::SerializeBuiltin(<span class='keyword'>int</span> builtin_index, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN2501">2501</td><td class="line">                                      WhereToPoint where_to_point) {</td></tr>
<tr><td class="num" id="LN2502">2502</td><td class="line">  <span class='macro'>DCHECK((how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) ||<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2504, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2503">2503</td><td class="line">         <span class='macro'>(how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) ||<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2504, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2504">2504</td><td class="line">         <span class='macro'>(how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer))<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2504, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2505">2505</td><td class="line">  <span class='macro'>DCHECK_LT(builtin_index, Builtins::builtin_count)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLTImpl( (builtin_index<br>), (Builtins::builtin_count), "builtin_index" " " "&lt;" " " "Builtins::builtin_count"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 2505, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2506">2506</td><td class="line">  <span class='macro'>DCHECK_LE(0, builtin_index)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckLEImpl( (0), (builtin_index<br>), "0" " " "&lt;=" " " "builtin_index")) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2506, "Check failed: %s.", _msg-&gt;c_str()); delete _msg; }<br> } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2507">2507</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2508">2508</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2509">2509</td><td class="line">    PrintF(<span class='string_literal'>" Encoding builtin: %s\n"</span>,</td></tr>
<tr><td class="num" id="LN2510">2510</td><td class="line">           isolate()-&gt;builtins()-&gt;name(builtin_index));</td></tr>
<tr><td class="num" id="LN2511">2511</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2512">2512</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2513">2513</td><td class="line">  sink_-&gt;Put(kBuiltin + how_to_code + where_to_point, <span class='string_literal'>"Builtin"</span>);</td></tr>
<tr><td class="num" id="LN2514">2514</td><td class="line">  sink_-&gt;PutInt(builtin_index, <span class='string_literal'>"builtin_index"</span>);</td></tr>
<tr><td class="num" id="LN2515">2515</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2516">2516</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2517">2517</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2518">2518</td><td class="line"><span class='keyword'>void</span> CodeSerializer::SerializeCodeStub(uint32_t stub_key, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN2519">2519</td><td class="line">                                       WhereToPoint where_to_point) {</td></tr>
<tr><td class="num" id="LN2520">2520</td><td class="line">  <span class='macro'>DCHECK((how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) ||<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2522, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2521">2521</td><td class="line">         <span class='macro'>(how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) ||<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2522, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2522">2522</td><td class="line">         <span class='macro'>(how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer))<span class='expansion'>do { if ((__builtin_expect(!!(!((how_to_code == kPlain &amp;&amp;<br> where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp;<br> where_to_point == kInnerPointer) || (how_to_code == kFromCode<br> &amp;&amp; where_to_point == kInnerPointer))), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2522, "Check failed: %s.", "(how_to_code == kPlain &amp;&amp; where_to_point == kStartOfObject) || (how_to_code == kPlain &amp;&amp; where_to_point == kInnerPointer) || (how_to_code == kFromCode &amp;&amp; where_to_point == kInnerPointer)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2523">2523</td><td class="line">  <span class='macro'>DCHECK(CodeStub::MajorKeyFromKey(stub_key) != CodeStub::NoCache)<span class='expansion'>do { if ((__builtin_expect(!!(!(CodeStub::MajorKeyFromKey(stub_key<br>) != CodeStub::NoCache)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2523, "Check failed: %s.", "CodeStub::MajorKeyFromKey(stub_key) != CodeStub::NoCache"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2524">2524</td><td class="line">  <span class='macro'>DCHECK(!CodeStub::GetCode(isolate(), stub_key).is_null())<span class='expansion'>do { if ((__builtin_expect(!!(!(!CodeStub::GetCode(isolate(),<br> stub_key).is_null())), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2524, "Check failed: %s.", "!CodeStub::GetCode(isolate(), stub_key).is_null()"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2525">2525</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2526">2526</td><td class="line">  <span class='keyword'>int</span> index = AddCodeStubKey(stub_key) + kCodeStubsBaseIndex;</td></tr>
<tr><td class="num" id="LN2527">2527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2528">2528</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2529">2529</td><td class="line">    PrintF(<span class='string_literal'>" Encoding code stub %s as %d\n"</span>,</td></tr>
<tr><td class="num" id="LN2530">2530</td><td class="line">           CodeStub::MajorName(CodeStub::MajorKeyFromKey(stub_key)), index);</td></tr>
<tr><td class="num" id="LN2531">2531</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2532">2532</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2533">2533</td><td class="line">  sink_-&gt;Put(kAttachedReference + how_to_code + where_to_point, <span class='string_literal'>"CodeStub"</span>);</td></tr>
<tr><td class="num" id="LN2534">2534</td><td class="line">  sink_-&gt;PutInt(index, <span class='string_literal'>"CodeStub key"</span>);</td></tr>
<tr><td class="num" id="LN2535">2535</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2536">2536</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2537">2537</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2538">2538</td><td class="line"><span class='keyword'>void</span> CodeSerializer::SerializeIC(Code* ic, HowToCode how_to_code,</td></tr>
<tr><td class="num" id="LN2539">2539</td><td class="line">                                 WhereToPoint where_to_point) {</td></tr>
<tr><td class="num" id="LN2540">2540</td><td class="line">  <span class='comment'>// The IC may be implemented as a stub.</span></td></tr>
<tr><td class="num" id="LN2541">2541</td><td class="line">  uint32_t stub_key = ic-&gt;stub_key();</td></tr>
<tr><td class="num" id="LN2542">2542</td><td class="line">  <span class='keyword'>if</span> (stub_key != CodeStub::NoCacheKey()) {</td></tr>
<tr><td class="num" id="LN2543">2543</td><td class="line">    <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2544">2544</td><td class="line">      PrintF(<span class='string_literal'>" %s is a code stub\n"</span>, Code::Kind2String(ic-&gt;kind()));</td></tr>
<tr><td class="num" id="LN2545">2545</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2546">2546</td><td class="line">    SerializeCodeStub(stub_key, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2547">2547</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2548">2548</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2549">2549</td><td class="line">  <span class='comment'>// The IC may be implemented as builtin. Only real builtins have an</span></td></tr>
<tr><td class="num" id="LN2550">2550</td><td class="line">  <span class='comment'>// actual builtin_index value attached (otherwise it's just garbage).</span></td></tr>
<tr><td class="num" id="LN2551">2551</td><td class="line">  <span class='comment'>// Compare to make sure we are really dealing with a builtin.</span></td></tr>
<tr><td class="num" id="LN2552">2552</td><td class="line">  <span class='keyword'>int</span> builtin_index = ic-&gt;builtin_index();</td></tr>
<tr><td class="num" id="LN2553">2553</td><td class="line">  <span class='keyword'>if</span> (builtin_index &lt; Builtins::builtin_count) {</td></tr>
<tr><td class="num" id="LN2554">2554</td><td class="line">    Builtins::Name name = <span class='keyword'>static_cast</span>&lt;Builtins::Name&gt;(builtin_index);</td></tr>
<tr><td class="num" id="LN2555">2555</td><td class="line">    Code* builtin = isolate()-&gt;builtins()-&gt;builtin(name);</td></tr>
<tr><td class="num" id="LN2556">2556</td><td class="line">    <span class='keyword'>if</span> (builtin == ic) {</td></tr>
<tr><td class="num" id="LN2557">2557</td><td class="line">      <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2558">2558</td><td class="line">        PrintF(<span class='string_literal'>" %s is a builtin\n"</span>, Code::Kind2String(ic-&gt;kind()));</td></tr>
<tr><td class="num" id="LN2559">2559</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN2560">2560</td><td class="line">      <span class='macro'>DCHECK(ic-&gt;kind() == Code::KEYED_LOAD_IC ||<span class='expansion'>do { if ((__builtin_expect(!!(!(ic-&gt;kind() == Code::KEYED_LOAD_IC<br> || ic-&gt;kind() == Code::KEYED_STORE_IC)), 0))) { V8_Fatal(<br>"../src/snapshot/serialize.cc", 2561, "Check failed: %s.", "ic-&gt;kind() == Code::KEYED_LOAD_IC || ic-&gt;kind() == Code::KEYED_STORE_IC"<br>); } } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2561">2561</td><td class="line">             <span class='macro'>ic-&gt;kind() == Code::KEYED_STORE_IC)<span class='expansion'>do { if ((__builtin_expect(!!(!(ic-&gt;kind() == Code::KEYED_LOAD_IC<br> || ic-&gt;kind() == Code::KEYED_STORE_IC)), 0))) { V8_Fatal(<br>"../src/snapshot/serialize.cc", 2561, "Check failed: %s.", "ic-&gt;kind() == Code::KEYED_LOAD_IC || ic-&gt;kind() == Code::KEYED_STORE_IC"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2562">2562</td><td class="line">      SerializeBuiltin(builtin_index, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2563">2563</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN2564">2564</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2565">2565</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2566">2566</td><td class="line">  <span class='comment'>// The IC may also just be a piece of code kept in the non_monomorphic_cache.</span></td></tr>
<tr><td class="num" id="LN2567">2567</td><td class="line">  <span class='comment'>// In that case, just serialize as a normal code object.</span></td></tr>
<tr><td class="num" id="LN2568">2568</td><td class="line">  <span class='keyword'>if</span> (FLAG_trace_serializer) {</td></tr>
<tr><td class="num" id="LN2569">2569</td><td class="line">    PrintF(<span class='string_literal'>" %s has no special handling\n"</span>, Code::Kind2String(ic-&gt;kind()));</td></tr>
<tr><td class="num" id="LN2570">2570</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2571">2571</td><td class="line">  <span class='macro'>DCHECK(ic-&gt;kind() == Code::LOAD_IC || ic-&gt;kind() == Code::STORE_IC)<span class='expansion'>do { if ((__builtin_expect(!!(!(ic-&gt;kind() == Code::LOAD_IC<br> || ic-&gt;kind() == Code::STORE_IC)), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2571, "Check failed: %s.", "ic-&gt;kind() == Code::LOAD_IC || ic-&gt;kind() == Code::STORE_IC"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2572">2572</td><td class="line">  SerializeGeneric(ic, how_to_code, where_to_point);</td></tr>
<tr><td class="num" id="LN2573">2573</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2574">2574</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2575">2575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2576">2576</td><td class="line"><span class='keyword'>int</span> CodeSerializer::AddCodeStubKey(uint32_t stub_key) {</td></tr>
<tr><td class="num" id="LN2577">2577</td><td class="line">  <span class='comment'>// TODO(yangguo) Maybe we need a hash table for a faster lookup than O(n^2).</span></td></tr>
<tr><td class="num" id="LN2578">2578</td><td class="line">  <span class='keyword'>int</span> index = 0;</td></tr>
<tr><td class="num" id="LN2579">2579</td><td class="line">  <span class='keyword'>while</span> (index &lt; stub_keys_.length()) {</td></tr>
<tr><td class="num" id="LN2580">2580</td><td class="line">    <span class='keyword'>if</span> (stub_keys_[index] == stub_key) <span class='keyword'>return</span> index;</td></tr>
<tr><td class="num" id="LN2581">2581</td><td class="line">    index++;</td></tr>
<tr><td class="num" id="LN2582">2582</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2583">2583</td><td class="line">  stub_keys_.Add(stub_key);</td></tr>
<tr><td class="num" id="LN2584">2584</td><td class="line">  <span class='keyword'>return</span> index;</td></tr>
<tr><td class="num" id="LN2585">2585</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2586">2586</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2587">2587</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2588">2588</td><td class="line">MaybeHandle&lt;SharedFunctionInfo&gt; CodeSerializer::Deserialize(</td></tr>
<tr><td class="num" id="LN2589">2589</td><td class="line">    Isolate* isolate, ScriptData* cached_data, Handle&lt;String&gt; source) {</td></tr>
<tr><td class="num" id="LN2590">2590</td><td class="line">  base::ElapsedTimer timer;</td></tr>
<tr><td class="num" id="LN2591">2591</td><td class="line">  <span class='keyword'>if</span> (FLAG_profile_deserialization) timer.Start();</td></tr>
<tr><td class="num" id="LN2592">2592</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2593">2593</td><td class="line">  HandleScope scope(isolate);</td></tr>
<tr><td class="num" id="LN2594">2594</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2595">2595</td><td class="line">  base::SmartPointer&lt;SerializedCodeData&gt; scd(</td></tr>
<tr><td class="num" id="LN2596">2596</td><td class="line">      SerializedCodeData::FromCachedData(isolate, cached_data, *source));</td></tr>
<tr><td class="num" id="LN2597">2597</td><td class="line">  <span class='keyword'>if</span> (scd.is_empty()) {</td></tr>
<tr><td class="num" id="LN2598">2598</td><td class="line">    <span class='keyword'>if</span> (FLAG_profile_deserialization) PrintF(<span class='string_literal'>"[Cached code failed check]\n"</span>);</td></tr>
<tr><td class="num" id="LN2599">2599</td><td class="line">    <span class='macro'>DCHECK(cached_data-&gt;rejected())<span class='expansion'>do { if ((__builtin_expect(!!(!(cached_data-&gt;rejected())),<br> 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2599, "Check failed: %s."<br>, "cached_data-&gt;rejected()"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2600">2600</td><td class="line">    <span class='keyword'>return</span> MaybeHandle&lt;SharedFunctionInfo&gt;();</td></tr>
<tr><td class="num" id="LN2601">2601</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2602">2602</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2603">2603</td><td class="line">  <span class='comment'>// Prepare and register list of attached objects.</span></td></tr>
<tr><td class="num" id="LN2604">2604</td><td class="line">  Vector&lt;<span class='keyword'>const</span> uint32_t&gt; code_stub_keys = scd-&gt;CodeStubKeys();</td></tr>
<tr><td class="num" id="LN2605">2605</td><td class="line">  Vector&lt;Handle&lt;Object&gt; &gt; attached_objects = Vector&lt;Handle&lt;Object&gt; &gt;::New(</td></tr>
<tr><td class="num" id="LN2606">2606</td><td class="line">      code_stub_keys.length() + kCodeStubsBaseIndex);</td></tr>
<tr><td class="num" id="LN2607">2607</td><td class="line">  attached_objects[kSourceObjectIndex] = source;</td></tr>
<tr><td class="num" id="LN2608">2608</td><td class="line">  <span class='keyword'>for</span> (<span class='keyword'>int</span> i = 0; i &lt; code_stub_keys.length(); i++) {</td></tr>
<tr><td class="num" id="LN2609">2609</td><td class="line">    attached_objects[i + kCodeStubsBaseIndex] =</td></tr>
<tr><td class="num" id="LN2610">2610</td><td class="line">        CodeStub::GetCode(isolate, code_stub_keys[i]).ToHandleChecked();</td></tr>
<tr><td class="num" id="LN2611">2611</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2612">2612</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2613">2613</td><td class="line">  Deserializer deserializer(scd.get());</td></tr>
<tr><td class="num" id="LN2614">2614</td><td class="line">  deserializer.SetAttachedObjects(attached_objects);</td></tr>
<tr><td class="num" id="LN2615">2615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2616">2616</td><td class="line">  <span class='comment'>// Deserialize.</span></td></tr>
<tr><td class="num" id="LN2617">2617</td><td class="line">  Handle&lt;SharedFunctionInfo&gt; result;</td></tr>
<tr><td class="num" id="LN2618">2618</td><td class="line">  <span class='keyword'>if</span> (!deserializer.DeserializeCode(isolate).ToHandle(&amp;result)) {</td></tr>
<tr><td class="num" id="LN2619">2619</td><td class="line">    <span class='comment'>// Deserializing may fail if the reservations cannot be fulfilled.</span></td></tr>
<tr><td class="num" id="LN2620">2620</td><td class="line">    <span class='keyword'>if</span> (FLAG_profile_deserialization) PrintF(<span class='string_literal'>"[Deserializing failed]\n"</span>);</td></tr>
<tr><td class="num" id="LN2621">2621</td><td class="line">    <span class='keyword'>return</span> MaybeHandle&lt;SharedFunctionInfo&gt;();</td></tr>
<tr><td class="num" id="LN2622">2622</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2623">2623</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2624">2624</td><td class="line">  <span class='keyword'>if</span> (FLAG_profile_deserialization) {</td></tr>
<tr><td class="num" id="LN2625">2625</td><td class="line">    <span class='keyword'>double</span> ms = timer.Elapsed().InMillisecondsF();</td></tr>
<tr><td class="num" id="LN2626">2626</td><td class="line">    <span class='keyword'>int</span> length = cached_data-&gt;length();</td></tr>
<tr><td class="num" id="LN2627">2627</td><td class="line">    PrintF(<span class='string_literal'>"[Deserializing from %d bytes took %0.3f ms]\n"</span>, length, ms);</td></tr>
<tr><td class="num" id="LN2628">2628</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2629">2629</td><td class="line">  result-&gt;set_deserialized(<span class='keyword'>true</span>);</td></tr>
<tr><td class="num" id="LN2630">2630</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2631">2631</td><td class="line">  <span class='keyword'>if</span> (isolate-&gt;logger()-&gt;is_logging_code_events() ||</td></tr>
<tr><td class="num" id="LN2632">2632</td><td class="line">      isolate-&gt;cpu_profiler()-&gt;is_profiling()) {</td></tr>
<tr><td class="num" id="LN2633">2633</td><td class="line">    String* name = isolate-&gt;heap()-&gt;empty_string();</td></tr>
<tr><td class="num" id="LN2634">2634</td><td class="line">    <span class='keyword'>if</span> (result-&gt;script()-&gt;IsScript()) {</td></tr>
<tr><td class="num" id="LN2635">2635</td><td class="line">      Script* script = Script::cast(result-&gt;script());</td></tr>
<tr><td class="num" id="LN2636">2636</td><td class="line">      <span class='keyword'>if</span> (script-&gt;name()-&gt;IsString()) name = String::cast(script-&gt;name());</td></tr>
<tr><td class="num" id="LN2637">2637</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2638">2638</td><td class="line">    isolate-&gt;logger()-&gt;CodeCreateEvent(Logger::SCRIPT_TAG, result-&gt;code(),</td></tr>
<tr><td class="num" id="LN2639">2639</td><td class="line">                                       *result, <span class='macro'>NULL<span class='expansion'>__null</span></span>, name);</td></tr>
<tr><td class="num" id="LN2640">2640</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2641">2641</td><td class="line">  <span class='keyword'>return</span> scope.CloseAndEscape(result);</td></tr>
<tr><td class="num" id="LN2642">2642</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2643">2643</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2644">2644</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2645">2645</td><td class="line"><span class='keyword'>void</span> SerializedData::AllocateData(<span class='keyword'>int</span> size) {</td></tr>
<tr><td class="num" id="LN2646">2646</td><td class="line">  <span class='macro'>DCHECK(!owns_data_)<span class='expansion'>do { if ((__builtin_expect(!!(!(!owns_data_)), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2646, "Check failed: %s.", "!owns_data_"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2647">2647</td><td class="line">  data_ = NewArray&lt;byte&gt;(size);</td></tr>
<tr><td class="num" id="LN2648">2648</td><td class="line">  size_ = size;</td></tr>
<tr><td class="num" id="LN2649">2649</td><td class="line">  owns_data_ = <span class='keyword'>true</span>;</td></tr>
<tr><td class="num" id="LN2650">2650</td><td class="line">  <span class='macro'>DCHECK(IsAligned(<span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(data_), kPointerAlignment))<span class='expansion'>do { if ((__builtin_expect(!!(!(IsAligned(reinterpret_cast&lt;<br>intptr_t&gt;(data_), kPointerAlignment))), 0))) { V8_Fatal("../src/snapshot/serialize.cc"<br>, 2650, "Check failed: %s.", "IsAligned(reinterpret_cast&lt;intptr_t&gt;(data_), kPointerAlignment)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2651">2651</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2652">2652</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2653">2653</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2654">2654</td><td class="line">SnapshotData::SnapshotData(<span class='keyword'>const</span> Serializer&amp; ser) {</td></tr>
<tr><td class="num" id="LN2655">2655</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN2656">2656</td><td class="line">  List&lt;Reservation&gt; reservations;</td></tr>
<tr><td class="num" id="LN2657">2657</td><td class="line">  ser.EncodeReservations(&amp;reservations);</td></tr>
<tr><td class="num" id="LN2658">2658</td><td class="line">  <span class='keyword'>const</span> List&lt;byte&gt;&amp; payload = ser.sink()-&gt;data();</td></tr>
<tr><td class="num" id="LN2659">2659</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2660">2660</td><td class="line">  <span class='comment'>// Calculate sizes.</span></td></tr>
<tr><td class="num" id="LN2661">2661</td><td class="line">  <span class='keyword'>int</span> reservation_size = reservations.length() * kInt32Size;</td></tr>
<tr><td class="num" id="LN2662">2662</td><td class="line">  <span class='keyword'>int</span> size = kHeaderSize + reservation_size + payload.length();</td></tr>
<tr><td class="num" id="LN2663">2663</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2664">2664</td><td class="line">  <span class='comment'>// Allocate backing store and create result data.</span></td></tr>
<tr><td class="num" id="LN2665">2665</td><td class="line">  AllocateData(size);</td></tr>
<tr><td class="num" id="LN2666">2666</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2667">2667</td><td class="line">  <span class='comment'>// Set header values.</span></td></tr>
<tr><td class="num" id="LN2668">2668</td><td class="line">  SetMagicNumber(ser.isolate());</td></tr>
<tr><td class="num" id="LN2669">2669</td><td class="line">  SetHeaderValue(kCheckSumOffset, Version::Hash());</td></tr>
<tr><td class="num" id="LN2670">2670</td><td class="line">  SetHeaderValue(kNumReservationsOffset, reservations.length());</td></tr>
<tr><td class="num" id="LN2671">2671</td><td class="line">  SetHeaderValue(kPayloadLengthOffset, payload.length());</td></tr>
<tr><td class="num" id="LN2672">2672</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2673">2673</td><td class="line">  <span class='comment'>// Copy reservation chunk sizes.</span></td></tr>
<tr><td class="num" id="LN2674">2674</td><td class="line">  CopyBytes(data_ + kHeaderSize, <span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(reservations.begin()),</td></tr>
<tr><td class="num" id="LN2675">2675</td><td class="line">            reservation_size);</td></tr>
<tr><td class="num" id="LN2676">2676</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2677">2677</td><td class="line">  <span class='comment'>// Copy serialized data.</span></td></tr>
<tr><td class="num" id="LN2678">2678</td><td class="line">  CopyBytes(data_ + kHeaderSize + reservation_size, payload.begin(),</td></tr>
<tr><td class="num" id="LN2679">2679</td><td class="line">            <span class='keyword'>static_cast</span>&lt;size_t&gt;(payload.length()));</td></tr>
<tr><td class="num" id="LN2680">2680</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2681">2681</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2682">2682</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2683">2683</td><td class="line"><span class='keyword'>bool</span> SnapshotData::IsSane() {</td></tr>
<tr><td class="num" id="LN2684">2684</td><td class="line">  <span class='keyword'>return</span> GetHeaderValue(kCheckSumOffset) == Version::Hash();</td></tr>
<tr><td class="num" id="LN2685">2685</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2686">2686</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2687">2687</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2688">2688</td><td class="line">Vector&lt;<span class='keyword'>const</span> SerializedData::Reservation&gt; SnapshotData::Reservations() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2689">2689</td><td class="line">  <span class='keyword'>return</span> Vector&lt;<span class='keyword'>const</span> Reservation&gt;(</td></tr>
<tr><td class="num" id="LN2690">2690</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> Reservation*&gt;(data_ + kHeaderSize),</td></tr>
<tr><td class="num" id="LN2691">2691</td><td class="line">      GetHeaderValue(kNumReservationsOffset));</td></tr>
<tr><td class="num" id="LN2692">2692</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2693">2693</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2694">2694</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2695">2695</td><td class="line">Vector&lt;<span class='keyword'>const</span> byte&gt; SnapshotData::Payload() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2696">2696</td><td class="line">  <span class='keyword'>int</span> reservations_size = GetHeaderValue(kNumReservationsOffset) * kInt32Size;</td></tr>
<tr><td class="num" id="LN2697">2697</td><td class="line">  <span class='keyword'>const</span> byte* payload = data_ + kHeaderSize + reservations_size;</td></tr>
<tr><td class="num" id="LN2698">2698</td><td class="line">  <span class='keyword'>int</span> length = GetHeaderValue(kPayloadLengthOffset);</td></tr>
<tr><td class="num" id="LN2699">2699</td><td class="line">  <span class='macro'>DCHECK_EQ(data_ + size_, payload + length)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (data_ +<br> size_), (payload + length), "data_ + size_" " " "==" " " "payload + length"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 2699, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2700">2700</td><td class="line">  <span class='keyword'>return</span> Vector&lt;<span class='keyword'>const</span> byte&gt;(payload, length);</td></tr>
<tr><td class="num" id="LN2701">2701</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2702">2702</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2703">2703</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2704">2704</td><td class="line"><span class='keyword'>class</span> Checksum {</td></tr>
<tr><td class="num" id="LN2705">2705</td><td class="line"> <span class='keyword'>public</span>:</td></tr>
<tr><td class="num" id="LN2706">2706</td><td class="line">  <span class='keyword'>explicit</span> Checksum(Vector&lt;<span class='keyword'>const</span> byte&gt; payload) {</td></tr>
<tr><td class="num" id="LN2707">2707</td><td class="line"><span class='directive'>#ifdef MEMORY_SANITIZER</span></td></tr>
<tr><td class="num" id="LN2708">2708</td><td class="line">    <span class='comment'>// Computing the checksum includes padding bytes for objects like strings.</span></td></tr>
<tr><td class="num" id="LN2709">2709</td><td class="line">    <span class='comment'>// Mark every object as initialized in the code serializer.</span></td></tr>
<tr><td class="num" id="LN2710">2710</td><td class="line">    MSAN_MEMORY_IS_INITIALIZED(payload.start(), payload.length());</td></tr>
<tr><td class="num" id="LN2711">2711</td><td class="line"><span class='directive'>#endif  // MEMORY_SANITIZER</span></td></tr>
<tr><td class="num" id="LN2712">2712</td><td class="line">    <span class='comment'>// Fletcher's checksum. Modified to reduce 64-bit sums to 32-bit.</span></td></tr>
<tr><td class="num" id="LN2713">2713</td><td class="line">    uintptr_t a = 1;</td></tr>
<tr><td class="num" id="LN2714">2714</td><td class="line">    uintptr_t b = 0;</td></tr>
<tr><td class="num" id="LN2715">2715</td><td class="line">    <span class='keyword'>const</span> uintptr_t* cur = <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> uintptr_t*&gt;(payload.start());</td></tr>
<tr><td class="num" id="LN2716">2716</td><td class="line">    <span class='macro'>DCHECK(IsAligned(payload.length(), kIntptrSize))<span class='expansion'>do { if ((__builtin_expect(!!(!(IsAligned(payload.length(), kIntptrSize<br>))), 0))) { V8_Fatal("../src/snapshot/serialize.cc", 2716, "Check failed: %s."<br>, "IsAligned(payload.length(), kIntptrSize)"); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2717">2717</td><td class="line">    <span class='keyword'>const</span> uintptr_t* end = cur + payload.length() / kIntptrSize;</td></tr>
<tr><td class="num" id="LN2718">2718</td><td class="line">    <span class='keyword'>while</span> (cur &lt; end) {</td></tr>
<tr><td class="num" id="LN2719">2719</td><td class="line">      <span class='comment'>// Unsigned overflow expected and intended.</span></td></tr>
<tr><td class="num" id="LN2720">2720</td><td class="line">      a += *cur++;</td></tr>
<tr><td class="num" id="LN2721">2721</td><td class="line">      b += a;</td></tr>
<tr><td class="num" id="LN2722">2722</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN2723">2723</td><td class="line"><span class='directive'>#if <span class='macro'>V8_HOST_ARCH_64_BIT<span class='expansion'>1</span></span></span></td></tr>
<tr><td class="num" id="LN2724">2724</td><td class="line">    a ^= a &gt;&gt; 32;</td></tr>
<tr><td class="num" id="LN2725">2725</td><td class="line">    b ^= b &gt;&gt; 32;</td></tr>
<tr><td class="num" id="LN2726">2726</td><td class="line"><span class='directive'>#endif  // V8_HOST_ARCH_64_BIT</span></td></tr>
<tr><td class="num" id="LN2727">2727</td><td class="line">    a_ = <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(a);</td></tr>
<tr><td class="num" id="LN2728">2728</td><td class="line">    b_ = <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(b);</td></tr>
<tr><td class="num" id="LN2729">2729</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2730">2730</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2731">2731</td><td class="line">  <span class='keyword'>bool</span> Check(uint32_t a, uint32_t b) <span class='keyword'>const</span> { <span class='keyword'>return</span> a == a_ &amp;&amp; b == b_; }</td></tr>
<tr><td class="num" id="LN2732">2732</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2733">2733</td><td class="line">  uint32_t a() <span class='keyword'>const</span> { <span class='keyword'>return</span> a_; }</td></tr>
<tr><td class="num" id="LN2734">2734</td><td class="line">  uint32_t b() <span class='keyword'>const</span> { <span class='keyword'>return</span> b_; }</td></tr>
<tr><td class="num" id="LN2735">2735</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2736">2736</td><td class="line"> <span class='keyword'>private</span>:</td></tr>
<tr><td class="num" id="LN2737">2737</td><td class="line">  uint32_t a_;</td></tr>
<tr><td class="num" id="LN2738">2738</td><td class="line">  uint32_t b_;</td></tr>
<tr><td class="num" id="LN2739">2739</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2740">2740</td><td class="line">  <span class='macro'>DISALLOW_COPY_AND_ASSIGN(Checksum)<span class='expansion'>Checksum(const Checksum&amp;) = delete; void operator=(const Checksum<br>&amp;) = delete</span></span>;</td></tr>
<tr><td class="num" id="LN2741">2741</td><td class="line">};</td></tr>
<tr><td class="num" id="LN2742">2742</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2743">2743</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2744">2744</td><td class="line">SerializedCodeData::SerializedCodeData(<span class='keyword'>const</span> List&lt;byte&gt;&amp; payload,</td></tr>
<tr><td class="num" id="LN2745">2745</td><td class="line">                                       <span class='keyword'>const</span> CodeSerializer&amp; cs) {</td></tr>
<tr><td class="num" id="LN2746">2746</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN2747">2747</td><td class="line">  <span class='keyword'>const</span> List&lt;uint32_t&gt;* stub_keys = cs.stub_keys();</td></tr>
<tr><td class="num" id="LN2748">2748</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2749">2749</td><td class="line">  List&lt;Reservation&gt; reservations;</td></tr>
<tr><td class="num" id="LN2750">2750</td><td class="line">  cs.EncodeReservations(&amp;reservations);</td></tr>
<tr><td class="num" id="LN2751">2751</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2752">2752</td><td class="line">  <span class='comment'>// Calculate sizes.</span></td></tr>
<tr><td class="num" id="LN2753">2753</td><td class="line">  <span class='keyword'>int</span> reservation_size = reservations.length() * kInt32Size;</td></tr>
<tr><td class="num" id="LN2754">2754</td><td class="line">  <span class='keyword'>int</span> num_stub_keys = stub_keys-&gt;length();</td></tr>
<tr><td class="num" id="LN2755">2755</td><td class="line">  <span class='keyword'>int</span> stub_keys_size = stub_keys-&gt;length() * kInt32Size;</td></tr>
<tr><td class="num" id="LN2756">2756</td><td class="line">  <span class='keyword'>int</span> payload_offset = kHeaderSize + reservation_size + stub_keys_size;</td></tr>
<tr><td class="num" id="LN2757">2757</td><td class="line">  <span class='keyword'>int</span> padded_payload_offset = <span class='macro'>POINTER_SIZE_ALIGN(payload_offset)<span class='expansion'>(((payload_offset) + kPointerAlignmentMask) &amp; ~kPointerAlignmentMask<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN2758">2758</td><td class="line">  <span class='keyword'>int</span> size = padded_payload_offset + payload.length();</td></tr>
<tr><td class="num" id="LN2759">2759</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2760">2760</td><td class="line">  <span class='comment'>// Allocate backing store and create result data.</span></td></tr>
<tr><td class="num" id="LN2761">2761</td><td class="line">  AllocateData(size);</td></tr>
<tr><td class="num" id="LN2762">2762</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2763">2763</td><td class="line">  <span class='comment'>// Set header values.</span></td></tr>
<tr><td class="num" id="LN2764">2764</td><td class="line">  SetMagicNumber(cs.isolate());</td></tr>
<tr><td class="num" id="LN2765">2765</td><td class="line">  SetHeaderValue(kVersionHashOffset, Version::Hash());</td></tr>
<tr><td class="num" id="LN2766">2766</td><td class="line">  SetHeaderValue(kSourceHashOffset, SourceHash(cs.source()));</td></tr>
<tr><td class="num" id="LN2767">2767</td><td class="line">  SetHeaderValue(kCpuFeaturesOffset,</td></tr>
<tr><td class="num" id="LN2768">2768</td><td class="line">                 <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(CpuFeatures::SupportedFeatures()));</td></tr>
<tr><td class="num" id="LN2769">2769</td><td class="line">  SetHeaderValue(kFlagHashOffset, FlagList::Hash());</td></tr>
<tr><td class="num" id="LN2770">2770</td><td class="line">  SetHeaderValue(kNumReservationsOffset, reservations.length());</td></tr>
<tr><td class="num" id="LN2771">2771</td><td class="line">  SetHeaderValue(kNumCodeStubKeysOffset, num_stub_keys);</td></tr>
<tr><td class="num" id="LN2772">2772</td><td class="line">  SetHeaderValue(kPayloadLengthOffset, payload.length());</td></tr>
<tr><td class="num" id="LN2773">2773</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2774">2774</td><td class="line">  Checksum checksum(payload.ToConstVector());</td></tr>
<tr><td class="num" id="LN2775">2775</td><td class="line">  SetHeaderValue(kChecksum1Offset, checksum.a());</td></tr>
<tr><td class="num" id="LN2776">2776</td><td class="line">  SetHeaderValue(kChecksum2Offset, checksum.b());</td></tr>
<tr><td class="num" id="LN2777">2777</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2778">2778</td><td class="line">  <span class='comment'>// Copy reservation chunk sizes.</span></td></tr>
<tr><td class="num" id="LN2779">2779</td><td class="line">  CopyBytes(data_ + kHeaderSize, <span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(reservations.begin()),</td></tr>
<tr><td class="num" id="LN2780">2780</td><td class="line">            reservation_size);</td></tr>
<tr><td class="num" id="LN2781">2781</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2782">2782</td><td class="line">  <span class='comment'>// Copy code stub keys.</span></td></tr>
<tr><td class="num" id="LN2783">2783</td><td class="line">  CopyBytes(data_ + kHeaderSize + reservation_size,</td></tr>
<tr><td class="num" id="LN2784">2784</td><td class="line">            <span class='keyword'>reinterpret_cast</span>&lt;byte*&gt;(stub_keys-&gt;begin()), stub_keys_size);</td></tr>
<tr><td class="num" id="LN2785">2785</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2786">2786</td><td class="line">  memset(data_ + payload_offset, 0, padded_payload_offset - payload_offset);</td></tr>
<tr><td class="num" id="LN2787">2787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2788">2788</td><td class="line">  <span class='comment'>// Copy serialized data.</span></td></tr>
<tr><td class="num" id="LN2789">2789</td><td class="line">  CopyBytes(data_ + padded_payload_offset, payload.begin(),</td></tr>
<tr><td class="num" id="LN2790">2790</td><td class="line">            <span class='keyword'>static_cast</span>&lt;size_t&gt;(payload.length()));</td></tr>
<tr><td class="num" id="LN2791">2791</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2792">2792</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2793">2793</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2794">2794</td><td class="line">SerializedCodeData::SanityCheckResult SerializedCodeData::SanityCheck(</td></tr>
<tr><td class="num" id="LN2795">2795</td><td class="line">    Isolate* isolate, String* source) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2796">2796</td><td class="line">  uint32_t magic_number = GetMagicNumber();</td></tr>
<tr><td class="num" id="LN2797">2797</td><td class="line">  <span class='keyword'>if</span> (magic_number != ComputeMagicNumber(isolate)) <span class='keyword'>return</span> MAGIC_NUMBER_MISMATCH;</td></tr>
<tr><td class="num" id="LN2798">2798</td><td class="line">  uint32_t version_hash = GetHeaderValue(kVersionHashOffset);</td></tr>
<tr><td class="num" id="LN2799">2799</td><td class="line">  uint32_t source_hash = GetHeaderValue(kSourceHashOffset);</td></tr>
<tr><td class="num" id="LN2800">2800</td><td class="line">  uint32_t cpu_features = GetHeaderValue(kCpuFeaturesOffset);</td></tr>
<tr><td class="num" id="LN2801">2801</td><td class="line">  uint32_t flags_hash = GetHeaderValue(kFlagHashOffset);</td></tr>
<tr><td class="num" id="LN2802">2802</td><td class="line">  uint32_t c1 = GetHeaderValue(kChecksum1Offset);</td></tr>
<tr><td class="num" id="LN2803">2803</td><td class="line">  uint32_t c2 = GetHeaderValue(kChecksum2Offset);</td></tr>
<tr><td class="num" id="LN2804">2804</td><td class="line">  <span class='keyword'>if</span> (version_hash != Version::Hash()) <span class='keyword'>return</span> VERSION_MISMATCH;</td></tr>
<tr><td class="num" id="LN2805">2805</td><td class="line">  <span class='keyword'>if</span> (source_hash != SourceHash(source)) <span class='keyword'>return</span> SOURCE_MISMATCH;</td></tr>
<tr><td class="num" id="LN2806">2806</td><td class="line">  <span class='keyword'>if</span> (cpu_features != <span class='keyword'>static_cast</span>&lt;uint32_t&gt;(CpuFeatures::SupportedFeatures())) {</td></tr>
<tr><td class="num" id="LN2807">2807</td><td class="line">    <span class='keyword'>return</span> CPU_FEATURES_MISMATCH;</td></tr>
<tr><td class="num" id="LN2808">2808</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN2809">2809</td><td class="line">  <span class='keyword'>if</span> (flags_hash != FlagList::Hash()) <span class='keyword'>return</span> FLAGS_MISMATCH;</td></tr>
<tr><td class="num" id="LN2810">2810</td><td class="line">  <span class='keyword'>if</span> (!Checksum(Payload()).Check(c1, c2)) <span class='keyword'>return</span> CHECKSUM_MISMATCH;</td></tr>
<tr><td class="num" id="LN2811">2811</td><td class="line">  <span class='keyword'>return</span> CHECK_SUCCESS;</td></tr>
<tr><td class="num" id="LN2812">2812</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2813">2813</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2814">2814</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2815">2815</td><td class="line">uint32_t SerializedCodeData::SourceHash(String* source) <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2816">2816</td><td class="line">  <span class='keyword'>return</span> source-&gt;length();</td></tr>
<tr><td class="num" id="LN2817">2817</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2818">2818</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2819">2819</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2820">2820</td><td class="line"><span class='comment'>// Return ScriptData object and relinquish ownership over it to the caller.</span></td></tr>
<tr><td class="num" id="LN2821">2821</td><td class="line">ScriptData* SerializedCodeData::GetScriptData() {</td></tr>
<tr><td class="num" id="LN2822">2822</td><td class="line">  <span class='macro'>DCHECK(owns_data_)<span class='expansion'>do { if ((__builtin_expect(!!(!(owns_data_)), 0))) { V8_Fatal<br>("../src/snapshot/serialize.cc", 2822, "Check failed: %s.", "owns_data_"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2823">2823</td><td class="line">  ScriptData* result = <span class='keyword'>new</span> ScriptData(data_, size_);</td></tr>
<tr><td class="num" id="LN2824">2824</td><td class="line">  result-&gt;AcquireDataOwnership();</td></tr>
<tr><td class="num" id="LN2825">2825</td><td class="line">  owns_data_ = <span class='keyword'>false</span>;</td></tr>
<tr><td class="num" id="LN2826">2826</td><td class="line">  data_ = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN2827">2827</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr><td class="num" id="LN2828">2828</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2829">2829</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2830">2830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2831">2831</td><td class="line">Vector&lt;<span class='keyword'>const</span> SerializedData::Reservation&gt; SerializedCodeData::Reservations()</td></tr>
<tr><td class="num" id="LN2832">2832</td><td class="line">    <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2833">2833</td><td class="line">  <span class='keyword'>return</span> Vector&lt;<span class='keyword'>const</span> Reservation&gt;(</td></tr>
<tr><td class="num" id="LN2834">2834</td><td class="line">      <span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> Reservation*&gt;(data_ + kHeaderSize),</td></tr>
<tr><td class="num" id="LN2835">2835</td><td class="line">      GetHeaderValue(kNumReservationsOffset));</td></tr>
<tr><td class="num" id="LN2836">2836</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2837">2837</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2838">2838</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2839">2839</td><td class="line">Vector&lt;<span class='keyword'>const</span> byte&gt; SerializedCodeData::Payload() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2840">2840</td><td class="line">  <span class='keyword'>int</span> reservations_size = GetHeaderValue(kNumReservationsOffset) * kInt32Size;</td></tr>
<tr><td class="num" id="LN2841">2841</td><td class="line">  <span class='keyword'>int</span> code_stubs_size = GetHeaderValue(kNumCodeStubKeysOffset) * kInt32Size;</td></tr>
<tr><td class="num" id="LN2842">2842</td><td class="line">  <span class='keyword'>int</span> payload_offset = kHeaderSize + reservations_size + code_stubs_size;</td></tr>
<tr><td class="num" id="LN2843">2843</td><td class="line">  <span class='keyword'>int</span> padded_payload_offset = <span class='macro'>POINTER_SIZE_ALIGN(payload_offset)<span class='expansion'>(((payload_offset) + kPointerAlignmentMask) &amp; ~kPointerAlignmentMask<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN2844">2844</td><td class="line">  <span class='keyword'>const</span> byte* payload = data_ + padded_payload_offset;</td></tr>
<tr><td class="num" id="LN2845">2845</td><td class="line">  <span class='macro'>DCHECK(IsAligned(<span class='keyword'>reinterpret_cast</span>&lt;intptr_t&gt;(payload), kPointerAlignment))<span class='expansion'>do { if ((__builtin_expect(!!(!(IsAligned(reinterpret_cast&lt;<br>intptr_t&gt;(payload), kPointerAlignment))), 0))) { V8_Fatal(<br>"../src/snapshot/serialize.cc", 2845, "Check failed: %s.", "IsAligned(reinterpret_cast&lt;intptr_t&gt;(payload), kPointerAlignment)"<br>); } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2846">2846</td><td class="line">  <span class='keyword'>int</span> length = GetHeaderValue(kPayloadLengthOffset);</td></tr>
<tr><td class="num" id="LN2847">2847</td><td class="line">  <span class='macro'>DCHECK_EQ(data_ + size_, payload + length)<span class='expansion'>do { if (std::string* _msg = ::v8::base::CheckEQImpl( (data_ +<br> size_), (payload + length), "data_ + size_" " " "==" " " "payload + length"<br>)) { V8_Fatal("../src/snapshot/serialize.cc", 2847, "Check failed: %s."<br>, _msg-&gt;c_str()); delete _msg; } } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2848">2848</td><td class="line">  <span class='keyword'>return</span> Vector&lt;<span class='keyword'>const</span> byte&gt;(payload, length);</td></tr>
<tr><td class="num" id="LN2849">2849</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2850">2850</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2851">2851</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2852">2852</td><td class="line">Vector&lt;<span class='keyword'>const</span> uint32_t&gt; SerializedCodeData::CodeStubKeys() <span class='keyword'>const</span> {</td></tr>
<tr><td class="num" id="LN2853">2853</td><td class="line">  <span class='keyword'>int</span> reservations_size = GetHeaderValue(kNumReservationsOffset) * kInt32Size;</td></tr>
<tr><td class="num" id="LN2854">2854</td><td class="line">  <span class='keyword'>const</span> byte* start = data_ + kHeaderSize + reservations_size;</td></tr>
<tr><td class="num" id="LN2855">2855</td><td class="line">  <span class='keyword'>return</span> Vector&lt;<span class='keyword'>const</span> uint32_t&gt;(<span class='keyword'>reinterpret_cast</span>&lt;<span class='keyword'>const</span> uint32_t*&gt;(start),</td></tr>
<tr><td class="num" id="LN2856">2856</td><td class="line">                                GetHeaderValue(kNumCodeStubKeysOffset));</td></tr>
<tr><td class="num" id="LN2857">2857</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2858">2858</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2859">2859</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2860">2860</td><td class="line">SerializedCodeData::SerializedCodeData(ScriptData* data)</td></tr>
<tr><td class="num" id="LN2861">2861</td><td class="line">    : SerializedData(<span class='keyword'>const_cast</span>&lt;byte*&gt;(data-&gt;data()), data-&gt;length()) {}</td></tr>
<tr><td class="num" id="LN2862">2862</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2863">2863</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2864">2864</td><td class="line">SerializedCodeData* SerializedCodeData::FromCachedData(Isolate* isolate,</td></tr>
<tr><td class="num" id="LN2865">2865</td><td class="line">                                                       ScriptData* cached_data,</td></tr>
<tr><td class="num" id="LN2866">2866</td><td class="line">                                                       String* source) {</td></tr>
<tr><td class="num" id="LN2867">2867</td><td class="line">  DisallowHeapAllocation no_gc;</td></tr>
<tr><td class="num" id="LN2868">2868</td><td class="line">  SerializedCodeData* scd = <span class='keyword'>new</span> SerializedCodeData(cached_data);</td></tr>
<tr><td class="num" id="LN2869">2869</td><td class="line">  SanityCheckResult r = scd-&gt;SanityCheck(isolate, source);</td></tr>
<tr><td class="num" id="LN2870">2870</td><td class="line">  <span class='keyword'>if</span> (r == CHECK_SUCCESS) <span class='keyword'>return</span> scd;</td></tr>
<tr><td class="num" id="LN2871">2871</td><td class="line">  cached_data-&gt;Reject();</td></tr>
<tr><td class="num" id="LN2872">2872</td><td class="line">  source-&gt;GetIsolate()-&gt;counters()-&gt;code_cache_reject_reason()-&gt;AddSample(r);</td></tr>
<tr><td class="num" id="LN2873">2873</td><td class="line">  <span class='keyword'>delete</span> scd;</td></tr>
<tr><td class="num" id="LN2874">2874</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN2875">2875</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2876">2876</td><td class="line">}  <span class='comment'>// namespace internal</span></td></tr>
<tr><td class="num" id="LN2877">2877</td><td class="line">}  <span class='comment'>// namespace v8</span></td></tr>
</table></body></html>
